// ---------------------------------------------------------------------------
/**
@file    DrivingControl.cpp
@version OHT 7.0
@brief   DrivingControl Class CPP File
*/
#include <stdlib.h> // _fullpath
#include <string.h>// memcmp
#include <time.h>
#include <math.h>
#include "OHTMain.h"
#include "DrivingControl.h"
//#include "LIniFile.h"


#define NO_ERR 0
#define NODE_NONE 0


#define DEFAULT_ACCEL           0.0020  // 0.0025 mm/msec2 = 2.0 m/s2
#define DEFAULT_DECEL           0.0030  // 0.0028 mm/msec2 = 3.0 m/s2

#define OHTDETECT_EMERGENCY_DECEL 0.0035

#if(OHT_NAME == OHT_NAME_STD_V81S)
#define DEFAULT_EMERGENCY_DECEL 0.0032  // 0.0035 mm/msec2 = 3.0 m/s2
#elif(OHT_NAME == OHT_NAME_STD_V82)
#define DEFAULT_EMERGENCY_DECEL 0.0040  // 0.0035 mm/msec2 = 3.0 m/s2
#else
#define DEFAULT_EMERGENCY_DECEL 0.0035  // 0.0035 mm/msec2 = 3.0 m/s2
#endif
#define DEFAULT_TURNOFF_DECEL	0.0030  // 0.0020mm/msec2  = 3.0 m/s2
#define DEFAULT_CURVE_DECEL		0.0025  // 0.0035 mm/msec2 = 3.0 m/s2

#define DEFAULT_EMERGENCY_MIN_SPEED 1.0 //최저속도-> 0 도달 거리 마진을 구하기 위한 변수

#define QRR_MARK_ACCEL          0.0001  // 0.0001 mm/msec2 = 0.1 m/s2
#define QRR_MARK_FIRST_DECEL    0.0020  // 0.0020 mm/msec2 = 2.0 m/s2
#define QRR_MARK_FIRST_SPEED    0.1     // 0.051mm/msec = 0.05 m/s

#define DRIVING_MIN_ACCEL       0.00005 // 0.0035 mm/msec2 = 0.05 m/s2
#define DRIVING_MAX_ACCEL       0.0035  // 0.0035 mm/msec2 = 3.5 m/s2
#define DRIVING_MIN_DECEL       0.00005 // 0.0035 mm/msec2 = 0.05 m/s2
#define DRIVING_MAX_DECEL       0.0035  // 0.0035 mm/msec2 = 3.5 m/s2

#define DRIVING_OUT_IN_NODE_AREA_SPEED  0.3     // 0.1mm/msec = 0.1 m/s
#define DRIVING_MIN_SPEED               0.05        // 0.051mm/msec = 0.05 m/s
#define DRIVING_MAX_SPEED_JOG           3.3     // 3.3mm/msec = 3.3 m/s
#define DRIVING_MAX_SPEED               8.0
#define DRIVING_SPEED_SMOOTHING_FACTOR  0.85

#define MIN_DRIVING_DISTANCE    -50000   // -5000mm: 뒤로 너무 이동하는 것 방지
#define MAX_DRIVING_DISTANCE    1300000 // 1.3km    - S1에서 1.7km 이상 주행 시 오버 플로우에 의해 이상 주행 발생 : 안정적으로 1Km로 제한
                                        // 추후 AMC 단에서 인자의 오버플로 범위에 입각한 갑 설정및 처리 방안 고민 필요

#define OFFSET_TO_CHECK_FIRST_NODE          10.0    // Station에서 출발하여 처음 Node 만날 때 이상 Node Count 방지를 위해 Node Count Reset 해야 하는 Station 의 기준 Offset Max
#define POSITION_TO_CHECK_FIRST_NODE        20.0    // Offset이 -10~10mm인 Station 처음 Node 만날 때 이상 Node Count 방지를 위해 Node Count Reset 하는 위치
#define DIST_TO_CHECK_FIRST_NODE_MARGIN     80.0    // Offset이 -10~10mm인 Station 처음 Node 만날 때 이상 Node Count 방지를 위해 Node Count Reset 하는 종안 보내는 목적 거리
#define DIST_TO_CHECK_FIRST_NODE_POSITION   50.0
#define DIST_TO_CHECK_MARK_NODE_MARGIN      200.0   // Offset이 300mm인 Tag로 이동할 경우, 급가속하는 현상을 방지하기 위해 Mark동작으로 빠지게하는 거리

#define DIST_MARGIN_FOR_SMALL_ADD_START     450 // 500mm
#define SPEED_MARGIN_FOR_SMALL_ADD_START    1.0 // 1.0mm/msec

#define SPEED_MARGIN_FOR_CURVE_STOP 1250.0 // 1.25m/s

#define ACCEPTABLE_QR_MARK_POSITION_ERROR               0.5 //0.5       // 허용 오차범위    mm
#define ACCEPTABLE_DRIVING_POSITION_ERROR               0.5 //0.5       // 허용 오차범위    mm
#define ACCEPTABLE_DRIVING_POSITION_ERROR_HIGH          50.0    //50.0  // 허용 오차범위    mm
#define ACCEPTABLE_DRIVING_POSITION_ERROR_ON_QR_WAIT    5.0 //0.5   // 허용 오차범위    mm

#define ACCEPTABLE_DRIVING_FRISTNODE_POSITION_ERROR     5.0 //0.5       // 허용 오차범위    mm

#define ACCEPTABLE_DRIVING_SPEED_ERROR                  0.2 // 허용 오차범위    mm/msec

#define DRIVING_START_MARGIN                    50      // 주행 시작을 위한 마진 거리 : 시작점을 지났음을 확인하기 위한 마진
#define NODE_MARK_MARGIN                        150     // 주행 TAG Stop 할 경우 오차 보정을 위한 사전 마진 거리 : 이거리 전부터 이거리+350mm 정도까지 오차 보정이 가능하다.

#define TIME_STEER                              1000        // msec
#define TIME_INTERVAL_OF_STEER_COMPLETED        100     // 조향이 완전히 바뀌었다고 판단할 수 있는 시간 간격        // 16

#define DIST_BETWEEN_NODE_CHECK_AND_PRECHECK    	 350     // 350mm
#define DIST_MARGIN_TO_NODE_TO_CONPENSATE_SLIP  	 180     // 200mm
#define DIST_MARGIN_TO_NODE_TO_CONPENSATE_SLIP_200   200     // 200mm
#define SPEED_OF_OUT_IN_NODE                    0.05        // 0.1mm/msec
#define DIST_MARGIN_TO_NODE_SPEED_STANARD           3.3     // 3.3mm/msec = 3.3 m/s


#define MIN_DIST_BETWEEN_NODE                   350     // 주행 노드간의 최소 거리 350mm
#define DIST_MARGIN_TO_OUTNODE                  500     // 500mm Out Node 작업을 기다리기 위한 마진
#define DIST_MARGIN_TO_N_BRANCH_MOVING_CHECK    700     // 700mm N분기에 조향이 충분히 들어갔다고 판단하는 마진
#define DIST_MARGIN_OF_NODE                     400.0   // 400mm Node 감지가 map 위치에서 ±400 mm 를 벗어나서 나타날 경우 에러 발생
#define DIST_MARGIN_OF_NODE_FDC                 200.0   // 200mm Node 감지가 map 위치에서 ±200 mm 를 벗어나서 나타날 경우 FDC 전송
#define DIST_MARGIN_BETWEEN_TRANS_STATION       150     // 150mm 이적재 Node 간의 최소 간격
#define DIST_BETWEEN_TRANS_TAG_FRONT_AND_REAR   150     // 150mm 이적재 Node 간의 최소 간격
#define DIST_MARGIN_OF_TRANS_TAG                60      // 45mm 이적재 Station 명령 마진(이 거리 만큼 정위치 전으로 1차 명령을 보낸다)
#define DIST_MARGIN_OF_FINAL_MARK_RETRY     60      // 20mm 마지막 마크 안된 상태에서 정지 시 정위치 잡는 추가 마진 거리
#define DIST_MARGIN_OF_OVERRUN                  100     // 100mm Mark 시 Tag 검출 양의 방향 오차 범위

#define DRIVING1_ABNOMARL_MOVE_SPEED_LIMIT      0.3     // mm/msec
#define DRIVING2_ABNOMARL_MOVE_SPEED_LIMIT      0.3     // mm/msec

#define DRIVING1_ABNOMARL_MOVE_SPEED_LIMIT_BACK      -0.3     // mm/msec


//2 TimeOut
#define CHECK_TIME_OF_DETECT_FAIL_ERR           200     // ms
#define CHECK_TIME_OF_OBS_FAIL_ERR              200     // ms
#define TIMEOVER_OF_OBS_DETECT                  30000   // ms
#define TIMEOVER_OF_STEERING_CHANGE             15000        // ms
#define TIMEOVER_OF_DRIVING_ABNORMAL_STOP       15000        // ms

// Steering 재시도 시간
#define TIME_STEERING_RETRY                     2000    // 2 sec
//2 Jog
#define MAX_ADD_DIST_OF_JOG_DRIVING_CMD         1000.0  // 1000mm : 3.5m/s로 조그 이동시 1m 경우 285ms 주기의 업데이트 필요
#define MAX_DIST_OF_JOG_MARK_CMD                1000.0  // 1000mm : OHT의 길이만큼 이동, 그 이상 이동하지 않음
#define MAX_SPEED_OF_DRIVING_JOG                3.5     // mm/msec
#define TIMEOUT_DRIVING_JOG_COMMAND             1000        // msec : 이 시간 이상 통신 두절시 멈춤

#define DIST_FRONT_ON_MOVE_BACK_OF_TRANS_MARK   (-50.0)
#define DIST_REAR_ON_MOVE_BACK_OF_TRANS_MARK    (-10.0)
#define DIST_MARGIN_OF_MARK                     5.0
#define DIST_Of_ONE_QR_MARK_MOVE                50.0

#define EVENT_ON    true
#define EVENT_OFF   false
#define STATE_ON    true
#define STATE_OFF   false

#define WATING_TIME_OF_ID_READ              300     // msec //100: Keyence, 300: OPTICON
#define WATING_TIME_OF_ID_READER_REENABLE   300     // msec

#define RUN_TO_MARK_MINDIST   				400.0     // msec
#define RUN_TO_MARK_MINSPEED   				0.17     // msec

#define DIST_LIMIT_OF_FRONT_ON_WAIT     10      // mm
#define DIST_LIMIT_OF_REAR_ON_WAIT      10      // mm

#define STATUS_NORMAL					0
#define STATUS_OBS_STOP					1
#define STATUS_PBS_STOP					2
#define STATUS_OHT_PAUSED    			3
#define STATUS_PBS_DETECT               4

#define SETSLOPE    1
#define RELSLOPE    2

#define MAX_BYTE_SIZE_OF_DRIVING_LOG    1024*10
#define PATH_DIS_OFFSET					10

#define MAX(a,b)    ((a>b)?a:b)
#define MIN(a,b)    ((a<b)?a:b)

#define GET_DRIVING_DIST_IN_TIMEOUT(speed_mm_per_msec)  (speed_mm_per_msec)*TIMEOUT_DRIVING_JOG_COMMAND     // TimeOut 내 추가 명령이 없으면 정지하는 거리
#define GET_DRIVING_SPEED_IN_LIMIT(speed_mm_per_msec)   ((speed_mm_per_msec)<MAX_SPEED_OF_DRIVING_JOG)?(speed_mm_per_msec):MAX_SPEED_OF_DRIVING_JOG

#define OBS_REST_DISTANCE_1000mm		1000
#define OBS_REST_DISTANCE_900mm			900
#define OBS_REST_DISTANCE_800mm			800
#define OBS_REST_DISTANCE_700mm			700
#define OBS_REST_DISTANCE_600mm			600
#define OBS_REST_DISTANCE_500mm			500
#define OBS_REST_DISTANCE_400mm			400
#define OBS_REST_DISTANCE_300mm			300
#define OBS_REST_DISTANCE_200mm			200
#define OBS_REST_DISTANCE_100mm			100
#define OBS_REST_DISTANCE_0mm			0

#define	OHT_DETECT_CMD_PATH_DIRECTION_NO_USE 	0	// 미사용: 예전 없음
#define	OHT_DETECT_CMD_PATH_DIRECTION_NORMAL	1	// 직진 구간: 예전 N
#define	OHT_DETECT_CMD_PATH_DIRECTION_LEFT		2	// 왼쪽: 예전 L
#define	OHT_DETECT_CMD_PATH_DIRECTION_RIGHT 	3	// 오른쪽: 예전 R
#define	OHT_DETECT_CMD_PATH_DIRECTION_SHORT	    4	// N분기 사용: 예전 S
#define	OHT_DETECT_CMD_PATH_DIRECTION_BOTH		5	// 짧은 S자형 곡선: 예전 B
#define	OHT_DETECT_CMD_PATH_DIRECTION_NARROW	6	// 레일 간격이 900mm 이하일때의 짧은 S자형 곡선: 예전 V

#define SICK_OBS_AREA_0					0
#define SICK_OBS_AREA_4					4
#define SICK_OBS_AREA_5					5
#define SICK_OBS_AREA_6					6
#define SICK_OBS_AREA_7					7

#define HO_OBS_AREA_TEST					1
#define HO_OBS_AREA_SET						14

#define DRIVING_SETTING_TIME   			5000 //리트라이 조건이 2초이므로 해당 시간보다 큰값 처리.
#define SENSOR_CHECK_DISTANCE			100.0 // PreCheck Sensor On과 NodeCount/Position위치가 맞지 않는거에 대한 방어코드 거리값(후진방지)

#if(OHT_NAME != OHT_NAME_P4_MASK)
#define STATION_FRONT_REAR_DIST      155.0
#else
#define STATION_FRONT_REAR_DIST      123.0
#endif
// 로그 작성 함수
#define USE_DRIVING_LOG 1
#define ADD_LOG(...)    WRITE_LOG_UNIT(pLogUnit, __VA_ARGS__)
#define RESET_LOG       CLEAR_LOG(pLogUnit)

//#define ERR_LOG(...)    WRITE_LOG_ON_THIS_FILE("D:\\log\\DrivingError.log", __VA_ARGS__);\
//						ADD_LOG(__VA_ARGS__)
//#define BCR_LOG(...)    WRITE_LOG_ON_THIS_FILE("D:\\log\\BCR.log", __VA_ARGS__)
//#define DETECT_LOG(...)    WRITE_LOG_ON_THIS_FILE("D:\\log\\OHTDETECTWarnning.log", __VA_ARGS__)
//#define CID_MONITOR_LOG(...)    WRITE_LOG_ON_THIS_FILE("D:\\log\\CID_MONITORING.log", __VA_ARGS__)


// 로그 작성 함수 수정
#define ERR_LOG(...)    WRITE_LOG_UNIT(pLogDrivingError, __VA_ARGS__)
#define BCR_LOG(...)    WRITE_LOG_UNIT(pLogBCR, __VA_ARGS__)
#define DETECT_LOG(...)    WRITE_LOG_UNIT(pLogDetect, __VA_ARGS__)
#define CID_MONITOR_LOG(...)    WRITE_LOG_UNIT(pLogCIDMonitor, __VA_ARGS__)
//#define ADD_MCC_LOG(usemode, ...)	if(usemode)   WRITE_LOG_UNIT(pLogMCC, __VA_ARGS__)
#define ADD_MCC_LOG(usemode, ...)							\
	if(usemode)												\
	{										        		\
		try{									    		\
			WRITE_LOG_UNIT(pLogMCC, __VA_ARGS__)    		\
		}                                           		\
		catch(...)                                  		\
		{                                           		\
			WRITE_LOG_UNIT(pLogMCC, "Driving Exception")	\
		}                                           		\
	}
#define ADD_MD_LOG(...)    WRITE_LOG_UNIT(pLogMDetail, __VA_ARGS__)  //AOHC-253 Monitoring 항목 추가 2

#define AUTO_RECOV_LOG(usemode, ...)                        \
	if(usemode)												\
	{										        		\
		try{									    		\
			WRITE_LOG_UNIT(pLogAutoRecovery, __VA_ARGS__)   \
		}                                           		\
		catch(...)                                  		\
		{                                           		\
			WRITE_LOG_UNIT(pLogAutoRecovery, "Driving Exception")	\
		}                                           		\
	}

#define ADD_FDC_LOG(...)			writeFDCUnit(pFDCUnit, __VA_ARGS__)
#define SEND_WARN(...)				writeFDCUnit_WARN(pFDCUnit, __VA_ARGS__)
/**
@brief   pList 의 상태를 확인하고 nNodeCount 값 이전 정보를 삭제
@author  ehoto
@date    2013.7.19
@param pList: Command 리스트
@param nNodeCount: 기준 NodeCount 시작하는 위치
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
template <typename T>
bool    clearListLessThan(List<T*> *pList, int nNodeCount);

/**
@brief   pList 의 상태를 확인하고 nNodeCount 값 이전 정보를 삭제
@author  ehoto
@date    2013.7.19
@param pList: Command 리스트
@param nNodeCount: 기준 NodeCount 시작하는 위치
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
template <typename T>
bool    clearListLessAfter(List<T*> *pList, int nNodeCount);


/**
@brief   pList 의 상태를 확인하고 Index의 값 이후 의 정보를 삭제
@author  ehoto
@date    2013.7.19
@param pList: Command 리스트
@param Index: 찾기 시작하는 위치
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
template <typename T>
bool    clearListFrom(List<T*> *pList, int nIndex);

/**
@brief   pList 의 상태를 확인하고 모든 정보를 삭제
@author  ehoto
@date    2013.7.19
@param pList: Command 리스트
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
template <typename T>
bool    clearList(List<T*> *pList);


/**
@brief   DrivingControl Class 생성자 함수
@author  ehoto
@date    2012.11.07
@param   pHWSet : HWSet 클래스 포인터
*/
DrivingControl::DrivingControl():VirtualDrivingControl()
{
#if USE_DRIVING_LOG
    pLogUnit = getLogUnit("D:\\log\\DrivingCtrl.log", MAX_BYTE_SIZE_OF_DRIVING_LOG);
#else
    pLogUnit = NULL;
#endif


	pLogDrivingError = getLogUnit("D:\\log\\DrivingError.log",MAX_BYTE_SIZE_OF_MAIN_LOG);
	pLogBCR = getLogUnit("D:\\log\\BCR.log", MAX_BYTE_SIZE_OF_MAIN_LOG);
	pLogDetect = getLogUnit("D:\\log\\OHTDETECTWarnning.log", MAX_BYTE_SIZE_OF_MAIN_LOG);
	pLogCIDMonitor = getLogUnit("D:\\log\\CID_MONITORING.log", MAX_BYTE_SIZE_OF_MAIN_LOG);
    pLogMCC = getLogUnit("D:\\log\\MCC.log", MAX_BYTE_SIZE_OF_MAIN_LOG);
	pFDCUnit = getFDCUnit("D:\\log\\FDC.log", MAX_BYTE_SIZE_OF_MAIN_LOG);
	pLogMDetail = getLogUnit("D:\\log\\MonitoringDetail.log", MAX_BYTE_SIZE_OF_MAIN_LOG);
	pLogAutoRecovery = getLogUnit("D:\\log\\AutoRecovery.log", MAX_BYTE_SIZE_OF_MAIN_LOG);

    m_pTransBCR     = NULL;
    m_pDrivingBCR   = NULL;
    m_pDrivingAxis  = NULL;
    m_pDrivingTag   = NULL;
    m_pObstacle     = NULL;
    m_pOHTDetect    = NULL;
    m_pLeftQRR      = NULL;
    m_pRightQRR     = NULL;
    m_pSteer        = NULL;
    m_pTransStopTag = NULL;
	m_pPassBoxPIO   = NULL;
	m_pMTLPIO       = NULL;
#if((OHT_NAME == OHT_NAME_STD_V82)|| (OHT_NAME == OHT_NAME_STD_V85S)||(OHT_NAME == OHT_NAME_STD_V86)|| (OHT_NAME == OHT_NAME_P4_MASK))
#else
	m_pServoControl = NULL;
	m_pRSAControl   = NULL;
#endif

	m_pTmpParamSet = NULL;   //17라인 버그로인하여 추가
	m_pUBG_Fail3_HourCounter = NULL;
	m_pUBG_Fail3_WeekCounter = NULL;

	m_strOhtName = "OHT001";	// lifter send param

	m_iLifterPrePass = VHL_ELEVETOR_PREPASS_STEP_NONE;
	m_IsLifterCheck = false;
	m_IsMTLCheck = false;



	pHWSet = OHTMainForm->GetHWSet();
	m_pExecuteInfo = OHTMainForm->GetExecuteInfo();
	m_defualtparam = OHTMainForm->GetDefaultParam();
	m_pOHTMainStatus = OHTMainForm->GetOHTStatus();

	m_LineParamSet = OHTMainForm->GetLineParam();  //AOHC-285

    if(pHWSet!=NULL)
    {
        m_pTransBCR     = pHWSet->m_pTransBCR;
        m_pDrivingBCR   = pHWSet->m_pDrivingBCR;
		m_pDrivingAxis  = pHWSet->m_pDrivingAxis;
        m_pDrivingTag   = pHWSet->m_pDrivingTag;
        m_pObstacle     = pHWSet->m_pObstacle;
        m_pOHTDetect    = pHWSet->m_pOHTDetect;
		m_pLeftQRR      = pHWSet->m_pLeftQRR;
        m_pRightQRR     = pHWSet->m_pRightQRR;
        m_pSteer        = pHWSet->m_pSteer;
        m_pTransStopTag = pHWSet->m_pTransStopTag;
		m_pPassBoxPIO   = pHWSet->m_pPassBoxPIO;
		m_pMTLPIO       = pHWSet->m_pMTLPIO;
#if((OHT_NAME == OHT_NAME_STD_V82)|| (OHT_NAME == OHT_NAME_STD_V85S)||(OHT_NAME == OHT_NAME_STD_V86)|| (OHT_NAME == OHT_NAME_P4_MASK))
#else
		if(m_defualtparam->bUseRSA==true)
			m_pRSAControl   = pHWSet->m_pRSAMonitoring;
		else
			m_pServoControl = pHWSet->m_pServoMonitoring;
#endif
	}
	m_ParamChehckError = NO_ERR;

	m_pParamSet = new DRIVING_PARAM_SET();
	memset(m_pParamSet, 0x00, sizeof(DRIVING_PARAM_SET));
	loadParameterRecovery("DataFiles\\Driving.ini", m_pParamSet);

	if (m_pParamSet->UbgFail3Err.bHourlyCheck)
		m_pUBG_Fail3_HourCounter = new PeriodicCounter(TimeUnit::Hour, 1, true);
	if (m_pParamSet->UbgFail3Err.bWeeklyCheck)
		m_pUBG_Fail3_WeekCounter = new PeriodicCounter(TimeUnit::Week, 1, true);

	m_pDrivingAxis->SetGearRatio(m_defualtparam->DrivingDefault);

    m_pDrivingAxis->SetNegativeSWLimit(-1*MAX_DRIVING_DISTANCE);
	m_pDrivingAxis->SetPositiveSWLimit(MAX_DRIVING_DISTANCE);

//	m_pDrivingAxis->SetBrakeRelease(ON);
	m_pDrivingAxis->SetBrakeRelease(false);    //브레이 잡는거

	m_pDrivingAxis->SetAMPEnable(true);          //서버 On
	m_pDrivingAxis->SetSlaveAMPEnable(true);     //서버 On

	m_cSlopeNodeInfo = INIT_NTYPE;
#if((OHT_NAME == OHT_NAME_STD_V82)|| (OHT_NAME == OHT_NAME_STD_V85S)||(OHT_NAME == OHT_NAME_STD_V86)|| (OHT_NAME == OHT_NAME_P4_MASK))
#else
	if(m_defualtparam->bUseRSA==true)
	{
		m_pRSAControl->SetInnerLimitTorque_90();
		m_pRSAControl->SetInnerLimitTorque_300_Trans();
	}
	else
	{
		m_pServoControl->SetInnerLimitTorque_90();
		m_pServoControl->SetInnerLimitTorque_800_Trans();
	}
#endif

	m_bOnMapMake = false;
	m_bOnBackMove = false;
//	m_bJobChange = false;
	memset(&m_bMapMakeType, 0x00, sizeof(MAP_MAKER_TYPE));
	m_DiagManager = DiagManager::getInstance();
    //1 NEW
    initCommandSet();
	initInfoSet();
	initPreviousArrivalInfo();

    memset(&m_PositionInfo, 0, sizeof(EXECUTE_POSITION_INFO));

	init();

	m_nCidControlStep = CID_STEP_CONNECTING;
	m_Continue_CID_MODE = false;
	m_Continue_CID_MODE_StopNode=0;
	m_Continue_CID_MODE_ResetNode=0;
	m_Continue_CID_MODE_ResetNodeType=0;
//	m_OverRunCount_E2313 = 0;
//	m_OverRunCount_E2314 = 0;
//	m_OverRunCount_E250 = 0;
	m_OverRunCount = 0;
	bReqLifterCounterReset = false;

	m_nMarkFailRetryCheckID = 0;
	b_ReadBcr = false;
	b_WaitTrg = false;
	memset(&CID_Save_Node, 0, sizeof(CID_Save_Node));
	CheckReadyToRunTime_ExcuteGo = timeGetTime();
	CheckReadyToRunTime_ManualMark = timeGetTime();
	CheckComplete_ExcuteGo = timeGetTime();
	CheckComplete_ManualMark = timeGetTime();

	dwRearSensorChatteringDelayV82 = timeGetTime();

	m_MoniCFNode=0;

	m_dCheckAMCDecelPosition = 0.0;
	m_dPreTargetPosition = 0.0;

	bCheckDrivParam = false;

	m_nOptDistChange = 0;
	m_bMarkOffsetCheck = false;

	CID_Fiber_Monitoring = false;
	CID_SERIAL_CMD_DELAY_TURN =  10;

	m_nCurrStation = 0;

	m_nMTLNextNode = 0;
	m_nMTLCheckCurNode = 0;
	m_nMTLCheckCurNode2 = 0;
	m_nPreAutoDoorNode = 0;
	m_bE250RearOnCheck = false;
	nCheckAutoRecoveryTry = 0;
	m_bE250AutoRecoveryFlag = false;
	m_bE231xAutoRecovery = false;
	m_bE231xAutoRecovery_RearCheck = false;
	m_dE231xAutoRecoveryDist = 0.0;
	m_bE231xAutoRecoveryCase2 = false;
	m_bE231xAutoRecoveryCase2_DistCheck = false;
	m_nAutoRecoveyCount = 0;
	m_dE231xFront2RearDist = 0.0;
	m_dChekRearDist = 0.0;
	m_dE231xFront2CurPositionDist = 0.0;
	m_dE250RearOffPosition = 0.0;
	m_dE250RearOnPosition = 0.0;
	nMinDecode = 0;
	nMaxDecode = 0;
	dAvgDecode = 0.0;
	nQRSetupVersion = 0;

	m_nShutterRecovery_Cnt = false;
	m_nShutterRecovery_Time = 0;

	m_nLeftSteerRecovery_Cnt = false;
	m_nLFrontSteerRecovery_Time = 0;
	m_nLRearSteerRecovery_Time = 0;
	m_nRightSteerRecovery_Cnt = false;
	m_nRFrontSteerRecovery_Time = 0;
	m_nRRearSteerRecovery_Time = 0;
	Check_Node = 0;
	Check_AutoRecovery_PreCheck = 0;

	m_DetectFail_Cnt = false;
	m_mccparam.dwOHTDetectAreaTime = timeGetTime();
	nUbgFailStart_Time = 0;
}

/**
@brief   DrivingControl Class 소멸자 함수
@author  ehoto
@date    2012.11.07
*/
DrivingControl::~DrivingControl()
{
//    saveParameter("DataFiles\\Driving.ini", m_pParamSet);

	m_pDrivingAxis->MoveStop(DEFAULT_EMERGENCY_DECEL);
    m_pDrivingAxis->SetBrakeRelease(false);

    // 정보 초기화
    initStatusSet();
    initCommandSet();
	initInfoSet();
    initPreviousArrivalInfo();

    init();

    delete m_pParamSet;

	delete m_pUBG_Fail3_HourCounter;
	delete m_pUBG_Fail3_WeekCounter;
}
//---------------------------------------------------------------------------

/**
@brief   DrivingControl Class 초기화 함수
@author  ehoto
@date    2012.11.27
*/
void DrivingControl::init(void)
{
	m_QuickCmd = EXECUTE_QUICK_CMD_NONE;

    memset(&m_Detect,       0, sizeof(m_Detect));

    //1 NEW
	//2 마크 되어 있을 경우 현재 위치 정보가 그 후에도 계속 업데이트 되어 Data 양식과 달라질 수 있음
	//오버런과 기동off는 처리하지않는것롤 확인한다.

	POSITION_STATUS CurrPositionStatus  =   (m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.bMarked==true)
                                            ?   m_PreviousArrivalInfo
											:   m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus;


    initCommandSet();
	initInfoSet();
    initPreviousArrivalInfo();
    m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus = CurrPositionStatus;    //1 함수화 필요
    m_PreviousArrivalInfo = CurrPositionStatus;
    //1

    // 상태 정보 초기화
    m_StatusSet.byStatus    = STS_INIT;
    m_StatusSet.uError      = NO_ERR;
    m_StatusSet.uStep       = 0;

    // 받은 명령에 대한 초기화
    m_Detect.UseFollowControlFlag   = false;
    m_Detect.NodeCount              =0;
	m_pDrivingAxis->SetDetectInfo(m_Detect);
//	ADD_LOG("D-1");

	m_pDrivingBCR->ReStart();
    m_pTransBCR->ReStart();

	m_pPassBoxPIO->PIODisable(true);
	m_nPassBoxPIOStep = PASSBOX_CTRL_STEP_NONE;
	m_RunOffsetDistance = 0.0;
	m_nMarkFailRetryCheckID = 0;
	//TG추가
	m_pMTLPIO->PIODisable(true);
	m_nMTLTakeOutPIOStep = MTL_TakeOut_CTRL_STEP_NONE;
	m_nMTLTakeInPIOStep = MTL_TakeIn_CTRL_STEP_NONE;


	// VHL 엘리베이터 구현 관련 추가
	m_nElevetorRideStep = VHL_ELEVETOR_RIDE_CTRL_STEP_CID_INIT;		// 상태값을 초기화 한다
	m_nElevetorOffStep = VHL_ELEVETOR_OFF_CTRL_STEP_INIT;
	m_nElevetorDirection = PASS_DIRECTION_REQUEST_ALL;

	//m_nCidControlStep = CID_STEP_CONNECTING;

	m_Dectect_Dir = PATH_DIRECTION_NO_USE;
	m_Dectect_OBS_Dir =PATH_OBS_DIRECTION_NO_USE;

	m_bShutterCloseFlag = false;
	m_bShutterOpenFlag = false;
	m_bShutterCloseMovingFlag = false;

	m_pDrivingAxis->SetCurveEstop(false);
	// CID Reading Buffer
	// memset(&SEREAL_READING_BUFFER, CID_SERIAL_WORK_NONE, (SEREAL_READING_BUFFER_SIZE + 1));
	bOverrunReverse = false;
	bCheckPulse = true;

	pHWSet->m_pShutter->SetAutoRecoveryClose(SHUTTER_AR_CLOSE_NONE);
}



/**
@brief   제어기 정지 시키는 명령(내부 사용)
@author  ehoto
@date    2013.04.13
*/
void DrivingControl::stop()
{
   //	m_Detect.UseFollowControlFlag = false;    //HJH
  //	m_Detect.NodeCount=0;                //HJH
  //	m_pDrivingAxis->SetDetectInfo(m_Detect);  //HJH
	m_nMarkFailRetryCheckID = 0;
//	ADD_LOG("D-2");

	m_StatusSet.bIsOnProcess = false;
	m_pExecuteInfo->bPopListOfCmd = false;
	m_StatusSet.uStep = DRIVING_CTRL_STEP_NONE;
	m_pExecuteInfo->ExecuteDrivingStep = DRIVING_CTRL_STEP_NONE;

	ERR_LOG("Driving Stop");

	if(((m_Dectect_Dir == PATH_DIRECTION_LEFT)||(m_Dectect_Dir == PATH_DIRECTION_RIGHT))
		&& m_pDrivingAxis->GetCurrentVelocity() < SPEED_MARGIN_FOR_CURVE_STOP)
	{
		m_pDrivingAxis->SetCurveEstop(true);
		m_pDrivingAxis->MoveStop(DEFAULT_CURVE_DECEL);
		ERR_LOG("DEFAULT_CURVE_DECEL ");
	}
	else
	{
		m_pDrivingAxis->MoveStop(DEFAULT_EMERGENCY_DECEL);
		ERR_LOG("DEFAULT_EMERGENCY_DECEL ");
    }
	m_pSteer->Stop();

//	if((m_iLifterPrePass != VHL_ELEVETOR_PREPASS_STEP_NONE) ||  (m_nElevetorRideStep != VHL_ELEVETOR_RIDE_CTRL_STEP_CID_INIT)  ||(m_nElevetorOffStep != VHL_ELEVETOR_OFF_CTRL_STEP_INIT))
//		CID_SELECT_ALL_OFF();

	m_iLifterPrePass = VHL_ELEVETOR_PREPASS_STEP_NONE;
	m_nElevetorRideStep = VHL_ELEVETOR_RIDE_CTRL_STEP_CID_INIT;		// 상태값을 초기화 한다
	m_nElevetorOffStep = VHL_ELEVETOR_OFF_CTRL_STEP_INIT;


	m_nMTLTakeOutPIOStep = MTL_TakeOut_CTRL_STEP_NONE;
	m_nMTLTakeInPIOStep  = MTL_TakeIn_CTRL_STEP_NONE;

	if(m_pExecuteInfo->FlagMTLInfo.bTakeInCycle ==true)
	{
		EnterCriticalSection(&OHTMainForm->m_CS);
		m_pExecuteInfo->FlagMTLInfo.bTakeInCycle = false;
		m_pExecuteInfo->FlagMTLInfo.nTakeInOrder = INIT;
		LeaveCriticalSection(&OHTMainForm->m_CS);
    }

	m_bOnMapMake = false;
	m_bOnBackMove = false;

	m_IsLifterCheck = false;
	m_IsMTLCheck = false;
	m_IsAutoDoorCheck = false;
	m_bIsFirstNodeCountAdd = false;
	m_bIsAMCVHLDetectIgnore = false;

	DrivingCMDExuteFunc(false);
#if(OHT_NAME != OHT_NAME_P4_MASK)
	// CID 연결 시도 AMOHTV80F-1267
	pHWSet->m_pCID->CID_Manual_Mode_On();

	if(m_StatusSet.byStatus==STS_ERROR)
	{
		if(pHWSet->m_pCID->ISCidOperatingMode() == false)
		{
			Manual_CID(MANUAL_CID_MODE);
			ADD_LOG("D-35");
		}

		if(pHWSet->m_pCID->IsLinkOK() == false)
		{
			Manual_CID(MANUAL_CID_DIRECTION_CHK);
			ADD_LOG("D_23/%d", m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode);
			ADD_LOG("CID 연결 시도");
		}

		// Step 3. Reserve On : Occupying control
		if(pHWSet->m_pCID->IsLinkOK() == true)
		{
			if(pHWSet->m_pCID->IsInterlock_ON() == false)
			{
				Manual_CID(MANUAL_CID_RESERVED_ON);
				ADD_LOG("D_26/%d", m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode);
			}


			else
			{
				Manual_CID(MANUAL_CID_RESERVED_OFF);
			}
		}
	}

#endif
	//MapMaker 쓰레기 Data 삭제
	ClearMapMakingInfo();

//	m_bJobChange = false;
}

/**
@brief   제어기 정지 시키는 명령(내부 사용)
@author  puting
@date    2015.12.30
*/
void DrivingControl::turnoff()
{

//    m_Detect.UseFollowControlFlag = false;
//    m_Detect.NodeCount=0;
//    m_pDrivingAxis->SetDetectInfo(m_Detect);

	ERR_LOG("Driving Turn Off");
	m_StatusSet.bIsOnProcess = false;
	m_StatusSet.uStep = DRIVING_CTRL_STEP_NONE;
	m_pExecuteInfo->ExecuteDrivingStep = DRIVING_CTRL_STEP_NONE;

	m_pDrivingAxis->MoveStop(DEFAULT_TURNOFF_DECEL);
	m_pSteer->Stop();


	m_iLifterPrePass = VHL_ELEVETOR_PREPASS_STEP_NONE;
	m_nElevetorRideStep = VHL_ELEVETOR_RIDE_CTRL_STEP_CID_INIT;		// 상태값을 초기화 한다
	m_nElevetorOffStep = VHL_ELEVETOR_OFF_CTRL_STEP_INIT;

	m_nMTLTakeOutPIOStep = MTL_TakeOut_CTRL_STEP_NONE;
	m_nMTLTakeInPIOStep  = MTL_TakeIn_CTRL_STEP_NONE;

	if(m_pExecuteInfo->FlagMTLInfo.bTakeInCycle ==true)
	{
		EnterCriticalSection(&OHTMainForm->m_CS);
		m_pExecuteInfo->FlagMTLInfo.bTakeInCycle = false;
		m_pExecuteInfo->FlagMTLInfo.nTakeInOrder = INIT;
		LeaveCriticalSection(&OHTMainForm->m_CS);
    }

	//기동 off시 조향명령 초기화 : 다시 출발시킬때 조향확인후 출발 테스트 확인 필요
	m_InfoSet.Time.Steer.SteeringChangeCmded.bFlag =false;
//	m_InfoSet.Steer.FrontMoving = false;
//	m_InfoSet.Steer.RearMoving = false;
//	m_InfoSet.Time.Steer.FrontSteeringArrived.bFlag = true;
//	m_InfoSet.Time.Steer.RearSteeringArrived.bFlag = true;


	m_bOnMapMake = false;
	m_bOnBackMove = false;

	m_IsLifterCheck = false;
	m_IsMTLCheck = false;
	m_IsAutoDoorCheck = false;
	m_bIsFirstNodeCountAdd = false;
	m_bIsAMCVHLDetectIgnore = false;

	DrivingCMDExuteFunc(false);

//	m_bJobChange = false;
}


/**
@brief   대기 중 이상 상태 확인
@author  ehoto
@date    2013.02.07
@return  문제 있을 경우 에러 반환, 그 외에는 NO_ERR(0) 반환
*/
UINT DrivingControl::CheckAbnormalOnWait(void)
{
    UINT        nTmpError   = NO_ERR;

	if( m_StatusSet.bIsOnProcess    == true) return NO_ERR;

    DRIVING_HW_INFO_SET TmpHwInfo = getHWInfo();

    // [ DRIVING ] //
    // Driving 가 서보 오프 되었을 때 에러 발생
    // Driving 가 움직일 경우 에러 발생
    // Driving 가 Limit를 벗어날 경우 에러 발생: 30mm
    bool    bFrontAMPEnable = TmpHwInfo.IO.Axis1AmpOn;
    bool    bFrontIsRunning = TmpHwInfo.IO.Axis1Running;
    bool    bRearAMPEnable      = TmpHwInfo.IO.Axis2AmpOn;
    bool    bRearIsRunning      = TmpHwInfo.IO.Axis2Running;

	//2 원점 틀어짐 확인

//  if( nTmpError==NO_ERR   &&  bFrontAMPEnable         == false    )   nTmpError   = ERR_DRIVING_NOTORIGIN+1000;   //@todo: 서보 오프 에러 추가 필요
//  if( nTmpError==NO_ERR   &&  bFrontIsRunning         == true     )   nTmpError   = ERR_DRIVING_NOTORIGIN+2000;   //@todo: 서보 오프 에러 추가 필요
//
//  if( nTmpError==NO_ERR   &&  m_pDrivingAxis->IsSyncControl() == true )   // 전후륜 구동일 경우
//  {
//      if( nTmpError==NO_ERR   &&  bRearAMPEnable      == true     )   nTmpError   = ERR_DRIVING_NOTORIGIN+4000;   //@todo: 서보 오프 에러 추가 필요
//      if( nTmpError==NO_ERR   &&  bRearIsRunning      == true     )   nTmpError   = ERR_DRIVING_NOTORIGIN+5000;   //@todo: 서보 오프 에러 추가 필요
//  }

     //Slope에서 모터관련 에러일 경우 브레이크 동작
//	if((TmpHwInfo.Axis1.nError !=NO_ERR) ||  (TmpHwInfo.Axis2.nError !=NO_ERR))
//	{
//		if(m_pDrivingAxis->IsBrakeReleased()==true)
//		{
//			ADD_LOG("D-3");
//			m_pDrivingAxis->SetBrakeRelease(false);
//		}
//	}
//	//슬로프에서 일반적인 에러일 경우 or 기동 Off일 경우, 내부제한 토크 설정.
//	else
//	{
//		if((bFrontIsRunning ==false) && (bRearIsRunning==false))
//		{
//			if(m_pServoControl->IsSetInnerLimitTorque_90() ==false)
//			{
//				m_pServoControl->SetInnerLimitTorque_90();
//				ADD_LOG("D-4");
//			}
//		}
//	}


    if(nTmpError    != NO_ERR)
    {
        setMarkStatusFalse();
        return nTmpError;
    }

    return nTmpError;
}


/**
@brief   항시 이상 상태 확인
@author  ehoto
@date    2013.02.07
@return  문제 있을 경우 에러 반환, 그 외에는 NO_ERR(0) 반환
*/
UINT DrivingControl::CheckAlways(void)
{

	DRIVING_HW_INFO_SET TmpHwInfo;

#if((OHT_NAME == OHT_NAME_STD_V81S) ||(OHT_NAME == OHT_NAME_STD_V80)||(OHT_NAME == OHT_NAME_STD_V81)||(OHT_NAME == OHT_NAME_STD_V85S)||(OHT_NAME == OHT_NAME_STD_V82)|| (OHT_NAME == OHT_NAME_P4_MASK))
	static DWORD dwLastTimeOfFoupCoverOpenDetect = timeGetTime();
	static DWORD dwLastTimeOfFoupDetectWarnning = timeGetTime();
	static DWORD dwLastTimeOfDrivingDetectWarnning = timeGetTime();
	static int nLastTimeOfDrivingDetectWarnning = 0;

	bool bShiftHome = pHWSet->m_pShiftAxis->IsShiftHome();
	static bool bPreShiftHome = pHWSet->m_pShiftAxis->IsShiftHome();

	static bool bPreHoistHome = pHWSet->m_pHoistAxis->IsHoistHome();

	static bool bPreFOUPDetect = pHWSet->m_pInnerFoup->IsFoupDetect();
	bool bFOUPCoverDetect = pHWSet->m_pFoupCoverOpenDetect->IsDetect();
#endif
    bool bHoistHome = pHWSet->m_pHoistAxis->IsHoistHome();
	bool bFOUPDetect = pHWSet->m_pInnerFoup->IsFoupDetect();

	if( m_StatusSet.bIsOnProcess==true)
	{
		TmpHwInfo = m_InfoSet.HwInfo;
    }
    else
	{
        TmpHwInfo = getHWInfo();
    }

    // Mark //
	MARK_TYPE   MarkType        = m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.MarkType;
	int         nCurrNodeID  	= m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode;
    int         nCurrStationID  = m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uStation;

    bool bNodeOn                = TmpHwInfo.IO.NodeOn;
    bool bTagStationFrontOn = TmpHwInfo.IO.TagStationFrontOn;
    bool bTagStationRearOn  = TmpHwInfo.IO.TagStationRearOn;


    // QR Sensor 확인 //
	static  bool    bQROnTriger = false;
    static  int     bCountOfQRNG    = 0;
	static  DWORD   dwQRTrigerTime  = timeGetTime();

    DWORD       dwCurrTime  = timeGetTime();
	UINT        nTmpError   = NO_ERR;

//    QR_Reader   *pQRR;
	int         nID     = 0x00;
    double      dOffset = 0.0;

    bool        bFrontOnMarkPosition    = false;
    bool        bRearOnMarkPosition 	= false;

    // [ STEERING ] //
    bool    bSteerFrontLeft = TmpHwInfo.IO.SteerFrontLeftInOn;
    bool    bSteerFrontRight    = TmpHwInfo.IO.SteerFrontRightInOn;
    bool    bSteerRearLeft      = TmpHwInfo.IO.SteerRearLeftInOn;
    bool    bSteerRearRight = TmpHwInfo.IO.SteerRearRightInOn;

    // [ DRIVING ] //
    bool    bFrontAMPEnable = TmpHwInfo.IO.Axis1AmpOn;
    bool    bFrontIsRunning = TmpHwInfo.IO.Axis1Running;
    bool    bRearAMPEnable      = TmpHwInfo.IO.Axis2AmpOn;
    bool    bRearIsRunning      = TmpHwInfo.IO.Axis2Running;

    double dFrontAxisCurrPos    = TmpHwInfo.Axis1.dCurrPos;
    double dRearAxisCurrPos = TmpHwInfo.Axis2.dCurrPos;
    double dFrontAxisMarkPos    = m_InfoSet.Position.Mark.dFrontPosition;
    double dRearAxisMarkPos = m_InfoSet.Position.Mark.dRearPosition;

	double dFrontAxisSpeed  = TmpHwInfo.Axis1.dSpeed;
	double dRearAxisSpeed       = TmpHwInfo.Axis2.dSpeed;

	// [ SHUTTER ] //
	bool bShutterFrontOpen = pHWSet->m_pShutter->IsOpen(FRONT);
	bool bShutterFrontClose = pHWSet->m_pShutter->IsClose(FRONT);
	bool bShutterRearOpen = pHWSet->m_pShutter->IsOpen(REAR);
	bool bShutterRearClose = pHWSet->m_pShutter->IsClose(REAR);
	bool bShutterBothOpen = bShutterFrontOpen & bShutterRearOpen;
	bool bShutterBothClose = bShutterFrontClose & bShutterRearClose;

//	bool bMidShutterFront =  pHWSet->m_pShutter->IsMidClose(FRONT);   //0:open, 1:close
//	bool bMidShutterRear = pHWSet->m_pShutter->IsMidClose(REAR);
//	bool bMidShutterBoth = pHWSet->m_pShutter->IsMidClose(BOTH);

	static bool bPreShutterFrontOpen = pHWSet->m_pShutter->IsOpen(FRONT);
	static bool bPreShutterFrontClose = pHWSet->m_pShutter->IsClose(FRONT);
	static bool bPreShutterRearOpen = pHWSet->m_pShutter->IsOpen(REAR);
	static bool bPreShutterRearClose = pHWSet->m_pShutter->IsClose(REAR);

    static bool bPreFrontIsRunning = false;
	int     nOBSStatus = TmpHwInfo.IO.ObsStatus;
	int     nDetectStatus = TmpHwInfo.IO.DetectStatus;
    static  DWORD   dwStartOnDetectTime = timeGetTime();
	static bool bStartOnDetect = false;

	static int nMarkCheckCount = 0;

	static  DWORD   dwRearServoOffTime = timeGetTime();

	static  DWORD   dwTurnoffTime = timeGetTime();
	static   DWORD   dwLastTimeOfTriggerOn = timeGetTime();

	static DWORD dwCheckMoveAbnormalBack = timeGetTime();
	static DWORD dwCheckAMCDetectStopDecelDownStatusTime = timeGetTime();   //AOHC-295


//기성능 검증용으로 추후 삭제 필요
	static double nPreOffset = 0.0	;
	static int nPreNodeID = 0;

	static int nCountOfMidShutterDiff = 0;
	static int nCountOfOHTDetectAreaCapture = 0;

#if((OHT_NAME == OHT_NAME_STD_V82)||(OHT_NAME == OHT_NAME_STD_V86))

if(pHWSet->m_pOHTDetect->GetSOSLABFramEnableFlag() == false)
{
	if((m_defualtparam->OhtDetectSensorType == OHTDETECT_SOSLAB)&&(nTmpError == NO_ERR)&&(m_pOHTMainStatus->StatusCommon.MSCmdID.Info.Mode == MODE_AUTO))
	{
		nCountOfOHTDetectAreaCapture++;
		pHWSet->m_pOHTDetect->ResultOHTDetectInputCheck();    //Input 상시 체크
		pHWSet->m_pOHTDetect->ResultOHTDetectOutputCheck();   //Output 상시 체크
		if(nCountOfOHTDetectAreaCapture > 7)
		{
			nTmpError = pHWSet->m_pOHTDetect->GetAreaLevelCapture(); //IO Serial 비교
			nCountOfOHTDetectAreaCapture = 0;
		}

		if(nTmpError != NO_ERR)
			return nTmpError;
	}
}

#endif

//CID link 된 경우 E-Stop
//   pHWSet->m_pCID->CID_Out_Left_Select(ON);
//   pHWSet->m_pCID->CID_Out_Operation(ON);
//   if(pHWSet->m_pCID->IsLinkOK() == true)
//   {
//		ERR_LOG("[CID LINK]CurNode : %06d, Current Position : %6.1lf", m_pOHTMainStatus->StatusCommon.CurNodeID, TmpHwInfo.Axis1.dCurrPos);
//		return ERR_TP_ESTOP;
//   }
//


//특정 Node 만나면 E-Stop 기능 추가. (제동거리 측정 기능)
//	if(OHTMainForm->chkNodeEstop->Checked == true)
//	{
//		if(OHTMainForm->NodeEstop->Text.ToIntDef(-1) == m_pOHTMainStatus->StatusCommon.CurNodeID)
//		{
//			if(nPreNodeID != m_pOHTMainStatus->StatusCommon.CurNodeID)
//			{
//				nPreNodeID = m_pOHTMainStatus->StatusCommon.CurNodeID;
//				ERR_LOG("NodeEstop node : %d, CurNode : %06d, Current Position : %6.1lf", OHTMainForm->NodeEstop->Text.ToIntDef(-1), m_pOHTMainStatus->StatusCommon.CurNodeID, TmpHwInfo.Axis1.dCurrPos);
//			}
//			return ERR_TP_ESTOP;
//		}
//		else
//		{
//			nPreNodeID = m_pOHTMainStatus->StatusCommon.CurNodeID; //직전 노드
//		}
//	}
#if ((OHT_NAME == OHT_NAME_STD_V86) /*&& (OHT_RETICLE_EXTEND_MODEL == RETICLE_EUV_1)*/)
//if((m_StatusSet.bIsOnProcess==true) && (m_StatusSet.byStatus==STS_GOING) && (m_StatusSet.uStep > DRIVING_CTRL_STEP_GO_PREPARE))
//{
//	ERR_LOG("SQA-CheckAbnormal : ERR_SHUTTER_DIFFSTATUS - 0,IsInnerFoup : %d,  bMidShutterFront : %d, bMidShutterRear : %d ",IsInnerFoup(),bMidShutterFront,bMidShutterRear);
//	if((IsInnerFoup() == false )&& ((bMidShutterFront == true) || (bMidShutterRear == true)))   //POD 없을 때 F,R Mid Close 센서 둘 중에 하나라도  On이면 에러 발생
//	{       ERR_LOG("SQA-CheckAbnormal : ERR_SHUTTER_DIFFSTATUS - 1");
//			nCountOfMidShutterDiff++;
//			if(nCountOfMidShutterDiff > 3)
//			{
//				nCountOfMidShutterDiff = 0;
//				ERR_LOG("SQA-CheckAbnormal : ERR_SHUTTER_DIFFSTATUS - 2");
//				return ERR_SHUTTER_DIFFSTATUS;
//			}
//	}
//	else
//			nCountOfMidShutterDiff = 0;
//}

#endif


	if(m_defualtparam->PreShutter)
	{
		static int nCountOfShutterDiff		= 0;
		static int nCountOfShutterNotClose	= 0;
		static int nCountOfShutterNotOpen	= 0;

		static DWORD dwLastTimeOfShutterClose = timeGetTime();
		static DWORD dwLastTimeOfShutterOpen = timeGetTime();

		static bool	bShutterFrontClose_AR = false;
		static bool	bShutterRearClose_AR = false;


		// 2 [ SHUTTER ]
		// SHUTTER 열림 닫힘 센서가 둘다 On 이면 에러 발생
		// SHUTTER 열림 닫힘 센서가 둘다 Off 이면 에러 발생
		// FOUP 있을 때 닫혀 있지 않으면 에러 발생
		// FOUP 없을 때 열려 있지 않으면 에러 발생

		//사전 동작 및 Close 동작중이 아닐 경우만 항시 Check할것.
#if((OHT_NAME == OHT_NAME_STD_V81) ||(OHT_NAME == OHT_NAME_STD_V81S) ||(OHT_NAME == OHT_NAME_STD_V80) || (OHT_NAME == OHT_NAME_STD_V82) ||  (OHT_NAME == OHT_NAME_P4_MASK) || (OHT_NAME == OHT_NAME_STD_V85S))
		if(pHWSet->m_pShutter->GetAutoRecoveryClose() != SHUTTER_AR_CLOSE_NONE &&(bFOUPDetect == false || bFOUPCoverDetect == true))
		{
			if(bFOUPDetect == false)
			{
				ERR_LOG("[AutoRecovery]Shutter Close Fail -ERR_INNER_FOUP_NOT_DETECT ");
				return ERR_INNER_FOUP_NOT_DETECT;
			}


			else if(bFOUPCoverDetect == true)
			{
				ERR_LOG("[AutoRecovery]Shutter Close Fail -ERR_FOUP_COVER_OPEN_DETECT ");
				return ERR_FOUP_COVER_OPEN_DETECT;
			}

		}
		if(pHWSet->m_pShutter->GetAutoRecoveryClose() == SHUTTER_AR_CLOSE_START && fabs(m_pDrivingAxis->GetCurrentVelocity()) < DRIVING1_ABNOMARL_MOVE_SPEED_LIMIT)
		{
			pHWSet->m_pShutter->SetAutoRecoveryClose(SHUTTER_AR_CLOSING);
			nTmpError = pHWSet->m_pShutter->Close_AutoRecovery();
			ERR_LOG("[AutoRecovery]Shutter Close Start");

		}
		else if(pHWSet->m_pShutter->GetAutoRecoveryClose() == SHUTTER_AR_CLOSE_COMPLETE /*&& fabs(m_pDrivingAxis->GetCurrentVelocity()) < DRIVING1_ABNOMARL_MOVE_SPEED_LIMIT*/)
		{
			if(bShutterFrontClose == true && bShutterRearClose == true)
			{
				  pHWSet->m_pShutter->SetAutoRecoveryClose(SHUTTER_AR_CLOSE_NONE);
				 // AutoRecovery 성공 Log
				 ERR_LOG("[AutoRecovery]Shutter Close Complete");
					if(bShutterFrontClose_AR == true)
					{
						AUTO_RECOV_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,SHUTTER FRONT CLOSE,End,%s,%06d,%06d,%06d,%d,%3.3lf,Current Position,%3.3lf,Inner FOUP Detect,%d,Foup Cover Open Detect,%d,Shutter Front AR Status,%d,Shutter Front Open,%d,Shutter Rear Open,%d,Shutter Front Close,%d,Shutter Rear Close,%d",
							m_defualtparam->VHLName,m_mccparam.cCarrierType,
							m_mccparam.uSourceNode,
							m_mccparam.uTargetNode,
							m_pExecuteInfo->ExecutePositionInfo.CurrNode,
							m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
							m_InfoSet.HwInfo.Axis1.dSpeed,
							//-------------------------------------------------
							m_pDrivingAxis->GetCurrentPosition(),
							bFOUPDetect,
							bFOUPCoverDetect,
							bShutterFrontClose_AR,
							bShutterFrontOpen, bShutterRearOpen,
							bShutterFrontClose, bShutterRearClose);

							bShutterFrontClose_AR = false;
					}
					if(bShutterRearClose_AR == true)
					{
						AUTO_RECOV_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,SHUTTER REAR CLOSE,End,%s,%06d,%06d,%06d,%d,%3.3lf,Current Position,%3.3lf,Inner FOUP Detect,%d,Foup Cover Open Detect,%d,Shutter Front AR Status,%d,Shutter Front Open,%d,Shutter Rear Open,%d,Shutter Front Close,%d,Shutter Rear Close,%d",
							m_defualtparam->VHLName,m_mccparam.cCarrierType,
							m_mccparam.uSourceNode,
							m_mccparam.uTargetNode,
							m_pExecuteInfo->ExecutePositionInfo.CurrNode,
							m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
							m_InfoSet.HwInfo.Axis1.dSpeed,
							//-------------------------------------------------
							m_pDrivingAxis->GetCurrentPosition(),
							bFOUPDetect,
							bFOUPCoverDetect,
							bShutterRearClose_AR,
							bShutterFrontOpen, bShutterRearOpen,
							bShutterFrontClose, bShutterRearClose);

							bShutterRearClose_AR = false;
					}
			}
			else if(bShutterFrontOpen == bShutterFrontClose || bShutterRearOpen == bShutterRearClose /*|| nTmpError != NO_ERR*/)
			{
				ERR_LOG("[AutoRecovery]Shutter Close Error - 2");
				pHWSet->m_pShutter->SetAutoRecoveryClose(SHUTTER_AR_CLOSE_ERROR);
				bShutterFrontClose_AR = false;
				bShutterRearClose_AR = false;

				return ERR_SHUTTER_DIFFSTATUS;
			}
		}
		else if(pHWSet->m_pShutter->GetAutoRecoveryClose() != SHUTTER_AR_CLOSE_NONE && OHTUTILITY::PreventOverflowGetTimeMs(pHWSet->m_pShutter->GetAutoRecoveryStartTime())>6*1000)
		{
			if(bShutterFrontOpen == bShutterFrontClose || bShutterRearOpen == bShutterRearClose)
			{
				ERR_LOG("[AutoRecovery]Shutter Close Error - 2-1");
				pHWSet->m_pShutter->SetAutoRecoveryClose(SHUTTER_AR_CLOSE_ERROR);

				return ERR_SHUTTER_DIFFSTATUS;
			}
			else
			{
				  pHWSet->m_pShutter->SetAutoRecoveryClose(SHUTTER_AR_CLOSE_COMPLETE);
				 // AutoRecovery 성공 Log
				 ERR_LOG("[AutoRecovery]Shutter Close Complete-2");
			}
			bShutterFrontClose_AR = false;
			bShutterRearClose_AR = false;
		}
#endif

		if((m_StatusSet.bIsOnProcess==true) && (m_StatusSet.byStatus==STS_GOING) && (m_StatusSet.uStep > DRIVING_CTRL_STEP_GO_PREPARE))
		{
			if((m_bShutterOpenFlag ==false) && (m_bShutterCloseFlag == false))
			{
#if((OHT_NAME == OHT_NAME_STD_V81) ||(OHT_NAME == OHT_NAME_STD_V81S) ||(OHT_NAME == OHT_NAME_STD_V80)||(OHT_NAME == OHT_NAME_STD_V82)|| (OHT_NAME == OHT_NAME_STD_V85S)|| (OHT_NAME == OHT_NAME_P4_MASK))


				if(bShutterFrontOpen == bShutterFrontClose || bShutterRearOpen == bShutterRearClose)
				{
					nCountOfShutterDiff++;
				   	if((nCountOfShutterDiff > 30 && bFOUPDetect == false) || (nCountOfShutterDiff > 60 && bFOUPDetect == true))  //2023.01.02 sseung AutoRecovery E161 Case1

					{

					if(bFOUPDetect == false) //2023.01.02 sseung AutoRecovery E161 Case3
					{
						AUTO_RECOV_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,SHUTTER STATUS,Start,%s,%06d,%06d,%06d,%d,%3.3lf,Hoist Home On,%d,Inner FOUP Detect,%d,Shutter Front Open,%d,Shutter Rear Open,%d,Shutter Front Close,%d,Shutter Rear Close,%d",
							m_defualtparam->VHLName,m_mccparam.cCarrierType,
							m_mccparam.uSourceNode,
							m_mccparam.uTargetNode,
							m_pExecuteInfo->ExecutePositionInfo.CurrNode,
							m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
							m_InfoSet.HwInfo.Axis1.dSpeed,
							//-------------------------------------------------
							bHoistHome,
							bFOUPDetect,
							bShutterFrontOpen, bShutterRearOpen,
							bShutterFrontClose, bShutterRearClose);

						m_nShutterRecovery_Time = timeGetTime();
						nCountOfShutterDiff = 0;
						ERR_LOG("E161 AutoRecovery 진행");
						m_nShutterRecovery_Cnt = true;

							ERR_LOG("AutoRecovery Shutter Open");
							nTmpError = pHWSet->m_pShutter->Open_AutoRecovery();
							if(nTmpError!=NO_ERR)
							{
								AUTO_RECOV_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,SHUTTER STATUS,End,%s,%06d,%06d,%06d,%d,%3.3lf,Hoist Home On,%d,Inner FOUP Detect,%d,Shutter Front Open,%d,Shutter Rear Open,%d,Shutter Front Close,%d,Shutter Rear Close,%d,Shutter Front Open Sensor Count,%d,Shutter Front Close Sensor Count,%d,Shutter Rear Open Sensor Count,%d,Shutter Rear Close Sensor Count,%d",
									m_defualtparam->VHLName,m_mccparam.cCarrierType,
									m_mccparam.uSourceNode,
									m_mccparam.uTargetNode,
									m_pExecuteInfo->ExecutePositionInfo.CurrNode,
									m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
									m_InfoSet.HwInfo.Axis1.dSpeed,
									//-------------------------------------------------
									bHoistHome,
									bFOUPDetect,
									bShutterFrontOpen, bShutterRearOpen,
									bShutterFrontClose, bShutterRearClose,
									m_mccparam.nShutterFrontOpenCount,
									m_mccparam.nShutterFrontCloseCount,
									m_mccparam.nShutterRearOpenCount,
									m_mccparam.nShutterRearCloseCount);

								m_nShutterRecovery_Cnt = false;
								return nTmpError;
							}

							ERR_LOG("---Check Shutter after Open");
							bShutterFrontOpen = pHWSet->m_pShutter->IsOpen(FRONT);
							bShutterFrontClose = pHWSet->m_pShutter->IsClose(FRONT);
							bShutterRearOpen = pHWSet->m_pShutter->IsOpen(REAR);
							bShutterRearClose = pHWSet->m_pShutter->IsClose(REAR);

							AUTO_RECOV_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,SHUTTER STATUS,End,%s,%06d,%06d,%06d,%d,%3.3lf,Hoist Home On,%d,Inner FOUP Detect,%d,Shutter Front Open,%d,Shutter Rear Open,%d,Shutter Front Close,%d,Shutter Rear Close,%d,Shutter Front Open Sensor Count,%d,Shutter Front Close Sensor Count,%d,Shutter Rear Open Sensor Count,%d,Shutter Rear Close Sensor Count,%d",
									m_defualtparam->VHLName,m_mccparam.cCarrierType,
									m_mccparam.uSourceNode,
									m_mccparam.uTargetNode,
									m_pExecuteInfo->ExecutePositionInfo.CurrNode,
									m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
									m_InfoSet.HwInfo.Axis1.dSpeed,
									//-------------------------------------------------
									bHoistHome,
									bFOUPDetect,
									bShutterFrontOpen, bShutterRearOpen, bShutterFrontClose, bShutterRearClose,
									m_mccparam.nShutterFrontOpenCount,
									m_mccparam.nShutterFrontCloseCount,
									m_mccparam.nShutterRearOpenCount,
									m_mccparam.nShutterRearCloseCount);
							m_nShutterRecovery_Cnt = false;

							if(bShutterFrontOpen == bShutterFrontClose || bShutterRearOpen == bShutterRearClose)
							{
								ERR_LOG("CheckAbnormal : ERR_SHUTTER_DIFFSTATUS");
								return ERR_SHUTTER_DIFFSTATUS;
						}

						}
						//Hand Close 상태도 볼지 검토
						else if(bFOUPDetect == true && bFOUPCoverDetect == false) // Foup O 상태에서 Foup Cover가 감지되지 않는 경우에만 AutoRecovery 시도
						{
							if(pHWSet->m_pShutter->GetAutoRecoveryClose() == SHUTTER_AR_CLOSE_NONE /*|| pHWSet->m_pShutter->GetAutoRecoveryClose() == SHUTTER_AR_CLOSE_COMPLETE*/)
							{
								pHWSet->m_pShutter->SetAutoRecoveryClose(SHUTTER_AR_CLOSE_START);
								ERR_LOG("SetAutoRecoveryClose(SHUTTER_AR_CLOSE_START)");
								if(bShutterFrontClose == false)
								{
									AUTO_RECOV_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,SHUTTER FRONT CLOSE,Start,%s,%06d,%06d,%06d,%d,%3.3lf,Current Position,%3.3lf,Inner FOUP Detect,%d,Foup Cover Open Detect,%d,Shutter Front Open,%d,Shutter Rear Open,%d,Shutter Front Close,%d,Shutter Rear Close,%d",
										m_defualtparam->VHLName,m_mccparam.cCarrierType,
										m_mccparam.uSourceNode,
										m_mccparam.uTargetNode,
										m_pExecuteInfo->ExecutePositionInfo.CurrNode,
										m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
										m_InfoSet.HwInfo.Axis1.dSpeed,
										//-------------------------------------------------
										m_pDrivingAxis->GetCurrentPosition(),
										bFOUPDetect,
										bFOUPCoverDetect,
										bShutterFrontOpen, bShutterRearOpen,
										bShutterFrontClose, bShutterRearClose);
										bShutterFrontClose_AR = true;
								}
								if(bShutterRearClose == false)
								{
									AUTO_RECOV_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,SHUTTER REAR CLOSE,Start,%s,%06d,%06d,%06d,%d,%3.3lf,Current Position,%3.3lf,Inner FOUP Detect,%d,Foup Cover Open Detect,%d,Shutter Front Open,%d,Shutter Rear Open,%d,Shutter Front Close,%d,Shutter Rear Close,%d",
										m_defualtparam->VHLName,m_mccparam.cCarrierType,
										m_mccparam.uSourceNode,
										m_mccparam.uTargetNode,
										m_pExecuteInfo->ExecutePositionInfo.CurrNode,
										m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
										m_InfoSet.HwInfo.Axis1.dSpeed,
										//-------------------------------------------------
										m_pDrivingAxis->GetCurrentPosition(),
										bFOUPDetect,
										bFOUPCoverDetect,
										bShutterFrontOpen, bShutterRearOpen,
										bShutterFrontClose, bShutterRearClose);
										bShutterRearClose_AR = true;
								}
							}
						}
						else
						{
 							if(bShutterFrontOpen == bShutterFrontClose || bShutterRearOpen == bShutterRearClose)
							{
								ERR_LOG("CheckAbnormal : ERR_SHUTTER_DIFFSTATUS");
								pHWSet->m_pShutter->SetAutoRecoveryClose(SHUTTER_AR_CLOSE_ERROR); // SHUTTER_AR_CLOSE_START 시도 후 Foup 비정상 감지로 에러 발생한 경우 Resume 처리 위하여 추가
								return ERR_SHUTTER_DIFFSTATUS;
							}

						}
					}
				}
				else
					nCountOfShutterDiff = 0;
#elif((OHT_NAME == OHT_NAME_STD_V80_RETICLE) || (OHT_NAME == OHT_NAME_STD_V85) || (OHT_NAME == OHT_NAME_STD_V86))
					if(bShutterFrontOpen == bShutterFrontClose || bShutterRearOpen == bShutterRearClose)
				{
					nCountOfShutterDiff++;
					if((nCountOfShutterDiff > 30 && bFOUPDetect == false) || (nCountOfShutterDiff > 60 && bFOUPDetect == true))  //2023.01.02 sseung AutoRecovery E161 Case1
					{
						AUTO_RECOV_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,SHUTTER STATUS,Start,%s,%06d,%06d,%06d,%d,%3.3lf,Hoist Home On,%d,Inner FOUP Detect,%d,Shutter Front Open,%d,Shutter Rear Open,%d,Shutter Front Close,%d,Shutter Rear Close,%d",
							m_defualtparam->VHLName,m_mccparam.cCarrierType,
							m_mccparam.uSourceNode,
							m_mccparam.uTargetNode,
							m_pExecuteInfo->ExecutePositionInfo.CurrNode,
							m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
							m_InfoSet.HwInfo.Axis1.dSpeed,
							bHoistHome,
							bFOUPDetect,
							bShutterFrontOpen, bShutterRearOpen,
							bShutterFrontClose, bShutterRearClose);
						m_nShutterRecovery_Time = timeGetTime();
						nCountOfShutterDiff = 0;
						ERR_LOG("E161 AutoRecovery 진행");
						m_nShutterRecovery_Cnt = true;
						if(bFOUPDetect == false) //2023.01.02 sseung AutoRecovery E161 Case3
						{
							ERR_LOG("AutoRecovery Shutter Open");
							nTmpError = pHWSet->m_pShutter->Open_AutoRecovery();
							if(nTmpError != NO_ERR)
							{
								AUTO_RECOV_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,SHUTTER STATUS,End,%s,%06d,%06d,%06d,%d,%3.3lf,Hoist Home On,%d,Inner FOUP Detect,%d,Shutter Front Open,%d,Shutter Rear Open,%d,Shutter Front Close,%d,Shutter Rear Close,%d,Shutter Front Open Sensor Count,%d,Shutter Front Close Sensor Count,%d,Shutter Rear Open Sensor Count,%d,Shutter Rear Close Sensor Count,%d",
									m_defualtparam->VHLName,m_mccparam.cCarrierType,
									m_mccparam.uSourceNode,
									m_mccparam.uTargetNode,
									m_pExecuteInfo->ExecutePositionInfo.CurrNode,
									m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
									m_InfoSet.HwInfo.Axis1.dSpeed,
									bHoistHome,
									bFOUPDetect,
									bShutterFrontOpen, bShutterRearOpen,
									bShutterFrontClose, bShutterRearClose,
									m_mccparam.nShutterFrontOpenCount,
									m_mccparam.nShutterFrontCloseCount,
									m_mccparam.nShutterRearOpenCount,
									m_mccparam.nShutterRearCloseCount);
								m_nShutterRecovery_Cnt = false;

								return nTmpError;
							}
							ERR_LOG("---Check Shutter after Open");
							bShutterFrontOpen = pHWSet->m_pShutter->IsOpen(FRONT);
							bShutterFrontClose = pHWSet->m_pShutter->IsClose(FRONT);
							bShutterRearOpen = pHWSet->m_pShutter->IsOpen(REAR);
							bShutterRearClose = pHWSet->m_pShutter->IsClose(REAR);
							AUTO_RECOV_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,SHUTTER STATUS,End,%s,%06d,%06d,%06d,%d,%3.3lf,Hoist Home On,%d,Inner FOUP Detect,%d,Shutter Front Open,%d,Shutter Rear Open,%d,Shutter Front Close,%d,Shutter Rear Close,%d,Shutter Front Open Sensor Count,%d,Shutter Front Close Sensor Count,%d,Shutter Rear Open Sensor Count,%d,Shutter Rear Close Sensor Count,%d",
									m_defualtparam->VHLName,m_mccparam.cCarrierType,
									m_mccparam.uSourceNode,
									m_mccparam.uTargetNode,
									m_pExecuteInfo->ExecutePositionInfo.CurrNode,
									m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
									m_InfoSet.HwInfo.Axis1.dSpeed,
									//-------------------------------------------------
									bHoistHome,
									bFOUPDetect,
									bShutterFrontOpen, bShutterRearOpen, bShutterFrontClose, bShutterRearClose,
									m_mccparam.nShutterFrontOpenCount,
									m_mccparam.nShutterFrontCloseCount,
									m_mccparam.nShutterRearOpenCount,
									m_mccparam.nShutterRearCloseCount);
							m_nShutterRecovery_Cnt = false;
						}
						if(bShutterFrontOpen == bShutterFrontClose || bShutterRearOpen == bShutterRearClose)
						{
						ERR_LOG("CheckAbnormal : ERR_SHUTTER_DIFFSTATUS");
						return ERR_SHUTTER_DIFFSTATUS;
						}
					}
				}
				else
					nCountOfShutterDiff = 0;
#endif
			}
			//////Close 무시 구간.
			if(m_bShutterCloseFlag == true)
			{
				if(pHWSet->m_pShutter->IsInposition(FRONT) && pHWSet->m_pShutter->IsClose(FRONT) && m_mccparam.bFrontShutterFlag && (m_mccparam.nShutterFrontTime == 0))
				{
					m_mccparam.nShutterFrontTime = OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwShutterFrontTime);
				}

				if(pHWSet->m_pShutter->IsInposition(REAR) && pHWSet->m_pShutter->IsClose(REAR) && m_mccparam.bRearShutterFlag && (m_mccparam.nShutterRearTime == 0))
				{
					m_mccparam.nShutterRearTime = OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwShutterRearTime);
				}

				if(OHTUTILITY::PreventOverflowGetTimeMs(dwLastTimeOfShutterClose) < 3000)
				{
					if(m_bShutterCloseMovingFlag == true)
					{
					   if(pHWSet->m_pShutter->IsInposition(BOTH))
					   {
							pHWSet->m_pShutter->SendCloseCmd_Classifying_Material();
							ADD_LOG("D-5");
							m_bShutterCloseMovingFlag = false;
					   }
					}
					else
						CheckShutterClose(dFrontAxisSpeed);
				}
				else
					m_bShutterCloseFlag = false;

			}
			else  // Close 명령관련된 부분이 아닐때만 확인.
			{
				dwLastTimeOfShutterClose = timeGetTime();
				m_bShutterCloseMovingFlag = false;

				if(m_bShutterOpenFlag ==false)
				{
					if(IsInnerFoup() == true && bShutterBothClose == false)
					{
						nCountOfShutterNotClose++;
						if(nCountOfShutterNotClose > 40)   //inner Foup 에러 발생 채터링과 동기화처리
						{
							nCountOfShutterNotClose = 0;
							ERR_LOG("CheckAbnormal: ERR_SHUTTER_NOT_CLOSE");
							ADD_FDC_LOG("ERR/%d/2/9/%06d/%06d/%d/%d/%06d/%d/%d/%d/%d",
										ERR_SHUTTER_NOT_CLOSE,
										m_pOHTMainStatus->StatusCommon.CurNodeID,
										m_pExecuteInfo->ExecutePositionInfo.NextNode,
										m_pOHTMainStatus->StatusCommon.CurNodeOffset,
										m_pOHTMainStatus->StatusCommon.ExistFoup,
										m_pOHTMainStatus->StatusCommon.StopStationID,
										bShutterFrontOpen,
										bShutterFrontClose,
										bShutterRearOpen,
										bShutterRearClose);
							return ERR_SHUTTER_NOT_CLOSE;
						}
					}
					else
						nCountOfShutterNotClose = 0;
				}
			}

		   //사전 동작 시는 무시함...
			if(m_bShutterOpenFlag ==false)  //사전 동작. Open관련 명령이 없을 경우만  Check
			{
				dwLastTimeOfShutterOpen  = timeGetTime();
#if(OHT_NAME != OHT_NAME_P4_MASK)
				if(IsInnerFoup() == false && bShutterBothOpen == false)
#else
				if(IsInnerFoup() == false && bShutterBothClose == false)    // MASK OHT는 Shutter 닫고 이동
#endif
				{
					nCountOfShutterNotOpen++;
					if(nCountOfShutterNotOpen > 40)   //inner Foup 에러 발생 채터링과 동기화처리
					{
						nCountOfShutterNotOpen = 0;
						ERR_LOG("CheckAbnormal: ERR_SHUTTER_NOTORIGIN");
						ADD_FDC_LOG("ERR/%d/8/9/%06d/%06d/%d/%d/%06d/%d/%d/%d/%d",
									ERR_SHUTTER_NOTORIGIN,
									m_pOHTMainStatus->StatusCommon.CurNodeID,
									m_pExecuteInfo->ExecutePositionInfo.NextNode,
									m_pOHTMainStatus->StatusCommon.CurNodeOffset,
									m_pOHTMainStatus->StatusCommon.ExistFoup,
									m_pOHTMainStatus->StatusCommon.StopStationID,
									bShutterFrontOpen,
									bShutterFrontClose,
									bShutterRearOpen,
									bShutterRearClose);
						return ERR_SHUTTER_NOTORIGIN;
					}
				}
				else
					nCountOfShutterNotOpen = 0;
			}
			else if(m_bShutterOpenFlag == true)
			{
				if(pHWSet->m_pShutter->IsInposition(FRONT) && pHWSet->m_pShutter->IsOpen(FRONT) && m_mccparam.bFrontShutterFlag && (m_mccparam.nShutterFrontTime == 0))
				{
					m_mccparam.nShutterFrontTime = OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwShutterFrontTime);
				}

				if(pHWSet->m_pShutter->IsInposition(REAR) && pHWSet->m_pShutter->IsOpen(REAR) && m_mccparam.bRearShutterFlag && (m_mccparam.nShutterRearTime == 0))
				{
					m_mccparam.nShutterRearTime = OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwShutterRearTime);
				}
			}

			nTmpError =CheckShutterAlarm();
			if(nTmpError!=NO_ERR)return nTmpError;

		}
		else
		{
			dwLastTimeOfShutterClose = timeGetTime();
			m_bShutterCloseMovingFlag = false;
		}
	}

#if(OHT_NAME != OHT_NAME_P4_MASK)
	CID_Monitor_Status(&Info,dFrontAxisSpeed);
#endif


    // 정위치 아닐 경우 에러 발생: 주행 Tag / 이적재 Tag / QR Tag 별 처리 필요 - 정위치 Type 상태 정보 필요
    // 정지 위치에서 특정 거리만큼 차이 발생 시 에러 발생: 엔코더 값을 이용한 확인
    // 정지 후 리미트 초과 시 에러 발생: 추가 논의 필요 - 리미트 설정 하고 싶지 않음

    //1 파라미터 정보 확인 및 업데이트
    if(m_StatusSet.bIsOnProcess==false)
    {
        updateParameter();
    }


	//저진동 대차감지시 감속도 설정 부분 puting 20190421

	if(m_LineParamSet->bUseLowVibration == true)   //AOHC-285
	{
		if(pHWSet->GetLowVabraionStatus() == 0)
		{
			m_pDrivingAxis->SetLowVibration();
			 //ON하는 플래그 확인.
		}

		//AOHC-286 연속 명령 방지.  //AOHC-295
		if(OHTUTILITY::PreventOverflowGetTimeMs(dwCheckAMCDetectStopDecelDownStatusTime) > 100)
		{
			if((m_StatusSet.bIsOnProcess==false)||(m_InfoSet.EventAndState.State.MarkArea==true))  // 마크단계 3.5m/s^2 적용해야되는 시점
			{
				if(pHWSet->GetAMCDetectStopDecelDownStatus() == 1) // 0.5m/s^2 일 경우,
				{
					m_pDrivingAxis->SetDetectStopDecelDown();   //3.5m/s^2로 설정 -> 0으로
					dwCheckAMCDetectStopDecelDownStatusTime = timeGetTime();    //AOHC-295
				}
			}
			else  //주행단계 0.5 적용해야되는 시점.
			{
				if(pHWSet->GetAMCDetectStopDecelDownStatus() == 0) //3.5m/s^2 일 경우
				{
					m_pDrivingAxis->SetDetectStopDecelDownRelease();   //0.5m/s^2로 설정 -> 1로
					dwCheckAMCDetectStopDecelDownStatusTime = timeGetTime();   //AOHC-295
				}
			}
        }

	}else
	{
		if(pHWSet->GetLowVabraionStatus() == 1)
		{
			m_pDrivingAxis->SetLowVibrationRelease();
             //OFF하는 플래그 확인.
        }

		if(pHWSet->GetAMCDetectStopDecelDownStatus() == 1) // 0.5m/s^2 일 경우,
		{
			m_pDrivingAxis->SetDetectStopDecelDown();   //3.5m/s^2로 설정 -> 0으로
		}
    }
    //1 0. 위치 정보 Update
	  if(m_StatusSet.bIsOnProcess==false && m_PositionInfo.Marked==false && m_StatusSet.byStatus!=STS_INIT)
	  {
			if(fabs(dFrontAxisSpeed) > DRIVING1_ABNOMARL_MOVE_SPEED_LIMIT)
			{
				  if(OHTUTILITY::PreventOverflowGetTimeMs(dwLastTimeOfTriggerOn) > 100)
				  {
						ERR_LOG("DrivingFrontSpeed :%f",dFrontAxisSpeed);
						m_InfoSet.Control.IdReader[0] = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;  // Stop Tag
						dwLastTimeOfTriggerOn = timeGetTime();
						nTmpError = controlAll(m_InfoSet.Control);
				  }
			}

		getPostionInfoOnManual(TmpHwInfo,&m_PositionInfo);
	  }

		//빼냄과 투입은 항시 감시해야됨.
	nTmpError =checMTLTakeIn(TmpHwInfo);
	if(nTmpError!=NO_ERR)return nTmpError;

	nTmpError =checMTLTakeOut(TmpHwInfo);
	if(nTmpError!=NO_ERR)return nTmpError;


	if(m_StatusSet.byStatus!=STS_TURN_OFF) dwTurnoffTime = timeGetTime();

	//1 1. 자동 복구
	//2     Rear OFF  기동 off에 관련된 부분
	if((((m_StatusSet.byStatus==STS_TURN_OFF) || (m_StatusSet.byStatus==STS_INIT)|| (m_StatusSet.byStatus==STS_AUTORECOVERY_OVERRUN) ||(m_StatusSet.byStatus==STS_AUTORECOVERY) ||(m_StatusSet.byStatus==STS_AUTORECOVERY_BLANKTRANS)||(m_StatusSet.byStatus==STS_AUTORECOVERY_DOUBLETRANS)) ||   //기동 상태
		((m_StatusSet.bIsOnProcess==true) && (m_StatusSet.byStatus==STS_GOING) &&
		((TmpHwInfo.IO.DetectStatus==DETECT_AND_STOP) || (TmpHwInfo.IO.ObsStatus==DETECT_AND_STOP) ||
		(m_pExecuteInfo->bTpPause != false) || (m_pExecuteInfo->bOcsPause != false) || (pHWSet->m_pCID->GetCIDPause() != false))))   //대차감지 상태일때
	&&	(m_pExecuteInfo->ExecuteMode == EXECUTE_MODE_AUTO)
	&&  m_pDrivingAxis->IsSyncControl() == true
	&&  bFrontAMPEnable == true
	&&  bFrontIsRunning == false
	&&  bRearAMPEnable  == true
	&&  bRearIsRunning  == false
	&&  m_cSlopeNodeInfo !=SLOPE_NTYPE
	)
	{

		if(OHTUTILITY::PreventOverflowGetTimeMs(dwRearServoOffTime) > 10000)
		{
//			ERR_LOG("SetSlaveAMPEnable Auto Off");
#if((OHT_NAME == OHT_NAME_STD_V80) ||(OHT_NAME == OHT_NAME_STD_V81) || (OHT_NAME == OHT_NAME_STD_V81S)  ||(OHT_NAME == OHT_NAME_STD_V85)|| (OHT_NAME == OHT_NAME_STD_V80_RETICLE))
		 	m_pDrivingAxis->SetSlaveAMPEnable(false);    //E2302대응
#endif
		}
	}
	else
	{
		//MTL Lifter 고려할것.
		if(((m_StatusSet.bIsOnProcess==true) && (m_StatusSet.byStatus==STS_GOING) &&
		   (TmpHwInfo.IO.DetectStatus!=DETECT_AND_STOP) &&(TmpHwInfo.IO.ObsStatus!=DETECT_AND_STOP) &&
		   (m_pExecuteInfo->bTpPause == false) && (m_pExecuteInfo->bOcsPause == false) && (pHWSet->m_pCID->GetCIDPause() == false))   //대차감지 상태일때
		&&  m_pDrivingAxis->IsSyncControl() == true
		&&  bRearAMPEnable  == false
		&&  bRearIsRunning  == false
		&&  ((m_StatusSet.uStep > DRIVING_CTRL_STEP_GO_FIRST_NODE) &&  (m_StatusSet.uStep < DRIVING_CTRL_STEP_GO_CHECK_STOP))
		)
		{

			if(OHTUTILITY::PreventOverflowGetTimeMs(dwRearServoOffTime)> 1000)
			{
				ERR_LOG("SetSlaveAMPEnable Auto ON OD:%d OS:%d", TmpHwInfo.IO.DetectStatus,TmpHwInfo.IO.ObsStatus);
				m_pDrivingAxis->SetSlaveAMPEnable(true);
			}

		}
		else
		{
			dwRearServoOffTime = timeGetTime();
		}
	}


     // 1. 주행 중 Break 상태 확인하는 부분
//	if(m_StatusSet.byStatus==STS_GOING)
//	{
//		if(m_pDrivingAxis->IsBrakeReleased()==false)
//		{
//           if((bFrontIsRunning ==true) || (bRearIsRunning==true))
//		   {
//				m_pDrivingAxis->SetBrakeRelease(true);
//		   }
//		}
//	}
//	  // 2. 에러 Or 기동 Off시  break 사용/ 내부제한토크 선택적으로 사용할것.
	if((m_StatusSet.byStatus==STS_ERROR) || (m_StatusSet.byStatus==STS_TURN_OFF))
	{
//		if((cSlopeNodeInfo ==NODE_SLOPE)  || (m_StatusSet.bIsOnProcess==false))
		if((m_cSlopeNodeInfo ==SLOPE_NTYPE) || (m_cSlopeNodeInfo ==INIT_NTYPE) ||
		   (m_pExecuteInfo->bJogInterlockIgnore == true))
		{
			//Slope에서 모터관련 에러일 경우 브레이크 동작
			if((TmpHwInfo.Axis1.nError !=NO_ERR) ||  (TmpHwInfo.Axis2.nError !=NO_ERR))
			{
				if(m_pDrivingAxis->IsBrakeReleased()==true)
				{
					ADD_LOG("D-6");
					m_pDrivingAxis->SetBrakeRelease(false);
				}
			}
			//슬로프에서 일반적인 에러일 경우 or 기동 Off일 경우, 내부제한 토크 설정.
			else
			{
				if((bFrontIsRunning ==false) && (bRearIsRunning==false))
				{
#if((OHT_NAME == OHT_NAME_STD_V82)|| (OHT_NAME == OHT_NAME_STD_V85S)||(OHT_NAME == OHT_NAME_STD_V86)|| (OHT_NAME == OHT_NAME_P4_MASK))
#else

					DWORD dwCurrTime  = timeGetTime();
					//SetInnerLimitTorque_90 자체 800ms Sleep있으므로 2회 Retry 가능하도록 500ms->1000ms로 변경  #Jrespect.im
					if(m_defualtparam->bUseRSA==true)
					{
						while(OHTUTILITY::PreventOverflowGetTimeMs( dwCurrTime)<1000)
						{
							 if(m_pRSAControl->IsSetInnerLimitTorque_90() == true)
								break;
								m_pRSAControl->SetInnerLimitTorque_90();

								ADD_LOG("D-7");
								Sleep(5);
						}

						if( m_pRSAControl->IsSetInnerLimitTorque_90() ==false)
						{
						  // nTmpError = ERR_SERVO_DRIVING_ALARM;
						   ADD_LOG("D-8");
						}
						else
						{
							//ERR_LOG("[CheckAlways] Success SetInnerLimitTorque_90");
						}
					}
					else
					{
						while(OHTUTILITY::PreventOverflowGetTimeMs( dwCurrTime)<1000)
						{

							 if(m_pServoControl->IsSetInnerLimitTorque_90() == true)
								break;
								m_pServoControl->SetInnerLimitTorque_90();   //DrivingControl::CheckAlways Retry Error 처리 0

								ADD_LOG("D-7");
								Sleep(5);
						}
						if(m_pServoControl->IsSetInnerLimitTorque_90() == false)
						{
						 // nTmpError = ERR_SERVO_DRIVING_ALARM;
						   ADD_LOG("D-8");
						}
						else
						{
							//ERR_LOG("[CheckAlways] Success SetInnerLimitTorque_90");
						}
                                         }
#endif
				}

			}
		}
	}
    // 축 에러 확인
    nTmpError = TmpHwInfo.Axis1.nError;
    if(nTmpError!=NO_ERR)return nTmpError;

    if( m_pDrivingAxis->IsSyncControl() == true )
    {
        nTmpError = TmpHwInfo.Axis2.nError;
        if(nTmpError!=NO_ERR)return nTmpError;
    }


	if((m_pExecuteInfo->ExecuteMode == EXECUTE_MODE_MANUAL) && (m_pExecuteInfo->bJogInterlockIgnore == true))
	{
		return NO_ERR;
	}
#if((OHT_NAME != OHT_NAME_STD_V85S)&&(OHT_NAME != OHT_NAME_STD_V82)&&(OHT_NAME != OHT_NAME_STD_V86)&&(OHT_NAME != OHT_NAME_P4_MASK))
	if((m_pExecuteInfo->ExecuteMode == EXECUTE_MODE_MANUAL) && (m_pOHTMainStatus->DataUseFlag.fUBGLoad == false))
	{
		m_pOHTMainStatus->DataUseFlag.fUBGLoad = 0xff;
		return ERR_UBG_NO_DATA;
	}
#endif

	//1 2. Mark 해제
    //2     Marked 해제: 센서 가 들어오지 않을 경우
    if( getMarkStatus() == true
//  &&  m_StatusSet.bIsOnProcess==false
	&&  (m_StatusSet.byStatus!=STS_GOING)
    )
	{
		switch(MarkType)
        {
		case MARK_TYPE_NODE:
            if(bNodeOn == OFF)
            {
				ERR_LOG("[ERR_MARK_FAIL:Node]MarkType: %d, Status:%d, OnProcess:%d [%d:%d:%d]"
                    , MarkType, m_StatusSet.byStatus, m_StatusSet.bIsOnProcess
                    , bNodeOn, m_InfoSet.HwInfo.IO.NodeOn, m_pDrivingTag->IsOn());
				ADD_FDC_LOG("ERR/%d/2/8/%06d/%06d/%d/%d/%06d/%d/%d/%d",
							ERR_MARK_FAIL,
							m_pOHTMainStatus->StatusCommon.CurNodeID,
							m_pExecuteInfo->ExecutePositionInfo.NextNode,
							m_pOHTMainStatus->StatusCommon.CurNodeOffset,
							m_pOHTMainStatus->StatusCommon.ExistFoup,
							m_pOHTMainStatus->StatusCommon.StopStationID,
							MarkType,
							m_StatusSet.byStatus,
							m_StatusSet.bIsOnProcess);

				nMarkCheckCount++;
				//에러는 미처리하며 로그만 찍음. (엔코더는 정상이고, BCR데이터는 읽힌 이후이나 반사판이 미인식된경우)

//				if(nMarkCheckCount == 3)
//					setMarkStatusFalse();
				if(m_bFDCMarkFailFlag == true)
				{
					SEND_WARN("WARN/52/1/8/%06d/%06d/%d/%d/%06d/%d/%d/%d",
							m_pOHTMainStatus->StatusCommon.CurNodeID,
							m_pExecuteInfo->ExecutePositionInfo.NextNode,
							m_pOHTMainStatus->StatusCommon.CurNodeOffset,
							m_pOHTMainStatus->StatusCommon.ExistFoup,
							m_pOHTMainStatus->StatusCommon.StopStationID,
							MarkType,
							m_StatusSet.byStatus,
							m_StatusSet.bIsOnProcess);
					m_bFDCMarkFailFlag = false;
				}

            }
            break;

		case MARK_TYPE_TAG_STATION:
		case MARK_TYPE_TAG_STATION_BACK:
//			if( bTagStationFrontOn  == OFF  ||
//				bTagStationRearOn   == OFF      )
			if( bTagStationFrontOn  == OFF  ||
			   ((bTagStationRearOn   == OFF)  &&   //리커버리 동작하지 않을는 거리값도 같이봄, 리커버리 동작했을때는 센서만 체크함.
				(((m_bIsRecovery==false) && (fabs(dFrontAxisCurrPos - m_dStationMarkInpos) > m_pParamSet->StationMarkInPos))||
				 (m_bIsRecovery==true)))
				)
			{
				ERR_LOG("[ERR_MARK_FAIL:Tag]MarkType: %d, Status:%d, OnProcess:%d F[%d:%d:%d]R[%d:%d:%d][%f,%f,%f]"
                    , MarkType, m_StatusSet.byStatus, m_StatusSet.bIsOnProcess
                    , bTagStationFrontOn, m_InfoSet.HwInfo.IO.TagStationFrontOn, m_pTransStopTag->IsOnFrontSensor()
					, bTagStationRearOn, m_InfoSet.HwInfo.IO.TagStationRearOn, m_pTransStopTag->IsOnRearSensor(),
					(dFrontAxisCurrPos - m_dStationMarkInpos),dFrontAxisCurrPos,m_dStationMarkInpos);

				nMarkCheckCount++;

				if(nMarkCheckCount == 50)
				{
					setMarkStatusFalse();
					ADD_FDC_LOG("ERR/%d/3/8/%06d/%06d/%d/%d/%06d/%d/%d/%d",
								ERR_MARK_FAIL,
								m_pOHTMainStatus->StatusCommon.CurNodeID,
								m_pExecuteInfo->ExecutePositionInfo.NextNode,
								m_pOHTMainStatus->StatusCommon.CurNodeOffset,
								m_pOHTMainStatus->StatusCommon.ExistFoup,
								m_pOHTMainStatus->StatusCommon.StopStationID,
								MarkType,
								m_StatusSet.byStatus,
								m_StatusSet.bIsOnProcess);
				}

				if((m_bFDCMarkFailFlag == true) && (nMarkCheckCount == 30))
				{
					SEND_WARN("WARN/52/2/8/%06d/%06d/%d/%d/%06d/%d/%d/%d",
							m_pOHTMainStatus->StatusCommon.CurNodeID,
							m_pExecuteInfo->ExecutePositionInfo.NextNode,
							m_pOHTMainStatus->StatusCommon.CurNodeOffset,
							m_pOHTMainStatus->StatusCommon.ExistFoup,
							m_pOHTMainStatus->StatusCommon.StopStationID,
							MarkType,
							m_StatusSet.byStatus,
							m_StatusSet.bIsOnProcess);
					m_bFDCMarkFailFlag = false;
				}
			}
			else
				nMarkCheckCount = 0;

            break;

        }

        if(getMarkStatus()==false)
        {
            ERR_LOG("[ERR_MARK_FAIL]MarkType: %d, Status:%d, OnProcess:%d",MarkType, m_StatusSet.byStatus, m_StatusSet.bIsOnProcess);
			bCountOfQRNG = 0;

			if(MarkType == MARK_TYPE_NODE)
				nTmpError   = ERR_MARK_FAIL_DRIVING;
			if((m_StatusSet.byStatus==STS_ARRIVED) || (m_StatusSet.byStatus==STS_UNLOADED) || (m_StatusSet.byStatus==STS_LOADED))
               	nTmpError   = ERR_MARK_FAIL;
			else
				nTmpError   = ERR_MARK_FAIL_TRANS;

			ADD_FDC_LOG("ERR/%d/1/8/%06d/%06d/%d/%d/%06d/%d/%d/%d",
						nTmpError,
						m_pOHTMainStatus->StatusCommon.CurNodeID,
						m_pExecuteInfo->ExecutePositionInfo.NextNode,
						m_pOHTMainStatus->StatusCommon.CurNodeOffset,
						m_pOHTMainStatus->StatusCommon.ExistFoup,
						m_pOHTMainStatus->StatusCommon.StopStationID,
						MarkType,
						m_StatusSet.byStatus,
						m_StatusSet.bIsOnProcess);

            return  nTmpError;  //@todo: 마크가 틀어진 에러
        }
    }
	else
    {
        bQROnTriger=false;
		nMarkCheckCount = 0;
    }

    //2 Mark 해제: 정위치에서 오차 범위 이상 벗어날 경우
    if(getMarkStatus()==true
//  && m_StatusSet.bIsOnProcess==false
	&&  (m_StatusSet.byStatus!=STS_GOING)
    )
    {
        bFrontOnMarkPosition    = (fabs(dFrontAxisCurrPos-dFrontAxisMarkPos)
                                < DIST_LIMIT_OF_FRONT_ON_WAIT)?true:false;
        if( m_pDrivingAxis->IsSyncControl() == true )
		{
            bRearOnMarkPosition = (fabs(dRearAxisCurrPos-dRearAxisMarkPos)
                                < DIST_LIMIT_OF_REAR_ON_WAIT)?true:false;
        }
        else
        {
            bRearOnMarkPosition = true;
        }

		if(bFrontOnMarkPosition==false  ||  bRearOnMarkPosition==false)
        {
            setMarkStatusFalse();
            nTmpError               = ERR_DRIVING_NOTORIGIN;
            ERR_LOG("MarkType: %d, F(%d:%6.1lf:%6.1lf)R(%d:%6.1lf:%6.1lf)"
                , MarkType
                , bFrontOnMarkPosition, dFrontAxisCurrPos, dFrontAxisMarkPos
                , bRearOnMarkPosition, dRearAxisCurrPos, dRearAxisMarkPos
                );
			ADD_FDC_LOG("ERR/%d/1/5/%06d/%06d/%d/%d/%06d",
						ERR_DRIVING_NOTORIGIN,
						m_pOHTMainStatus->StatusCommon.CurNodeID,
						m_pExecuteInfo->ExecutePositionInfo.NextNode,
						m_pOHTMainStatus->StatusCommon.CurNodeOffset,
						m_pOHTMainStatus->StatusCommon.ExistFoup,
						m_pOHTMainStatus->StatusCommon.StopStationID);
            return nTmpError;
        }
    }

	//2 축이 외력에 의해 움직일 경우 에러 발생
	if( m_StatusSet.bIsOnProcess==false )
	{
		if(dFrontAxisSpeed > DRIVING_MAX_SPEED || dRearAxisSpeed > DRIVING_MAX_SPEED )
		{
			ERR_LOG("Driving Max Speed!!");
			return ERR_DRIVING_SPEED_MAX_LIMIT;
		}
		if(dFrontAxisSpeed < -1.0 || dRearAxisSpeed < -1.0)
		{
			ERR_LOG("Driving Min Speed!!");
			return ERR_DRIVING_SPEED_MIN_LIMIT;
		}
		if(dFrontAxisCurrPos > MAX_DRIVING_DISTANCE || dRearAxisCurrPos > MAX_DRIVING_DISTANCE )
		{
			ERR_LOG("Driving Max Distance!!");
			return ERR_DRIVING_DIST_P_LIMIT;
		}
	}

	if( m_StatusSet.bIsOnProcess==false )
	{
		if(fabs(dFrontAxisSpeed)>DRIVING1_ABNOMARL_MOVE_SPEED_LIMIT  && bFrontIsRunning==false  )
		{
			if(m_StatusSet.byStatus!=STS_TURN_OFF)
			{
				ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d",
						ERR_DRIVING1_ABNORMAL_MOVING,
						m_pOHTMainStatus->StatusCommon.CurNodeID,
						m_pExecuteInfo->ExecutePositionInfo.NextNode,
						m_pOHTMainStatus->StatusCommon.CurNodeOffset,
						m_pOHTMainStatus->StatusCommon.ExistFoup,
						m_pOHTMainStatus->StatusCommon.StopStationID,
						fabs(dFrontAxisSpeed));
				return ERR_DRIVING1_ABNORMAL_MOVING;
			}
			else
			{

			   if(OHTUTILITY::PreventOverflowGetTimeMs(dwTurnoffTime) > 5000)
			   {
					ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d",
						ERR_DRIVING1_ABNORMAL_MOVING,
						m_pOHTMainStatus->StatusCommon.CurNodeID,
						m_pExecuteInfo->ExecutePositionInfo.NextNode,
						m_pOHTMainStatus->StatusCommon.CurNodeOffset,
						m_pOHTMainStatus->StatusCommon.ExistFoup,
						m_pOHTMainStatus->StatusCommon.StopStationID,
						fabs(dFrontAxisSpeed));
                	return ERR_DRIVING1_ABNORMAL_MOVING;
			   }
			}
		}
	}

    if( m_StatusSet.bIsOnProcess==false &&  m_pDrivingAxis->IsSyncControl() ==true )
    {
		if( (fabs(dRearAxisSpeed)>DRIVING2_ABNOMARL_MOVE_SPEED_LIMIT) &&  (bRearIsRunning==false) && (bFrontIsRunning ==false) )
        {
			if(m_StatusSet.byStatus!=STS_TURN_OFF)
			{
				ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d",
						ERR_DRIVING2_ABNORMAL_MOVING,
						m_pOHTMainStatus->StatusCommon.CurNodeID,
						m_pExecuteInfo->ExecutePositionInfo.NextNode,
						m_pOHTMainStatus->StatusCommon.CurNodeOffset,
						m_pOHTMainStatus->StatusCommon.ExistFoup,
						m_pOHTMainStatus->StatusCommon.StopStationID,
						fabs(dRearAxisSpeed));
				return ERR_DRIVING2_ABNORMAL_MOVING;
			}
			else
			{

			   if(OHTUTILITY::PreventOverflowGetTimeMs(dwTurnoffTime) > 5000)
			   {
					ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d",
						ERR_DRIVING2_ABNORMAL_MOVING,
						m_pOHTMainStatus->StatusCommon.CurNodeID,
						m_pExecuteInfo->ExecutePositionInfo.NextNode,
						m_pOHTMainStatus->StatusCommon.CurNodeOffset,
						m_pOHTMainStatus->StatusCommon.ExistFoup,
						m_pOHTMainStatus->StatusCommon.StopStationID,
						fabs(dRearAxisSpeed));
					return ERR_DRIVING2_ABNORMAL_MOVING;
			   }
			}

        }
    }

 	if(( m_StatusSet.bIsOnProcess==true )  && (m_StatusSet.byStatus==STS_GOING) && (m_bOnBackMove ==false)
 	 &&( dFrontAxisSpeed < DRIVING1_ABNOMARL_MOVE_SPEED_LIMIT_BACK))
	{

		ADD_LOG("D_1/%f",dFrontAxisSpeed);
		if(OHTUTILITY::PreventOverflowGetTimeMs(dwCheckMoveAbnormalBack) > 100)
		{
			ADD_FDC_LOG("ERR/%d/1/5/%06d/%06d/%d/%d/%06d",
								ERR_DRIVING_CAN_NOT_BECAME_HOME,
								m_pOHTMainStatus->StatusCommon.CurNodeID,
								m_pExecuteInfo->ExecutePositionInfo.NextNode,
								m_pOHTMainStatus->StatusCommon.CurNodeOffset,
								m_pOHTMainStatus->StatusCommon.ExistFoup,
								m_pOHTMainStatus->StatusCommon.StopStationID);
			return ERR_DRIVING_CAN_NOT_BECAME_HOME;
	}
	}
	else
		dwCheckMoveAbnormalBack = timeGetTime();

    //1 4. 센서 이상 확인
    //2 STEERING 이 좌우 2개가 들어왔을 때 에러 발생

	if( (bSteerFrontLeft==true)   && (bSteerFrontRight==true))
	{
		ADD_LOG("D_2/%d/%d",bSteerRearLeft,bSteerRearRight);
		ADD_FDC_LOG("ERR/%d/1/9/%06d/%06d/%d/%d/%06d/%d/%d/%d/%d",
					ERR_SEN_ABNORMAL_STEERING_FRONT,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pExecuteInfo->ExecutePositionInfo.NextNode,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					m_pOHTMainStatus->StatusCommon.ExistFoup,
					m_pOHTMainStatus->StatusCommon.StopStationID,
					bSteerRearLeft,bSteerRearRight,bSteerRearLeft,bSteerRearRight);
	    return ERR_SEN_ABNORMAL_STEERING_FRONT;
    }
	if( (bSteerRearLeft==true)    && (bSteerRearRight==true))
	{
		ADD_LOG("D_3/%d/%d",bSteerRearLeft,bSteerRearRight);
		ADD_FDC_LOG("ERR/%d/1/9/%06d/%06d/%d/%d/%06d/%d/%d/%d/%d",
					ERR_SEN_ABNORMAL_STEERING_REAR,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pExecuteInfo->ExecutePositionInfo.NextNode,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					m_pOHTMainStatus->StatusCommon.ExistFoup,
					m_pOHTMainStatus->StatusCommon.StopStationID,
					bSteerRearLeft,bSteerRearRight,bSteerRearLeft,bSteerRearRight);
	    return ERR_SEN_ABNORMAL_STEERING_REAR;
	}

	if((m_StatusSet.bIsOnProcess==true) && (m_StatusSet.byStatus==STS_GOING))
	{
		if(m_cSlopeNodeInfo ==SLOPE_NTYPE)
		  m_pExecuteInfo->nHIDPathInfo = EXECUTE_HIDPATH_SLOOP;
		else
		{
			if((m_Dectect_Dir == PATH_DIRECTION_NO_USE) ||(m_Dectect_Dir == PATH_DIRECTION_NORMAL))
				m_pExecuteInfo->nHIDPathInfo = EXECUTE_HIDPATH_LINE;
			else
				m_pExecuteInfo->nHIDPathInfo = EXECUTE_HIDPATH_CURVE;
		}

	}else
	{
		//메뉴얼이 아닐 경우 이전상태 유지.
		if(m_pExecuteInfo->ExecuteMode == EXECUTE_MODE_MANUAL)
			m_pExecuteInfo->nHIDPathInfo = EXECUTE_HIDPATH_NONE;
	}

#if(((OHT_NAME == OHT_NAME_STD_V81S) ||(OHT_NAME == OHT_NAME_STD_V80)||(OHT_NAME == OHT_NAME_STD_V81)||(OHT_NAME == OHT_NAME_STD_V85S)||(OHT_NAME == OHT_NAME_STD_V82)||(OHT_NAME == OHT_NAME_P4_MASK)) && (SAMSUNG_COMMON_SPEC==ON))
//   ERR_FOUP_COVER_OPEN_DETECT 에러관련 주행시만 감시하도록 변경됨. (센서 위치 변경으로)
	if(m_LineParamSet->bUseFoupCoverOepnwaitingInterlock == false)
	{
		static DWORD dwLastTimeOfFoupCoverOpenDetect = timeGetTime();
		DWORD dwFoupCoverOpenDetectCheckTime = 200;
		bool bFoupCoverOpenDetect = pHWSet->m_pFoupCoverOpenDetect->IsDetect();
		static bool bPreFoupCoverOpenDetect = pHWSet->m_pFoupCoverOpenDetect->IsDetect();
		static PATH_DIRECTION_INFO TempPreFoupCoverDectect = PATH_DIRECTION_NO_USE;


		if(TempPreFoupCoverDectect != m_Dectect_Dir)
		{
			TempPreFoupCoverDectect =  m_Dectect_Dir;
			dwLastTimeOfFoupCoverOpenDetect = timeGetTime();
		}

		if((m_StatusSet.bIsOnProcess==true) && (m_StatusSet.byStatus==STS_GOING) && ( bFoupCoverOpenDetect == true) && (m_bShutterOpenFlag == false) && (m_bShutterCloseFlag ==false))
		{
			if(bPreFoupCoverOpenDetect != bFoupCoverOpenDetect)
			{
				m_DiagManager->IncreasePreviosDiagCount(PREVIOS_DIAG_FC);  //사전로그
				m_mccparam.nFoupCoverDetectCount++;
			}

			if((m_Dectect_Dir == PATH_DIRECTION_NO_USE) ||(m_Dectect_Dir == PATH_DIRECTION_NORMAL))
			{
				dwFoupCoverOpenDetectCheckTime = m_pParamSet->FoupCover.nLineFoupChattering;
				ADD_LOG("D_4/%d/%d",dwFoupCoverOpenDetectCheckTime,OHTUTILITY::PreventOverflowGetTimeMs( dwLastTimeOfFoupCoverOpenDetect));     //20191104 KDS
			}
			else
			{
				if((m_Dectect_OBS_Dir ==PATH_OBS_DIRECTION_UTrun_L) || (m_Dectect_OBS_Dir ==PATH_OBS_DIRECTION_UTrun_R))
				{
				   dwFoupCoverOpenDetectCheckTime= m_pParamSet->FoupCover.nSPCurveFoupChattering;
				}
				else
				{
					dwFoupCoverOpenDetectCheckTime= m_pParamSet->FoupCover.nCurveFoupChattering;
				}

				ADD_LOG("D_5/%d/%d/%d",dwFoupCoverOpenDetectCheckTime,OHTUTILITY::PreventOverflowGetTimeMs( dwLastTimeOfFoupCoverOpenDetect),m_Dectect_OBS_Dir);   //20191104 KDS
			}

			if(OHTUTILITY::PreventOverflowGetTimeMs(dwLastTimeOfFoupCoverOpenDetect) > dwFoupCoverOpenDetectCheckTime)
			{
				ADD_LOG("D_6/%d/%d", bFoupCoverOpenDetect, OHTUTILITY::PreventOverflowGetTimeMs( dwLastTimeOfFoupCoverOpenDetect));  //20191104 KDS

				ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d/%d",
							ERR_FOUP_COVER_OPEN_DETECT,
							m_pOHTMainStatus->StatusCommon.CurNodeID,
							m_pExecuteInfo->ExecutePositionInfo.NextNode,
							m_pOHTMainStatus->StatusCommon.CurNodeOffset,
							m_pOHTMainStatus->StatusCommon.ExistFoup,
							m_pOHTMainStatus->StatusCommon.StopStationID,
							bFoupCoverOpenDetect);
				return ERR_FOUP_COVER_OPEN_DETECT;
			}
		}
		else
		{
			dwLastTimeOfFoupCoverOpenDetect = timeGetTime();
		}

		bPreFoupCoverOpenDetect = bFoupCoverOpenDetect;

    }




	if((m_StatusSet.bIsOnProcess==true) && (m_StatusSet.byStatus==STS_GOING) && (bShiftHome == false) && (m_bShutterOpenFlag == false) && (m_bShutterCloseFlag ==false))
	{
		if( bPreShiftHome != bShiftHome)
		{
			m_mccparam.nShiftHomeSenOffCount++;
		}
	}

	bPreShiftHome = bShiftHome;

	if((m_StatusSet.bIsOnProcess==true) && (m_StatusSet.byStatus==STS_GOING) && (bHoistHome == false) && (m_bShutterOpenFlag == false) && (m_bShutterCloseFlag ==false))
	{
		if( bPreHoistHome != bHoistHome)
		{
			m_mccparam.nHoistHomeSenOffCount++;
		}
	}

	bPreHoistHome = bHoistHome;

	if((m_StatusSet.bIsOnProcess==true) && (m_StatusSet.byStatus==STS_GOING) && (bFOUPDetect == true) && (bShutterBothClose == false) && (m_bShutterOpenFlag == false) && (m_bShutterCloseFlag ==false))
	{
		if( bPreFOUPDetect != bFOUPDetect)
		{
			m_mccparam.nInnerFOUPDetectCount++;
		}
	}

	if((m_StatusSet.bIsOnProcess==true) && (m_StatusSet.byStatus==STS_GOING) && (bFOUPDetect == false) && (bShutterBothClose == true) && (m_bShutterOpenFlag == false) && (m_bShutterCloseFlag ==false))
	{
		if( bPreFOUPDetect != bFOUPDetect)
		{
			m_mccparam.nInnerFOUPNotDetectCount++;
		}
	}

	bPreFOUPDetect = bFOUPDetect;

	if((m_StatusSet.bIsOnProcess==true) && (m_StatusSet.byStatus==STS_GOING) && (m_bShutterOpenFlag == false) && (m_bShutterCloseFlag ==false))
	{
		if( bPreShutterFrontOpen != bShutterFrontOpen)
		{
			m_mccparam.nShutterFrontOpenCount++;
		}

		if( bPreShutterFrontClose != bShutterFrontClose)
		{
			m_mccparam.nShutterFrontCloseCount++;
		}

		if( bPreShutterRearOpen != bShutterRearOpen)
		{
			m_mccparam.nShutterRearOpenCount++;
		}

		if( bPreShutterRearClose != bShutterRearClose)
		{
			m_mccparam.nShutterRearCloseCount++;
		}
	}

	bPreShutterFrontOpen = bShutterFrontOpen;
	bPreShutterFrontClose = bShutterFrontClose;
	bPreShutterRearOpen = bShutterRearOpen;
	bPreShutterRearClose = bShutterRearClose;

	bool TmpHandStatus = pHWSet->m_pHand->IsInposition();

	///10의 자리수 이상으로 올라가면 햇갈릴 여지가 있어서 우선 1로 고정, 추후 정립되면 Count로 사용
	if(TmpHandStatus != m_mccparam.bpreHandInposition)
	{
		m_mccparam.nHandInpositionOffCount = 1;
	}
	m_mccparam.bpreHandInposition = TmpHandStatus;

	TmpHandStatus = pHWSet->m_pHand->IsAlarm();
	if(TmpHandStatus != m_mccparam.bpreHandAlarm)
	{
		m_mccparam.nHandAlarmOffCount = 1;
	}
	m_mccparam.bpreHandAlarm = TmpHandStatus;


	TmpHandStatus = pHWSet->m_pHand->IsRightGripOn();
	if(TmpHandStatus != m_mccparam.bpreHandRightGrip)
	{
		m_mccparam.nHandRightGripOffCount = 1;
	}
	m_mccparam.bpreHandRightGrip = TmpHandStatus;


	TmpHandStatus = pHWSet->m_pHand->IsLeftGripOn();
	if(TmpHandStatus != m_mccparam.bpreHandLeftGrip)
	{
		m_mccparam.nHandLeftGripOffCount = 1;
	}
	m_mccparam.bpreHandLeftGrip = TmpHandStatus;


	TmpHandStatus = pHWSet->m_pHand->IsClose();
	if(TmpHandStatus != m_mccparam.bpreHandClose)
	{
		m_mccparam.nHandCloseOffCount = 1;
	}
	m_mccparam.bpreHandClose = TmpHandStatus;


	TmpHandStatus = pHWSet->m_pHand->IsOpen();
	if(TmpHandStatus != m_mccparam.bpreHandOpen)
	{
		m_mccparam.nHandOpenOffCount = 1;
	}
	m_mccparam.bpreHandOpen = TmpHandStatus;


	TmpHandStatus = pHWSet->m_pHand->IsGoSigOn();
	if(TmpHandStatus != m_mccparam.bpreHandPIO)
	{
		m_mccparam.nHandPIOOffCount = 1;
	}
	m_mccparam.bpreHandPIO = TmpHandStatus;

	if((m_StatusSet.bIsOnProcess==true) && (m_StatusSet.byStatus==STS_GOING))
	{
		//주행중 직선패턴일 경우, 장애물/대차감지 센서 감지유무에 따라 로그 추가.
		if(m_Dectect_Dir == PATH_DIRECTION_NORMAL)
		{
			if(!((TmpHwInfo.IO.DetectStatus==DETECT_NONE)&&(TmpHwInfo.IO.ObsStatus!=DETECT_NONE)))
			 	dwLastTimeOfFoupDetectWarnning = timeGetTime();
		}
		else
			dwLastTimeOfFoupDetectWarnning = timeGetTime();

		if(OHTUTILITY::PreventOverflowGetTimeMs(dwLastTimeOfFoupDetectWarnning) > 2000)
		{
			m_DiagManager->IncreasePreviosDiagCount(PREVIOS_DIAG_PS); //사전 로그
			DETECT_LOG("Detect Warnning! Time:%d, Detect:%d, OBS %d",OHTUTILITY::PreventOverflowGetTimeMs(dwLastTimeOfFoupDetectWarnning),TmpHwInfo.IO.DetectStatus,TmpHwInfo.IO.ObsStatus);
			dwLastTimeOfFoupDetectWarnning = timeGetTime();
		}

	}else
		dwLastTimeOfFoupDetectWarnning = timeGetTime();


	 //S1B 이슈내용 관련 적용
	if((m_StatusSet.bIsOnProcess==true) && (m_StatusSet.byStatus==STS_GOING))
	{
		 if((nDetectStatus == DETECT_AND_STOP) &&
		  ((pHWSet->GetAMCStopStatus() != Move_None) && (pHWSet->GetAMCStopStatus() != Move_Stop)) &&
		  (m_StatusSet.uStep ==DRIVING_CTRL_STEP_GO_RUN))
		 {
		 	nLastTimeOfDrivingDetectWarnning++;
			ADD_LOG("D_7/%d/%d",pHWSet->GetAMCStopStatus(),nLastTimeOfDrivingDetectWarnning);

		 }
		 else
			nLastTimeOfDrivingDetectWarnning = 0;


		 if(nLastTimeOfDrivingDetectWarnning > 15)
		 {
			ADD_FDC_LOG("ERR/%d/1/5/%06d/%06d/%d/%d/%06d",
						ERR_DRV_MOVE_IN_PBS_UBG_DETECT,
						m_pOHTMainStatus->StatusCommon.CurNodeID,
						m_pExecuteInfo->ExecutePositionInfo.NextNode,
						m_pOHTMainStatus->StatusCommon.CurNodeOffset,
						m_pOHTMainStatus->StatusCommon.ExistFoup,
						m_pOHTMainStatus->StatusCommon.StopStationID);
		 	return ERR_DRV_MOVE_IN_PBS_UBG_DETECT;
		 }
//		 if(OHTUTILITY::PreventOverflowGetTimeMs(dwLastTimeOfDrivingDetectWarnning) > 200)
//		 {
//			return ERR_DRV_MOVE_IN_PBS_UBG_DETECT;
//		 }
	}
	else
		nLastTimeOfDrivingDetectWarnning = 0;

#endif


    // 2014.02.11 By LSJ 장애물이 감지되어 있는데 멈춰 있다가 출발하는 경우 에러 발생
#if(UBG_SENSOR_ENABLE == ON)
	if((bPreFrontIsRunning == false) && (bFrontIsRunning == true)
		&& (((nOBSStatus == DETECT_AND_STOP)&&(m_pOHTDetect->GetStatusLevel() !=7)) || (nDetectStatus == DETECT_AND_STOP)))
#else
	if((bPreFrontIsRunning == false) && (bFrontIsRunning == true) && (nOBSStatus == DETECT_AND_STOP))
#endif
	{

		if(bStartOnDetect == false)
        {
			dwStartOnDetectTime = timeGetTime();
            bStartOnDetect = true;
		}

		if((bStartOnDetect == true) && (m_StatusSet.uStep !=DRIVING_CTRL_STEP_GO_FIRST_NODE) && (OHTUTILITY::PreventOverflowGetTimeMs(dwStartOnDetectTime)>100))
        {
            bStartOnDetect = false;
			ADD_FDC_LOG("ERR/%d/2/5/%06d/%06d/%d/%d/%06d",
						ERR_DRV_MOVE_IN_PBS_UBG_DETECT,
						m_pOHTMainStatus->StatusCommon.CurNodeID,
						m_pExecuteInfo->ExecutePositionInfo.NextNode,
						m_pOHTMainStatus->StatusCommon.CurNodeOffset,
						m_pOHTMainStatus->StatusCommon.ExistFoup,
						m_pOHTMainStatus->StatusCommon.StopStationID);
			return ERR_DRV_MOVE_IN_PBS_UBG_DETECT;
		}
    }
	else
	{
		dwStartOnDetectTime= timeGetTime();
		bStartOnDetect = false;
	}
	bPreFrontIsRunning = bFrontIsRunning;

	int nTmpDiff = 0;
	int nTmpValue = 0;
	int nTmpOHTDetectArea = 0;
	int nTmpnOHTDetectLevel = 0;
	int nTmpOBSDetectArea = 0;
	int nTmpOBSDetectLevel = 0;
	int nPreOHTDetectLevel = 0;
	m_UBGFail_1 = false;

	nTmpValue = m_pOHTDetect->GetUbgAreaStatus();
	if(nTmpValue != m_mccparam.nOHTDetectArea)
	{
		nTmpDiff++;
		nTmpOHTDetectArea = OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwOHTDetectAreaTime);
		m_mccparam.dwOHTDetectAreaTime = timeGetTime();

		nTmpnOHTDetectLevel = OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwOHTDetectLevelTime);
		m_mccparam.dwOHTDetectLevelTime = timeGetTime();

		if(m_mccparam.nOHTDetectLevel > 0) //Pattern이 변한 경우. Detect Level이 0보다 큰 경우만
		{
			ADD_LOG("Pattern OHTDetectArea:%d, OHTDetectLevel:%d, nTmpnOHTDetectLevel:%d", m_mccparam.nOHTDetectArea, m_mccparam.nOHTDetectLevel, nTmpnOHTDetectLevel);
			OHTMainForm->GetStatusCheckThread()->UBGDetectTimeCheck(m_mccparam.nOHTDetectArea, m_mccparam.nOHTDetectLevel, nTmpnOHTDetectLevel);

			if(nTmpValue != 15 && m_DetectFail_Cnt)    //2023.04.20 sseung UBG Fail 3 조건(OHT Detect Area 변경)
			{
				m_DetectFail_Cnt = false;
				AUTO_RECOV_LOG(m_pExecuteInfo->ExecuteMode,",-------- UBG Fail 3, Pattern Change");
				ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,UBG FAIL 3,-,%s,%06d,%06d,%06d,%d,%3.3lf,OHT Detect Area,%d,OHT Detect Level,%d,OBS Detect Area,%d,OBS Detect Level,%d,Path Steering,%d,Detect Fail Time,%d,Pattern Change Time,%d",
							m_defualtparam->VHLName,m_mccparam.cCarrierType,
							m_mccparam.uSourceNode,
							m_mccparam.uTargetNode,
							m_pExecuteInfo->ExecutePositionInfo.CurrNode,
							m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
							m_InfoSet.HwInfo.Axis1.dSpeed,
							//-------------------------------------------------
							m_mccparam.nOHTDetectArea,
							m_mccparam.nOHTDetectLevel,
							m_mccparam.nOBSDetectArea,
							m_mccparam.nOBSDetectLevel,
						OHTMainForm->GetPathSearch()->GetSteeringInfo(OHTMainForm->GetMap(),m_pExecuteInfo->ExecutePositionInfo.CurrNode,m_pExecuteInfo->ExecutePositionInfo.NextNode),
						OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwOHTDetectLevelFailTime),
						nUbgFailStart_Time);
				AUTO_RECOV_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,UBG FAIL 3,-,%s,%06d,%06d,%06d,%d,%3.3lf,OHT Detect Area,%d,OHT Detect Level,%d,OBS Detect Area,%d,OBS Detect Level,%d,Path Steering,%d,Detect Fail Time,%d,Pattern Change Time,%d",
						m_defualtparam->VHLName,m_mccparam.cCarrierType,
						m_mccparam.uSourceNode,
						m_mccparam.uTargetNode,
						m_pExecuteInfo->ExecutePositionInfo.CurrNode,
						m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
						m_InfoSet.HwInfo.Axis1.dSpeed,
						//-------------------------------------------------
						m_mccparam.nOHTDetectArea,
						m_mccparam.nOHTDetectLevel,
						m_mccparam.nOBSDetectArea,
						m_mccparam.nOBSDetectLevel,
						OHTMainForm->GetPathSearch()->GetSteeringInfo(OHTMainForm->GetMap(),m_pExecuteInfo->ExecutePositionInfo.CurrNode,m_pExecuteInfo->ExecutePositionInfo.NextNode),
						OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwOHTDetectLevelFailTime),
						nUbgFailStart_Time);

				if (checkUBG_Fail3_Error())
					return ERR_DETECT_SENSOR_FAIL;
			}
		}

		m_mccparam.nOHTDetectArea = nTmpValue;
	}
	nTmpValue =  m_pOHTDetect->GetSensorLevel_MCC();
	if(nTmpValue != m_mccparam.nOHTDetectLevel)
	{
		if(m_mccparam.nOHTDetectArea == 14 && OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwOHTDetectAreaTime) > 100)    //2023.04.19 sseung UBG Pattern 1이고, 패턴 변경 후 100msec 이상 지난 시점
		{
			if((nTmpValue == 7 && m_mccparam.nOHTDetectLevel == 3) || (nTmpValue == 3 && m_mccparam.nOHTDetectLevel == 7))
			{
				m_UBGFail_1 = true;
				nPreOHTDetectLevel = m_mccparam.nOHTDetectLevel;
			}

			if(m_mccparam.bOHTDetectFail2Flag)
			{
				m_mccparam.bOHTDetectFail2Flag = false;
				ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,UBG FAIL 2,-,%s,%06d,%06d,%06d,%d,%3.3lf,OHT Detect Area,%d,OHT Detect Level,%d,OBS Detect Area,%d,OBS Detect Level,%d,Path Steering,%d,Detect Fail Time,%d",
						m_defualtparam->VHLName,m_mccparam.cCarrierType,
						m_mccparam.uSourceNode,
						m_mccparam.uTargetNode,
						m_pExecuteInfo->ExecutePositionInfo.CurrNode,
						m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
						m_InfoSet.HwInfo.Axis1.dSpeed,
						//-------------------------------------------------
						m_mccparam.nOHTDetectArea,
						m_mccparam.nOHTDetectLevel,
						m_mccparam.nOBSDetectArea,
						m_mccparam.nOBSDetectLevel,
						OHTMainForm->GetPathSearch()->GetSteeringInfo(OHTMainForm->GetMap()
							,m_pExecuteInfo->ExecutePositionInfo.CurrNode
							,m_pExecuteInfo->ExecutePositionInfo.NextNode),
						OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwOHTDetectLevelFailTime));
			}
		}
		else if(m_mccparam.nOHTDetectArea == 16)
		{
			if(nTmpValue != 0)
			{
            	ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,UBG ABNORMAL ON,-,%s,%06d,%06d,%06d,%d,%3.3lf,OHT Detect Area,%d,OHT Detect Level,%d",
						m_defualtparam->VHLName,m_mccparam.cCarrierType,
						m_mccparam.uSourceNode,
						m_mccparam.uTargetNode,
						m_pExecuteInfo->ExecutePositionInfo.CurrNode,
						m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
						m_InfoSet.HwInfo.Axis1.dSpeed,
						//-------------------------------------------------
						m_mccparam.nOHTDetectArea,
						m_mccparam.nOHTDetectLevel);
			}
		}
		else if(m_mccparam.nOHTDetectArea == 15 && OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwOHTDetectAreaTime) > 100)    //2023.04.19 sseung UBG Pattern 0(정지)이고, 패턴 변경 후 100msec 이상 지난 시점
		{
			//최초 감지 레벨에 들어온 경우 카운트 시작
			if(!m_DetectFail_Cnt && nTmpValue < 8 && nTmpValue > 1)
			{
				nUbgFailStart_Time = OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwOHTDetectAreaTime);  //최초 이상 감지 시점까지의 시간 기록
				m_mccparam.dwOHTDetectLevelFailTime = timeGetTime();
				m_DetectFail_Cnt = true;
			}
		}
		else
		{
			if(nTmpValue == 4 || nTmpValue == 5 || nTmpValue == 6)
			{
				m_mccparam.bOHTDetectFail2Flag = true;
				m_mccparam.dwOHTDetectLevelFailTime = timeGetTime();
			}
			else
			{
				if(m_mccparam.bOHTDetectFail2Flag)
				{
					m_mccparam.bOHTDetectFail2Flag = false;
					ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,UBG FAIL 2,-,%s,%06d,%06d,%06d,%d,%3.3lf,OHT Detect Area,%d,OHT Detect Level,%d,OBS Detect Area,%d,OBS Detect Level,%d,Path Steering,%d,Detect Fail Time,%d",
							m_defualtparam->VHLName,m_mccparam.cCarrierType,
							m_mccparam.uSourceNode,
							m_mccparam.uTargetNode,
							m_pExecuteInfo->ExecutePositionInfo.CurrNode,
							m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
							m_InfoSet.HwInfo.Axis1.dSpeed,
							//-------------------------------------------------
							m_mccparam.nOHTDetectArea,
							m_mccparam.nOHTDetectLevel,
							m_mccparam.nOBSDetectArea,
							m_mccparam.nOBSDetectLevel,
							OHTMainForm->GetPathSearch()->GetSteeringInfo(OHTMainForm->GetMap()
								,m_pExecuteInfo->ExecutePositionInfo.CurrNode
								,m_pExecuteInfo->ExecutePositionInfo.NextNode),
							OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwOHTDetectLevelFailTime));
				}
			}
		}
		nTmpDiff++;
		nTmpnOHTDetectLevel = OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwOHTDetectLevelTime);
		m_mccparam.dwOHTDetectLevelTime = timeGetTime();

		if(nTmpDiff == 1 && m_mccparam.nOHTDetectLevel > 0) //Pattern은 그대로인데 Detect Level만 변한 경우
		{
			ADD_LOG("Level OHTDetectArea:%d, OHTDetectLevel:%d, nTmpnOHTDetectLevel:%d", m_mccparam.nOHTDetectArea, m_mccparam.nOHTDetectLevel, nTmpnOHTDetectLevel);
			OHTMainForm->GetStatusCheckThread()->UBGDetectTimeCheck(m_mccparam.nOHTDetectArea, m_mccparam.nOHTDetectLevel, nTmpnOHTDetectLevel);
		}

		if(nTmpValue == 8 && m_DetectFail_Cnt)    //2023.04.20 sseung UBG Fail 3 조건(Detect Level이 미감지로 변경)
		{
			m_DetectFail_Cnt = false;

			ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,UBG FAIL 3,-,%s,%06d,%06d,%06d,%d,%3.3lf,OHT Detect Area,%d,OHT Detect Level,%d,OBS Detect Area,%d,OBS Detect Level,%d,Path Steering,%d,Detect Fail Time,%d,Pattern Change Time,%d",
					m_defualtparam->VHLName,m_mccparam.cCarrierType,
					m_mccparam.uSourceNode,
					m_mccparam.uTargetNode,
					m_pExecuteInfo->ExecutePositionInfo.CurrNode,
					m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
					m_InfoSet.HwInfo.Axis1.dSpeed,
					//-------------------------------------------------
					m_mccparam.nOHTDetectArea,
					m_mccparam.nOHTDetectLevel,
					m_mccparam.nOBSDetectArea,
					m_mccparam.nOBSDetectLevel,
					OHTMainForm->GetPathSearch()->GetSteeringInfo(OHTMainForm->GetMap(),m_pExecuteInfo->ExecutePositionInfo.CurrNode,m_pExecuteInfo->ExecutePositionInfo.NextNode),
					OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwOHTDetectLevelFailTime),
					nUbgFailStart_Time);
			AUTO_RECOV_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,UBG FAIL 3,-,%s,%06d,%06d,%06d,%d,%3.3lf,OHT Detect Area,%d,OHT Detect Level,%d,OBS Detect Area,%d,OBS Detect Level,%d,Path Steering,%d,Detect Fail Time,%d,Pattern Change Time,%d",
					m_defualtparam->VHLName,m_mccparam.cCarrierType,
					m_mccparam.uSourceNode,
					m_mccparam.uTargetNode,
					m_pExecuteInfo->ExecutePositionInfo.CurrNode,
					m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
					m_InfoSet.HwInfo.Axis1.dSpeed,
					//-------------------------------------------------
					m_mccparam.nOHTDetectArea,
					m_mccparam.nOHTDetectLevel,
					m_mccparam.nOBSDetectArea,
					m_mccparam.nOBSDetectLevel,
					OHTMainForm->GetPathSearch()->GetSteeringInfo(OHTMainForm->GetMap(),m_pExecuteInfo->ExecutePositionInfo.CurrNode,m_pExecuteInfo->ExecutePositionInfo.NextNode),
					OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwOHTDetectLevelFailTime),
					nUbgFailStart_Time);

			if (checkUBG_Fail3_Error())
				return ERR_DETECT_SENSOR_FAIL;
		}

		m_mccparam.nOHTDetectLevel = nTmpValue;
	}
	nTmpValue =  m_pObstacle->GetObsAreaStatus();
	if(nTmpValue != m_mccparam.nOBSDetectArea)
	{
		nTmpDiff++;
		nTmpOBSDetectArea = OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwOBSDetectAreaTime);
		m_mccparam.dwOBSDetectAreaTime = timeGetTime();
		m_mccparam.nOBSDetectArea = nTmpValue;
	}
	nTmpValue =  m_pObstacle->GetSensorLevel_MCC();
	if(nTmpValue != m_mccparam.nOBSDetectLevel)
	{
		nTmpDiff++;
		nTmpOBSDetectLevel = OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwOBSDetectLevelTime);
		m_mccparam.dwOBSDetectLevelTime = timeGetTime();
		m_mccparam.nOBSDetectLevel = nTmpValue;
	}

	if(m_mccparam.nOBSDetectArea == 16)
	{
		if(nTmpValue != 0)
		{
			ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,OBS ABNORMAL ON,-,%s,%06d,%06d,%06d,%d,%3.3lf,OBS Detect Area,%d,OBS Detect Level,%d",
					m_defualtparam->VHLName,m_mccparam.cCarrierType,
					m_mccparam.uSourceNode,
					m_mccparam.uTargetNode,
					m_pExecuteInfo->ExecutePositionInfo.CurrNode,
					m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
					m_InfoSet.HwInfo.Axis1.dSpeed,
					//-------------------------------------------------
					m_mccparam.nOBSDetectArea,
					m_mccparam.nOBSDetectLevel);
		}
	}

	if(m_UBGFail_1)
	{
		m_UBGFail_1 = false;

		ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,UBG FAIL 1,-,%s,%06d,%06d,%06d,%d,%3.3lf,OHT Detect Area,%d,Pre OHT Detect Level,%d,OHT Detect Level,%d,OBS Detect Area,%d,OBS Detect Level,%d,Path Steering,%d,Pattern Change Time,%d",
					m_defualtparam->VHLName,m_mccparam.cCarrierType,
					m_mccparam.uSourceNode,
					m_mccparam.uTargetNode,
					m_pExecuteInfo->ExecutePositionInfo.CurrNode,
					m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
					m_InfoSet.HwInfo.Axis1.dSpeed,
					//-------------------------------------------------
					m_mccparam.nOHTDetectArea,
					nPreOHTDetectLevel,
					m_mccparam.nOHTDetectLevel,
					m_mccparam.nOBSDetectArea,
					m_mccparam.nOBSDetectLevel,
					OHTMainForm->GetPathSearch()->GetSteeringInfo(OHTMainForm->GetMap()
						,m_pExecuteInfo->ExecutePositionInfo.CurrNode
						,m_pExecuteInfo->ExecutePositionInfo.NextNode),
					OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwOHTDetectAreaTime));
		AUTO_RECOV_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,UBG FAIL 1,-,%s,%06d,%06d,%06d,%d,%3.3lf,OHT Detect Area,%d,Pre OHT Detect Level,%d,OHT Detect Level,%d,OBS Detect Area,%d,OBS Detect Level,%d,Path Steering,%d,Pattern Change Time,%d",
					m_defualtparam->VHLName,m_mccparam.cCarrierType,
					m_mccparam.uSourceNode,
					m_mccparam.uTargetNode,
					m_pExecuteInfo->ExecutePositionInfo.CurrNode,
					m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
					m_InfoSet.HwInfo.Axis1.dSpeed,
					//-------------------------------------------------
					m_mccparam.nOHTDetectArea,
					nPreOHTDetectLevel,
					m_mccparam.nOHTDetectLevel,
					m_mccparam.nOBSDetectArea,
					m_mccparam.nOBSDetectLevel,
					OHTMainForm->GetPathSearch()->GetSteeringInfo(OHTMainForm->GetMap()
						,m_pExecuteInfo->ExecutePositionInfo.CurrNode
						,m_pExecuteInfo->ExecutePositionInfo.NextNode),
					OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwOHTDetectAreaTime));
	}

//	if(nTmpDiff != 0)
//	{                                                                                                //                                                                                               //
//		ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,DETECT STATUS,-,%s,%06d,%06d,%06d,%d,%3.3lf,OHT Detect Area,%d,OHT Detect Level,%d,OBS Detect Area,%d,OBS Detect Level,%d,Path Steering,%d,OHT Detect Area Time,%d,OHT Detect Level Time,%d,OBS Detect Area Time,%d,OBS Detect Level Time,%d",
//			m_defualtparam->VHLName,m_mccparam.cCarrierType,
//			m_mccparam.uSourceNode,
//			m_mccparam.uTargetNode,
//			m_pExecuteInfo->ExecutePositionInfo.CurrNode,
//			m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
//			m_InfoSet.HwInfo.Axis1.dSpeed,
//			//-------------------------------------------------
//			m_mccparam.nOHTDetectArea,
//			m_mccparam.nOHTDetectLevel,
//			m_mccparam.nOBSDetectArea,
//			m_mccparam.nOBSDetectLevel,
//			OHTMainForm->GetPathSearch()->GetSteeringInfo(OHTMainForm->GetMap()
//				,m_pExecuteInfo->ExecutePositionInfo.CurrNode
//				,m_pExecuteInfo->ExecutePositionInfo.NextNode),
//			nTmpOHTDetectArea,
//			nTmpnOHTDetectLevel,
//			nTmpOBSDetectArea,
//			nTmpOBSDetectLevel
//		);
//	}

	switch(m_pOHTMainStatus->StatusCommon.CarrierType)
	{
		case CARRIER_NOTDEFINED:
			sprintf(m_mccparam.cCarrierType,"None");
			break;
		case CARRIER_FOUP:
			sprintf(m_mccparam.cCarrierType,"FOUP");
			break;
		case CARRIER_POD:
			sprintf(m_mccparam.cCarrierType,"POD");
			break;
		case CARRIER_EUV:
			sprintf(m_mccparam.cCarrierType,"EUV");
			break;
		case CARRIER_MAC:
			sprintf(m_mccparam.cCarrierType,"MAC");
			break;
		case CARRIER_FOSB:
			sprintf(m_mccparam.cCarrierType,"FOSB");
			break;
	}

	bool TmpLookDownDetect = pHWSet->m_pLookdown->IsDetect();
	bool TmpLookDownError = pHWSet->m_pLookdown->IsError();

	if((TmpLookDownDetect == true && m_mccparam.bLookDownDetect == false) || (TmpLookDownError == true && m_mccparam.bLookDownError == false))
	{
		ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,LOOKDOWN ABNORMAL ON,-,%s,%06d,%06d,%06d,%d,%3.3lf,LookDown Detect,%d,LookDown Error,%d",
					m_defualtparam->VHLName,m_mccparam.cCarrierType,
					m_mccparam.uSourceNode,
					m_mccparam.uTargetNode,
					m_pExecuteInfo->ExecutePositionInfo.CurrNode,
					m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
					m_InfoSet.HwInfo.Axis1.dSpeed,
					//-------------------------------------------------
					TmpLookDownDetect,
					TmpLookDownError);
	}
	m_mccparam.bLookDownDetect = TmpLookDownDetect;
	m_mccparam.bLookDownError = TmpLookDownError;


////////Hokuyo 대차감지 검증 ///////
	static DWORD dwLastTimeOfHokuyoCheck = timeGetTime();
	static int nPreHokuyoCheckOutput = 0;
	static bool bHokuyoCheckState = true;


	int nTempUBGSelectStatus = m_pOHTDetect->GetUBGSelectStatus();

#if(OHT_NAME == OHT_NAME_STD_V80)
	if(m_defualtparam->bUseUBGMonitoring == true)
	{
		if(m_StatusSet.bIsOnProcess==true)
		{
			//Step 초기화 될까지 센서 Data 확보
			if(m_pOHTDetect->nStepCheckUBGSeriInfo !=0)  m_pOHTDetect->CheckUBGSeriInfo(m_StatusSet.byStatus); // 주행 시 Update

			// Case 1 I/O Missmatching 시점
			if(m_pOHTDetect->CheckUBGOuputInfo() == false)
			{
				//I/O가 다를 경우 즉시 로깅 및 패턴 정보 Read 처리
				DETECT_LOG("UBGMonitor_2/bCheckInputOutput,HokuyoCommInfo,CurOuputIO:%d/%d/%d",m_pOHTDetect->CheckUBGOuputInfo(), (m_pOHTDetect->UBGSeriInfoOuput-48), nTempUBGSelectStatus);
				if(m_pOHTDetect->nStepCheckUBGSeriInfo ==0)	m_pOHTDetect->CheckUBGSeriInfo(m_StatusSet.byStatus);
			}
			//Case 2 곡선 진입 시점 ::패턴 변경 시점에서 현재 패턴이 곡선인 경우
			else if(nPreHokuyoCheckOutput != nTempUBGSelectStatus && (nPreHokuyoCheckOutput !=OHT_DETECT_CMD_PATH_DIRECTION_NO_USE) &&
			  ((nTempUBGSelectStatus==OHT_DETECT_CMD_PATH_DIRECTION_LEFT) || (nTempUBGSelectStatus ==OHT_DETECT_CMD_PATH_DIRECTION_RIGHT)))
			{
				dwLastTimeOfHokuyoCheck = timeGetTime();
				bHokuyoCheckState =false;
				if(m_pOHTDetect->nStepCheckUBGSeriInfo ==0)	m_pOHTDetect->CheckUBGSeriInfo(m_StatusSet.byStatus);
			}


			//Case 2의 경우, 패턴 정보(시리얼 통신 정보 속도약 400msec 이후)와 비교하여 다른 경우 로깅 처리.
			if((OHTUTILITY::PreventOverflowGetTimeMs(dwLastTimeOfHokuyoCheck) > 400) &&
				(bHokuyoCheckState ==false))
			{
				if((m_pOHTDetect->UBGSeriInfoOuput-48) != nTempUBGSelectStatus)
				{
					DETECT_LOG("UBGMonitor_1/bCheckInputOutput,HokuyoCommInfo,CurOuputIO:%d/%d/%d",m_pOHTDetect->CheckUBGOuputInfo(), (m_pOHTDetect->UBGSeriInfoOuput-48), nTempUBGSelectStatus);
				}
				bHokuyoCheckState =true;
			}

			nPreHokuyoCheckOutput = nTempUBGSelectStatus;

		}
		else
		{
			dwLastTimeOfHokuyoCheck = timeGetTime();
			bHokuyoCheckState =true;
			nPreHokuyoCheckOutput = nTempUBGSelectStatus;
		}
	}
#endif

////////Hokuyo 대차감지 검증 End//////



	return NO_ERR;


}




bool DrivingControl::DeleteCmd(void *pCmd)
{
    bool bReturn = true;
    try
    {
        EXECUTE_DRIVING_INFO    *sTmpDrivingControlInfo = (EXECUTE_DRIVING_INFO *)pCmd;
		ADD_LOG("D_8/%06d/%06d"
            , sTmpDrivingControlInfo->BasicInfo.StartNID
            , sTmpDrivingControlInfo->BasicInfo.EndNID
			);

        delete sTmpDrivingControlInfo;
    }
    catch(...)
    {
        bReturn = false;
    }
    return bReturn;
}


/**
@brief   파라미터 로드
@author  임태웅
@date    2013.05.30
@return  성공 하면 파라미터 포인터 리턴, 실패하면 NULL 리턴
*/
void* DrivingControl::LoadParam(char* NewFileNameAndDirectory, char* BackUpFileNameAndDirectory)
{
    bool bSuccess = false;
    DRIVING_PARAM_SET* pTmpParamSet = new DRIVING_PARAM_SET();

    //2 Back Up
    saveParameter(BackUpFileNameAndDirectory ,m_pParamSet);

	//2 Load
    bSuccess = loadParameter(NewFileNameAndDirectory, pTmpParamSet);

    //2 성공 실패 여부 확인
    if( bSuccess == true)
	{
		Reload_QR_Data();
    }
    else
    {
        delete pTmpParamSet;
        pTmpParamSet = NULL;
    }

    return (void*)pTmpParamSet;

}



/**
@brief   파라미터 업데이트 요청
@author  임태웅
@date    2013.05.30
@return  성공 하면 파라미터 포인터 리턴, 실패하면 NULL 리턴
*/
bool DrivingControl::RequestParamUpdate(void* pParameter)
{
    if(pParameter!=NULL)
    {
        m_pTmpParamSet = (DRIVING_PARAM_SET* )pParameter;
        return true;
    }
    else
    {
        return false;
    }
}


/**
@brief   파라미터 업데이트 요청
@author  임태웅
@date    2013.05.30
@return  파라미터가 포인터 리턴, 실패하면 NULL 리턴
*/
bool DrivingControl::IsParamUpdated()
{
    if(m_pTmpParamSet==NULL)
    {
        return true;
    }
    else
    {
        return false;
    }
}


/**
@brief   긴급 정지
@author  ehoto
@date    2012.11.27
@return  EXECUTE_ACK_NO_ERR     // 명령 실행 완료 응답
*/
EXECUTE_ACK DrivingControl::Stop(void)
{
    ERR_LOG("Stop Status:%X, Err:%d, Pos:%7.1lf(%d)"
        , m_StatusSet.byStatus, m_StatusSet.uError
        , m_pDrivingAxis->GetCurrentPosition()
        , m_pDrivingAxis->IsRunning());

	m_StatusSet.byStatus = STS_ERROR;

	m_bOnMapMake = false;
	m_bOnBackMove = false;


	if(m_pExecuteInfo->QuickCmdEStopCommander == ESTOP_BY_TP)
	{
		m_StatusSet.uError = ERR_TP_ESTOP;  // - E_Stop 호출은 OCS 도 가능하므로 내용 추가 필요
	}
	else
	{
		if(m_pExecuteInfo->QuickCmdEStopType == EXIT_ROUTE_OCS_PATH)		    	m_StatusSet.uError = ERR_OCS_ESTOP1;
		else if(m_pExecuteInfo->QuickCmdEStopType == OHT_EXIST_IN_COLLISON_AREA)	m_StatusSet.uError = ERR_OCS_ESTOP2;
		else if(m_pExecuteInfo->QuickCmdEStopType == CARRIER_EXIST_4_UNLOADING)	    m_StatusSet.uError = ERR_OCS_ESTOP3;
		else if(m_pExecuteInfo->QuickCmdEStopType == NOT_CARRIER_4_LOADING)		    m_StatusSet.uError = ERR_OCS_ESTOP4;
		else if(m_pExecuteInfo->QuickCmdEStopType == TRUNOFF_STOP)					m_StatusSet.uError = NO_ERR;
		else if(m_pExecuteInfo->QuickCmdEStopType == TRUNON)						m_StatusSet.uError = NO_ERR;
		else																		m_StatusSet.uError = ERR_OCS_ESTOP5;

		ADD_FDC_LOG("ERR/%d/1/5/%06d/%06d/%d/%d/%06d",
					m_StatusSet.uError,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pExecuteInfo->ExecutePositionInfo.NextNode,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					m_pOHTMainStatus->StatusCommon.ExistFoup,
					m_pOHTMainStatus->StatusCommon.StopStationID);
	}

    stop();

    return EXECUTE_ACK_NO_ERR;
}

/**
@brief   기동 Off
@author  ehoto
@date    2012.11.27
@return  EXECUTE_ACK_NO_ERR     // 명령 실행 완료 응답
*/
EXECUTE_ACK DrivingControl::TurnON(void)
{
    // 상태 정보 초기화
    m_StatusSet.byStatus    = STS_INIT;
    m_StatusSet.uError      = NO_ERR;
    m_StatusSet.uStep       = 0;
}

/**
@brief   기동 Off
@author  ehoto
@date    2012.11.27
@return  EXECUTE_ACK_NO_ERR     // 명령 실행 완료 응답
*/
EXECUTE_ACK DrivingControl::TurnOff(void)
{
    ERR_LOG("Stop Status:%X, Err:%d, Pos:%7.1lf(%d)"
        , m_StatusSet.byStatus, m_StatusSet.uError
        , m_pDrivingAxis->GetCurrentPosition()
        , m_pDrivingAxis->IsRunning());

	m_StatusSet.byStatus = STS_TURN_OFF;//STS_AUTOPOSITION;
	m_pExecuteInfo->bPopListOfCmd = false;

	m_bOnMapMake = false;
	m_bOnBackMove = false;

	if(m_pExecuteInfo->QuickCmdEStopCommander == ESTOP_BY_TP)
	{
		m_StatusSet.uError = ERR_TP_ESTOP;  // - E_Stop 호출은 OCS 도 가능하므로 내용 추가 필요
	}
	else
	{
		if(m_pExecuteInfo->QuickCmdEStopType == EXIT_ROUTE_OCS_PATH)		    	m_StatusSet.uError = ERR_OCS_ESTOP1;
		else if(m_pExecuteInfo->QuickCmdEStopType == OHT_EXIST_IN_COLLISON_AREA)	m_StatusSet.uError = ERR_OCS_ESTOP2;
		else if(m_pExecuteInfo->QuickCmdEStopType == CARRIER_EXIST_4_UNLOADING)	    m_StatusSet.uError = ERR_OCS_ESTOP3;
		else if(m_pExecuteInfo->QuickCmdEStopType == NOT_CARRIER_4_LOADING)		    m_StatusSet.uError = ERR_OCS_ESTOP4;
		else if(m_pExecuteInfo->QuickCmdEStopType == TRUNOFF_STOP)					m_StatusSet.uError = NO_ERR;
		else if(m_pExecuteInfo->QuickCmdEStopType == TRUNON)						m_StatusSet.uError = NO_ERR;
		else																		m_StatusSet.uError = ERR_OCS_ESTOP5;

		ADD_FDC_LOG("ERR/%d/1/5/%06d/%06d/%d/%d/%06d",
					m_StatusSet.uError,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pExecuteInfo->ExecutePositionInfo.NextNode,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					m_pOHTMainStatus->StatusCommon.ExistFoup,
					m_pOHTMainStatus->StatusCommon.StopStationID);
	}

    turnoff();

    return EXECUTE_ACK_NO_ERR;
}


/**
@brief   초기화
@author  ehoto
@date    2012.11.27
@return  EXECUTE_ACK_NO_ERR     // 명령 실행 완료 응답
*/
EXECUTE_ACK DrivingControl::Reset(void)
{
	DWORD   dwCurrTime  = timeGetTime();

	int nNodeIndex = 0;
	NODE_INFO	*pNODE_INFO		= NULL;	// Node 정보
	bool bSlopeCheck = false;
	bool bCheckNode = false;

	// 메뉴얼 조치시에만 초기화해 줄 것.
	if((m_StatusSet.byStatus!=STS_AUTORECOVERY) &&
	   (m_StatusSet.byStatus!=STS_AUTORECOVERY_BLANKTRANS) &&
	   (m_StatusSet.byStatus!=STS_AUTORECOVERY_DOUBLETRANS) &&
	   (m_StatusSet.byStatus!=STS_AUTORECOVERY_OVERRUN) &&
	   (m_StatusSet.byStatus!=STS_TURN_OFF) &&
	   (m_pExecuteInfo->ExecuteMode != EXECUTE_MODE_AUTO))
	   {
	   		m_bsecond = false;
			m_CID_Pause = false;
			m_CIDComptFlag = false;  // cid 완료 처리 Flag
			m_CIDComptTryFlag = false;  // cid 완료 처리 시도 Flag
			m_CID_COMMON_bit_off_need = false;
			m_CIDMonitoringFlag = false;
			m_CIDLinkFlag = false;
			m_CIDStatusFlag = false;
			m_CIDStatusPauseFlag = false;
			m_CIDPauseTime = 0;
			m_CID_Status_Pause = false;
			m_Igro_CIDStatusPuaseFlag = false;
			m_bLinkFail = false;
			m_bLinkDisconnected = false;
			m_bInitialLink = false;
			m_CIDDirection = CID_DIRECTION_NOT_LINK;
			m_bCIDNotUse = false;
			m_CIDOperationStarted = false;  // 2016. 12. 23 추가
			m_job_change_flag_no_cid_area = false; //0: not change 1 : change
			m_job_change_flag_exception_CommonTag = false;
			m_CurrCIDStartnode = 0;
			m_sCIDStatus[0]=0;
			m_sCIDStatus[1]=0;
			m_sCIDStatus[2]=0;

			bCountOfCID_Delay    = 0;
			bCountOfCIDLink    = 0; 	   //링크 연결 관련
			m_job_change_without_link_complete = false;
			bCountOfCIDDualOccup	= 0;  //동시진입 관련
			bCountOfCIDComptACK    = 0;  //완료처리 응답 관련

			bDirCIDChage = false;		// 방향전환 전에 완료처리를 함을 나타내는 변수
			tmpStopID = 0;
			memset(&Info, 0, sizeof(CID_CTRL_INFO));
			memset(&CID_4WAY_CONTROL_INFO, 0, sizeof(CID_4WAY_INFO));

			m_CIDNameReadFlag = false;
			m_tmpCurrentResetNode = 0;
			m_tmpCurrentStopNode = 0;
			m_nCIDTerminateCount = 0;

			m_Diag_CID_index = 0;
			memset(&m_Diag_CID_R_ID[0][0],'0',sizeof(m_Diag_CID_R_ID));
			memset(&m_Diag_ResetNode[0],0,sizeof(m_Diag_ResetNode));
			memset(&m_Diag_StopNode[0],0,sizeof(m_Diag_StopNode));

			m_nCidControlStep = CID_STEP_CONNECTING;
			pHWSet->m_pCID->CID_Occup_Resume(&m_CID_Pause); //Resume CID Status
			m_pExecuteInfo->FlagCIDReport.bCIDInterlock= false; //Resume CID Status
			m_pExecuteInfo->FlagCIDReport.bCIDStop= false; //Resume CID Status
		 //	m_iLifterPrePass = VHL_ELEVETOR_PREPASS_STEP_NONE;    //Auto Door Test로 추가 - 전체 적용 여부 확인 필요
  			ADD_LOG("C-1");

	   }

    //2 주행  중에는 먹지 않는다.
//#if 0
//  if(m_StatusSet.bIsOnProcess==true)
//  {
//      return EXECUTE_ACK_BUSY;
//  }
//#else
//  if(m_StatusSet.bIsOnProcess==true)
//  {
//      if(m_StatusSet.byStatus==STS_GOING || m_StatusSet.byStatus==STS_ARRIVED)
//      {
//          return EXECUTE_ACK_BUSY;
//      }
//      else
//      {
//          stop();
//      }
//  }
//#endif

	m_bOnMapMake = false;
	m_bOnBackMove = false;

	   //2 Reset Process 시작
    m_StatusSet.bIsOnProcess = true;

    //2 Node 정보 초기화
    if(m_PositionInfo.Marked==false)
    {
		initCommandSet();
		initInfoSet();
		initPreviousArrivalInfo();

		if((m_StatusSet.byStatus!=STS_AUTORECOVERY) &&
	   (m_StatusSet.byStatus!=STS_AUTORECOVERY_BLANKTRANS) &&
	   (m_StatusSet.byStatus!=STS_AUTORECOVERY_DOUBLETRANS) &&
	   (m_StatusSet.byStatus!=STS_AUTORECOVERY_OVERRUN) &&
	   (m_StatusSet.byStatus!=STS_TURN_OFF) &&
	   (m_pExecuteInfo->ExecuteMode != EXECUTE_MODE_AUTO))
	   {
        	memset(&m_PositionInfo, 0x00, sizeof(EXECUTE_POSITION_INFO));
	   }

        //      setCompensationInfo(m_PreviousArrivalInfo);
    }
    else if(    (m_PositionInfo.CurrStation!=0x00)
            &&  (m_PositionInfo.StationType==MARK_TYPE_NODE)
    )
    {
        m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uStation = 0x00;
        m_PositionInfo.CurrStation=0x00;
    }

    //2 조향 초기화
    m_pSteer->Adjust();

	//정위치 경사로 정보 확인
	 if((getMarkStatus() ==true) && (m_PositionInfo.Marked ==true))
	 {
		nNodeIndex =	OHTMainForm->GetMap()->FindNodeIndex(m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode);
		if(nNodeIndex!=INDEX_NONE) pNODE_INFO = &(OHTMainForm->GetMap()->m_NodeArray[nNodeIndex]);		// Node 정보

		if(pNODE_INFO !=NULL)
		{
			if(pNODE_INFO->InOutInfo ==SLOPE_NTYPE)
				bSlopeCheck = true;
			else
				bSlopeCheck = false;
		}
		else
		{
		   bSlopeCheck = true;
		}

		bCheckNode = true;

	 }
	 else if(m_pExecuteInfo->ExecuteMode == EXECUTE_MODE_AUTO)
     {
        if(m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode!=0)
        {
            nNodeIndex =    OHTMainForm->GetMap()->FindNodeIndex(m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode);
            if(nNodeIndex!=INDEX_NONE) pNODE_INFO = &(OHTMainForm->GetMap()->m_NodeArray[nNodeIndex]);        // Node 정보

            if(pNODE_INFO !=NULL)
            {
				if(pNODE_INFO->InOutInfo ==SLOPE_NTYPE)
					bSlopeCheck = true;
                else
                    bSlopeCheck = false;
            }
			else
			{
			   bSlopeCheck = true;
			}
            bCheckNode = true;
        }
     }


	//2 축 초기화
	// 주행 축 서보 오프 및 Reset
   //정위치 상태 구분
   //AOHC-191 Reset시 AMP 초기화 동시 제어 -> 차등 제어로 변경 #JRespect.im 2019.08.06
   if((((getMarkStatus() == false) || (m_PositionInfo.Marked == false)) && (bCheckNode ==false)) ||
	  (bSlopeCheck ==true))
	{

	   ADD_LOG("D-10");

		if((m_StatusSet.byStatus != STS_INIT) || fabs(m_pDrivingAxis->GetCurrentPosition())>2.0)
		{

				m_pDrivingAxis->SetBrakeRelease(false);
				ADD_LOG("D-11");

				Sleep(50);   // brake release false 될때까지 대기

				if( fabs(m_pDrivingAxis->GetCurrentPosition())>0.1 || m_pDrivingAxis->GetError()!=NO_ERR)
				{
					 m_pDrivingAxis->SetAMPEnable(false);
					 ADD_LOG("D-12");
					 ADD_LOG("D_9/%d/%d",m_pDrivingAxis->IsAMPEnable(),m_pDrivingAxis->IsSlaveAMPEnable() );

					Sleep(200);   //brake 잡히는데 최소 100mmsec

					if(m_pDrivingAxis->IsSyncControl())
					{

						 m_pDrivingAxis->SetSlaveAMPEnable(false);
						 ADD_LOG("D-13");
						 ADD_LOG("D_10/%d/%d",m_pDrivingAxis->IsAMPEnable(),m_pDrivingAxis->IsSlaveAMPEnable() );

						 Sleep(50); //slave amp off 되는데 대기  시간

						 ERR_LOG("Driving Set SW Limit 삭제");

						 m_pDrivingAxis->Reset();
						 ADD_LOG("D-14");
						 ADD_LOG("D_11/%d/%d",m_pDrivingAxis->IsAMPEnable(),m_pDrivingAxis->IsSlaveAMPEnable() );

						 m_pDrivingAxis->ResetSlave();
						 ADD_LOG("D-15");
						 ADD_LOG("D_12/%d/%d",m_pDrivingAxis->IsAMPEnable(),m_pDrivingAxis->IsSlaveAMPEnable() );

						 m_pDrivingAxis->SetHome();
						 ADD_LOG("D-16");
						 ADD_LOG("D_13/%d/%d",m_pDrivingAxis->IsAMPEnable(),m_pDrivingAxis->IsSlaveAMPEnable() );
#if((OHT_NAME == OHT_NAME_STD_V82)|| (OHT_NAME == OHT_NAME_STD_V85S)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
						 m_pDrivingAxis->Reset();
						 ADD_LOG("[slope]set home -> reset");

						 m_pDrivingAxis->ResetSlave();
						 ADD_LOG("[slope]set home -> slave reset");
#else
						 m_pDrivingAxis->SetSlaveHome();
						 ADD_LOG("D-17");
						 ADD_LOG("D_14/%d/%d",m_pDrivingAxis->IsAMPEnable(),m_pDrivingAxis->IsSlaveAMPEnable() );
#endif

					}
				}
				dwCurrTime  = timeGetTime();
				while(OHTUTILITY::PreventOverflowGetTimeMs(dwCurrTime)<200)       // master, slave reset 완료 판단
				{
					if( fabs(m_pDrivingAxis->GetCurrentPosition())<0.1      &&
						fabs(m_pDrivingAxis->GetSlaveCurrentPosition())<0.1     )
						break;
					Sleep(5);
				}
				if(m_pDrivingAxis->IsSyncControl())
				{
					if(m_pDrivingAxis->IsSlaveAMPEnable()==false)
					{
							m_pDrivingAxis->SetSlaveAMPEnable(true);
							ADD_LOG("D-18");
							 ADD_LOG("D_15/%d/%d",m_pDrivingAxis->IsAMPEnable(),m_pDrivingAxis->IsSlaveAMPEnable() );
					}
				}
				Sleep(50);   //brake 개방 시간 100mmsec 이하
				if(m_pDrivingAxis->IsAMPEnable()==false)
				{
					m_pDrivingAxis->SetAMPEnable(true);
					ADD_LOG("D-19");
					 ADD_LOG("D_16/%d/%d",m_pDrivingAxis->IsAMPEnable(),m_pDrivingAxis->IsSlaveAMPEnable() );
				}

				dwCurrTime  = timeGetTime();
				while(OHTUTILITY::PreventOverflowGetTimeMs(dwCurrTime)<500)
				{
					if((m_pDrivingAxis->IsAMPEnable() == true)&&(m_pDrivingAxis->IsSlaveAMPEnable() == true))
					{
						m_pDrivingAxis->SetBrakeRelease(true);
						ADD_LOG("D-20");
						 ADD_LOG("D_17/%d/%d",m_pDrivingAxis->IsAMPEnable(),m_pDrivingAxis->IsSlaveAMPEnable() );
						break;
					}
					Sleep(5);
				}
		}
#if((OHT_NAME == OHT_NAME_STD_V82)|| (OHT_NAME == OHT_NAME_STD_V85S)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
#else
		//SetInnerLimitTorque_90 자체 800ms Sleep있으므로 2회 Retry 가능하도록 1s로 변경  #Jrespect.im
		dwCurrTime  = timeGetTime();
		if(m_defualtparam->bUseRSA==true)
		{
			while(OHTUTILITY::PreventOverflowGetTimeMs(dwCurrTime)<1000)
			{
				if(m_pRSAControl->IsSetInnerLimitTorque_90() == true)
					break;

				m_pRSAControl->SetInnerLimitTorque_90();  //DrivingControl::Reset Retry 존재 Error 처리 0
				Sleep(5);
			}
			//Reset 시도 중 Torque Limit설정 Fail했을 경우 Error Clear가 되지 않아 Error처리하지않고 로그만 남김
			if(m_pRSAControl->IsSetInnerLimitTorque_90() == false)
			{
				//nTmpError = ERR_SERVO_DRIVING_ALARM;
				//return EXECUTE_ACK_ON_ERR;
				ADD_LOG("D-21");
			}
			else
			{
				//ERR_LOG("[Reset] Success SetInnerLimitTorque_90");
			}
		}
		else
		{
			while(OHTUTILITY::PreventOverflowGetTimeMs(dwCurrTime)<1000)
			{
				if(m_pServoControl->IsSetInnerLimitTorque_90() == true)
					break;

				m_pServoControl->SetInnerLimitTorque_90(); //DrivingControl::Reset Retry 존재 Error 처리 0
				Sleep(5);
			}
			//Reset 시도 중 Torque Limit설정 Fail했을 경우 Error Clear가 되지 않아 Error처리하지않고 로그만 남김
			if(m_pServoControl->IsSetInnerLimitTorque_90() == false)
			{
				//nTmpError = ERR_SERVO_DRIVING_ALARM;
				//return EXECUTE_ACK_ON_ERR;
				ADD_LOG("D-21");
			}
			else
			{
				//ERR_LOG("[Reset] Success SetInnerLimitTorque_90");
			}

		}
#endif

	}
	else
	{

			ADD_LOG("D-22");
			if( fabs(m_pDrivingAxis->GetCurrentPosition())>0.1 || m_pDrivingAxis->GetError()!=NO_ERR)
			{
				m_pDrivingAxis->SetAMPEnable(false);
			}
			if(m_pDrivingAxis->IsSyncControl())
			{
				if(fabs(m_pDrivingAxis->GetSlaveCurrentPosition())>0.1 || m_pDrivingAxis->GetSlaveError()!=NO_ERR)
					m_pDrivingAxis->SetSlaveAMPEnable(false);
			}

			ERR_LOG("Driving Set SW Limit 삭제");

			//Error Reset
			if( fabs(m_pDrivingAxis->GetCurrentPosition())>0.1 || m_pDrivingAxis->GetError()!=NO_ERR)
				m_pDrivingAxis->Reset();
			if(m_pDrivingAxis->IsSyncControl())
			{
				if(fabs(m_pDrivingAxis->GetSlaveCurrentPosition())>0.1 || m_pDrivingAxis->GetSlaveError()!=NO_ERR)
					m_pDrivingAxis->ResetSlave();
			}

			// 주행 축 원점
			if(fabs(m_pDrivingAxis->GetCurrentPosition())>0.1)
				m_pDrivingAxis->SetHome();
#if((OHT_NAME == OHT_NAME_STD_V82)|| (OHT_NAME == OHT_NAME_STD_V85S)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
			//Error Reset
			if (m_pDrivingAxis->GetError()!=NO_ERR)
			{
				m_pDrivingAxis->Reset();
				ADD_LOG("[normal]set home -> reset");
			}
			if(m_pDrivingAxis->IsSyncControl())
			{
				if (m_pDrivingAxis->GetSlaveError()!=NO_ERR)
				{
					m_pDrivingAxis->ResetSlave();
					ADD_LOG("[normal]set home -> slave reset");
				}
			}
#else
			if(m_pDrivingAxis->IsSyncControl())
			{
				if(fabs(m_pDrivingAxis->GetSlaveCurrentPosition())>0.1)
				m_pDrivingAxis->SetSlaveHome();
			}
#endif


			dwCurrTime  = timeGetTime();
			while(OHTUTILITY::PreventOverflowGetTimeMs(dwCurrTime)<200)
			{
				if( fabs(m_pDrivingAxis->GetCurrentPosition())<0.1      &&
					fabs(m_pDrivingAxis->GetSlaveCurrentPosition())<0.1 )
					break;
				Sleep(5);
			}
			// 주행 축 서보 온
			if(m_pDrivingAxis->IsAMPEnable()==false)
			{
				m_pDrivingAxis->SetAMPEnable(true);

			}

	}
	//2 명령 초기화

	//AMC의 경사로 처리 부분 초기화(주행시 재설정됨)
	if(pHWSet->GetAMCTorqueStatus()==RELSLOPE)
	{
#if((OHT_NAME == OHT_NAME_STD_V82)|| (OHT_NAME == OHT_NAME_STD_V85S)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
#else
		   if(m_defualtparam->bUseRSA==true)
		   {
				if(m_pRSAControl->IsSetInnerLimitTorque_300() == true)
				  m_pDrivingAxis->SetTorqueLimitRelease();
		   }
		   else
		   {
				if(m_pServoControl->IsSetInnerLimitTorque_800() ==true)
					m_pDrivingAxis->SetTorqueLimitRelease();
		   }
#endif
	}

	m_pDrivingAxis->SetSlopeTimeRelease();
    ////
	//2 Node Count Reset
	m_pDrivingAxis->ClearNodeCountInfo();
//  NODE_CHECK_DATA NodeCheckData;
//  m_pDrivingAxis->GetNodeCountInfo(NodeCheckData);

	//2 근젭제어 Off
	m_Detect.UseFollowControlFlag = false;
	m_Detect.NodeCount = 0;
	m_pDrivingAxis->SetDetectInfo(m_Detect);
//	ADD_LOG("D-23");

    init();
	m_StatusSet.uError =    NO_ERR;
	m_StatusSet.bIsOnProcess = false;

	DrivingCMDExuteFunc(false);

    return EXECUTE_ACK_NO_ERR;
}

#define OBS_SENSOR_FAIL_TIMEOVER		3000
#define STEER_IO_CHECK_TIMEOVER			500
#define STEER_IO_CHECK_TIMEOVER2		1000


/**
@brief   Driving 이상여부  확인

    1. 주행 축 알람 확인
      : 주행 축 알람 발생 시 에러 처리

    2. 조향 이상 확인
      ① Map 기준 조향이 왼쪽이나 오른쪽일 때, 현재의 조향 방향과 같지 않고
      ② 조향이 움직이지 않는 상태가 아닌 상태가 10번 이상일 경우 에러 처리함
        (진입 전 조향 변경, 나오면서 사전 조향 변경을 위한 예외 사항)

    3. 주행 TAG 간격 이상 확인
      : 다음 TAG가 Map 기준 대비 400mm 초과될 때가지 나오지 않을 경우 에러 처리

    4. 과속 시 에러 처리
      : 주행 속도가 기준 속도 대비, 0.5m/s 초과될 경우 에러 처리 (V기준 + 0.5m/s)

	5. 레일 Support Home 위치 확인
      : 레일 Support 가 Home 위치가 아닐 경우 에러 처리

@todo 내용 추가 필요 - 기존 코드 참조
@author  ehoto
@date    2012.11.07
@return     nTmpError 를 ㄹ리턴함 (0이면 정상, 아니면 에러)
*/
int DrivingControl::checkError(DRIVING_INFO_SET *pInfoSet)
{
    int     nTmpError   = NO_ERR;

	DWORD   dwCurrTime  = timeGetTime();
	static DWORD dwStaticObsPowerResetTime = 0;
	static bool bObsPowerReset = false;

	UINT    uCurrNode       = pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.uNode;
    double  dCurrOffset = pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset;

    UINT    uLimitNode  = (pInfoSet->Position.CurrentAndTarget.TargetPosition.MarkType==MARK_TYPE_NODE)
						? pInfoSet->Position.CurrentAndTarget.TargetPosition.uNode
                        : pInfoSet->Position.CurrentAndTarget.TargetPosition.uNextNode;

    UINT    uNodeBCR = (UINT)pInfoSet->HwInfo.Node.nBcrId;
	UINT    uStationBCR = (UINT)pInfoSet->HwInfo.TagStaion.nBcrId;

    MARK_TYPE   MarkType    = pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.MarkType;

    static bool bObsCheckArea = false;// AOHC-152 센서 데이터 로그 저장
	double  dSpeedOfNow                 = pInfoSet->HwInfo.Axis1.dSpeed;
	DRIVING_CMD_INFO_OF_NODE* pNodeInfo = getNodeInfo(pInfoSet->HwInfo.Node.nNodeCount);
    // -----------------------------------------------------------------------------------------------------------
    //1 0.  Mark 시 OverRun 감지
    // -----------------------------------------------------------------------------------------------------------
    if( (nTmpError==NO_ERR)
    &&  (uCurrNode==uLimitNode)
    &&  (pInfoSet->EventAndState.State.MarkArea==true)
    &&  (dCurrOffset>100.0) //1 기준 거리 확정 필요
	)
	{
		MarkType =  m_ClassifiedCmd.TargetInfo.Type;

        switch(MarkType)
        {
            case MARK_TYPE_NODE:
				nTmpError = ERR_NOTMATCH_TAGLENGTH_FINALNODE_MET_LATE;
				break;
            case MARK_TYPE_TAG_STATION:
				nTmpError = ERR_NOTMATCH_TAGLENGTH_FINALSTATION_TAG_MET_LATE;
				break;
			case MARK_TYPE_QR_STATION_LEFT:
			case MARK_TYPE_QR_LEFT_TOP:
			case MARK_TYPE_QR_LEFT_BOTTOM:
			case MARK_TYPE_QR_LEFT_BOTTOM_S:
			case MARK_TYPE_QR_PSTB_LEFT:
				nTmpError = ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_LEFT_MET_LATE;
                break;
            case MARK_TYPE_QR_STATION_RIGHT:
			case MARK_TYPE_QR_RIGHT_TOP:
			case MARK_TYPE_QR_RIGHT_BOTTOM:
			case MARK_TYPE_QR_RIGHT_BOTTOM_S:
			case MARK_TYPE_QR_PSTB_RIGHT:
				nTmpError = ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_RIGHT_MET_LATE;
                break;
            default:
				nTmpError = ERR_NOTMATCH_TAGLENGTH_FINALNODE;
				break;
		}
		ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d/%6.1lf",
					nTmpError,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pExecuteInfo->ExecutePositionInfo.NextNode,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					m_pOHTMainStatus->StatusCommon.ExistFoup,
					m_pOHTMainStatus->StatusCommon.StopStationID,
					dCurrOffset);
		m_PositionInfo.CurrNode = uCurrNode;
		m_PositionInfo.CurrPreCheckNode = uCurrNode;  //
		m_PositionInfo.CurrNodeOffset = dCurrOffset;
		ERR_LOG("[checkError] E%d Node(C:%6X/L:%6X) Offset:%6.1lf,DistSum:%6.1lf,Compensation[dPreArriveOffset:%6.1lf, dDistErrorSum:%6.1lf], CurPos:%6.1lf"
			, nTmpError, uCurrNode, uLimitNode, dCurrOffset,pNodeInfo->dDistSum,pInfoSet->Position.Compensation.dPreArriveOffset,pInfoSet->Position.Compensation.dDistErrorSum, pInfoSet->HwInfo.Axis1.dCurrPos);
	}

    if( (nTmpError==NO_ERR)
	&&  (pInfoSet->Position.CurrentAndTarget.TargetPosition.MarkType!=MARK_TYPE_NODE)
    &&  (uCurrNode==uLimitNode)
    &&  (pInfoSet->EventAndState.MarkState.Arrived==true)
    &&  ((pInfoSet->HwInfo.IO.NodeOn==true) ||(dCurrOffset>-5.0))   //1 기준 거리 확정 필요
    )
    {
        switch(MarkType)
        {
            case MARK_TYPE_NODE:
                nTmpError = ERR_NOTMATCH_TAGLENGTH_FINALNODE_MET_EARLY;
                break;
            case MARK_TYPE_TAG_STATION:
                nTmpError = ERR_NOTMATCH_TAGLENGTH_FINALSTATION_TAG_MET_EARLY;
                break;
            case MARK_TYPE_QR_STATION_LEFT:
            case MARK_TYPE_QR_LEFT_TOP:
			case MARK_TYPE_QR_LEFT_BOTTOM:
			case MARK_TYPE_QR_LEFT_BOTTOM_S:
			case MARK_TYPE_QR_PSTB_LEFT:
				nTmpError = ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_LEFT_MET_EARLY;
                break;
            case MARK_TYPE_QR_STATION_RIGHT:
			case MARK_TYPE_QR_RIGHT_TOP:
			case MARK_TYPE_QR_RIGHT_BOTTOM:
			case MARK_TYPE_QR_RIGHT_BOTTOM_S:
			case MARK_TYPE_QR_PSTB_RIGHT:
				nTmpError = ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_RIGHT_MET_EARLY;
                break;
            default:
                nTmpError = ERR_NOTMATCH_TAGLENGTH_FINALNODE;
                break;
        }
		ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d/%6.1lf",
					nTmpError,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pExecuteInfo->ExecutePositionInfo.NextNode,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					m_pOHTMainStatus->StatusCommon.ExistFoup,
					m_pOHTMainStatus->StatusCommon.StopStationID,
					dCurrOffset);
		m_PositionInfo.CurrNode = uCurrNode;
		m_PositionInfo.CurrPreCheckNode = uCurrNode;
        m_PositionInfo.CurrNodeOffset = MAX(0.0, dCurrOffset);//dCurrOffset;
		ERR_LOG("[checkError] After Mark: E%d Node(C:%6X/L:%6X) Offset:%6.1lf,DistSum:%6.1lf,Compensation[dPreArriveOffset:%6.1lf, dDistErrorSum:%6.1lf], CurPos:%6.1lf"
			, nTmpError, uCurrNode, uLimitNode, dCurrOffset,pNodeInfo->dDistSum,pInfoSet->Position.Compensation.dPreArriveOffset,pInfoSet->Position.Compensation.dDistErrorSum, pInfoSet->HwInfo.Axis1.dCurrPos);
	}



    // -----------------------------------------------------------------------------------------------------------
    //1 0.  전방 감지 센서 Fail 확인
    // -----------------------------------------------------------------------------------------------------------
#if(UBG_SENSOR_ENABLE == ON)
	//2 OHT Detect 센서 에러
	if(nTmpError==NO_ERR && pInfoSet->HwInfo.IO.DetectStatus==DETECT_UNIT_FAIL)
	{
		if(pInfoSet->Time.FrontObserve.OHTDetectFail.bFlag==true)
		{
			if(OHTUTILITY::PreventOverflowGetTimeMs(pInfoSet->Time.FrontObserve.OHTDetectFail.dwTime) >m_pParamSet->FrontDetect.dwDetectFailChatteringTime)
			{
				nTmpError = ERR_DETECT_SENSOR_FAIL;
				ADD_FDC_LOG("ERR/%d/1/5/%06d/%06d/%d/%d/%06d",
							ERR_DETECT_SENSOR_FAIL,
							m_pOHTMainStatus->StatusCommon.CurNodeID,
							m_pExecuteInfo->ExecutePositionInfo.NextNode,
							m_pOHTMainStatus->StatusCommon.CurNodeOffset,
							m_pOHTMainStatus->StatusCommon.ExistFoup,
							m_pOHTMainStatus->StatusCommon.StopStationID);
			}
		}
	}
#endif
	//2 전방 장애물 감지 센서 에러
	if(nTmpError==NO_ERR && pInfoSet->HwInfo.IO.ObsStatus==DETECT_UNIT_FAIL)
	{
		if(pInfoSet->Time.FrontObserve.OBSDetectFail.bFlag==true)
		{
			if(OHTUTILITY::PreventOverflowGetTimeMs(pInfoSet->Time.FrontObserve.OBSDetectFail.dwTime) >m_pParamSet->FrontDetect.dwObsFailChatteringTime)
			{
				//nTmpError = ERR_OBS_SENSOR_FAIL;
				if(bObsPowerReset == false)
				{
					m_pObstacle->PowerControl(PWR_OFF);
					ADD_LOG("D-24");
					dwStaticObsPowerResetTime = timeGetTime();
					bObsPowerReset = true;
				}
			}
			if((OHTUTILITY::PreventOverflowGetTimeMs(dwStaticObsPowerResetTime)>500) && (bObsPowerReset == true))
			{
				m_pObstacle->PowerControl(PWR_ON);
				ADD_LOG("D-25");
				bObsPowerReset = false;
			}

			if(OHTUTILITY::PreventOverflowGetTimeMs(-pInfoSet->Time.FrontObserve.OBSDetectFail.dwTime) > (m_pParamSet->FrontDetect.dwObsFailChatteringTime+OBS_SENSOR_FAIL_TIMEOVER))
			{
				nTmpError = ERR_OBS_SENSOR_FAIL;
				ERR_LOG("ERR_OBS_SENSOR_FAIL");
				ADD_FDC_LOG("ERR/%d/1/5/%06d/%06d/%d/%d/%06d",
							ERR_OBS_SENSOR_FAIL,
							m_pOHTMainStatus->StatusCommon.CurNodeID,
							m_pExecuteInfo->ExecutePositionInfo.NextNode,
							m_pOHTMainStatus->StatusCommon.CurNodeOffset,
							m_pOHTMainStatus->StatusCommon.ExistFoup,
							m_pOHTMainStatus->StatusCommon.StopStationID);
			}
		}
	}

    // -----------------------------------------------------------------------------------------------------------
    //1 1. 주행 축 알람 확인
    // -----------------------------------------------------------------------------------------------------------
    if(nTmpError==NO_ERR)
    {
        nTmpError = pInfoSet->HwInfo.Axis1.nError;
    }

    if(nTmpError==NO_ERR && m_pDrivingAxis->IsSlaveRunning()==true)
    {
        nTmpError = pInfoSet->HwInfo.Axis2.nError;
    }


    // -----------------------------------------------------------------------------------------------------------
    //1 2. Steering check
    // -----------------------------------------------------------------------------------------------------------

    PATH_STEERING_INFO PathSteerInfo = pInfoSet->Steer.PathSteer;
    bool    bSteerFrontLeft = pInfoSet->HwInfo.IO.SteerFrontLeftInOn;
    bool    bSteerFrontRight    = pInfoSet->HwInfo.IO.SteerFrontRightInOn;
    bool    bSteerRearLeft      = pInfoSet->HwInfo.IO.SteerRearLeftInOn;
    bool    bSteerRearRight = pInfoSet->HwInfo.IO.SteerRearRightInOn;


    if( nTmpError==NO_ERR )
    if( (bSteerFrontLeft==true && bSteerFrontRight==true)
    &&  (bSteerRearLeft==true && bSteerRearRight==true)
    )   // 센서가 좌우에 다 들어온 경우 에러 발생
    {
        nTmpError = ERR_STEER_NOTSAMESTATUS;
		ADD_FDC_LOG("ERR/%d/2/9/%06d/%06d/%d/%d/%06d/%d/%d/%d/%d",
					ERR_STEER_NOTSAMESTATUS,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pExecuteInfo->ExecutePositionInfo.NextNode,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					m_pOHTMainStatus->StatusCommon.ExistFoup,
					m_pOHTMainStatus->StatusCommon.StopStationID,
					bSteerFrontLeft,
					bSteerFrontRight,
					bSteerRearLeft,
					bSteerRearRight);
    }


    if(nTmpError==NO_ERR)
    {
		if(pInfoSet->Time.Steer.SteeringNotMatch.bFlag==true)
        {
			if(OHTUTILITY::PreventOverflowGetTimeMs(pInfoSet->Time.Steer.SteeringNotMatch.dwTime) > (m_pParamSet->Steer.dwChangeTime*3))     // 3.3mm/msec * (30 + a) -->99+(3.3*a)mm : 샘플링 타임 만큼 더 갈 수 있음
			{
				switch(PathSteerInfo)
				{
				case PATH_STEERING_LEFT:
					nTmpError = AutoRecovery_Steer(ERR_STEER_FR_LEFTNOTON, pInfoSet);    //AutoRecovery E309
					break;
				case PATH_STEERING_RIGHT:
					nTmpError = AutoRecovery_Steer(ERR_STEER_FR_RIGHTNOTON, pInfoSet);   //AutoRecovery E310
					break;
				case PATH_STEERING_NONE:
					nTmpError = ERR_STEER_NOTSAMESTATUS;
					break;
				case PATH_STEERING_N_BRANCH_L2R:
				case PATH_STEERING_N_BRANCH_R2L:
					if(OHTUTILITY::PreventOverflowGetTimeMs(pInfoSet->Time.Steer.SteeringNotMatch.dwTime) > (m_pParamSet->Steer.dwChangeTime*10))     // 3.3mm/msec * (30 + a) -->99+(3.3*a)mm : 샘플링 타임 만큼 더 갈 수 있음
					{
						nTmpError = ERR_STEER_NOTSAMESTATUS;
					}
					break;
                }
				ADD_FDC_LOG("ERR/%d/1/9/%06d/%06d/%d/%d/%06d/%d/%d/%d/%d",
					nTmpError,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pExecuteInfo->ExecutePositionInfo.NextNode,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					m_pOHTMainStatus->StatusCommon.ExistFoup,
					m_pOHTMainStatus->StatusCommon.StopStationID,
					bSteerFrontLeft,
					bSteerFrontRight,
					bSteerRearLeft,
					bSteerRearRight);
				if(nTmpError == NO_ERR)
				{
					ADD_LOG("!Get Steering Data!");
					bSteerFrontLeft = pInfoSet->HwInfo.IO.SteerFrontLeftInOn;
					bSteerFrontRight = pInfoSet->HwInfo.IO.SteerFrontRightInOn;
					bSteerRearLeft = pInfoSet->HwInfo.IO.SteerRearLeftInOn;
					bSteerRearRight = pInfoSet->HwInfo.IO.SteerRearRightInOn;
				}
			}

        }
	}


    if(nTmpError!=NO_ERR)
	{
		ERR_LOG("[%d]ERR_STEER PathType[%d] Front[%d:%d] Rear[%d:%d]"
            , uCurrNode
            , PathSteerInfo
            , bSteerFrontLeft
            , bSteerFrontRight
            , bSteerRearLeft
            , bSteerRearRight
        );

        return nTmpError;
    }

    DRIVING_CMD_INFO_OF_PATH* pPathInfo = getPathInfo(pInfoSet->HwInfo.Node.nNodeCount);
    // -----------------------------------------------------------------------------------------------------------
    //1 3. 일정 범위 오차 내에 TAG가 감지되지 않을 경우
    // -----------------------------------------------------------------------------------------------------------
    if( (nTmpError==NO_ERR)
    &&  (fabs(pInfoSet->Position.Compensation.dLinkDistError)>DIST_MARGIN_OF_NODE) //너무 일찍 나타나거나
    )
    {
        nTmpError = ERR_NOTMATCH_TAGLENGTH;

        ERR_LOG("ERR_NOTMATCH_TAGLENGTH-Meet Node Too Fast: |%7.1lf| > %7.1lf"
            ,pInfoSet->Position.Compensation.dLinkDistError ,DIST_MARGIN_OF_NODE);
		ADD_FDC_LOG("ERR/%d/1/7/%06d/%06d/%d/%d/%06d/%6.1lf/%6.1lf",
						ERR_NOTMATCH_TAGLENGTH,
						m_pOHTMainStatus->StatusCommon.CurNodeID,
						m_pExecuteInfo->ExecutePositionInfo.NextNode,
						m_pOHTMainStatus->StatusCommon.CurNodeOffset,
						m_pOHTMainStatus->StatusCommon.ExistFoup,
						m_pOHTMainStatus->StatusCommon.StopStationID,
						fabs(pInfoSet->Position.Compensation.dLinkDistError),
						DIST_MARGIN_OF_NODE);
    }

    if( (nTmpError==NO_ERR)
    &&  (pPathInfo!=NULL)
	)
    {
        if((pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset-pPathInfo->dLength)>DIST_MARGIN_OF_NODE)// 너무 늦게 나타나는 것 방지
        {
			nTmpError = ERR_NOTMATCH_TAGLENGTH;

			ERR_LOG("ERR_NOTMATCH_TAGLENGTH-Meet Node Too Late: %7.1lf(%7.1lf-%7.1lf[%d~%d(%d)]) > %7.1lf"
				, pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset - pPathInfo->dLength
                , pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset
				, pPathInfo->dLength
                , pPathInfo->StartNID
				, pPathInfo->EndNID
				, pInfoSet->HwInfo.Node.nNodeCount
				, DIST_MARGIN_OF_NODE);
			ADD_FDC_LOG("ERR/%d/2/7/%06d/%06d/%d/%d/%06d/%6.1lf/%6.1lf",
						ERR_NOTMATCH_TAGLENGTH,
						m_pOHTMainStatus->StatusCommon.CurNodeID,
						m_pExecuteInfo->ExecutePositionInfo.NextNode,
						m_pOHTMainStatus->StatusCommon.CurNodeOffset,
						m_pOHTMainStatus->StatusCommon.ExistFoup,
						m_pOHTMainStatus->StatusCommon.StopStationID,
						pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset-pPathInfo->dLength,
						DIST_MARGIN_OF_NODE);
		}
	}

	if( (nTmpError==NO_ERR)
	&&  (fabs(pInfoSet->Position.Compensation.dLinkDistError)>DIST_MARGIN_OF_NODE_FDC)) //너무 일찍 나타나거나
	{
		if(m_bFDCEarlyPathFlag == true)
		{
			SEND_WARN("WARN/4/1/6/%06d/%06d/%d/%d/%06d/%6.1lf",
						m_pOHTMainStatus->StatusCommon.CurNodeID,
						m_pExecuteInfo->ExecutePositionInfo.NextNode,
						m_pOHTMainStatus->StatusCommon.CurNodeOffset,
						m_pOHTMainStatus->StatusCommon.ExistFoup,
						m_pOHTMainStatus->StatusCommon.StopStationID,
						pInfoSet->Position.Compensation.dLinkDistError);
			m_bFDCEarlyPathFlag = false;
		}
	}
	else
	{
		m_bFDCEarlyPathFlag = true;
    }

	if((nTmpError==NO_ERR)&&(pPathInfo!=NULL))
	{
		if((pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset-pPathInfo->dLength)>DIST_MARGIN_OF_NODE_FDC)// 너무 늦게 나타나는 것 방지
		{
			if(m_bFDCLatePathFlag == true)
			{
				SEND_WARN("WARN/4/2/6/%06d/%06d/%d/%d/%06d/%6.1lf",
						m_pOHTMainStatus->StatusCommon.CurNodeID,
						m_pExecuteInfo->ExecutePositionInfo.NextNode,
						m_pOHTMainStatus->StatusCommon.CurNodeOffset,
						m_pOHTMainStatus->StatusCommon.ExistFoup,
						m_pOHTMainStatus->StatusCommon.StopStationID,
						pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset-pPathInfo->dLength);
				m_bFDCLatePathFlag = false;
			}
		}
		else
		{
        	m_bFDCLatePathFlag = true;
        }
	}

	//AOHC-196 사전 로그 추가
	if(pPathInfo!=NULL)
	{
		if(fabs(pInfoSet->Position.Compensation.dLinkDistError)>100.0) //너무 일찍 나타나거나
		{
			   /*//	  ERR_LOG("일찍 LinkDistError : %7.1f, 차이 : %7.1f, 마크 지점 :%7.1f, 맵 거리 : %7.1f, "
				  ,fabs(pInfoSet->Position.Compensation.dLinkDistError)
				  ,pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset - pPathInfo->dLength
				  , pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset
				  , pPathInfo->dLength);     */
			m_DiagManager->IncreasePreviosDiagCount(PREVIOS_DIAG_MAP_DGAP);   //사전로그
			ERR_LOG("[MNE]N:%d, Diff:%7.1lf",uCurrNode,fabs(pInfoSet->Position.Compensation.dLinkDistError));
		}
		else if((pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset-pPathInfo->dLength)>100.0)// 너무 늦게 나타나는 것 방지
		{    /*
			ERR_LOG("늦게 차이 : %7..1lf, 마크 지점 :%7..1lf, 맵 거리 : %7..1lf, "
				,pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset - pPathInfo->dLength
				, pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset
				, pPathInfo->dLength);*/
			m_DiagManager->IncreasePreviosDiagCount(PREVIOS_DIAG_MAP_DGAP);   //사전로그
			ERR_LOG("[MNL]N:%d, Offset:%7.1lf",uCurrNode,pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset - pPathInfo->dLength);
		}
	}


	if( (nTmpError==NO_ERR)
    &&  (pPathInfo!=NULL))
	{
		if(fabs(m_dCheckPrecheckNodecountPosition) > DIST_MARGIN_OF_NODE)
		{
		  //nTmpError = ERR_CURRNODE_INVALID;

			ERR_LOG("ERR_CURRNODE_INVALID-Meet Node MissMatch: %7.1lf([%d~%d(%d)]) > %7.1lf"
				, m_dCheckPrecheckNodecountPosition
                , pPathInfo->StartNID
				, pPathInfo->EndNID
				, pInfoSet->HwInfo.Node.nNodeCount
				, DIST_MARGIN_OF_NODE);
        }
    }
    //2 BCR 이상 확인
	if( (nTmpError==NO_ERR) &&(pPathInfo!=NULL) && (uNodeBCR!=0))// && (pInfoSet->HwInfo.Node.nNodeCount>0))
    {
        /* // [BEGIN] by zzang9un 2014.03.12 : BCR 인식 불량 인터락 제거
        if( (uNodeBCR==pPathInfo->StartNID)
        &&  (fabs(pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset)>200)
		)
		{
            nTmpError = ERR_NOTMATCHTGNODE; // 시작 노드인데 위치가 이상
            ERR_LOG("BCR:%6X/%6X Offset:%6.1lf", uNodeBCR, pPathInfo->StartNID, pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset);
        }
        else if( (uNodeBCR==pPathInfo->EndNID)
            &&  (fabs(pPathInfo->dLength-pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset)>MAX(200, pPathInfo->dLength*0.4))
        )
        {
            nTmpError = ERR_NOTMATCHTGNODE; // 끝 노드인데 위치가 이상
            ERR_LOG("BCR:%6X/%6X Offset:%6.1lf/%6.1lf", uNodeBCR, pPathInfo->EndNID, pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset, pPathInfo->dLength);
        }
        else
        */ // [END] by zzang9un 2014.03.12 : BCR 인식 불량 인터락 제거
//        if((uNodeBCR != pPathInfo->StartNID) && (uNodeBCR != pPathInfo->EndNID))
//		{
//			nTmpError = ERR_NOTMATCHTGNODE; // 이상한 노드가 읽힌 경우
//			ERR_LOG("BCR:%6d/%6d:%6d", uNodeBCR, pPathInfo->StartNID, pPathInfo->EndNID);
//		}
    }

    //1 4. Timeout Error
    //2 전방 장애물 감지 센서
	//2 전방 장애물 감지 센서 에러
    if(nTmpError==NO_ERR && pInfoSet->HwInfo.IO.ObsStatus==DETECT_AND_STOP)
    {
        if(pInfoSet->Time.FrontObserve.OBSDetect.bFlag==true)
		{
            /*
			if((dwCurrTime-pInfoSet->Time.FrontObserve.OBSDetect.dwTime)
				>(m_pParamSet->FrontDetect.dwObsTimeout)) // 삽체/정체로 대체사용유무 확인 필요.
			{
				nTmpError = ERR_OBS_TIMEOVER;
			}
            */
            // test 필요
			if(OHTUTILITY::PreventOverflowGetTimeMs(pInfoSet->Time.FrontObserve.OBSDetect.dwTime) //Overflow 방지
				>(m_pParamSet->FrontDetect.dwObsTimeout)) // 삽체/정체로 대체사용유무 확인 필요.
			{
                //ADD_LOG("D-26");
				int nObsResult = m_pObstacle->CheckObsSensorData();
                ERR_LOG("Check OBS Sensor Data : %d", nObsResult);
				nTmpError = ERR_OBS_TIMEOVER;
				bObsCheckArea = false;

				if(m_mccparam.dwUBGDetectTime != 0)
				{
					m_mccparam.dwUBGDetectTime = OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwUBGDetectTime);
				}

				if(m_mccparam.dwOBSDetectTime != 0)
				{
					m_mccparam.dwOBSDetectTime = OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwOBSDetectTime);
				}

				ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d/%d",
							ERR_OBS_TIMEOVER,
							m_pOHTMainStatus->StatusCommon.CurNodeID,
							m_pExecuteInfo->ExecutePositionInfo.NextNode,
							m_pOHTMainStatus->StatusCommon.CurNodeOffset,
							m_pOHTMainStatus->StatusCommon.ExistFoup,
							m_pOHTMainStatus->StatusCommon.StopStationID,
							OHTUTILITY::PreventOverflowGetTimeMs(pInfoSet->Time.FrontObserve.OBSDetect.dwTime));
				ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,OHT DETECT AND STOP,End,%s,%06d,%06d,%06d,%d,%3.3lf,OHT Detect Stop Time,%d,OBS Detect Stop Time,%d,OHT Detect Level,%d,OBS Detect Level,%d",
							m_defualtparam->VHLName,m_mccparam.cCarrierType,
							m_mccparam.uSourceNode,
							m_mccparam.uTargetNode,
							m_pExecuteInfo->ExecutePositionInfo.CurrNode,
							m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
							dSpeedOfNow,
							m_mccparam.dwUBGDetectTime,
							m_mccparam.dwOBSDetectTime,
							pHWSet->m_pOHTDetect->GetSensorLevel_MCC(),
							pHWSet->m_pObstacle->GetSensorLevel_MCC());
				m_mccparam.bDetectStatus = false;
				m_mccparam.dwOBSDetectTime = 0;
				m_mccparam.dwUBGDetectTime = 0;
			}
			else if(OHTUTILITY::PreventOverflowGetTimeMs(pInfoSet->Time.FrontObserve.OBSDetect.dwTime)   //Overflow 방지
				>(m_pParamSet->FrontDetect.dwObsTimeout - OBSLOGTIME)) // 삽체/정체로 대체사용유무 확인 필요.
			{
				if(bObsCheckArea == false)
                {
					m_pObstacle->RequestData();
                    //ERR_LOG("Request OBS Sensor Data!");
                    bObsCheckArea = true;
                }

			}
			else if(OHTUTILITY::PreventOverflowGetTimeMs(pInfoSet->Time.FrontObserve.OBSDetect.dwTime)  //Overflow 방지
				>(m_pParamSet->FrontDetect.dwObsChangeTime)) // 삽체/정체로 대체사용유무 확인 필요.
			{

				int nNowOBSAreaSelect = m_pObstacle->GetObsAreaStatus();

				//대차 패턴 모양에 의해 장애물 변경유무 결정 //직선이 아닐경우는 모두 변경
				if((m_Dectect_Dir != PATH_DIRECTION_NO_USE) &&
				(m_Dectect_Dir != PATH_DIRECTION_NORMAL))
				{
					//변경된 경우는 그대로 유지
					if(nNowOBSAreaSelect !=HO_OBS_AREA_TEST)
					{
						 ERR_LOG("OBS Data Set: %d %d",nNowOBSAreaSelect,m_Dectect_Dir);
						 m_pObstacle->AreaSelect(HO_OBS_AREA_SET);


					}
				}

			}
        }

        }
    else
    {
        if(bObsCheckArea ==true)
        {
			m_pObstacle->CloseCom();
            //ERR_LOG("[2325]driving reset OBS CloseCom : %d", );
        }
        bObsCheckArea = false;
    }

    STEER_HW_INFO_CMD SteerCmdDirection = pInfoSet->Steer.FrontCmdDirection;    // 전후방이 항상 같은 방향으로 명령을 주기 때문에

    //2 Steering 변경
    if(nTmpError==NO_ERR)
    {
        if(pInfoSet->Time.Steer.SteeringChangeCmded.bFlag==true)
        {
			if(OHTUTILITY::PreventOverflowGetTimeMs(pInfoSet->Time.Steer.SteeringChangeCmded.dwTime)>m_pParamSet->Steer.dwCompleteLimitTime)
            {
				switch(SteerCmdDirection)
                {
				case STEER_HW_INFO_CMD_LEFT:
					nTmpError = AutoRecovery_Steer(ERR_STEER_LEFT_EXEC_TIMEOVER, pInfoSet);     //AutoRecovery E764
					ADD_FDC_LOG("ERR/%d/1/9/%06d/%06d/%d/%d/%06d/%d/%d/%d/%d",
								ERR_STEER_LEFT_EXEC_TIMEOVER,
								m_pOHTMainStatus->StatusCommon.CurNodeID,
								m_pExecuteInfo->ExecutePositionInfo.NextNode,
								m_pOHTMainStatus->StatusCommon.CurNodeOffset,
								m_pOHTMainStatus->StatusCommon.ExistFoup,
								m_pOHTMainStatus->StatusCommon.StopStationID,
								bSteerFrontLeft,
								bSteerFrontRight,
								bSteerRearLeft,
								bSteerRearRight);
                    break;
                case STEER_HW_INFO_CMD_RIGHT:
					nTmpError = AutoRecovery_Steer(ERR_STEER_RIGHT_EXEC_TIMEOVER, pInfoSet);     //AutoRecovery E765
					ADD_FDC_LOG("ERR/%d/1/9/%06d/%06d/%d/%d/%06d/%d/%d/%d/%d",
								ERR_STEER_RIGHT_EXEC_TIMEOVER,
								m_pOHTMainStatus->StatusCommon.CurNodeID,
								m_pExecuteInfo->ExecutePositionInfo.NextNode,
								m_pOHTMainStatus->StatusCommon.CurNodeOffset,
								m_pOHTMainStatus->StatusCommon.ExistFoup,
								m_pOHTMainStatus->StatusCommon.StopStationID,
								bSteerFrontLeft,
								bSteerFrontRight,
								bSteerRearLeft,
								bSteerRearRight);
                    break;
				}

				if(nTmpError == NO_ERR)
				{
					ADD_LOG("!Get Steering Data!");
					bSteerFrontLeft = m_pSteer->IsFrontLeftOn();
					bSteerFrontRight = m_pSteer->IsFrontRightOn();
					bSteerRearLeft = m_pSteer->IsRearLeftOn();
					bSteerRearRight = m_pSteer->IsRearRightOn();
				}
				ADD_LOG("After Recvoery---FL:%d FR:%d, RL:%d, RR:%d", bSteerFrontLeft, bSteerFrontRight, bSteerRearLeft, bSteerRearRight);
            }
        }
    }

    //2 무언 정지 에러(Abonormal Error)
    if(nTmpError==NO_ERR)
    {
        if(pInfoSet->Time.Stop.OnAbnormalStop.bFlag==true)
        {
        	//AOHC-288
            if(OHTUTILITY::PreventOverflowGetTimeMs(pInfoSet->Time.Stop.OnAbnormalStop.dwTime)
                >TIMEOVER_OF_DRIVING_ABNORMAL_STOP
            )
            {
                if((bSteerFrontLeft != bSteerRearLeft) || (bSteerFrontRight != bSteerRearRight))
                {
                    // Front와 Rear Steering 방향이 다른 경우
                    nTmpError = ERR_DRV_ABNORMAL_STOP_STEER_CROSS;
                    ADD_LOG("D_18/%d/%d/%d/%d",
                            bSteerFrontLeft, bSteerRearLeft, bSteerFrontRight, bSteerRearRight);
					ADD_FDC_LOG("ERR/%d/1/9/%06d/%06d/%d/%d/%06d/%d/%d/%d/%d",
								ERR_DRV_ABNORMAL_STOP_STEER_CROSS,
								m_pOHTMainStatus->StatusCommon.CurNodeID,
								m_pExecuteInfo->ExecutePositionInfo.NextNode,
								m_pOHTMainStatus->StatusCommon.CurNodeOffset,
								m_pOHTMainStatus->StatusCommon.ExistFoup,
								m_pOHTMainStatus->StatusCommon.StopStationID,
								bSteerFrontLeft, bSteerRearLeft, bSteerFrontRight, bSteerRearRight);
                }
                else
                {
                    // 그 외 무언 정지 상황
					nTmpError   = ERR_DRV_ABNORMAL_STOP;
					ADD_LOG("D_19/%d/%d/%d/%d/%d/%d/%d/%6.1lf/%6.1lf/%6.1lf/%3d/%3d/%6.1lf/%6.1lf",
                            pInfoSet->HwInfo.IO.ObsStatus, pInfoSet->HwInfo.IO.DetectStatus
                            , bSteerFrontLeft, bSteerRearLeft, bSteerFrontRight, bSteerRearRight
                            , (dwCurrTime-pInfoSet->Time.Stop.OnAbnormalStop.dwTime)
                            , pInfoSet->HwInfo.Axis1.dCurrPos
                            , pInfoSet->HwInfo.Node.dPreCheckPosition
                            , pInfoSet->HwInfo.Node.dNodePosition
                            , pInfoSet->HwInfo.Node.nPreCheckCount
                            , pInfoSet->HwInfo.Node.nNodeCount
                            , pInfoSet->HwInfo.TagStaion.dFrontPosition
                            , pInfoSet->HwInfo.TagStaion.dRearPosition);
					ADD_FDC_LOG("ERR/%d/1/12/%06d/%06d/%d/%d/%06d/%d/%d/%d/%d/%d/%d/%d",
								ERR_DRV_ABNORMAL_STOP,
								m_pOHTMainStatus->StatusCommon.CurNodeID,
								m_pExecuteInfo->ExecutePositionInfo.NextNode,
								m_pOHTMainStatus->StatusCommon.CurNodeOffset,
								m_pOHTMainStatus->StatusCommon.ExistFoup,
								m_pOHTMainStatus->StatusCommon.StopStationID,
								pInfoSet->HwInfo.IO.DetectStatus,
								pInfoSet->HwInfo.IO.ObsStatus,
								bSteerFrontLeft, bSteerRearLeft, bSteerFrontRight, bSteerRearRight,
								OHTUTILITY::PreventOverflowGetTimeMs(pInfoSet->Time.Stop.OnAbnormalStop.dwTime));
				}
				if(m_mccparam.bAbnormalStopFlag == true)
				{
					ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,ABNORMAL STOP,End,%s,%06d,%06d,%06d,%d,%3.3lf,Abnormal Stop Time,%d",
								m_defualtparam->VHLName,m_mccparam.cCarrierType,
								m_mccparam.uSourceNode,
								m_mccparam.uTargetNode,
								m_pExecuteInfo->ExecutePositionInfo.CurrNode,
								m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
								dSpeedOfNow,
								OHTUTILITY::PreventOverflowGetTimeMs(pInfoSet->Time.Stop.OnAbnormalStop.dwTime));
					m_mccparam.bAbnormalStopFlag = false;
                }
			}
			if(m_mccparam.bAbnormalStopFlag == false)
			{
				if(OHTUTILITY::PreventOverflowGetTimeMs(pInfoSet->Time.Stop.OnAbnormalStop.dwTime) > 5000)
				{
					ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,ABNORMAL STOP,Start,%s,%06d,%06d,%06d,%d,%3.3lf",
								m_defualtparam->VHLName,m_mccparam.cCarrierType,
								m_mccparam.uSourceNode,
								m_mccparam.uTargetNode,
								m_pExecuteInfo->ExecutePositionInfo.CurrNode,
								m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
								dSpeedOfNow);
					m_mccparam.bAbnormalStopFlag = true;
				}
                }
            }
		else
		{
			if(m_mccparam.bAbnormalStopFlag == true)
			{
				ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,ABNORMAL STOP,End,%s,%06d,%06d,%06d,%d,%3.3lf,Abnormal Stop Time,%d",
							m_defualtparam->VHLName,m_mccparam.cCarrierType,
							m_mccparam.uSourceNode,
							m_mccparam.uTargetNode,
							m_pExecuteInfo->ExecutePositionInfo.CurrNode,
							m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
							dSpeedOfNow,
							OHTUTILITY::PreventOverflowGetTimeMs(pInfoSet->Time.Stop.OnAbnormalStop.dwTime));
            	m_mccparam.bAbnormalStopFlag = false;
			}
		}
    }

	if(nTmpError==NO_ERR)
	{
		if((pInfoSet->HwInfo.Node.nNodeCount <= pInfoSet->HwInfo.Node.nPreCheckCount-2)
		|| (pInfoSet->HwInfo.Node.nNodeCount > pInfoSet->HwInfo.Node.nPreCheckCount))
		{
				ADD_LOG("D_20/%d/%d",
					pInfoSet->HwInfo.Node.nNodeCount,
					pInfoSet->HwInfo.Node.nPreCheckCount);

				nTmpError = ERR_NODE_COUNT_RESET_NOT_AVAILABLE;
				ADD_FDC_LOG("ERR/%d/1/7/%06d/%06d/%d/%d/%06d/%d/%d",
									ERR_NODE_COUNT_RESET_NOT_AVAILABLE,
									m_pOHTMainStatus->StatusCommon.CurNodeID,
									m_pExecuteInfo->ExecutePositionInfo.NextNode,
									m_pOHTMainStatus->StatusCommon.CurNodeOffset,
									m_pOHTMainStatus->StatusCommon.ExistFoup,
									m_pOHTMainStatus->StatusCommon.StopStationID,
									pInfoSet->HwInfo.Node.nPreCheckCount,
									pInfoSet->HwInfo.Node.nNodeCount);
		}

//		else if(((double)(pInfoSet->HwInfo.Node.dPreCheckPosition - pInfoSet->HwInfo.Node.dNodePosition) > 0.0) &&
//				((pInfoSet->HwInfo.Node.dPreCheckPosition - pInfoSet->HwInfo.Node.dNodePosition) < 250.0) &&
//				 (pInfoSet->HwInfo.Node.nNodeCount > 1))
//				 {
//					ADD_LOG("D_21/%f/%f/%d",
//					pInfoSet->HwInfo.Node.dNodePosition,
//					pInfoSet->HwInfo.Node.dPreCheckPosition,
//					pInfoSet->HwInfo.Node.nNodeCount);
//					nTmpError = ERR_CURRNODE_INVALID;
//				 }
	}

    // -------------------------------------------
    // [BEGIN] by zzang9un 2014.02.24 : BCR 로그 추가(BCR ID Read Time 측정용, Debug)
    static AnsiString strPreBCRLog = "";
    AnsiString strBCRLog = "";
	strBCRLog.sprintf("%6d%d%5.1lf, %6d", uNodeBCR, pInfoSet->HwInfo.Node.nNodeCount, pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset, uStationBCR);
	if((strPreBCRLog != strBCRLog) && (uNodeBCR != 0))
	{
		BCR_LOG("/%6d/%d/%5.1lf, %6d", uNodeBCR, pInfoSet->HwInfo.Node.nNodeCount, pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset, uStationBCR);
		strPreBCRLog = strBCRLog;
	}
    // [END] by zzang9un 2014.02.24 : BCR 로그 추가(BCR ID Read Time 측정용, Debug)
    // -------------------------------------------

    return nTmpError;
}

/**
@brief  최적 속도를 산출 하는 함수

    삼각형 프로파일을 UniformSpeedRatio의 비율의 사다리꼴 프로파일로 만들기 위한 속도를 산출하는 함수
@author  ehoto
@date    2012.11.07
@param ListOfCmd: Command 리스트
@param CurrRefDrivingData: 찾기 시작하는 위치
@param UniformSpeedRatio: 현재가 감속 지점 초과 여부 반환하는 함수
@return GetOptimalSpeed 반환
*/
//double DrivingControl::getOptimalSpeed( double Distance, double SpeedIn, double AccelIn, double AccelOut, double SpeedOut, double UniformSpeedRatio)    // 전부 양수 값
//{
//	// 임시 속도 최적화
//#if 1
//	if      (UniformSpeedRatio>1.0) UniformSpeedRatio=1.0;
//	else if (UniformSpeedRatio<0.0) UniformSpeedRatio=0.0;
//	// 속도가 0에서 출발하여 가감속을 하여 정지하였을 때 최대 속도를 등속비율 비율만큼 감소한 속도
//	return MAX(((1.0-UniformSpeedRatio)*sqrt(fabs(2*Distance*((AccelOut*AccelIn)/(AccelOut+AccelIn))))),DRIVING_MIN_SPEED); //0.5 Defaul 속도
//#else
//
//	double dA = 0.0, dB = 0.0, dC = 0.0;
//	double dOptimalSpeed = 0.0;
//
//	if(SpeedOut<0.1)
//	{
//		SpeedOut=0.1;
//	}
//
//	if(Distance<(SpeedIn*SpeedIn/(2*DEFAULT_EMERGENCY_DECEL)))
//	{
//		return SpeedIn;
//	}
//
//	if(UniformSpeedRatio>0.9)
//	{
//		UniformSpeedRatio = 0.9;
//	}
//	else if(UniformSpeedRatio<0.1)
//	{
//		UniformSpeedRatio = 0.1;
//    }
//
//	if(AccelIn>DEFAULT_EMERGENCY_DECEL)
//	{
//		AccelIn = DEFAULT_EMERGENCY_DECEL;
//	}
//    if(AccelOut>DEFAULT_EMERGENCY_DECEL)
//	{
//		AccelOut = DEFAULT_EMERGENCY_DECEL;
//	}
//
//	dA = (UniformSpeedRatio+1)*(1/AccelIn+1/AccelOut) / (2*(1-UniformSpeedRatio));          // 항상 양수
//    dB = (SpeedOut/AccelOut+SpeedIn/AccelIn)*UniformSpeedRatio/(UniformSpeedRatio-1);       // 항상 음수
//	dC = ((SpeedOut*SpeedOut)/AccelOut+(SpeedIn*SpeedIn)/AccelIn+2*Distance)/(-2);                              // 항상 음수
//
//	dOptimalSpeed = (((-1)*dB)+ sqrt(((dB*dB)-(4*dA*dC))))/(2*dA);      // 근의 공식 중 이값만 양수임 --> 선택
//
//	return dOptimalSpeed;
//#endif
//
//}


/**
@brief   현재 위치 정보를 전달하는 함수
@author  임태웅
@date    2013.07.29
*/
EXECUTE_POSITION_INFO DrivingControl::GetPositionInfo()
{

	return m_PositionInfo;

}

/**
@brief   DrivingControl Class GetMapData 함수 : 축척된 MapData를 받아가는 함수
@author  임태웅
@date    2013.04.08
@return 받아오는 MapData의 개수
*/
int DrivingControl::GetMapData(List<EXECUTE_RESPONSE_MAPMAKING_INFO*> *pListOfMapData, volatile MAP_INFO_ON_ADDING_UNION *pMapInfoOnAdding)
{
    int nCount = m_ListOfMapData.getCount();
    int nOverCount = pListOfMapData->getCount()+nCount-100;
    EXECUTE_RESPONSE_MAPMAKING_INFO *pMapMakingInfo;
    EXECUTE_RESPONSE_MAPMAKING_INFO *pMapData;

    MAP_INFO_ON_ADDING_UNION MapInfoOnAdding;

    if(nOverCount>0)
	{
        for(int n=0; n<nOverCount; n++)
        {
            pMapMakingInfo = m_ListOfMapData.popFront();
            if(pMapMakingInfo!=NULL)
            {
                delete pMapMakingInfo;
            }
        }
    }

    if(nCount!=0)
    {
        pMapInfoOnAdding->Info.FlagExecuteThreadUsing = true;


		for(int n=0; n<nCount; n++)
        {
            pMapData = m_ListOfMapData.popFront();
            if(pMapData!=NULL)
            {
                pListOfMapData->insertBack(pMapData);
            }
        }

        MapInfoOnAdding.Info.FlagExecuteThreadUsing = true;
        MapInfoOnAdding.Info.CountOfResult = pListOfMapData->getCount();

		pMapInfoOnAdding->Data = MapInfoOnAdding.Data;

		ADD_LOG("D_22/%d",nCount);

    }
    else
	{
//		ADD_LOG("D-27");
        pMapInfoOnAdding->Info.FlagExecuteThreadUsing = false;
    }

    pMapInfoOnAdding->Info.FlagOnMapMaking = m_bOnMapMake;

    return nCount;
}

/**
@brief   DrivingControl Class Manual_Mark 함수
@author  임태웅
@date    2013.02.27
*/
int DrivingControl::Manual_Mark(MANUAL_MARK_CMD_TYPE pType)
{
    int nReturn = NO_ERR;

    MARK_TYPE MarkType;

    switch(pType)
    {
    case MANUAL_MARK_CMD_DEFAULT:
    case MANUAL_MARK_CMD_NODE:
        MarkType = MARK_TYPE_NODE;
        break;

    case MANUAL_MARK_CMD_STATION_STOP:
        MarkType = MARK_TYPE_TAG_STATION;
        break;

    case MANUAL_MARK_CMD_STATION_QR_LEFT:
        MarkType = MARK_TYPE_QR_STATION_LEFT;
        break;

    case MANUAL_MARK_CMD_STATION_QR_RIGHT:
        MarkType = MARK_TYPE_QR_STATION_RIGHT;
		break;
   //추가
	case MANUAL_MARK_CMD_STATION_STOP_BACK:
		MarkType = MARK_TYPE_TAG_STATION_BACK;
		break;
	}

	if(m_pExecuteInfo->bJogInterlockIgnore == true)
	{
		EnterCriticalSection(&OHTMainForm->m_CS);
		m_pExecuteInfo->bJogInterlockIgnore = false;
		LeaveCriticalSection(&OHTMainForm->m_CS);
	}

    try
    {
		nReturn = manual_Mark(MarkType);
    }
    catch(...)
    {
        ERR_LOG("[Exception] ERR_MARK_FAIL - manual_Mark Type:%d", MarkType);
        nReturn = ERR_MARK_FAIL;
    }

    return nReturn;

}

/**
@brief   MarkFail에 대한 Recovert 동작하는 함수
@author  puting
@date    2017.10.19
*/
bool DrivingControl::MarkFail_Recovery_Driving()
{
	bool breturn =false; //true는 리커버리 수행, false는 리커버리 미수행
	int     nTmpError       = NO_ERR;
	DWORD   dwATTrigerTime  = timeGetTime();

	DRIVING_HW_INFO_SET HwInfo = getHWInfo();

	double  dAccel = 0.0;         ///< 가속도: mm/msec2
	double  dDecel = 0.0;         ///< 감속도: mm/msec2
	double  dSpeed = 0.0;         ///< 속도: mm/msec
	double  dPosition = 0.0;      ///< 거리: mm


	//이적재 Tag가 아니거나, 슬로프이거나, Station Rear가 On일 경우 시도 안함.
	if((m_pDrivingAxis->IsBrakeReleased()==false) ||
	   (m_cSlopeNodeInfo ==SLOPE_NTYPE) ||
	   (m_ClassifiedCmd.TargetInfo.Type != MARK_TYPE_TAG_STATION) ||
	   ((HwInfo.IO.TagStationRearOn == true) && (fabs(m_pDrivingAxis->GetCurrentPosition() - m_dStationMarkInpos) > m_pParamSet->StationMarkInPos)))
			return breturn;


	//정합성 확인 : 특정거리 이상일 경우 에러처리를 위해
	if(fabs(m_pDrivingAxis->GetCurrentPosition() - m_dStationMarkInpos) > 10.0)
		return breturn;

	//1 2. 명령 분류
	dAccel          = 0.0001;
	dDecel          = 0.0001;
	dSpeed          = 0.05;

	//1 3. 주행 명령 인가 시 확인 하는 절차

	breturn = true;
	nTmpError = m_pDrivingAxis->SetAMPEnable(true);
	if(nTmpError == NO_ERR && m_pDrivingAxis->IsSyncControl())
	{
#if((OHT_NAME == OHT_NAME_STD_V80) ||(OHT_NAME == OHT_NAME_STD_V81) || (OHT_NAME == OHT_NAME_STD_V81S)  ||(OHT_NAME == OHT_NAME_STD_V85)|| (OHT_NAME == OHT_NAME_STD_V80_RETICLE))
	  	nTmpError = m_pDrivingAxis->SetSlaveAMPEnable(true);
#endif
	}

	if(nTmpError==NO_ERR)
	{
		while (1)
		{
			 if(OHTUTILITY::PreventOverflowGetTimeMs(dwATTrigerTime) > 3000)
			 {
				nTmpError = -1;
				ERR_LOG("[MarkFail_Recovery_Driving] Fail");
				break;
			 }

			if(m_pDrivingAxis->IsAMPEnable()==true  &&  m_pDrivingAxis->IsSlaveAMPEnable()==true)
				break;

			Sleep(10);
		}
	}

	//1 4 실제 이동하는 부분
	if(nTmpError==NO_ERR)
	{

		if(m_pDrivingAxis->IsAMPEnable()==true  &&  m_pDrivingAxis->IsSlaveAMPEnable()==true)
		{
			nTmpError = m_pDrivingAxis->MoveDistance(dAccel, dDecel, dSpeed, m_dStationMarkInpos);

			ERR_LOG("[MarkFail_Recovery_Driving]MoveDistance %f",m_pDrivingAxis->GetCurrentPosition());
			dwATTrigerTime  = timeGetTime();
		}
		//적당량 필요
		Sleep(500);

		if(nTmpError==NO_ERR)
		{
			while (1)
			{
				 HwInfo = getHWInfo();   //HW 정보 갱신

				 if(OHTUTILITY::PreventOverflowGetTimeMs(dwATTrigerTime) > 3000)
				 {
					nTmpError = -1;
					ERR_LOG("[MarkFail_Recovery_Driving] Fail1");
					break;
				 }

				if(m_pDrivingAxis->IsRunning()==false  &&  m_pDrivingAxis->IsSlaveRunning()==false)
					break;

				Sleep(50);
			}
		}

		HwInfo = getHWInfo();
		//Rear sensor On 유무 확인
		if(HwInfo.IO.TagStationRearOn == true)
		{
			ERR_LOG("[MarkFail_Recovery_Driving] Rear ON");
		}

		Sleep(10);

	}

	if(nTmpError==NO_ERR)
	{
		DWORD dwCurrTime  = timeGetTime();
#if((OHT_NAME == OHT_NAME_STD_V80) ||(OHT_NAME == OHT_NAME_STD_V81) || (OHT_NAME == OHT_NAME_STD_V81S)  ||(OHT_NAME == OHT_NAME_STD_V85)|| (OHT_NAME == OHT_NAME_STD_V80_RETICLE))
		if(m_pDrivingAxis->IsSlaveAMPEnable() ==true)
		{
			nTmpError = m_pDrivingAxis->SetSlaveAMPEnable(false);
		}
#endif

		ERR_LOG("[MarkFail_Recovery_Driving] Complete");

	}

	//1 4. 에러 처리
	if(nTmpError!=NO_ERR)
	{
		breturn = false; //에러발생으로 에러처리
		m_pDrivingAxis->MoveStop(0.001);
		ERR_LOG("[MarkFail_Recovery_Driving] Fail!");
	}

	return breturn;
}

/**
@brief   DrivingControl Class Manual_DRIVING 함수
@author  puting
@date    2017.01.10
*/
int DrivingControl::AutoTaeching_Driving(MANUAL_DRIVING_CMD_INFO Info)
{
//		DRIVING_HW_INFO_SET TmpHwInfo;

		static  DWORD   dwATTrigerTime  = timeGetTime();
//		DWORD       dwCurrTime  = timeGetTime();

		int     nTmpError       = NO_ERR;
		bool    bMoveDistCmd    = false;
		double  dCurrPosition   = m_pDrivingAxis->GetCurrentPosition(); ///< 거리: mm

		double  dAccel = 0.0;         ///< 가속도: mm/msec2
		double  dDecel = 0.0;         ///< 감속도: mm/msec2
		double  dSpeed = 0.0;         ///< 속도: mm/msec
		double  dPosition = 0.0;      ///< 거리: mm

			//조향
//		bool    bSteerFrontLeft = TmpHwInfo.IO.SteerFrontLeftInOn;
//		bool    bSteerFrontRight    = TmpHwInfo.IO.SteerFrontRightInOn;

		getPostionInfoOnManual(getHWInfo(),&m_PositionInfo);

#if((OHT_NAME == OHT_NAME_STD_V82)|| (OHT_NAME == OHT_NAME_STD_V85S)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
#else
		if(m_defualtparam->bUseRSA==true)
		{
		   if(m_pRSAControl->IsSetInnerLimitTorque_300() == false)
				m_pRSAControl->SetInnerLimitTorque_300();

		   if(m_pRSAControl->IsSetInnerLimitTorque_300() == false)
			{
				nTmpError = ERR_SERVO_DRIVING_ALARM;
				ERR_LOG("[AutoTaeching_Driving] RSA Fail SetInnerLimitTorque_800");
			}
			else
			{
			  //	ERR_LOG("[AutoTaeching_Driving] Success SetInnerLimitTorque_800");
			}
		}
		else
		{
			if(m_pServoControl->IsSetInnerLimitTorque_800() ==false)
				m_pServoControl->SetInnerLimitTorque_800();

			if(m_pServoControl->IsSetInnerLimitTorque_800() == false)
			{
				nTmpError = ERR_SERVO_DRIVING_ALARM;
				ERR_LOG("[AutoTaeching_Driving] YASKAWA Fail SetInnerLimitTorque_800");
			}
			else
			{
			 //	ERR_LOG("[AutoTaeching_Driving] Success SetInnerLimitTorque_800");
			}
		}
#endif

		//1 2. 명령 분류
		m_pDrivingAxis->SetBrakeRelease(true);

		setMarkStatusFalse_AutoTeahcing();

		dAccel          = Info.dAccel;
		dDecel          = Info.dDecel;
		dSpeed          = Info.dSpeed;
		dPosition       = dCurrPosition + Info.dDist;

		ERR_LOG("[AutoTaeching_Driving]dPosition:%f + Offset:%f",dCurrPosition,Info.dDist);

		//1 3. 주행 명령 인가 시 확인 하는 절차

		if( dAccel>DRIVING_MAX_ACCEL        )   nTmpError = ERR_DRIVING_ACCEL_MAX_LIMIT;
		if( dAccel<DRIVING_MIN_ACCEL        )   nTmpError = ERR_DRIVING_ACCEL_MIN_LIMIT;
		if( dDecel>DRIVING_MAX_DECEL        )   nTmpError = ERR_DRIVING_DECEL_MAX_LIMIT;
		if( dDecel<DRIVING_MIN_DECEL        )   nTmpError = ERR_DRIVING_DECEL_MIN_LIMIT;
		if( dSpeed>DRIVING_MAX_SPEED_JOG    )   nTmpError = ERR_DRIVING_SPEED_MAX_LIMIT;
		if( dSpeed<0.0                      )   nTmpError = ERR_DRIVING_SPEED_MIN_LIMIT;
		if( dPosition>MAX_DRIVING_DISTANCE  )   nTmpError = ERR_DRIVING_DIST_P_LIMIT;
		if( dPosition<MIN_DRIVING_DISTANCE  )   nTmpError = ERR_DRIVING_DIST_N_LIMIT;

		nTmpError = m_pDrivingAxis->SetAMPEnable(true);
		if(nTmpError == NO_ERR && m_pDrivingAxis->IsSyncControl())
#if((OHT_NAME == OHT_NAME_STD_V80) ||(OHT_NAME == OHT_NAME_STD_V81) || (OHT_NAME == OHT_NAME_STD_V81S)  ||(OHT_NAME == OHT_NAME_STD_V85)|| (OHT_NAME == OHT_NAME_STD_V80_RETICLE))
		 	nTmpError = m_pDrivingAxis->SetSlaveAMPEnable(true);      //E2302대응
#endif
		Sleep(500);
		//
		if(nTmpError==NO_ERR)
		{
			if(m_pDrivingAxis->IsAMPEnable()==true  &&  m_pDrivingAxis->IsSlaveAMPEnable()==true)
			{
				nTmpError = m_pDrivingAxis->MoveDistance(dAccel, dDecel, dSpeed, dPosition);
				ERR_LOG("[AutoTaeching_Driving]MoveDistance %d",nTmpError);
				dwATTrigerTime  = timeGetTime();
			}
			Sleep(1000);
    	}

		if(nTmpError==NO_ERR)
		{
			while (1)
			{

				 if(OHTUTILITY::PreventOverflowGetTimeMs(dwATTrigerTime)  > 7777)
				 {
					nTmpError = ERR_AUTOTEACHING_DRIVING_AB;
					break;
				 }

				if(m_pDrivingAxis->IsRunning()==false  &&  m_pDrivingAxis->IsSlaveRunning()==false)
					break;

				Sleep(50);
			}
		}

		if(nTmpError==NO_ERR)
		{
#if((OHT_NAME == OHT_NAME_STD_V82)|| (OHT_NAME == OHT_NAME_STD_V85S)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
#else
			DWORD dwCurrTime  = timeGetTime();
			//SetInnerLimitTorque_90 자체 800ms Sleep있으므로 2회 Retry 가능하도록 1s로 변경  #Jrespect.im
			if(m_defualtparam->bUseRSA==true)
			{
				while(OHTUTILITY::PreventOverflowGetTimeMs(dwCurrTime)<1000)
				{
					if(m_pRSAControl->IsSetInnerLimitTorque_90() == true)
						break;

					m_pRSAControl->SetInnerLimitTorque_90();

					ADD_LOG("D-28");
					Sleep(5);
				}
				if(m_pRSAControl->IsSetInnerLimitTorque_90() == false)
				{
				   nTmpError = ERR_SERVO_DRIVING_ALARM;
				   ERR_LOG("[AutoTaeching_Driving] RSA Fail SetInnerLimitTorque_90");
				}
				else
				{
					//ERR_LOG("[AutoTaeching_Driving] Success SetInnerLimitTorque_90");
				}
			}
			else
			{
				while(OHTUTILITY::PreventOverflowGetTimeMs(dwCurrTime)<1000)
				{
					if(m_pServoControl->IsSetInnerLimitTorque_90() ==true)
						break;

					m_pServoControl->SetInnerLimitTorque_90();

					ADD_LOG("D-28");
					Sleep(5);
				}

				if(m_pServoControl->IsSetInnerLimitTorque_90() == false)
				{
				   nTmpError = ERR_SERVO_DRIVING_ALARM;
				   ERR_LOG("[AutoTaeching_Driving] YASKAWA Fail SetInnerLimitTorque_90");
				}
				else
				{
					//ERR_LOG("[AutoTaeching_Driving] Success SetInnerLimitTorque_90");
				}
			}
#endif
			ERR_LOG("[AutoTaeching_Driving] Complete");
		}

    //1 4. 에러 처리
    if(nTmpError!=NO_ERR)
    {
        m_pDrivingAxis->MoveStop(0.001);
    }
    return nTmpError;

}

/**
@brief   DrivingControl Class Manual_DRIVING 함수
@author  임태웅
@date    2013.03.03
*/
int DrivingControl::Manual_Driving(MANUAL_DRIVING_CMD_INFO Info)
{
	DRIVING_HW_INFO_SET TmpHwInfo;

	int     nTmpError       = NO_ERR;
    bool    bMoveDistCmd    = false;
    double  dCurrPosition   = m_pDrivingAxis->GetCurrentPosition(); ///< 거리: mm

	double  dAccel = 0.0;         ///< 가속도: mm/msec2
	double  dDecel = 0.0;         ///< 감속도: mm/msec2
	double  dSpeed = 0.0;         ///< 속도: mm/msec
	double  dPosition = 0.0;      ///< 거리: mm

	//조향
	bool    bSteerFrontLeft = TmpHwInfo.IO.SteerFrontLeftInOn;
	bool    bSteerFrontRight    = TmpHwInfo.IO.SteerFrontRightInOn;

	//CID 관련
	static unsigned char CID_Confluence_Area = 0; // 0 : 합류 이외의 구간,  1 : 합류 구간 Stop 과 Reset 사이
	unsigned int CIDResetNode = 0;
	unsigned int CIDStopNode1 = 0;
	unsigned int CIDStopNode2 = 0;
	unsigned int CIDResetNode_arr = INDEX_NONE;
	unsigned int CIDStopNode1_arr = INDEX_NONE;
	unsigned int CIDStopNode2_arr = INDEX_NONE;

    try
    {

        if(Info.bNew==true)
        {
            m_StatusSet.uStep = DRIVING_CTRL_STEP_MANUAL_INIT;
            // 처음 시작이면 위치 정보 초기화
    //      initCommandSet();
			initInfoSet();
            initPreviousArrivalInfo();
			m_PositionInfo.Marked = false;
			m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uStation = 0x00;
			m_PositionInfo.CurrStation=0x00;
#if((OHT_NAME == OHT_NAME_STD_V82)|| (OHT_NAME == OHT_NAME_STD_V85S)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
#else
			// YASKAWA 플래그 처리 필요
			//AOHC-258 SetInnerLimitTorque_800 실패한 경우 Error 처리 Jrespect.im 2019.08.06
			if(m_defualtparam->bUseRSA==true)
			{
				if(m_pRSAControl->IsSetInnerLimitTorque_300() ==false)
					 m_pRSAControl->SetInnerLimitTorque_300();

				if(m_pRSAControl->IsSetInnerLimitTorque_300() ==false)
				{
					nTmpError = ERR_SERVO_DRIVING_ALARM;
					ERR_LOG("[Manual_Driving] RSA Fail SetInnerLimitTorque_800");
				}
				else
				{
					//ERR_LOG("[Manual_Driving] Success SetInnerLimitTorque_800");
				}
			}
			else
			{
				if(m_pServoControl->IsSetInnerLimitTorque_800() ==false) //DrivingControl::Manual_Driving Retry x Error 처리 0
					m_pServoControl->SetInnerLimitTorque_800();

				if(m_pServoControl->IsSetInnerLimitTorque_800() == false)
				{
					nTmpError = ERR_SERVO_DRIVING_ALARM;
					ERR_LOG("[Manual_Driving] YASKAWA Fail SetInnerLimitTorque_800");
				}
				else
				{
					//ERR_LOG("[Manual_Driving] Success SetInnerLimitTorque_800");
				}
			}
#endif
            // Jog 시 근접제어 정보 초기화
            m_Detect.UseFollowControlFlag = false;
			m_pDrivingAxis->SetDetectInfo(m_Detect);
//			ADD_LOG("D-29");
		}
        else
        {
            getPostionInfoOnManual(getHWInfo(),&m_PositionInfo);
        }

		//Get CID info==========================================================================================
		CIDResetNode_arr = OHTMainForm->GetMap()->FindNodeIndexFromCIDReset(m_PositionInfo.CurrNode);
		CIDStopNode1_arr = OHTMainForm->GetMap()->FindNodeIndexFromCIDStop_1(m_PositionInfo.CurrNode);
		CIDStopNode2_arr = OHTMainForm->GetMap()->FindNodeIndexFromCIDStop_2(m_PositionInfo.CurrNode);

		if (CIDResetNode_arr != INDEX_NONE)
		{
		  CIDResetNode = OHTMainForm->GetCID_STD()->m_NodeArray[CIDResetNode_arr].ResetNode;
		  //CIDResetNodeType = OHTMainForm->GetCID_STD()->m_NodeArray[CIDResetNode_arr].ResetNodeType; //필요한가?
		}
		if (CIDStopNode1_arr != INDEX_NONE)
		{
		  CIDStopNode1 = OHTMainForm->GetCID_STD()->m_NodeArray[CIDStopNode1_arr].StopNode1;
		  //CIDResetNode1 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStopNode1_arr].ResetNode;
		}
		if (CIDStopNode2_arr != INDEX_NONE)
		{
		  CIDStopNode2 = OHTMainForm->GetCID_STD()->m_NodeArray[CIDStopNode2_arr].StopNode2;
		  //CIDResetNode2 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStopNode2_arr].ResetNode;
		}
		//==========================================================================================Get CID info

        //1 1. 초기화 및 동작 실행 상태
        if(m_StatusSet.uStep==DRIVING_CTRL_STEP_MANUAL_INIT)
        {
            m_StatusSet.bIsOnProcess    = true;
            m_StatusSet.byStatus        = STS_RUNNING;

            setMarkStatusFalse();   // Mark 해제
            if(pHWSet->m_pCID->ISCidOperatingMode() == false)
			{
				Manual_CID(MANUAL_CID_MODE);
				ADD_LOG("D-30");
			}
			if(pHWSet->m_pCID->ISCidManualMode() == false)
			{
				Manual_CID(MANUAL_CID_ABNORMAL_MODE_ON);
				ADD_LOG("D-31");
			}
			if(pHWSet->m_pCID->IsLinkOK() == false)
			{
				Manual_CID(MANUAL_CID_DIRECTION_CHK);
				ADD_LOG("D_23/%d", m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode);
			}
        }

    //  ADD_LOG("D_24/%d/%d/%9.8lf/%9.8lf/%9.8lf/%8.1lf",
    //      Info.CmdType, Info.bNew, Info.dAccel, Info.dDecel, Info.dSpeed, Info.dDist);

        //1 2. 명령 분류
        switch(Info.CmdType)
        {
		case MANUAL_DRIVING_CMD_STOP:
			if(m_pExecuteInfo->bJogInterlockIgnore == true)
			{
				EnterCriticalSection(&OHTMainForm->m_CS);
				m_pExecuteInfo->bJogInterlockIgnore = false;
				LeaveCriticalSection(&OHTMainForm->m_CS);
			}
            m_pDrivingAxis->MoveStop(Info.dDecel);
            bMoveDistCmd    = true;
			m_StatusSet.uStep           = DRIVING_CTRL_STEP_MANUAL_CHECK_STOP;
            break;
		case MANUAL_DRIVING_CMD_FORWARD:
			if(m_pExecuteInfo->bJogInterlockIgnore == false)
			{
				EnterCriticalSection(&OHTMainForm->m_CS);
				m_pExecuteInfo->bJogInterlockIgnore = true;
				LeaveCriticalSection(&OHTMainForm->m_CS);
			}
			m_pDrivingAxis->SetBrakeRelease(true);
			m_cSlopeNodeInfo = INIT_NTYPE;
            dAccel          = Info.dAccel;
            dDecel          = Info.dDecel;
            dSpeed          = GET_DRIVING_SPEED_IN_LIMIT(Info.dSpeed);
            dPosition       = dCurrPosition + GET_DRIVING_DIST_IN_TIMEOUT(dSpeed);
			bMoveDistCmd    = true;
			if( m_PositionInfo.CurrNode == CIDStopNode1 ||
				m_PositionInfo.CurrNode == CIDStopNode2)
			{
				CID_Confluence_Area = 1;
			}
			else
			{
				CID_Confluence_Area = 0;
			}
			//pHWSet->m_pCID->CID_Manual_Mode_On();
		 //	ADD_LOG("D-32");
	//      m_StatusSet.byStatus        = STS_COMPLETE;
			break;
		case MANUAL_DRIVING_CMD_BACKWARD:
			if(m_pExecuteInfo->bJogInterlockIgnore == false)
			{
				EnterCriticalSection(&OHTMainForm->m_CS);
				m_pExecuteInfo->bJogInterlockIgnore = true;
				LeaveCriticalSection(&OHTMainForm->m_CS);
			}
			m_pDrivingAxis->SetBrakeRelease(true);
			m_cSlopeNodeInfo = INIT_NTYPE;
			dAccel          = Info.dAccel;
			dDecel          = Info.dDecel;
			dSpeed          = GET_DRIVING_SPEED_IN_LIMIT(Info.dSpeed);
			dPosition       = dCurrPosition - GET_DRIVING_DIST_IN_TIMEOUT(dSpeed);
			bMoveDistCmd    = true;
			if( m_PositionInfo.CurrNode == CIDResetNode )
			{
				CID_Confluence_Area = 1;
			}
			else
			{
				CID_Confluence_Area = 0;
			}
			//pHWSet->m_pCID->CID_Manual_Mode_On();
		 //	ADD_LOG("D-33");
	//      m_StatusSet.byStatus        = STS_COMPLETE;
            break;
		case MANUAL_DRIVING_CMD_DIST:
			if(m_pExecuteInfo->bJogInterlockIgnore == true)
			{
				EnterCriticalSection(&OHTMainForm->m_CS);
				m_pExecuteInfo->bJogInterlockIgnore = false;
				LeaveCriticalSection(&OHTMainForm->m_CS);
			}

			m_pDrivingAxis->SetBrakeRelease(true);
            dAccel          = Info.dAccel;
            dDecel          = Info.dDecel;
            dSpeed          = GET_DRIVING_SPEED_IN_LIMIT(Info.dSpeed);
            dPosition       = Info.dDist;
            bMoveDistCmd    = true;
			if( m_PositionInfo.CurrNode == CIDStopNode1 ||
				m_PositionInfo.CurrNode == CIDStopNode2)
			{
				CID_Confluence_Area = 1;
			}
			else
			{
				CID_Confluence_Area = 0;
			}
    //      m_StatusSet.byStatus        = STS_COMPLETE;
            break;
        case MANUAL_DRIVING_CMD_FRONT_AMP_ON:
            break;
        case MANUAL_DRIVING_CMD_FRONT_AMP_OFF:
            break;
        case MANUAL_DRIVING_CMD_REAR_AMP_ON:
            break;
        case MANUAL_DRIVING_CMD_REAR_AMP_OFF:
            break;
        case MANUAL_DRIVING_CMD_BRAKE_RELEASE:
            break;
        case MANUAL_DRIVING_CMD_BRAKE_NO_REALSE:
            break;
        }

        //1 3. 주행 명령 인가 시 확인 하는 절차
        if(bMoveDistCmd==true)
        {
			switch(m_StatusSet.uStep)
            {
            case DRIVING_CTRL_STEP_MANUAL_INIT: // AMP Enable
                if( dAccel>DRIVING_MAX_ACCEL        )   nTmpError = ERR_DRIVING_ACCEL_MAX_LIMIT;
                if( dAccel<DRIVING_MIN_ACCEL        )   nTmpError = ERR_DRIVING_ACCEL_MIN_LIMIT;
                if( dDecel>DRIVING_MAX_DECEL        )   nTmpError = ERR_DRIVING_DECEL_MAX_LIMIT;
				if( dDecel<DRIVING_MIN_DECEL        )   nTmpError = ERR_DRIVING_DECEL_MIN_LIMIT;
				if( dSpeed>DRIVING_MAX_SPEED_JOG    )   nTmpError = ERR_DRIVING_SPEED_MAX_LIMIT;
                if( dSpeed<0.0                      )   nTmpError = ERR_DRIVING_SPEED_MIN_LIMIT;
                if( dPosition>MAX_DRIVING_DISTANCE  )   nTmpError = ERR_DRIVING_DIST_P_LIMIT;
                if( dPosition<MIN_DRIVING_DISTANCE  )   nTmpError = ERR_DRIVING_DIST_N_LIMIT;

                if( nTmpError                           ==NO_ERR    &&
                    m_pDrivingAxis->IsAMPEnable()       ==true      &&
					m_pDrivingAxis->IsSlaveAMPEnable()  ==true          )
                {
                    m_StatusSet.uStep=DRIVING_CTRL_STEP_MANUAL_MOVE_CMD;
                }
                else
                {
                    m_StatusSet.uStep = DRIVING_CTRL_STEP_MANUAL_AMP_ON;
                }
                break;

            case DRIVING_CTRL_STEP_MANUAL_AMP_ON:   // Check AMP Enable
				nTmpError = m_pDrivingAxis->SetAMPEnable(true);

#if((OHT_NAME == OHT_NAME_STD_V80) ||(OHT_NAME == OHT_NAME_STD_V81) || (OHT_NAME == OHT_NAME_STD_V81S)  ||(OHT_NAME == OHT_NAME_STD_V85)|| (OHT_NAME == OHT_NAME_STD_V80_RETICLE))
                if(nTmpError == NO_ERR && m_pDrivingAxis->IsSyncControl())
				{
                    nTmpError = m_pDrivingAxis->SetSlaveAMPEnable(true);
					m_StatusSet.uStep=DRIVING_CTRL_STEP_MANUAL_MOVE_CMD;
				}
#else
				if(nTmpError == NO_ERR)
				{
					m_StatusSet.uStep=DRIVING_CTRL_STEP_MANUAL_MOVE_CMD;
				}
#endif
				break;

            case DRIVING_CTRL_STEP_MANUAL_MOVE_CMD: // Move Cmd
				if(m_pDrivingAxis->IsAMPEnable()==true  &&  m_pDrivingAxis->IsSlaveAMPEnable()==true)
                {
					// Jog 시 근접제어 정보 초기화

#if((OHT_NAME == OHT_NAME_STD_V82)|| (OHT_NAME == OHT_NAME_STD_V85S)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
#else
					//	AOHC-258 SetInnerLimitTorque_800 실패한 경우 Error 처리 Jrespect.im 2019.08.06
					if(m_defualtparam->bUseRSA==true)
					{
						if(m_pRSAControl->IsSetInnerLimitTorque_300() == false)
						   m_pRSAControl->SetInnerLimitTorque_300();

						if(m_pRSAControl->IsSetInnerLimitTorque_300() == false)
						{
							nTmpError = ERR_SERVO_DRIVING_ALARM;
							ERR_LOG("[Manual_Driving] RSA Fail SetInnerLimitTorque_800");
						}
						else
						{
							//ERR_LOG("[Manual_Driving] Success SetInnerLimitTorque_800");
						}
					}
					else
					{
						if(m_pServoControl->IsSetInnerLimitTorque_800() ==false)  //DrivingControl::Manual_Driving retry x Error 처리 0
							m_pServoControl->SetInnerLimitTorque_800();
	//
						if(m_pServoControl->IsSetInnerLimitTorque_800() == false)
						{
							nTmpError = ERR_SERVO_DRIVING_ALARM;
							ERR_LOG("[Manual_Driving] YASKAWA Fail SetInnerLimitTorque_800");
						}
						else
						{
							//ERR_LOG("[Manual_Driving] Success SetInnerLimitTorque_800");
						}
					}
#endif

                    m_Detect.UseFollowControlFlag = false;
					m_pDrivingAxis->SetDetectInfo(m_Detect);
//					ADD_LOG("D-34");

					m_pDrivingAxis->MoveDistance(dAccel, dDecel, dSpeed, dPosition);

					/*
					  매뉴얼 동작시 시나리오
					  shkim. 2016.10.21
					1) CID MODE ON, Abnormal모드 ON 부터 한다 (step : DRIVING_CTRL_STEP_MANUAL_INIT 에 추가 )
					2) 링크가 되어 있지 않으면 조향정보를 보고, 해당 방향의 링크 시도
					3) 링크 성공했는지 보고(IsLinkOK), 성공인 경우
					   - 상대쪽 점유(Interlock)이 들어오지 않는다면 내가 점유한다
					   - 상대쪽이 이미 점유되어 있다면, 나는 점유하지 않는다.
					4) 링크가 끊어졌는데, 나는 점유 시도중인 경우
					   - CID통신구간 밖으로 나갔다고 생각하고, reserve off한다

					5) 링크가 끊어진 경우 재링크 과정을 통해 점유 여부를 재확인 한다.
					6) 조향 변경시 10ms 이상 차이를 주어야 함. 변경 시 Select Off, 점유 off, sleep(20) 후 select on 함..
					*/
					// Step 1. CID Mode Set, Abnormal Mode Set


					IO_INFO_CID();

					if(pHWSet->m_pCID->ISCidOperatingMode() == false)
					{
						Manual_CID(MANUAL_CID_MODE);
						ADD_LOG("D-35");
					}
					if(pHWSet->m_pCID->ISCidManualMode() == false)
					{
						Manual_CID(MANUAL_CID_ABNORMAL_MODE_ON);
						ADD_LOG("D-36");
					}

					// Step 2. Direction Check & Link
					// if(pHWSet->m_pCID->IsLinkOK() == false)
					{
						Manual_CID(MANUAL_CID_DIRECTION_CHK);
						ADD_LOG("D_25/%d", m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode);
					}

					// Step 3. Reserve On : Occupying control
					if(pHWSet->m_pCID->IsLinkOK() == true)
					{
						if(pHWSet->m_pCID->IsLinkOK() == true)	// chettering. 2회 체크해보자.
						{
							if(pHWSet->m_pCID->IsInterlock_ON() == false)
							{
								Manual_CID(MANUAL_CID_RESERVED_ON);
								ADD_LOG("D_26/%d", m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode);
							}
							else
							{
								Manual_CID(MANUAL_CID_RESERVED_OFF);
							}

#if(OHT_NAME == OHT_NAME_STD_V81S)
							// [고속 OHT] KYH Manual 상태에서 Link 완료시 O8 Off
							if(pHWSet->m_pCID->IsImmediateLinkReqON() == true)
							{
								pHWSet->m_pCID->Immediate_Link_Req_OFF();
							}
#endif
						}
					}
#if(OHT_NAME == OHT_NAME_STD_V81S)
					// [고속 OHT] KYH Manual 상태에서 StopNode 지나갈때 O8 요청
					else if(pHWSet->m_pCID->IsLinkOK() == false && pHWSet->m_pCID->IsVHLRegistrationFull() == true
							&& (m_PositionInfo.CurrNode == CIDStopNode1 || m_PositionInfo.CurrNode == CIDStopNode2))
					{
						if(pHWSet->m_pCID->IsImmediateLinkReqON() == false)
						{
							pHWSet->m_pCID->Immediate_Link_Req_ON();
							ADD_LOG("D-37");
						}
					}
#endif
					else
					{
						Manual_CID(MANUAL_CID_RESERVED_OFF);
					}

					// Step 4. common tag control

					// Step 4. Reserve Off
					// Abnormal 상태에서는 통과완료 처리를 하지 않는다 (2016.11.10)
					/*
					if((pHWSet->m_pCID->IsLinkOK() == false) && (pHWSet->m_pCID->IsOccupying()==true))
					{
						Manual_CID(MANUAL_CID_RESERVED_OFF);
					}
					*/


                }
                if(m_pDrivingAxis->IsRunning()==true    ||  m_pDrivingAxis->IsSlaveRunning()==true)
                {
                    m_StatusSet.uStep=DRIVING_CTRL_STEP_MANUAL_CHECK_STOP;
                }
                break;

            case DRIVING_CTRL_STEP_MANUAL_CHECK_STOP:   // Check Stop
                if(m_pDrivingAxis->IsRunning()==false   &&  m_pDrivingAxis->IsSlaveRunning()==false)
                {

					if( m_pDrivingAxis->IsRunning() ==false &&	m_pDrivingAxis->IsSlaveRunning()==false )
					{
#if((OHT_NAME == OHT_NAME_STD_V82)|| (OHT_NAME == OHT_NAME_STD_V85S)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
#else
						DWORD dwCurrTime  = timeGetTime();
						//SetInnerLimitTorque_90 자체 800ms Sleep있으므로 2회 Retry 가능하도록 1s로 변경  #Jrespect.im
						if(m_defualtparam->bUseRSA==true)
						{
							while(OHTUTILITY::PreventOverflowGetTimeMs(dwCurrTime)<1000)      //20191104 KDS
							{
								if(m_pRSAControl->IsSetInnerLimitTorque_90() == true)
									break;

								m_pRSAControl->SetInnerLimitTorque_90();
								Sleep(5);
							}
							if(m_pRSAControl->IsSetInnerLimitTorque_90() == false)
							{
							   nTmpError = ERR_SERVO_DRIVING_ALARM;
							   ERR_LOG("[Manual_Driving] Fail SetInnerLimitTorque_90");
							}
							else
							{
								//ERR_LOG("[Manual_Driving] Success SetInnerLimitTorque_90");
							}
						}
						else
						{
							while(OHTUTILITY::PreventOverflowGetTimeMs(dwCurrTime)<1000)      //20191104 KDS
							{
								if(m_pServoControl->IsSetInnerLimitTorque_90() ==true)
									break;

								m_pServoControl->SetInnerLimitTorque_90(); //DrivingControl::Manual_Driving Retry 존재  Error 처리 0
								Sleep(5);
							}
							if(m_pServoControl->IsSetInnerLimitTorque_90() == false)
							{
							   nTmpError = ERR_SERVO_DRIVING_ALARM;
							   ERR_LOG("[Manual_Driving] Fail SetInnerLimitTorque_90");
							}
							else
							{
								//ERR_LOG("[Manual_Driving] Success SetInnerLimitTorque_90");
							}
						}


#endif
						m_StatusSet.byStatus        = STS_COMPLETE;
                        m_StatusSet.uError          = NO_ERR;
                        m_StatusSet.uStep           = DRIVING_CTRL_STEP_NONE;
                        m_StatusSet.bIsOnProcess    = false;

						ADD_LOG("D-38");

						if(pHWSet->m_pCID->ISCidOperatingMode() == false)
						{
							Manual_CID(MANUAL_CID_MODE);
							ADD_LOG("D-39");
						}
						if(pHWSet->m_pCID->ISCidManualMode() == false)
						{
							Manual_CID(MANUAL_CID_ABNORMAL_MODE_ON);
							ADD_LOG("D-40");
						}
						if(pHWSet->m_pCID->IsLinkOK() == false)
						{
							Manual_CID(MANUAL_CID_DIRECTION_CHK);
							ADD_LOG("D_27/%d", m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode);
						}
						if (pHWSet->m_pCID->ISCidManualMode() == true)
						{
							if(CID_Confluence_Area == 1)
							{// 합류 구간
								Manual_CID(MANUAL_CID_RESERVED_ON);
								ADD_LOG("C-2");
							}
							else
							{
								Manual_CID(MANUAL_CID_RESERVED_OFF);
								ADD_LOG("C-3");
#if(OHT_NAME == OHT_NAME_STD_V81S)
							// [고속 OHT] KYH Manual 상태에서 합류 구간이 아닐때 O8 반납처리
								if(pHWSet->m_pCID->IsImmediateLinkReqON() == true)
								{
									pHWSet->m_pCID->Immediate_Link_Req_OFF();
									ADD_LOG("D-41");

									if(pHWSet->m_pCID->IsLinking_Right() == true)
									{
										pHWSet->m_pCID->CID_Out_PASS_Compt(ON);
										Sleep(20);
										pHWSet->m_pCID->CID_Out_PASS_Compt(OFF);

										pHWSet->m_pCID->CID_Out_Right_Select(OFF);
										pHWSet->m_pCID->CID_Occup_return(8);
										Sleep(20);
										ADD_LOG("C-4");
									}
									else if(pHWSet->m_pCID->IsLinking_Left() == true)
									{
										pHWSet->m_pCID->CID_Out_PASS_Compt(ON);
										Sleep(20);
										pHWSet->m_pCID->CID_Out_PASS_Compt(OFF);

										pHWSet->m_pCID->CID_Out_Left_Select(OFF);
										pHWSet->m_pCID->CID_Occup_return(9);
										Sleep(20);

										ADD_LOG("C-5");
									}
								}
#endif
							}

						}

						/* 현재는 막아둠. 추후 적용 필요 20161017 김태균
						if (pHWSet->m_pCID->ISCidManualMode() == true)
						{
							pHWSet->m_pCID->CID_Manual_Mode_Off();
							ADD_LOG("D-42");
						}
						//Abnormal Mode OFF
						*/

                    }
//                    else
//                    {
//                        m_pDrivingAxis->SetSlaveAMPEnable(false);
//
//                    }


                }
            break;
            }
        }

    }
    catch(...)
    {
        ERR_LOG("[Exception] Manual_Driving Type:%d [%6.1lf:%6.1lf:%6.1lf:%6.1lf] New:%d"
            , Info.CmdType, Info.dAccel, Info.dDecel, Info.dSpeed, Info.dDist, Info.bNew);
        nTmpError = ERR_DRV_ABNORMAL_STOP;
    }

    //1 4. 에러 처리
    if(nTmpError!=NO_ERR)
    {
        m_pDrivingAxis->MoveStop(0.001);

//        if(m_pExecuteInfo->bJogInterlockIgnore == true)
//        {
//            EnterCriticalSection(&OHTMainForm->m_CS);
//            m_pExecuteInfo->bJogInterlockIgnore = false;
//            LeaveCriticalSection(&OHTMainForm->m_CS);
//        }

//        m_pDrivingAxis->SetSlaveAMPEnable(false);

        m_StatusSet.byStatus        = STS_ERROR;
        m_StatusSet.uError          = nTmpError;
        m_StatusSet.uStep           = DRIVING_CTRL_STEP_NONE;//DRIVING_CTRL_STEP_MANUAL_INIT;
        m_StatusSet.bIsOnProcess    = false;
    }
    return nTmpError;

}



int DrivingControl::Manual_IdReader(DRIVING_MANUAL_CMD_MARK_VALUE MarkType
										, DRIVING_MANUAL_CMD_FRONT_ID_READER_VALUE CmdType
										, int* pnResultID, double* pdResultOffset)
{
	return controlIdReader(MarkType, CmdType, pnResultID, pdResultOffset);
}


int DrivingControl::Manual_FrontObservation(DRIVING_MANUAL_CMD_FRONT_OBSERVATION_VALUE Level)
{
	CTRL_INFO_OF_FRONT_DETECT DirectionCmd;
	DirectionCmd.bCmdOn = true;
	DirectionCmd.Info.UseFollowControlFlag = true;
#if(USE_CHANGENODE == 1)
	DirectionCmd.Info.OHTDetectType = (char)Level;
#else
	DirectionCmd.Info.Type = (char)Level;
#endif
	DirectionCmd.Info.NodeCount = 0;
	DirectionCmd.Info.DistSumOfStraightPath = 0;

	return controlFrontObservation(DirectionCmd);
}

//1 --- NEW WAY -----------------------------------

/**
@brief   DrivingControl Reset 함수

    1. 초기화 처리 (대기 상태 서 첫 명령 인가 시)
      1) 변수 초기화
      2) 초기 주행 기준 정보 획득

    2. 받은 명령에 대한 공통 처리
      1) 명령 추가 및 분류

@author  임태웅
@date    2012.07.28.
@return
*/
EXECUTE_ACK DrivingControl::InsertGeneralCmd(void *pDrivingInfo)    //EXECUTE_DRIVING_INFO
{
	//int     nTmpError = NO_ERR;
    EXECUTE_ACK TmpExecuteAck = EXECUTE_ACK_ON_ERR;

    //1 0. 명령의 정합성 확인
	//2 명령 Type Casting
	EXECUTE_DRIVING_INFO *pTmpDrivingInfo=(EXECUTE_DRIVING_INFO *)pDrivingInfo;

	// debug only

   if(m_StatusSet.byStatus == STS_TURN_OFF)  return EXECUTE_ACK_ON_ERR;

   //IO 강제 설정 상태 확인
   if(pHWSet->GetVHLDetectForceIOStatus() ==1)
		m_pDrivingAxis->SetVHLDetectIOSet(false);

try{
	//2 주행 거리가 최대 거리 값보다 큰 명령이 들어올 경우 정지 후 다시 주행 시작

	if(     (m_StatusSet.bIsOnProcess==true)    // 작업 중이고
		&&  (m_ClassifiedCmd.TargetInfo.SQNum!=pTmpDrivingInfo->SQNum) //시퀀스가 나눠지는 위치에서
		&&  (pTmpDrivingInfo->BasicInfo.StartType ==STOP_NTYPE) //정지노드일만 정지해줌.
		&&  (   (m_ClassifiedCmd.TargetInfo.dDistSumToNode + pTmpDrivingInfo->BasicInfo.dLength)
                > m_pParamSet->Axis.Limit.Position.MaxValue )// 거리의 합이 기준 초과 일 경우
    )
	{
		ADD_LOG("D_28/%6.1lf/%6.1lf/%6.1lf/%6.1lf"
        , m_ClassifiedCmd.TargetInfo.dDistSumToNode
        , pTmpDrivingInfo->BasicInfo.dLength
        , (m_ClassifiedCmd.TargetInfo.dDistSumToNode + pTmpDrivingInfo->BasicInfo.dLength)
        , m_pParamSet->Axis.Limit.Position.MaxValue );

        //3 ※ Arived 이지만 잔여 명령이 남아 있을 경우, OCS로 보고시 Going으로 처리 필요
        return EXECUTE_ACK_BUSY;
	}


	if(!(pTmpDrivingInfo->AddInfo.StationType != MARK_TYPE_NODE)
		&& (m_ClassifiedCmd.TargetInfo.NextNode == pTmpDrivingInfo->AddInfo.FinalNode)
		//&& (m_InfoSet.EventAndState.State.SpeedDownPassed)
		&& (m_StatusSet.byStatus == STS_GOING)
		&& (m_StatusSet.bIsOnProcess == true) )
	{
		ADD_LOG("D_29/%d/%06d/%06d/%d",
				pTmpDrivingInfo->AddInfo.StationType,
				m_ClassifiedCmd.TargetInfo.NextNode,
				pTmpDrivingInfo->AddInfo.FinalNode,
				m_StatusSet.byStatus);

		return EXECUTE_ACK_BUSY;
	}

//---------------------------------------------------
    //3 VHL Lifter In/out Check
	if(((pTmpDrivingInfo->BasicInfo.NodeType >= LIFTIN_NTYPE_LEFT) && (pTmpDrivingInfo->BasicInfo.NodeType <= LIFTOUT_NTYPE)))
	{
		m_IsLifterCheck = true;

		if((m_StatusSet.byStatus == STS_GOING) &&(m_StatusSet.bIsOnProcess==true))
		{
			if(pTmpDrivingInfo->BasicInfo.NodeType == LIFTOUT_NTYPE)
			{
				//AOHC-217 VHLLifter 속도 개선
				// by jhoun.lim
				if(m_nElevetorDirection == PASS_DIRECTION_REQUEST_PASS && m_nElevetorRideStep == VHL_ELEVETOR_RIDE_CTRL_STEP_COMPLETE)
				{
					ADD_CID_LOG("[PREPASS_LIFT] - Insert General Cmd : PREPASS COMPLETE! SAME DIRECTION!! Right Go.. ");
				}
				else
				{
					return EXECUTE_ACK_BUSY;
				}

			}
			else
			{
				if(m_iLifterPrePass == VHL_ELEVETOR_PREPASS_STEP_COMPLETE)
				{
					ADD_CID_LOG("[PREPASS_LIFT] - Insert General Cmd : PREPASS COMPLETE! Right Go.. ");
					//m_iLifterPrePass = VHL_ELEVETOR_PREPASS_STEP_NONE;
				}else
				{
					//ADD_CID_LOG("[PREPASS] - Insert General Cmd : I'm busy ");
					return EXECUTE_ACK_BUSY;
				}
			}
		}


	}else
		m_IsLifterCheck = false;
	// MTL
	//if((m_pExecuteInfo->FlagMTLInfo.bTakeoutCycle == true)&&((m_StatusSet.byStatus == STS_GOING)||(m_StatusSet.bIsOnProcess==true)
	//	||(m_nMTLTakeOutPIOStep != MTL_TakeOut_CTRL_STEP_OHT_MTL_Insert_Start)))
	//{
	//	//log
	//	return EXECUTE_ACK_BUSY;
	//}

	if(((pTmpDrivingInfo->BasicInfo.NodeType >= MTL_STOP_LEFT) && (pTmpDrivingInfo->BasicInfo.NodeType <= MTL_STOP_RIGTH)))
	{
		m_IsMTLCheck = true;

		if((m_StatusSet.byStatus == STS_GOING) &&(m_StatusSet.bIsOnProcess==true))
		{
			if(m_iLifterPrePass == VHL_ELEVETOR_PREPASS_STEP_COMPLETE)
			{
				ADD_CID_LOG("[PREPASS_MTL] - Insert General Cmd : PREPASS COMPLETE! Right Go.. ");
				//m_iLifterPrePass = VHL_ELEVETOR_PREPASS_STEP_NONE;
			}else
			{
				static DWORD dwPrevTick3 = 0;
				if(OHTUTILITY::PreventOverflowGetTimeMs(dwPrevTick3) > 3000)           //20191104 KDS
				{
					ADD_CID_LOG("[PREPASS_MTL] - Insert General Cmd : I'm busy ");
					dwPrevTick3 = timeGetTime();
				}

				return EXECUTE_ACK_BUSY;
			}
		}


	}else
		m_IsMTLCheck = false;

	if(((pTmpDrivingInfo->BasicInfo.NodeType >= AUTODOOR_LEFT) && (pTmpDrivingInfo->BasicInfo.NodeType <= AUTODOOR_RIGHT)))
	{
		m_IsAutoDoorCheck = true;

		if((m_StatusSet.byStatus == STS_GOING) &&(m_StatusSet.bIsOnProcess==true))
		{
			if(m_iLifterPrePass == VHL_ELEVETOR_PREPASS_STEP_COMPLETE)
			{
				ADD_CID_LOG("[PREPASS_AUTODOOR] - Insert General Cmd : PREPASS COMPLETE! Right Go.. ");
			   //	m_iLifterPrePass = VHL_ELEVETOR_PREPASS_STEP_NONE;
			}else
			{
				static DWORD dwPrevTick4 = 0;
				if(OHTUTILITY::PreventOverflowGetTimeMs(dwPrevTick4) > 3000)           //20191104 KDS
				{
					ADD_CID_LOG("[PREPASS_AUTODOOR] - Insert General Cmd : I'm busy ");
					dwPrevTick4 = timeGetTime();
                }

				return EXECUTE_ACK_BUSY;
			}
		}


	}else
		m_IsAutoDoorCheck = false;

    //투입관련된 추가 인터락.
	if((m_pExecuteInfo->FlagMTLInfo.bTakeInCycle == true) &&(m_nMTLTakeInPIOStep < MTL_TakeIn_CTRL_STEP_OHT_MTL_TakeIn_Start))
	{
		ADD_CID_LOG("[bTakeInCycle_MTL] - busy ");
     	return EXECUTE_ACK_BUSY;
    }

	//김태균 선임한테 확인 필요......
//		if((pTmpDrivingInfo->BasicInfo.NodeType == MTL_NTYPE)&&((m_StatusSet.byStatus == STS_GOING)||(m_StatusSet.bIsOnProcess==true)
//		||(m_nMTLTakeInPIOStep != MTL_TakeIn_CTRL_STEP_OHT_MTL_TakeIn_Start)))
//	{
//		//log
//		return EXECUTE_ACK_BUSY;
//	}

    //Map Maker시 차이점.
	if((((pTmpDrivingInfo->AddInfo.CmdType == EXECUTE_DRIVING_CMD_MAPMAKE) && ( m_bOnMapMake == false)) ||
		((pTmpDrivingInfo->AddInfo.CmdType != EXECUTE_DRIVING_CMD_MAPMAKE) && ( m_bOnMapMake == true)))
		&&	((m_StatusSet.byStatus == STS_GOING)||(m_StatusSet.bIsOnProcess==true)))
	{
		//log
		return EXECUTE_ACK_BUSY;
	}

    //후진시 현재 주행중이 아니어야됨.
	if((((pTmpDrivingInfo->AddInfo.CmdType == EXECUTE_DRIVING_CMD_GOBACK) && ( m_bOnBackMove == false)) ||
		((pTmpDrivingInfo->AddInfo.CmdType != EXECUTE_DRIVING_CMD_GOBACK) && ( m_bOnBackMove == true)))
		&&	((m_StatusSet.byStatus == STS_GOING)||(m_StatusSet.bIsOnProcess==true)))
	{
		//log
		return EXECUTE_ACK_BUSY;
	}

//---------------------------------------------------
        //2 마크 루틴 경우 완료 후 다시 시작 : 오버런 상태일 수도 있음 / 서보 오프 중일 수 있음
	if(((m_InfoSet.EventAndState.State.MarkArea==true)  ||(m_StatusSet.uStep >= DRIVING_CTRL_STEP_GO_MARK))  &&
		(m_StatusSet.bIsOnProcess==true))
	{

		if(m_StatusSet.uStep==DRIVING_CTRL_STEP_GO_MARK)
		{
			if(((pTmpDrivingInfo->AddInfo.StationType == MARK_TYPE_TAG_STATION) ||
				(pTmpDrivingInfo->AddInfo.StationType == MARK_TYPE_QR_STATION_LEFT) ||
				(pTmpDrivingInfo->AddInfo.StationType == MARK_TYPE_QR_LEFT_TOP) ||
				(pTmpDrivingInfo->AddInfo.StationType == MARK_TYPE_QR_LEFT_BOTTOM) ||
				(pTmpDrivingInfo->AddInfo.StationType == MARK_TYPE_QR_LEFT_BOTTOM_S) ||
				(pTmpDrivingInfo->AddInfo.StationType == MARK_TYPE_QR_STATION_RIGHT) ||
				(pTmpDrivingInfo->AddInfo.StationType == MARK_TYPE_QR_RIGHT_TOP) ||
				(pTmpDrivingInfo->AddInfo.StationType == MARK_TYPE_QR_RIGHT_BOTTOM) ||
				(pTmpDrivingInfo->AddInfo.StationType == MARK_TYPE_QR_RIGHT_BOTTOM_S) ||
				(pTmpDrivingInfo->AddInfo.StationType == MARK_TYPE_QR_PSTB_LEFT) ||
				(pTmpDrivingInfo->AddInfo.StationType == MARK_TYPE_QR_PSTB_RIGHT))
				&&(pTmpDrivingInfo->AddInfo.DistToStation < 100))
			{
				static DWORD dwPrevTick2 = 0;
				if(OHTUTILITY::PreventOverflowGetTimeMs(dwPrevTick2) > 3000)           //20191104 KDS
				{
					ADD_LOG("D-43");
					dwPrevTick2 = timeGetTime();
				}


				return EXECUTE_ACK_BUSY;
			}
			else
			{
				//대차 센서가 Off일 경우에 마크동작 수행 후 다음 동작 처리.
				if((m_InfoSet.EventAndState.MarkState.FollowCtrlOffArea==true) || (m_pOHTDetect->CheckSensorOff() == true) || (pHWSet->GetAMCVHLDetectStatus() ==0) || (m_bIsAMCVHLDetectIgnore == true))
				{

						// 로그 중복 방지 코드
					static DWORD dwPrevTick = 0;
					if(OHTUTILITY::PreventOverflowGetTimeMs(dwPrevTick) > 3000)           //20191104 KDS
					{
						ADD_LOG("D-44");
						dwPrevTick = timeGetTime();
					}

					return EXECUTE_ACK_BUSY;
				}
				else
				{
					m_InfoSet.EventAndState.State.MarkArea=false;
					m_InfoSet.EventAndState.State.DualStageStbArea=false;
					m_StatusSet.uStep = DRIVING_CTRL_STEP_GO_RUN;
					memset(&m_InfoSet.EventAndState.MarkState, 0x00, sizeof(DRIVING_MARK_STATE));
					ADD_LOG("D-45");
					ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,NODE MARK,End,%s,%06d,%06d,%06d,%d,%3.3lf,Mark Type,0,Node Mark Dist,0,Node Sensor Dist,0,Node Mark Start Speed,0,Node Mark First Detect Speed,0,Node Mark Second Detect Speed,0,Driving BCR Read Fail,0,Driving BCR Trigger Count,0,Marking OHT Detect And STOP,0,PreCheck Sensor Haunting Count,0,Stop Sensor Haunting Count,0",
								m_defualtparam->VHLName,m_mccparam.cCarrierType,
								m_mccparam.uSourceNode,
								m_mccparam.uTargetNode,
								m_pExecuteInfo->ExecutePositionInfo.CurrNode,
								m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
								m_InfoSet.HwInfo.Axis1.dSpeed);
					m_mccparam.bMarkStartFlag = false;
					m_mccparam.dMarkStartSpeed = 0.0;
					m_mccparam.dMarkStartDist = 0.0;
					m_mccparam.bBCRReadFail = false;
					m_mccparam.nBCRTriggerCount = 0;
					m_mccparam.nPreCheckSensorHauntingCount = 0;
					m_mccparam.nStopSensorHauntingCount = 0;
                }
			}
		}
		else if(m_StatusSet.uStep==DRIVING_CTRL_STEP_GO_RUN)
		{
			m_InfoSet.EventAndState.State.MarkArea = false;
			m_InfoSet.EventAndState.State.DualStageStbArea=false;
			memset(&m_InfoSet.EventAndState.MarkState, 0x00, sizeof(DRIVING_MARK_STATE));
		}
		else if(m_StatusSet.uStep > DRIVING_CTRL_STEP_GO_MARK)
		{
            ADD_LOG("D-46");
			return EXECUTE_ACK_BUSY;
		}
	}

		// -----------------------------------------------------------------------------
	// Lifter Pre Node Setting    //초기화 위치 개선 필요
   
	if(((pTmpDrivingInfo->BasicInfo.NodeType == LIFTPRE_NTYPE_RIGHT) || (pTmpDrivingInfo->BasicInfo.NodeType == LIFTPRE_NTYPE_LEFT))
	   ||((pTmpDrivingInfo->BasicInfo.NodeType == MTL_SEL_ON_LEFT) || (pTmpDrivingInfo->BasicInfo.NodeType == MTL_SEL_ON_RIGHT)))
	{
		// 리프터 진입전에는 반드시 해야 하는 값 초기화는 여기서 하자
		m_nElevetorRideStep = VHL_ELEVETOR_RIDE_CTRL_STEP_CID_INIT;
		m_iLifterPrePass = VHL_ELEVETOR_PREPASS_STEP_NONE;

		AnsiString strLogTmp;
		strLogTmp.sprintf("[LIFTER PRE] PRE IN NODE, Reset Run. node no : %d  m_nElevetorRideStep =STEP_CID_INIT  m_iLifterPrePass = VHL_ELEVETOR_PREPASS_STEP_NONE",
			pTmpDrivingInfo->BasicInfo.StartNID);
		ADD_CID_LOG(strLogTmp);
	}
	
	// -----------------------------------------------------------------------------
    //명령 처리 가능할 경우
//	ADD_LOG("D-47");
	//1 1. 대기 상태에서 처음 명령이 들어온 경우
	if(m_StatusSet.bIsOnProcess==false)
	{

		if((m_pExecuteInfo->FlagInitPositon.dDrivingInitPosition !=0.0)  ||
			(m_pExecuteInfo->FlagInitPositon.bInitFlag ==true))
			{
				return EXECUTE_ACK_BUSY;
			}

//		m_pExecuteInfo->dCompensatedPosition   = 0.0;

		ADD_LOG("D-48");


		if(setStationOffset(pDrivingInfo)==EXECUTE_ACK_NO_ERR)
        {
            m_StatusSet.bIsOnProcess = false;
            m_StatusSet.byStatus = STS_INIT;
			m_StatusSet.uStep = DRIVING_CTRL_STEP_NONE;
            m_StatusSet.uError = NO_ERR;

			ADD_LOG("D-49");
			delete pTmpDrivingInfo;
			return EXECUTE_ACK_NO_ERR;
        }
        else
        {
            ADD_LOG("D-50");
		}

		//Offset 0인 경우로 주행에서 이적재로 온경우 오버런 처리.
		if((pTmpDrivingInfo->AddInfo.StationType == MARK_TYPE_TAG_STATION) ||
		 (pTmpDrivingInfo->AddInfo.StationType == MARK_TYPE_QR_STATION_LEFT) ||
		 (pTmpDrivingInfo->AddInfo.StationType == MARK_TYPE_QR_LEFT_TOP) ||
		 (pTmpDrivingInfo->AddInfo.StationType == MARK_TYPE_QR_LEFT_BOTTOM) ||
		 (pTmpDrivingInfo->AddInfo.StationType == MARK_TYPE_QR_LEFT_BOTTOM_S) ||
		 (pTmpDrivingInfo->AddInfo.StationType == MARK_TYPE_QR_STATION_RIGHT) ||
		 (pTmpDrivingInfo->AddInfo.StationType == MARK_TYPE_QR_RIGHT_TOP) ||
		 (pTmpDrivingInfo->AddInfo.StationType == MARK_TYPE_QR_RIGHT_BOTTOM) ||
		 (pTmpDrivingInfo->AddInfo.StationType == MARK_TYPE_QR_RIGHT_BOTTOM_S) ||
		 (pTmpDrivingInfo->AddInfo.StationType == MARK_TYPE_QR_PSTB_LEFT) ||
		 (pTmpDrivingInfo->AddInfo.StationType == MARK_TYPE_QR_PSTB_RIGHT))
		 {
				//오버런 처리
				if((m_PositionInfo.Marked ==true)&&
				  (pTmpDrivingInfo->AddInfo.DistToStation < 25))
				{
					ADD_LOG("D_30/%d",pTmpDrivingInfo->BasicInfo.DivInfo);

					m_pExecuteInfo->FlagOverRunInfo.nFinalNode = pTmpDrivingInfo->AddInfo.StationID;
					m_pExecuteInfo->FlagOverRunInfo.bCheck = true;
					m_pExecuteInfo->FlagOverRunInfo.OverrunType = 0x02; //이적재
					m_pExecuteInfo->FlagOverRunInfo.dDrivingInitPosition = 0.0;


					m_pExecuteInfo->nCheckDivInfo =   pTmpDrivingInfo->BasicInfo.DivInfo;


					m_PositionInfo.Marked = false;
					m_PositionInfo.CurrNodeOffset =  0.0;
					m_PositionInfo.NextNode = pTmpDrivingInfo->AddInfo.ProcessingGoInfo.StartNodeID;
					m_PositionInfo.CurrStation = pTmpDrivingInfo->AddInfo.StationID;
					m_PositionInfo.StationType = pTmpDrivingInfo->AddInfo.StationType;
					m_PositionInfo.CurrCommandedStation = pTmpDrivingInfo->AddInfo.StationID;


					m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.bMarked = false;
					m_InfoSet.Position.Mark.PositionStatus.bMarked = false;
					m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.MarkType = pTmpDrivingInfo->AddInfo.StationType;
					m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uStation = pTmpDrivingInfo->AddInfo.StationID;
					m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode = pTmpDrivingInfo->AddInfo.ProcessingGoInfo.OriginStartNodeID;
					m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNextNode = pTmpDrivingInfo->AddInfo.ProcessingGoInfo.StartNodeID;
					m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset =  0.0;


					m_StatusSet.uError =  ERR_BCR_READTIMEOUT;
                    m_StatusSet.byStatus = STS_AUTORECOVERY_OVERRUN;
                    m_StatusSet.bIsOnProcess = false;
					m_StatusSet.uStep = DRIVING_CTRL_STEP_NONE;

					return EXECUTE_ACK_ON_ERR;
				}
		 }

		RESET_LOG;
		ADD_LOG("D_31/%d",pTmpDrivingInfo->PathIndexNum);



        m_bOnBackMove=isBackMove(pDrivingInfo);

		if(m_bOnBackMove == true)
		{
		 //후진 기능에 대한 처리 할것.
			// uNiode 및 RealAriveNode는 현재 위치(MTL 진입 Node로 바꿔줄것)
			m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode       = pTmpDrivingInfo->BasicInfo.EndNID;
			m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uStation    = 0;
			m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNextNode   = 0;
			m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset     = 0;

			m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.MarkType = MARK_TYPE_TAG_STATION_BACK;

			m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.uRealArrivedNode = pTmpDrivingInfo->BasicInfo.EndNID;

			//현재 상태 갱신.
			m_InfoSet.Position.Mark.PositionStatus  = m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus;
          	setPreviousArrivalInfo(m_InfoSet.Position.Mark.PositionStatus);    ///< 이전 정보는 필요없음.
		}
		else
		{
			if(pTmpDrivingInfo->PathIndexNum ==0)
			{
				//2  현재 위치 정리
	//			if(m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.MarkType    != pTmpDrivingInfo->AddInfo.ProcessingGoInfo.)
	//					return EXECUTE_ACK_NOT_AVAILABLE_CMD;

				if(pTmpDrivingInfo->AddInfo.ProcessingGoInfo.IsStationStart == false)
				{

					m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode       = pTmpDrivingInfo->AddInfo.ProcessingGoInfo.OriginStartNodeID;
				  //	m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uStation    = =0;
				  //	m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNextNode   = pTmpDrivingInfo->BasicInfo.EndNID;
				  //	m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset     = pTmpDrivingInfo->AddInfo.DistToStation;

					m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.uRealArrivedNode = pTmpDrivingInfo->AddInfo.ProcessingGoInfo.OriginStartNodeID;


				//				m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.uRealArrivedNode = pTmpDrivingInfo->BasicInfo.StartNID;   ---실제 Mark or
				}
				else
				{
					 //			m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.bMarked          = true;    // 실제 마크된 정보를 이용. ------------------------실제 정보로 바꾸기.

					 m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode       = pTmpDrivingInfo->AddInfo.ProcessingGoInfo.OriginStartNodeID;
					 m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uStation    = pTmpDrivingInfo->AddInfo.StationID;
					 m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNextNode   = pTmpDrivingInfo->AddInfo.ProcessingGoInfo.StartNodeID;
					 m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset     = (double)pTmpDrivingInfo->AddInfo.ProcessingGoInfo.StationData_StartRunDist;

					 m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.uRealArrivedNode = pTmpDrivingInfo->AddInfo.ProcessingGoInfo.OriginStartNodeID;

					 if(m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.MarkType == MARK_TYPE_NODE)
						m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.MarkType = MARK_TYPE_OFFSET;

				}

				ADD_LOG("D_32/%06d/%06d/%06d/%f",m_InfoSet.Position.Mark.PositionStatus.Info.uNode,m_InfoSet.Position.Mark.PositionStatus.Info.uNextNode, m_InfoSet.Position.Mark.PositionStatus.Info.uStation,m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset);
				//2 마크 정보로 정리


	//
				m_InfoSet.Position.Mark.PositionStatus  = m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus;
				//2 마크 정보를 멤버변수로 저장
				setPreviousArrivalInfo(m_InfoSet.Position.Mark.PositionStatus);    ///< 이전 정보는 필요없음.
	//			getPostionInfoOnMarked(m_InfoSet, &m_PositionInfo);       // 중요한 부분 ----------수정 필요 puting

			}
		}



		if(m_PreviousArrivalInfo.Info.uNode==0)
		{
			ERR_LOG("Error[%d] : Start Command without Mark", ERR_CURRNODE_ZERO);
			m_StatusSet.uError = ERR_CURRNODE_ZERO;
			m_StatusSet.byStatus = STS_ERROR;
			m_StatusSet.bIsOnProcess = false;
			ADD_FDC_LOG("ERR/%d/1/5/%06d/%06d/%d/%d/%06d",
						ERR_CURRNODE_ZERO,
						m_pOHTMainStatus->StatusCommon.CurNodeID,
						m_pExecuteInfo->ExecutePositionInfo.NextNode,
						m_pOHTMainStatus->StatusCommon.CurNodeOffset,
						m_pOHTMainStatus->StatusCommon.ExistFoup,
						m_pOHTMainStatus->StatusCommon.StopStationID);
			return EXECUTE_ACK_ON_ERR;
		}



		if((m_defualtparam->PreEQPIO)
		&& (m_pExecuteInfo->FlagMTLInfo.bTakeoutCycle == false)
		&& (m_pExecuteInfo->FlagMTLInfo.bTakeInCycle == false))
		{
			ExeCmdEQPIOClose();
		}


		// 1) 변수 초기화
		initStatusSet();
		initCommandSet();
		initInfoSet();
		// 2) 초기 주행 기준 정보 획득
		setCompensationInfo(m_PreviousArrivalInfo);
		initPreviousArrivalInfo();
        // 3) 보고용 Data : Mark 해제
		m_PositionInfo.Marked = false;
//		m_PositionInfo.CurrStation=0x00;
//		m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uStation = 0x00;
        // 4) MapMake 여부 확인
		m_bOnMapMake=isMapMake(pDrivingInfo);
        if(m_bOnMapMake==true)
		{
    		ADD_LOG("D_33/%d/%d", m_bOnMapMake,m_bMapMakeType);
		}

        // ------------------------------------------------------------------------------
        // 프로세스 진행 중으로 상태 변경.
		m_StatusSet.bIsOnProcess = true;
		m_StatusSet.byStatus = STS_GOING;
		m_pExecuteInfo->bPopListOfCmd = false;
//		DrivingCMDExuteFunc(false);

		if(pTmpDrivingInfo->AddInfo.FinalPortType == GO_FINAL_PORT_TYPE_PassBoxOut)
		{
	        m_StatusSet.uStep = DRIVING_CTRL_STEP_GO_PASSBOX;
			m_nPassBoxPIOStep = PASSBOX_CTRL_STEP_INIT;
		}
//-------------------------------------------------------------------------------------
		else if((pTmpDrivingInfo->BasicInfo.NodeType == LIFTIN_NTYPE_LEFT) ||
				(pTmpDrivingInfo->BasicInfo.NodeType == LIFTIN_NTYPE_RIGHT))
		{
			AnsiString strLogTmp;
			strLogTmp.sprintf("[LIFTER IN NODE FOUND - Node : %d PrePass : %d",
								pTmpDrivingInfo->BasicInfo.StartNID, m_iLifterPrePass);

			ADD_CID_LOG(strLogTmp);


			bReqLifterCounterReset = true;

			switch(m_iLifterPrePass)
			{
				case VHL_ELEVETOR_PREPASS_STEP_NONE:
					ADD_CID_LOG("[PREPASS] - NORMAL RIDE GO");

					m_StatusSet.uStep = DRIVING_CTRL_STEP_ELEVETOR_RIDE;
					m_nElevetorRideStep = VHL_ELEVETOR_RIDE_CTRL_STEP_CID_INIT;
				break;

				case VHL_ELEVETOR_PREPASS_STEP_TOUCH:
					ADD_CID_LOG("[PREPASS] - TOUCH RIDE GO - Current State Continue...");

					m_StatusSet.uStep = DRIVING_CTRL_STEP_ELEVETOR_RIDE;
				break;

				case VHL_ELEVETOR_PREPASS_STEP_COMPLETE:
					m_StatusSet.uStep = DRIVING_CTRL_STEP_GO_INIT;
					ADD_CID_LOG("[PREPASS] - PREPASS COMPLETE! Right Go.. ");
   				break;
            }
		}
		//MTL
		else if((pTmpDrivingInfo->BasicInfo.NodeType == MTL_STOP_LEFT) ||
				(pTmpDrivingInfo->BasicInfo.NodeType == MTL_STOP_RIGTH))
		{
			AnsiString strLogTmp;
			strLogTmp.sprintf("[MTL IN NODE FOUND - Node : %d PrePass : %d",
								pTmpDrivingInfo->BasicInfo.StartNID, m_iLifterPrePass);

			ADD_CID_LOG(strLogTmp);

			switch(m_iLifterPrePass)
			{
				case VHL_ELEVETOR_PREPASS_STEP_NONE:
					ADD_CID_LOG("[PREPASS MTL] - NORMAL RIDE GO");

					m_StatusSet.uStep = DRIVING_CTRL_STEP_ELEVETOR_RIDE;
					m_nElevetorRideStep = VHL_ELEVETOR_RIDE_CTRL_STEP_CID_INIT;
				break;

				case VHL_ELEVETOR_PREPASS_STEP_TOUCH:
					ADD_CID_LOG("[PREPASS MTL] - TOUCH RIDE GO - Current State Continue...");

					m_StatusSet.uStep = DRIVING_CTRL_STEP_ELEVETOR_RIDE;
				break;

				case VHL_ELEVETOR_PREPASS_STEP_COMPLETE:
					m_StatusSet.uStep = DRIVING_CTRL_STEP_GO_INIT;
					ADD_CID_LOG("[PREPASS MTL] - PREPASS COMPLETE! Right Go.. ");
   				break;
            }
		}
		else if((pTmpDrivingInfo->BasicInfo.NodeType == AUTODOOR_LEFT) ||
				(pTmpDrivingInfo->BasicInfo.NodeType == AUTODOOR_RIGHT))
		{
			AnsiString strLogTmp;
			strLogTmp.sprintf("[AUTODOOR IN NODE FOUND - Node : %d PrePass : %d",
								pTmpDrivingInfo->BasicInfo.StartNID, m_iLifterPrePass);

			ADD_CID_LOG(strLogTmp);

			switch(m_iLifterPrePass)
			{
				case VHL_ELEVETOR_PREPASS_STEP_NONE:
					ADD_CID_LOG("[AUTODOOR] - NORMAL RIDE GO");

					m_StatusSet.uStep = DRIVING_CTRL_STEP_ELEVETOR_RIDE;
					m_nElevetorRideStep = VHL_ELEVETOR_RIDE_CTRL_STEP_CID_INIT;
				break;

				case VHL_ELEVETOR_PREPASS_STEP_TOUCH:
					ADD_CID_LOG("[AUTODOOR] - TOUCH RIDE GO - Current State Continue...");

					m_StatusSet.uStep = DRIVING_CTRL_STEP_ELEVETOR_RIDE;
				break;

				case VHL_ELEVETOR_PREPASS_STEP_COMPLETE:
					m_StatusSet.uStep = DRIVING_CTRL_STEP_GO_INIT;
					ADD_CID_LOG("[AUTODOOR] - PASS COMPLETE! Right Go.. ");
				break;
			}
		}
		else if(pTmpDrivingInfo->BasicInfo.NodeType == LIFTOUT_NTYPE)
		{
			m_StatusSet.uStep = DRIVING_CTRL_STEP_ELEVETOR_OFF;
			m_nElevetorOffStep = VHL_ELEVETOR_OFF_CTRL_STEP_INIT;

			if(pTmpDrivingInfo->BasicInfo.DivInfo == PATH_DIVERGENCE_RIGHT)
				m_nElevetorDirection =PASS_DIRECTION_REQUEST_RIGHT;
			else if(pTmpDrivingInfo->BasicInfo.DivInfo == PATH_DIVERGENCE_LEFT)
				m_nElevetorDirection =PASS_DIRECTION_REQUEST_LEFT;

			ADD_LOG("D_34/%d",pTmpDrivingInfo->BasicInfo.Steering);
		}
//-------------------------------------------------------------------------------------
		else
		{

			//VHLLifter 관련 내용 초기화
			m_iLifterPrePass = VHL_ELEVETOR_PREPASS_STEP_NONE;
			m_nElevetorRideStep = VHL_ELEVETOR_RIDE_CTRL_STEP_CID_INIT;
			m_nElevetorOffStep = VHL_ELEVETOR_OFF_CTRL_STEP_INIT;
			//초기화
			m_StatusSet.uStep = DRIVING_CTRL_STEP_GO_INIT;
		}

		m_StatusSet.uError = NO_ERR;

        // 이전 명령이 Station 인 경우, 다음 명령이 Next Node 로의 명령이 아닌 경우
//		checkStartCmd(pTmpDrivingInfo);

		if(m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.MarkType==MARK_TYPE_NODE)
		{

				//주행인 경우 바로 들어감.
				TmpExecuteAck=  makeCmdInfoLists(pDrivingInfo);

		}
		/// 후진기능 관련 기능 적용 할 것.
		else if(m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.MarkType==MARK_TYPE_TAG_STATION_BACK)
		{

             	TmpExecuteAck = makeCmdInfoListsBack(pDrivingInfo);

        }
		else    // Station Marked
		{
			if(pTmpDrivingInfo->BasicInfo.EndNID==m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNextNode)
			{
				return EXECUTE_ACK_NOT_AVAILABLE_CMD;
			}
			else if(pTmpDrivingInfo->BasicInfo.StartNID==m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNextNode)
			{
			   // TmpDrivingInfo = m_LastDrivingCmdInfo;
			   //	memset(&(TmpDrivingInfo.AddInfo), 0x00, sizeof(EXECUTE_DRIVING_ADD_INFO));
				TmpExecuteAck=  makeCmdInfoLists(pDrivingInfo);

				ADD_LOG("D_35/%d", TmpExecuteAck);
			}
			else
			{
				// 추후 에러 처리

			}
		}

		if(m_pOHTMainStatus->StatusCommon.StopStationID != 0)
		{
			m_mccparam.uSourceNode = m_pOHTMainStatus->StatusCommon.StopStationID;
		}
		else
		{
			m_mccparam.uSourceNode = m_pOHTMainStatus->StatusCommon.CurNodeID;
		}
	}
	else
	{
     //1 2. 명령이 추가된 경우
	//  ADD_LOG("D_36/%d/%d", 3, TmpExecuteAck);
	//2 Target Node의 정보를 반영하여 응답한다.

//		DrivingCMDExuteFunc(false);   //동기화 부분
		ADD_LOG("InsertGeneralCmd 4703");
		if(m_bOnBackMove == false)
			TmpExecuteAck = makeCmdInfoLists(pDrivingInfo);
		else
			TmpExecuteAck = makeCmdInfoListsBack(pDrivingInfo);

		 m_pExecuteInfo->bPopListOfCmd = false;
    }
//  ADD_LOG("D_37/%d/%d", 4, TmpExecuteAck);
	if(TmpExecuteAck==EXECUTE_ACK_NO_ERR)
	{
		delete pTmpDrivingInfo;
	}
}catch(...)
 	ADD_LOG("D-51");
    //2 잘 받았다고 응답한다
    return TmpExecuteAck;
}


/**
@brief   주행 시 반복 호출되는 함수
@author  임태웅
@date    2013.08.09
@return
*/
UINT DrivingControl::ExecuteJob()
{
	static bool nPreError                   = NO_ERR;
    int             nTmpError                   = NO_ERR;

    DRIVING_HW_INFO_SET HwInfo = getHWInfo();

	static DWORD dwLastTimeOfMapMakerTriggerOn = timeGetTime();
	static DWORD dwLastTimeOfMapMakerTriggerOnQR = timeGetTime();
    // ================================================================================
    //1 0. 이상 혹은 완료 처리
	if((m_StatusSet.uError != NO_ERR) && nPreError==NO_ERR) //@ 불필요한 호출 응답
	{
		if(AutoRecovery_Driving(m_StatusSet.uError) !=NO_ERR)
		{
         	m_StatusSet.byStatus = STS_ERROR;
			stop();
		}

		return m_StatusSet.uError;
    }
    else if(m_StatusSet.uError==NO_ERR)
    {
        nPreError=NO_ERR;
    }


	if(m_StatusSet.byStatus ==  STS_GOING)
	{
		if(m_pExecuteInfo->FlagCmdExcute.bCmdDrivingCMDExcute == true)
			DrivingCMDExuteFunc(false);
    }
    // ================================================================================
    //1 1. 상태 확인 및 명령 생성
    if(nTmpError==NO_ERR)
    {

	try{
        switch(m_StatusSet.uStep)
        {
        case DRIVING_CTRL_STEP_GO_PASSBOX :
			if(nTmpError==NO_ERR)nTmpError = executeOpenPassBox(HwInfo, &m_InfoSet, &(m_StatusSet.uStep));
			break;

		case DRIVING_CTRL_STEP_ELEVETOR_RIDE:
			if(nTmpError==NO_ERR)nTmpError = executeRideEvevetor(HwInfo, &m_InfoSet, &(m_StatusSet.uStep));
			break;

		case DRIVING_CTRL_STEP_ELEVETOR_OFF:
			if(nTmpError==NO_ERR)nTmpError = executeOffEvevetor(HwInfo, &m_InfoSet, &(m_StatusSet.uStep));
			break;

        case DRIVING_CTRL_STEP_GO_INIT:
            if(nTmpError==NO_ERR)nTmpError = executeGoInit(HwInfo, &m_InfoSet, &(m_StatusSet.uStep));
            break;

        case DRIVING_CTRL_STEP_GO_PREPARE:
            if(nTmpError==NO_ERR)nTmpError = executeGoPrepare(HwInfo, &m_InfoSet, &(m_StatusSet.uStep));
            break;

        case DRIVING_CTRL_STEP_GO_FIRST_NODE:
			if(nTmpError==NO_ERR)nTmpError = executeGoFirstNode(HwInfo, &m_InfoSet, &(m_StatusSet.uStep));
            break;

		case DRIVING_CTRL_STEP_GO_RUN:
			if(nTmpError==NO_ERR)nTmpError = checkError(&m_InfoSet);
			if(nTmpError==NO_ERR)nTmpError = executeGoRun(HwInfo, &m_InfoSet, &(m_StatusSet.uStep));
            break;

        case DRIVING_CTRL_STEP_GO_MARK:
            if(nTmpError==NO_ERR)nTmpError = checkError(&m_InfoSet);
            if(nTmpError==NO_ERR)nTmpError = executeGoMark(HwInfo, &m_InfoSet, &(m_StatusSet.uStep));
            break;

		case DRIVING_CTRL_STEP_GO_CHECK_STOP:
            if(nTmpError==NO_ERR)nTmpError = checkError(&m_InfoSet);
            if(nTmpError==NO_ERR)nTmpError = executeGoCheckStop(HwInfo, &m_InfoSet, &(m_StatusSet.uStep));
            break;

		case DRIVING_CTRL_STEP_GO_COMPLETE:
            if(nTmpError==NO_ERR)nTmpError = checkError(&m_InfoSet);
            if(nTmpError==NO_ERR)
			{


				//m_bIsRecovery = false;
                ////////
				DRIVING_HW_INFO_SET TempHwInfo = getHWInfo();
				//처음으로 온 위치일 경우만 리커버리 및 오보런 처리함.

				if(m_nMarkFailRetryCheckID != m_PositionInfo.CurrStation)  //동일 위치가 아닐경우만 시도함.
				{
					////AOHC-374
					if((m_ClassifiedCmd.TargetInfo.Type == MARK_TYPE_TAG_STATION) && (m_pExecuteInfo->nFinishOfStation == m_PositionInfo.CurrStation))
					{
						//1) 리커버리 동작 )

						DRIVING_HW_INFO_SET TempHwInfo = getHWInfo();

						if(((TempHwInfo.IO.TagStationRearOn == OFF)&& (fabs(m_pDrivingAxis->GetCurrentPosition() - m_dStationMarkInpos) > m_pParamSet->StationMarkInPos)) ||  //&&거리값 제한 추가로 둘지 고민할것.
						   (TempHwInfo.IO.TagStationFrontOn == OFF))
						{
//							m_bIsRecovery = MarkFail_Recovery_Driving();     //마지막 정지한 위치로 재이동.
							//오버런 처리.  Mark 상태 false로 만들것.
							ADD_LOG("D_38/%d/%d", m_nMarkFailRetryCheckID,m_PositionInfo.CurrStation);
							m_pExecuteInfo->FlagOverRunInfo.bCheck = true;
							m_pExecuteInfo->FlagOverRunInfo.OverrunType = 0x02; //이적재
							m_pExecuteInfo->FlagOverRunInfo.nFinalNode = m_PositionInfo.CurrStation;    //주행은 주행, 이적재는 이적재
							m_pExecuteInfo->FlagOverRunInfo.dDrivingInitPosition =0.0;
							nTmpError   = ERR_BCR_READTIMEOUT;
							m_DiagManager->IncreasePreviosDiagCount(PREVIOS_DIAG_TBT);
							ADD_MD_LOG("TBT Cur Station 1 : %d",m_PositionInfo.CurrStation);
							m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.bMarked = false;
							m_InfoSet.Position.Mark.PositionStatus.bMarked = false;
						}

						m_nMarkFailRetryCheckID = m_PositionInfo.CurrStation;
					}
//						ERR_LOG("[Sample]AOHC-374_1, %d/%d", m_PositionInfo.CurrStation,m_pExecuteInfo->nFinishOfStation);

				}
				//soming E248 오버런 이후 리커버리 동작 추가
				else
				{
					//AOHC-374
					if(m_ClassifiedCmd.TargetInfo.Type == MARK_TYPE_TAG_STATION)
					{
						DRIVING_HW_INFO_SET TempHwInfo = getHWInfo();

						if(((TempHwInfo.IO.TagStationRearOn == OFF)&& (fabs(m_pDrivingAxis->GetCurrentPosition() - m_dStationMarkInpos) > m_pParamSet->StationMarkInPos)) ||  //&&거리값 제한 추가로 둘지 고민할것.
							(TempHwInfo.IO.TagStationFrontOn == OFF))
							m_bIsRecovery = MarkFail_Recovery_Driving();
					}

				}
			}


			if(nTmpError==NO_ERR)
			{
				// Puting  만약에 통과허가 구간에서 정지할도 Going으로 표시해야될경우 해당구간에서 Target와 비교할것.
				EnterCriticalSection(&OHTMainForm->m_CS);

				m_pExecuteInfo->FlagInitPositon.bInitFlag = true;
				m_pExecuteInfo->FlagRunningPositon =false;
				LeaveCriticalSection(&OHTMainForm->m_CS);

				m_StatusSet.byStatus=STS_ARRIVED;
				m_StatusSet.bIsOnProcess=false;

				if(m_defualtparam->PreShutter)
				{
					m_bShutterCloseFlag = false;
					m_bShutterOpenFlag = false;

					pHWSet->m_pShutter->IO_Init();
				}

				nTmpError = executeGoComplete(HwInfo, &m_InfoSet, &(m_StatusSet.uStep));
			}

			m_bFDCMarkFailFlag = true;
			bOverrunReverse = false;

			break;
		}
		}catch(...)
          ADD_LOG("D-52");
	}


	//1 2. MapMake
    if(m_bOnMapMake==true)
	{
		if(OHTUTILITY::PreventOverflowGetTimeMs(dwLastTimeOfMapMakerTriggerOn) > 100)
		{
			m_InfoSet.Control.IdReader[0] = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;  // Stop Tag

			if(m_bMapMakeType.MapMake_StopTag ==ON)
				m_InfoSet.Control.IdReader[1] = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;  // Stop Tag

		   dwLastTimeOfMapMakerTriggerOn = timeGetTime();
		}
#if(OHT_NAME != OHT_NAME_P4_MASK)
		//QR Data 동기화 처리.
		if(m_bMapMakeType.MapMake_QR_Left_Tag ==ON)
		{
			if(m_pLeftQRR->IsQRDataSync()==false)
				m_pLeftQRR->SetQRDataSync(true);

			if( m_pLeftQRR->GetQRDataSync() == 0)
				m_InfoSet.Control.IdReader[2] = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;  // QR Left
			else if(m_pLeftQRR->GetQRDataSync() > 2)
				nTmpError = ERR_QRR_READ;
		}

		if(m_bMapMakeType.MapMake_QR_Right_Tag ==ON)
		{
			if(m_pRightQRR->IsQRDataSync()==false)
				m_pRightQRR->SetQRDataSync(true);

			if( m_pRightQRR->GetQRDataSync() == 0)
				m_InfoSet.Control.IdReader[3] = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON; // QR Right
			else if(m_pRightQRR->GetQRDataSync() > 2)
				nTmpError = ERR_QRR_READ;
		}
#endif
		// m_ListOfTmpStationData -> mapmkaer 진행중냉요이 담긴 임시  버퍼 puting
		// m_ListOfMapData -> Map Maker 관련된 내용이 담긴 버퍼            puting
		measureDist(m_InfoSet, &m_ListOfTmpStationData, &m_ListOfMapData);
	}
	else
	{
    	if(m_pLeftQRR->IsQRDataSync()==true)
			m_pLeftQRR->SetQRDataSync(false);

		if(m_pRightQRR->IsQRDataSync()==true)
			m_pRightQRR->SetQRDataSync(false);
	}


    //1 3. 명령 실행
    if(nTmpError==NO_ERR)
	{

#if 0
        if( (m_InfoSet.EventAndState.Event.StopWithNoReason==true)
        &&  (m_InfoSet.Control.Axis.byType==AXIS_CTRL_CMD_NONE)
        &&  (m_InfoSet.EventAndState.MarkState.Arrived==false)
        )
        {
            m_InfoSet.Control.Axis.byType = AXIS_CTRL_CMD_MOVE_DS;
//          m_InfoSet.Control.Axis.Dynamic.dAccel = 0;
//          m_InfoSet.Control.Axis.Dynamic.dDecel = 0;
//          m_InfoSet.Control.Axis.Dynamic.dSpeed = 0;
//          m_InfoSet.Control.Axis.Dynamic.dDist = 0;
//          m_InfoSet.Control.Axis.Dynamic.AdditionalInfo = 0;
        }
#endif

		nTmpError = controlAll(m_InfoSet.Control);
        clearDrivingCtrlInfoSet();
    }

    //1 5. 에러 처리 및 정지
	if(m_StatusSet.uError==NO_ERR && nTmpError!=NO_ERR)
	{
		if(AutoRecovery_Driving(nTmpError) !=NO_ERR)
		{
			m_StatusSet.byStatus = STS_ERROR;
			m_StatusSet.uError = nTmpError;
			m_StatusSet.bIsOnProcess=false;
			m_StatusSet.uStep = DRIVING_CTRL_STEP_NONE;

			stop();
		}


	}
		EnterCriticalSection(&OHTMainForm->m_CS);
		m_pExecuteInfo->ExecuteDrivingStep =  m_StatusSet.uStep;
		LeaveCriticalSection(&OHTMainForm->m_CS);

    // 잔여 명령 리스트 삭제
//  clearCmdInfoListsLessThan(m_InfoSet.HwInfo.Node.nNodeCount);

    return nTmpError;
}


/**
@brief   DrivingControl Class Manual_DRIVING 함수
@author  임태웅
@date    2013.07.01
*/
int DrivingControl::ExecuteManual(DRIVING_MANUAL_CMD_INFO Info)
{
	 return 0;
}

/**
@brief	목표 Tag 도달 여부 확인
@return	목표 Tag 도달한 경우 true, 아니면 false 반환
*/
bool DrivingControl::HasArrivedAtTargetTag()
{
	// InsertGeneralCmd 에서 m_ClassifiedCmd.TargetInfo 로 갱신하기에, 해당 값으로 비교
	// - m_pExecuteInfo->nFinishOfNode 는 MakeCycleList 할 때 갱신함
	// - E3011 (AMOHTV80F-1249) 발생 당시, IGC - Cycle Init (CheckTaskSatus 확인 후 실행) - MakeCycleList 순으로 실행되었음

	// Mark 상태 확인
	if (m_pExecuteInfo->ExecutePositionInfo.Marked == false)
		return false;

	// Node, Station 목표 Tag ID 확인
	bool bNodeArrival = m_pExecuteInfo->ExecutePositionInfo.CurrNode == m_ClassifiedCmd.TargetInfo.Node;
	bool bStationArrival = (
		(m_ClassifiedCmd.TargetInfo.Station != 0) &&
		(m_pExecuteInfo->ExecutePositionInfo.CurrStation == m_ClassifiedCmd.TargetInfo.Station)
	);

	if (bNodeArrival || bStationArrival)
		return true;

	return false;
}

/**
@brief	목표 Tag 존재 여부 확인
@return	목표 Tag 있는 경우 true, 아니면 false 반환
*/
bool DrivingControl::HasTargetTag()
{
	return (
		m_ClassifiedCmd.TargetInfo.Node != 0 ||
		m_ClassifiedCmd.TargetInfo.Station != 0
	);
}

bool DrivingControl::loadParameter(char* szFilePath, DRIVING_PARAM_SET* pParamSet)
{
    bool bRetrun = false;
    int nTmpValue = 0;
    //int nResult = 0;
	double dTmpValue = 0.0;
	bool bTmpValue = false;
	//double dResult = 0.0;
	char szSection[1024];
	memset(szSection, 0, sizeof(szSection));
	char strTempValue[8]= {0,};

    LIniFile *pIniFile;
    pIniFile = NULL;
    pIniFile = new LIniFile(szFilePath);

    if(!pIniFile->GetIniFileExist())
    {
        delete pIniFile;
        pIniFile = NULL;
	}
	//AOHC-358 파라미터 적용 오류 시, 에러 발생
	if(pIniFile == NULL || bCheckDrivParam == true)
	{
		//2 (1)DRIVING_AXIS_PARAM
		strcpy(pParamSet->Version, "00");

		pParamSet->Axis.Limit.Accel.MinValue = 0.0005;
		pParamSet->Axis.Limit.Accel.MaxValue = 0.0035;
		pParamSet->Axis.Limit.Decel.MinValue = 0.0005;
		pParamSet->Axis.Limit.Decel.MaxValue = 0.0035;
		pParamSet->Axis.Limit.Speed.MinValue = 0.05;
		pParamSet->Axis.Limit.Speed.MaxValue = 5.0;
		pParamSet->Axis.Limit.dAbnormalMoveSpeedMargin = 0.3;
		pParamSet->Axis.Limit.Position.MinValue = -5000;
		pParamSet->Axis.Limit.Position.MaxValue = 1200000;
		pParamSet->Axis.Limit.JogPosition.MinValue = -1000;
		pParamSet->Axis.Limit.JogPosition.MaxValue = 1000;
		pParamSet->Axis.Default.dDefaultAccel = 0.003;
		pParamSet->Axis.Default.dDefaultDecel = 0.003;
        pParamSet->Axis.Default.dEmergencyDecel = 0.0035;

        //2 (2)DRIVING_MARK_PARAM
		pParamSet->Mark[0].Type = 0;
		pParamSet->Mark[0].Dist.dMarginToTarget = 100;
		pParamSet->Mark[0].Dist.dDistFromFirstToSecond = 290;
		pParamSet->Mark[0].Dist.dLengthOfSecond = 20;
		pParamSet->Mark[0].Dist.dAddDistAfetrFirstMet = 260;
		pParamSet->Mark[0].Dist.dAddDistAfterSecondMet = 13;
		pParamSet->Mark[0].Dist.dForwardMoveDistLimit = 300;
		pParamSet->Mark[0].Dist.dBackMoveDistLimit = 80;
		pParamSet->Mark[0].Dist.dMarkInPosLimit = 4;
		pParamSet->Mark[0].Dist.dMinLengthToNext = 400;
		pParamSet->Mark[0].Dist.dIgnoreTagDist = 100;
		pParamSet->Mark[0].Speed.dOfFirstMet = 0.2;
		pParamSet->Mark[0].Speed.dOfSecondMet= 0.10;
		pParamSet->Mark[0].Accel.dOfFirstMet = 0.0015;
		pParamSet->Mark[0].Accel.dOfSecondMet = 0.0005;

        pParamSet->Mark[1].Type = 1;
		pParamSet->Mark[1].Dist.dMarginToTarget = 100;
		pParamSet->Mark[1].Dist.dDistFromFirstToSecond = 160;
        pParamSet->Mark[1].Dist.dLengthOfSecond = 5;
        pParamSet->Mark[1].Dist.dAddDistAfetrFirstMet = 125;
        pParamSet->Mark[1].Dist.dAddDistAfterSecondMet = 2.5;
		pParamSet->Mark[1].Dist.dForwardMoveDistLimit = 300;
		pParamSet->Mark[1].Dist.dBackMoveDistLimit = 80;
		pParamSet->Mark[1].Dist.dMarkInPosLimit = 1;//50;
		pParamSet->Mark[1].Dist.dMinLengthToNext = 400;
		pParamSet->Mark[1].Dist.dIgnoreTagDist = 180;
		pParamSet->Mark[1].Speed.dOfFirstMet = 0.17;//dSpeedInFirstMet = 0.50;
        pParamSet->Mark[1].Speed.dOfSecondMet = 0.05;//dSpeedInSecondMet = 0.05;
        pParamSet->Mark[1].Accel.dOfFirstMet = 0.0015;//dAccelInFirstMet = 0.0010;
        pParamSet->Mark[1].Accel.dOfSecondMet = 0.0005;//dAccelInSecondMet = 0.0005;

		pParamSet->Mark[2].Type = 2;
		pParamSet->Mark[2].MakerType = MAKER_TYPE_KEYENCE;
        pParamSet->Mark[2].Dist.dMarginToTarget = 100;
        pParamSet->Mark[2].Dist.dDistFromFirstToSecond = 70;
        pParamSet->Mark[2].Dist.dLengthOfSecond = 0;
		pParamSet->Mark[2].Dist.dAddDistAfetrFirstMet = 5;
        pParamSet->Mark[2].Dist.dAddDistAfterSecondMet = 0;
        pParamSet->Mark[2].Dist.dForwardMoveDistLimit = 300;
		pParamSet->Mark[2].Dist.dBackMoveDistLimit = 80;
		pParamSet->Mark[2].Dist.dMarkInPosLimit = 1;//50;
		pParamSet->Mark[2].Dist.dMinLengthToNext = 450;
		pParamSet->Mark[2].Dist.dIgnoreTagDist = 0;
		pParamSet->Mark[2].Speed.dOfFirstMet = 0.12;//0.05;//dSpeedInFirstMet = 0.05;
		pParamSet->Mark[2].Speed.dOfSecondMet = 0.05;//0.05;//dSpeedInSecondMet = 0.05;
		pParamSet->Mark[2].Accel.dOfFirstMet = 0.0005;//dAccelInFirstMet = 0.0010;
		pParamSet->Mark[2].Accel.dOfSecondMet = 0.0005;//dAccelInSecondMet = 0.0005;

		pParamSet->Mark[3].Type = 3;
		pParamSet->Mark[3].MakerType = MAKER_TYPE_KEYENCE;
		pParamSet->Mark[3].Dist.dMarginToTarget = 100;
		pParamSet->Mark[3].Dist.dDistFromFirstToSecond = 70;
		pParamSet->Mark[3].Dist.dLengthOfSecond = 0;
		pParamSet->Mark[3].Dist.dAddDistAfetrFirstMet = 5;
		pParamSet->Mark[3].Dist.dAddDistAfterSecondMet = 0;
		pParamSet->Mark[3].Dist.dForwardMoveDistLimit = 300;
		pParamSet->Mark[3].Dist.dBackMoveDistLimit = 80;
		pParamSet->Mark[3].Dist.dMarkInPosLimit = 1;//50;
		pParamSet->Mark[3].Dist.dMinLengthToNext = 450;
		pParamSet->Mark[3].Dist.dIgnoreTagDist = 0;
		pParamSet->Mark[3].Speed.dOfFirstMet = 0.12;//0.05;//dSpeedInFirstMet = 0.05;
		pParamSet->Mark[3].Speed.dOfSecondMet = 0.05;//0.05;//dSpeedInSecondMet = 0.05;
		pParamSet->Mark[3].Accel.dOfFirstMet = 0.0005;//dAccelInFirstMet = 0.0010;
		pParamSet->Mark[3].Accel.dOfSecondMet = 0.0005;//dAccelInSecondMet = 0.0005;

		//2 (3)DRIVING_STEER_PARAM
		pParamSet->Steer.dwChangeTime = 500;
		pParamSet->Steer.dwMovingTorqueTime = 50;
		pParamSet->Steer.dwCompleteCheckTime = 100;
		pParamSet->Steer.dwCompleteLimitTime = 10000;

		//2 (4)DRIVING_LINK_PARAM
		pParamSet->Link.dOutNodeAreaMargin = 500;
		pParamSet->Link.dNBranchMiddleAreaInMargin = 600;

		//2 (5)DRIVING_FRONT_DETECT_PARAM
		pParamSet->FrontDetect.dwDetectFailChatteringTime = 200;
		pParamSet->FrontDetect.dwObsFailChatteringTime = 2000;
		pParamSet->FrontDetect.dwObsTimeout = 60000;
		pParamSet->FrontDetect.dwObsChangeTime = 2000;
		pParamSet->FrontDetect.dObsStraightDetectMargin = 500.0;

		//2 (5)DRIVING_UBG_FAIL3_ERROR_PARAM
		pParamSet->UbgFail3Err.bHourlyCheck = true;
		pParamSet->UbgFail3Err.bWeeklyCheck = false;
		pParamSet->UbgFail3Err.nHourCount = 4;
		pParamSet->UbgFail3Err.nWeekCount = 10;

		//2 (5)Foup Cover PARAM
		pParamSet->FoupCover.nLineFoupChattering = 1000;
		pParamSet->FoupCover.nCurveFoupChattering = 3000;
		pParamSet->FoupCover.nSPCurveFoupChattering = 3000;


		pParamSet->StationMarkInPos = 2.0;
		pParamSet->MapMakerCount_Driving = 50;
		pParamSet->MapMakerCount_Trans = 3;
		pParamSet->MapMakerMargin_Gap = 40.0;
		pParamSet->ScatteredReflection = 120;
		pParamSet->ScatteredReflectionMax = 600;
		pParamSet->bVHLLifterDir  = false;


		pParamSet->CID_PAUSE_TIMEOVER = 30000;
		pParamSet->CIDWaitingTimeout = 10;

		pParamSet->LightGuide_TIME_OUT_MS_MTL = LIFTER_PASS_TIME_OUT_MS;
		pParamSet->LightGuide_TIME_OUT_MS_VHLLifter = LIFTER_PASS_TIME_OUT_MS;
		pParamSet->LightGuide_TIME_OUT_MS_AutoDoor = LIFTER_PASS_TIME_OUT_MS;

		bRetrun = false;
		bCheckDrivParam = false;



		ADD_MD_LOG("Driving Param Loading Fail");
		return bRetrun;
	}
	else if(pIniFile != NULL)
    {
        //2 (1)DRIVING_AXIS_PARAM
        //1.IniFile Read

		memset(&pParamSet->Version,0x00, sizeof(pParamSet->Version));
		pIniFile->ReadString("Version","IniVersion", "00", strTempValue);
		memmove(&pParamSet->Version, strTempValue, strlen(strTempValue)); //Return Value
		memset(strTempValue, 0, sizeof(strTempValue));


		pIniFile->ReadDoubleMinMaxCheck("AXIS","AccelMin", 0.0005, 0.0005, 0.0010, &dTmpValue);
        pParamSet->Axis.Limit.Accel.MinValue = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("AXIS","AccelMax", 0.0035, 0.0005, 0.0035, &dTmpValue);
        pParamSet->Axis.Limit.Accel.MaxValue = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("AXIS","DecelMin", 0.0005, 0.0005, 0.0010, &dTmpValue);
		pParamSet->Axis.Limit.Decel.MinValue = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("AXIS","DecelMax", 0.0035, 0.0005, 0.0035, &dTmpValue);
		pParamSet->Axis.Limit.Decel.MaxValue = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("AXIS","SpeedMin", 0.05, 0.05, 0.10, &dTmpValue);
		pParamSet->Axis.Limit.Speed.MinValue = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("AXIS","SpeedMax", 5.0, 0.1, 8.0, &dTmpValue);
        pParamSet->Axis.Limit.Speed.MaxValue = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("AXIS","AbnormalMoveSpeedMargin", 0.3, 0.05, 3.5, &dTmpValue);
        pParamSet->Axis.Limit.dAbnormalMoveSpeedMargin = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("AXIS","PositionMin", -50000, -500000, 0, &dTmpValue);
        pParamSet->Axis.Limit.Position.MinValue = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("AXIS","PositionMax", 1200000, 10000, 1200000, &dTmpValue);
        pParamSet->Axis.Limit.Position.MaxValue = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("AXIS","JogPositionMin", -1000, -10000, 0, &dTmpValue);
		pParamSet->Axis.Limit.JogPosition.MinValue = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("AXIS","JogPositionMax", 1000, 0, 10000, &dTmpValue);
        pParamSet->Axis.Limit.JogPosition.MaxValue = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("AXIS","DefaultAccel", 0.003, pParamSet->Axis.Limit.Accel.MinValue, pParamSet->Axis.Limit.Accel.MaxValue, &dTmpValue);
        pParamSet->Axis.Default.dDefaultAccel = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("AXIS","DefaultDecel", 0.003, pParamSet->Axis.Limit.Decel.MinValue, pParamSet->Axis.Limit.Decel.MaxValue, &dTmpValue);
        pParamSet->Axis.Default.dDefaultDecel = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("AXIS","EmergencyDecel", 0.0035, pParamSet->Axis.Limit.Decel.MinValue, pParamSet->Axis.Limit.Decel.MaxValue, &dTmpValue);
        pParamSet->Axis.Default.dEmergencyDecel = dTmpValue;

        //2 (2)DRIVING_MARK_PARAM

        // Node Type
        pIniFile->ReadIntegerMinMaxCheck("MARK0","Type", 0, 0, 3, &nTmpValue);
		pParamSet->Mark[0].Type = nTmpValue;

#if((OHT_NAME == OHT_NAME_STD_V82)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
		pIniFile->ReadDoubleMinMaxCheck("MARK0","MarginToTarget", 200, 200, 500, &dTmpValue);
#else
		pIniFile->ReadDoubleMinMaxCheck("MARK0","MarginToTarget", 100, 0, 500, &dTmpValue);
#endif
		pParamSet->Mark[0].Dist.dMarginToTarget = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("MARK0","DistFromFirstToSecond", 290, 0, 500, &dTmpValue);
        pParamSet->Mark[0].Dist.dDistFromFirstToSecond = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("MARK0","LengthOfSecond", 20, 0, 500, &dTmpValue);
        pParamSet->Mark[0].Dist.dLengthOfSecond = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("MARK0","AddDistAfterFirstMet", 260, 0, 500, &dTmpValue);
		pParamSet->Mark[0].Dist.dAddDistAfetrFirstMet = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("MARK0","AddDistAfterSecondMet", 13, 0, 500, &dTmpValue);
		pParamSet->Mark[0].Dist.dAddDistAfterSecondMet = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("MARK0","ForwardMoveDistLimit", 300, 0, 500, &dTmpValue);
		pParamSet->Mark[0].Dist.dForwardMoveDistLimit = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("MARK0","BackMoveDistLimit", 80, 0, 500, &dTmpValue);
		pParamSet->Mark[0].Dist.dBackMoveDistLimit = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("MARK0","MarkInPosLimit", 0.5, 0, 500, &dTmpValue);
		pParamSet->Mark[0].Dist.dMarkInPosLimit = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("MARK0","MinLengthToNext", 400, 0, 500, &dTmpValue);
		pParamSet->Mark[0].Dist.dMinLengthToNext = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("MARK0","IgnoreTagDist", 100, 0, 200, &dTmpValue);
		pParamSet->Mark[0].Dist.dIgnoreTagDist = dTmpValue;


		pIniFile->ReadDoubleMinMaxCheck("MARK0","SpeedInFirstMet", 0.20, pParamSet->Axis.Limit.Speed.MinValue, pParamSet->Axis.Limit.Speed.MaxValue, &dTmpValue);
		pParamSet->Mark[0].Speed.dOfFirstMet = dTmpValue;//dSpeedInFirstMet = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("MARK0","SpeedInSecondMet", 0.10, pParamSet->Axis.Limit.Speed.MinValue, pParamSet->Axis.Limit.Speed.MaxValue, &dTmpValue);
		pParamSet->Mark[0].Speed.dOfSecondMet = dTmpValue;//dSpeedInSecondMet = dTmpValue;

#if((OHT_NAME == OHT_NAME_STD_V82)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
		pIniFile->ReadDoubleMinMaxCheck("MARK0","AccelInFirstMet", 0.0025, 0.0025, pParamSet->Axis.Limit.Decel.MaxValue, &dTmpValue);
#else
		pIniFile->ReadDoubleMinMaxCheck("MARK0","AccelInFirstMet", 0.0015, pParamSet->Axis.Limit.Decel.MinValue, pParamSet->Axis.Limit.Decel.MaxValue, &dTmpValue);
#endif
		pParamSet->Mark[0].Accel.dOfFirstMet = dTmpValue;//.dAccelInFirstMet = dTmpValue;

#if((OHT_NAME == OHT_NAME_STD_V82)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
		pIniFile->ReadDoubleMinMaxCheck("MARK0","AccelInSecondMet", 0.0025, 0.0025, pParamSet->Axis.Limit.Decel.MaxValue, &dTmpValue);
#else
		pIniFile->ReadDoubleMinMaxCheck("MARK0","AccelInSecondMet", 0.0005, pParamSet->Axis.Limit.Decel.MinValue, pParamSet->Axis.Limit.Decel.MaxValue, &dTmpValue);
#endif
		pParamSet->Mark[0].Accel.dOfSecondMet = dTmpValue;//.dAccelInSecondMet = dTmpValue;


		// Tag Station
		pIniFile->ReadIntegerMinMaxCheck("MARK1","Type", 1, 0, 3, &nTmpValue);
		pParamSet->Mark[1].Type = nTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("MARK1","MarginToTarget", 100, 0, 500, &dTmpValue);
		pParamSet->Mark[1].Dist.dMarginToTarget = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("MARK1","DistFromFirstToSecond", 160, 0, 500, &dTmpValue);
		pParamSet->Mark[1].Dist.dDistFromFirstToSecond = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("MARK1","LengthOfSecond", 5, 0, 500, &dTmpValue);
		pParamSet->Mark[1].Dist.dLengthOfSecond = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("MARK1","AddDistAfterFirstMet", 125, 0, 500, &dTmpValue);
		pParamSet->Mark[1].Dist.dAddDistAfetrFirstMet = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("MARK1","AddDistAfterSecondMet", 2.5, 0, 500, &dTmpValue);
		pParamSet->Mark[1].Dist.dAddDistAfterSecondMet = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("MARK1","ForwardMoveDistLimit", 300, 0, 500, &dTmpValue);
		pParamSet->Mark[1].Dist.dForwardMoveDistLimit = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("MARK1","BackMoveDistLimit", 80, 0, 500, &dTmpValue);
		pParamSet->Mark[1].Dist.dBackMoveDistLimit = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("MARK1","MarkInPosLimit", 1, 0, 500, &dTmpValue);
		pParamSet->Mark[1].Dist.dMarkInPosLimit = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("MARK1","MinLengthToNext", 400, 0, 500, &dTmpValue);
		pParamSet->Mark[1].Dist.dMinLengthToNext = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("MARK1","IgnoreTagDist", 180, 0, 200, &dTmpValue);
		pParamSet->Mark[1].Dist.dIgnoreTagDist = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("MARK1","SpeedInFirstMet", 0.17, pParamSet->Axis.Limit.Speed.MinValue, pParamSet->Axis.Limit.Speed.MaxValue, &dTmpValue);
		pParamSet->Mark[1].Speed.dOfFirstMet = dTmpValue;//dSpeedInFirstMet = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("MARK1","SpeedInSecondMet", 0.05, pParamSet->Axis.Limit.Speed.MinValue, pParamSet->Axis.Limit.Speed.MaxValue, &dTmpValue);
		pParamSet->Mark[1].Speed.dOfSecondMet = dTmpValue;//dSpeedInSecondMet = dTmpValue;

#if((OHT_NAME == OHT_NAME_STD_V82)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
		pIniFile->ReadDoubleMinMaxCheck("MARK1","AccelInFirstMet", 0.0025, 0.0025, pParamSet->Axis.Limit.Decel.MaxValue, &dTmpValue);
#else
		pIniFile->ReadDoubleMinMaxCheck("MARK1","AccelInFirstMet", 0.0015, pParamSet->Axis.Limit.Decel.MinValue, pParamSet->Axis.Limit.Decel.MaxValue, &dTmpValue);
#endif
		pParamSet->Mark[1].Accel.dOfFirstMet = dTmpValue;//.dAccelInFirstMet = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("MARK1","AccelInSecondMet", 0.0005, pParamSet->Axis.Limit.Decel.MinValue, pParamSet->Axis.Limit.Decel.MaxValue, &dTmpValue);
		pParamSet->Mark[1].Accel.dOfSecondMet = dTmpValue;//.dAccelInSecondMet = dTmpValue;


		// QR Left
		pIniFile->ReadIntegerMinMaxCheck("MARK2","Type", 2, 0, 3, &nTmpValue);
		pParamSet->Mark[2].Type = nTmpValue;

		pIniFile->ReadIntegerMinMaxCheck("MARK2","MakerType", MAKER_TYPE_KEYENCE, 0, 4, &nTmpValue);
		pParamSet->Mark[2].MakerType = nTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("MARK2","MarginToTarget", 100, 0, 500, &dTmpValue);
		pParamSet->Mark[2].Dist.dMarginToTarget = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("MARK2","DistFromFirstToSecond", 70, 0, 500, &dTmpValue);
		pParamSet->Mark[2].Dist.dDistFromFirstToSecond = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("MARK2","LengthOfSecond", 0, 0, 500, &dTmpValue);
		pParamSet->Mark[2].Dist.dLengthOfSecond = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("MARK2","AddDistAfterFirstMet", 5, 0, 500, &dTmpValue);
		pParamSet->Mark[2].Dist.dAddDistAfetrFirstMet = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("MARK2","AddDistAfterSecondMet", 0, 0, 500, &dTmpValue);
		pParamSet->Mark[2].Dist.dAddDistAfterSecondMet = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("MARK2","ForwardMoveDistLimit", 300, 0, 500, &dTmpValue);
		pParamSet->Mark[2].Dist.dForwardMoveDistLimit = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("MARK2","BackMoveDistLimit", 80, 0, 500, &dTmpValue);
		pParamSet->Mark[2].Dist.dBackMoveDistLimit = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("MARK2","MarkInPosLimit", 1, 0, 500, &dTmpValue);
		pParamSet->Mark[2].Dist.dMarkInPosLimit = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("MARK2","MinLengthToNext", 450, 0, 500, &dTmpValue);
		pParamSet->Mark[2].Dist.dMinLengthToNext = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("MARK2","IgnoreTagDist", 0, 0, 200, &dTmpValue);
		pParamSet->Mark[2].Dist.dIgnoreTagDist = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("MARK2","SpeedInFirstMet", 0.12, pParamSet->Axis.Limit.Speed.MinValue, pParamSet->Axis.Limit.Speed.MaxValue, &dTmpValue);
		pParamSet->Mark[2].Speed.dOfFirstMet = dTmpValue;//dSpeedInFirstMet = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("MARK2","SpeedInSecondMet", 0.05, pParamSet->Axis.Limit.Speed.MinValue, pParamSet->Axis.Limit.Speed.MaxValue, &dTmpValue);
		pParamSet->Mark[2].Speed.dOfSecondMet = dTmpValue;//dSpeedInSecondMet = dTmpValue;

#if((OHT_NAME == OHT_NAME_STD_V82)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
		pIniFile->ReadDoubleMinMaxCheck("MARK2","AccelInFirstMet", 0.0025, 0.0025, pParamSet->Axis.Limit.Decel.MaxValue, &dTmpValue);
#else
		pIniFile->ReadDoubleMinMaxCheck("MARK2","AccelInFirstMet", 0.0005, pParamSet->Axis.Limit.Decel.MinValue, pParamSet->Axis.Limit.Decel.MaxValue, &dTmpValue);
#endif
		pParamSet->Mark[2].Accel.dOfFirstMet = dTmpValue;//.dAccelInFirstMet = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("MARK2","AccelInSecondMet", 0.0005, pParamSet->Axis.Limit.Decel.MinValue, pParamSet->Axis.Limit.Decel.MaxValue, &dTmpValue);
		pParamSet->Mark[2].Accel.dOfSecondMet = dTmpValue;//.dAccelInSecondMet = dTmpValue;


		// QR Right
		pIniFile->ReadIntegerMinMaxCheck("MARK3","Type", 3, 0, 3, &nTmpValue);
		pParamSet->Mark[3].Type = nTmpValue;

		pIniFile->ReadIntegerMinMaxCheck("MARK3","MakerType", MAKER_TYPE_KEYENCE, 0, 4, &nTmpValue);
		pParamSet->Mark[3].MakerType = nTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("MARK3","MarginToTarget", 100, 0, 500, &dTmpValue);
		pParamSet->Mark[3].Dist.dMarginToTarget = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("MARK3","DistFromFirstToSecond", 70, 0, 500, &dTmpValue);
		pParamSet->Mark[3].Dist.dDistFromFirstToSecond = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("MARK3","LengthOfSecond", 0, 0, 500, &dTmpValue);
		pParamSet->Mark[3].Dist.dLengthOfSecond = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("MARK3","AddDistAfterFirstMet", 5, 0, 500, &dTmpValue);
		pParamSet->Mark[3].Dist.dAddDistAfetrFirstMet = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("MARK3","AddDistAfterSecondMet", 0, 0, 500, &dTmpValue);
		pParamSet->Mark[3].Dist.dAddDistAfterSecondMet = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("MARK3","ForwardMoveDistLimit", 300, 0, 500, &dTmpValue);
		pParamSet->Mark[3].Dist.dForwardMoveDistLimit = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("MARK3","BackMoveDistLimit", 80, 0, 500, &dTmpValue);
		pParamSet->Mark[3].Dist.dBackMoveDistLimit = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("MARK3","MarkInPosLimit", 1, 0, 500, &dTmpValue);
		pParamSet->Mark[3].Dist.dMarkInPosLimit = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("MARK3","MinLengthToNext", 450, 0, 500, &dTmpValue);
		pParamSet->Mark[3].Dist.dMinLengthToNext = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("MARK3","IgnoreTagDist", 0, 0, 200, &dTmpValue);
		pParamSet->Mark[3].Dist.dIgnoreTagDist = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("MARK3","SpeedInFirstMet", 0.12, pParamSet->Axis.Limit.Speed.MinValue, pParamSet->Axis.Limit.Speed.MaxValue, &dTmpValue);
		pParamSet->Mark[3].Speed.dOfFirstMet = dTmpValue;//dSpeedInFirstMet = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("MARK3","SpeedInSecondMet", 0.05, pParamSet->Axis.Limit.Speed.MinValue, pParamSet->Axis.Limit.Speed.MaxValue, &dTmpValue);
		pParamSet->Mark[3].Speed.dOfSecondMet = dTmpValue;//dSpeedInSecondMet = dTmpValue;

#if((OHT_NAME == OHT_NAME_STD_V82)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
		pIniFile->ReadDoubleMinMaxCheck("MARK3","AccelInFirstMet", 0.0025, 0.0025, pParamSet->Axis.Limit.Decel.MaxValue, &dTmpValue);
#else
		pIniFile->ReadDoubleMinMaxCheck("MARK3","AccelInFirstMet", 0.0005, pParamSet->Axis.Limit.Decel.MinValue, pParamSet->Axis.Limit.Decel.MaxValue, &dTmpValue);
#endif
		pParamSet->Mark[3].Accel.dOfFirstMet = dTmpValue;//.dAccelInFirstMet = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("MARK3","AccelInSecondMet", 0.0005, pParamSet->Axis.Limit.Decel.MinValue, pParamSet->Axis.Limit.Decel.MaxValue, &dTmpValue);
		pParamSet->Mark[3].Accel.dOfSecondMet = dTmpValue;//.dAccelInSecondMet = dTmpValue;



		//2 (3)DRIVING_STEER_PARAM
		pIniFile->ReadIntegerMinMaxCheck("STEER","ChangeTime", 500, 400, 1000, &nTmpValue);
		pParamSet->Steer.dwChangeTime = nTmpValue;

#if((OHT_NAME == OHT_NAME_STD_V82)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
		pIniFile->ReadIntegerMinMaxCheck("STEER","MovingTorqueTime", 200, 200, 1000, &nTmpValue);
#else
		pIniFile->ReadIntegerMinMaxCheck("STEER","MovingTorqueTime", 50, 0, 1000, &nTmpValue);
#endif
		pParamSet->Steer.dwMovingTorqueTime = nTmpValue;

		pIniFile->ReadIntegerMinMaxCheck("STEER","CompleteCheckTime", 100, 0, 1000, &nTmpValue);
		pParamSet->Steer.dwCompleteCheckTime = nTmpValue;

		pIniFile->ReadIntegerMinMaxCheck("STEER","CompleteLimitTime", 10000, 500, 60000, &nTmpValue);
		pParamSet->Steer.dwCompleteLimitTime = nTmpValue;


		//2 (4)DRIVING_LINK_PARAM
		pIniFile->ReadDoubleMinMaxCheck("LINK","OutNodeAreaMargin", 500, 400, 600, &dTmpValue);
		pParamSet->Link.dOutNodeAreaMargin = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("LINK","NBranchMiddleAreaInMargin", 600, 500, 1000, &dTmpValue);
		pParamSet->Link.dNBranchMiddleAreaInMargin = dTmpValue;


        //2 (5)DRIVING_FRONT_DETECT_PARAM
		pIniFile->ReadIntegerMinMaxCheck("DETECT","DetectFailChatteringTime", 200, 0, 60000, &nTmpValue);
		pParamSet->FrontDetect.dwDetectFailChatteringTime = nTmpValue;

		pIniFile->ReadIntegerMinMaxCheck("DETECT","ObsFailChatteringTime", 2000, 0, 60000, &nTmpValue);
		pParamSet->FrontDetect.dwObsFailChatteringTime = nTmpValue;

		pIniFile->ReadIntegerMinMaxCheck("DETECT","ObsTimeout", 60000, 0, 60000, &nTmpValue);
		pParamSet->FrontDetect.dwObsTimeout = nTmpValue;


		pIniFile->ReadIntegerMinMaxCheck("DETECT","ObsChangeTime", 2000, 0, 15000, &nTmpValue);
		pParamSet->FrontDetect.dwObsChangeTime = nTmpValue;


		pIniFile->ReadDoubleMinMaxCheck("DETECT","ObsStraightDetectMargin",500.0, 0.0, 1000.0 , &dTmpValue);
		pParamSet->FrontDetect.dObsStraightDetectMargin = dTmpValue;

		//2 (5)DRIVING_UBG_FAIL3_ERROR_PARAM
		pIniFile->ReadBool("UBG_FAIL3_ERROR", "HourlyCheck", true, &bTmpValue);
		pParamSet->UbgFail3Err.bHourlyCheck = bTmpValue;

		pIniFile->ReadBool("UBG_FAIL3_ERROR", "WeeklyCheck", false, &bTmpValue);
		pParamSet->UbgFail3Err.bWeeklyCheck = bTmpValue;

		pIniFile->ReadIntegerMinMaxCheck("UBG_FAIL3_ERROR","HourCount", 4, 0, 100, &nTmpValue);
		pParamSet->UbgFail3Err.nHourCount = nTmpValue;

		pIniFile->ReadIntegerMinMaxCheck("UBG_FAIL3_ERROR","WeekCount", 10, 0, 100, &nTmpValue);
		pParamSet->UbgFail3Err.nWeekCount = nTmpValue;

		//2 (5)Foup Cover PARAM //KYH FoupCoverChattering Test 위하여 수정
		//pIniFile->ReadIntegerMinMaxCheck("FOUPCOVER","LineFoupChattering", 1000, 1000, 1500, &nTmpValue);
		pIniFile->ReadIntegerMinMaxCheck("FOUPCOVER","LineFoupChattering", 1000, 100, 1500, &nTmpValue);
		pParamSet->FoupCover.nLineFoupChattering = nTmpValue;

		//pIniFile->ReadIntegerMinMaxCheck("FOUPCOVER","CurveFoupChattering", 3000, 3000, 3500, &nTmpValue);
		pIniFile->ReadIntegerMinMaxCheck("FOUPCOVER","CurveFoupChattering", 3000, 100, 3500, &nTmpValue);
		pParamSet->FoupCover.nCurveFoupChattering = nTmpValue;

		//pIniFile->ReadIntegerMinMaxCheck("FOUPCOVER","SPCurveFoupChattering", 3000, 3000, 5000, &nTmpValue);
		pIniFile->ReadIntegerMinMaxCheck("FOUPCOVER","SPCurveFoupChattering", 3000, 100, 5000, &nTmpValue);
		pParamSet->FoupCover.nSPCurveFoupChattering = nTmpValue;



		//2 (6)이적재 Tag 정위치 InPos
		pIniFile->ReadDoubleMinMaxCheck("STATION","StationMarkInPos", 2.0, 0.0, 3.0, &dTmpValue);
		pParamSet->StationMarkInPos = dTmpValue;


		//2 (6)이적재 Tag 정위치 InPos
		pIniFile->ReadIntegerMinMaxCheck("STATION","MapMakerCount_Driving", 50, 0, 500, &nTmpValue);
		pParamSet->MapMakerCount_Driving = nTmpValue;

	   //2 (6)이적재 Tag 정위치 InPos
		pIniFile->ReadIntegerMinMaxCheck("STATION","MapMakerCount_Trans", 3, 0, 100, &nTmpValue);
		pParamSet->MapMakerCount_Trans = nTmpValue;

		//2 (6)이적재 Tag 정위치 InPos
		pIniFile->ReadDoubleMinMaxCheck("STATION","MapMakerMargin_Gap", 40.0, 0.0, 70.0, &dTmpValue);
		pParamSet->MapMakerMargin_Gap = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("STATION","ScatteredReflection", 120.0, 90.0, 150.0, &dTmpValue);
		pParamSet->ScatteredReflection = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("STATION","ScatteredReflectionMax", 600.0, 180.0, 700.0, &dTmpValue);
		pParamSet->ScatteredReflectionMax = dTmpValue;

		pIniFile->ReadBool("VHLLIFTER", "OutPosDir", false, &bTmpValue);
		pParamSet->bVHLLifterDir = bTmpValue;

		//2 (6)CID PARAM
		pIniFile->ReadIntegerMinMaxCheck("CID","CID_PAUSE_TIMEOVER", 30000, 1000, 60000, &nTmpValue);
		pParamSet->CID_PAUSE_TIMEOVER = nTmpValue;

		pIniFile->ReadIntegerMinMaxCheck("CID","CIDWaitingTimeout", 10, 0, 100, &nTmpValue);
		pParamSet->CIDWaitingTimeout = nTmpValue;

		//2 (7)Light Guide 파라미터
		pIniFile->ReadIntegerMinMaxCheck("LG","MTLWaitingTimeout", LIFTER_PASS_TIME_OUT_MS, 1000, LIFTER_PASS_TIME_OUT_MS, &nTmpValue);
		pParamSet->LightGuide_TIME_OUT_MS_MTL = nTmpValue;

		pIniFile->ReadIntegerMinMaxCheck("LG","VHLLIFTERWaitingTimeout", LIFTER_PASS_TIME_OUT_MS, 1000, LIFTER_PASS_TIME_OUT_MS, &nTmpValue);
		pParamSet->LightGuide_TIME_OUT_MS_VHLLifter = nTmpValue;

		pIniFile->ReadIntegerMinMaxCheck("LG","AUTODOORWaitingTimeout", LIFTER_PASS_TIME_OUT_MS, 1000, LIFTER_PASS_TIME_OUT_MS, &nTmpValue);
		pParamSet->LightGuide_TIME_OUT_MS_AutoDoor = nTmpValue;


		delete pIniFile;

		Reload_QR_Data();


        bRetrun = true;
    }
	return bRetrun;
}



bool DrivingControl::loadParameterRecovery(char* szFilePath, DRIVING_PARAM_SET* pParamSet)
{
	bool bSuccess = true;
    int nTmpValue = 0;
    //int nResult = 0;
	double dTmpValue = 0.0;
	bool bTmpValue = false;
	//double dResult = 0.0;
	char szSection[1024];
	memset(szSection, 0, sizeof(szSection));
	char strTempValue[8]= {0,};
	bool bCheckParam = false;

    LIniFile *pIniFile;
    pIniFile = NULL;
    pIniFile = new LIniFile(szFilePath);

    if(!pIniFile->GetIniFileExist())
    {
        delete pIniFile;
		pIniFile = NULL;
		bSuccess = false;
    }

    if(pIniFile != NULL)
    {
        //2 (1)DRIVING_AXIS_PARAM
        //1.IniFile Read
		pIniFile->ReadString("Version","IniVersion", "00", strTempValue);
		if(StrToIntA(strTempValue) <= StrToIntA(pParamSet->Version))
			bSuccess = false;
		else
		{
			memmove(&pParamSet->Version, strTempValue, strlen(strTempValue)); //Return Value
			memset(strTempValue, 0, sizeof(strTempValue));
		}


		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("AXIS","AccelMin", 0.0005, 0.0005, 0.0010, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Axis.Limit.Accel.MinValue = dTmpValue;
			}
			else
			{
            	bSuccess = false;
            }

		}

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("AXIS","AccelMax", 0.0035, 0.0005, 0.0035, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Axis.Limit.Accel.MaxValue = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("AXIS","DecelMin", 0.0005, 0.0005, 0.0010, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Axis.Limit.Decel.MinValue = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("AXIS","DecelMax", 0.0035, 0.0005, 0.0035, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Axis.Limit.Decel.MaxValue = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("AXIS","SpeedMin", 0.05, 0.05, 0.10, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Axis.Limit.Speed.MinValue = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("AXIS","SpeedMax", 3.5, 0.1, 8.0, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Axis.Limit.Speed.MaxValue = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("AXIS","AbnormalMoveSpeedMargin", 0.3, 0.05, 3.5, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Axis.Limit.dAbnormalMoveSpeedMargin = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("AXIS","PositionMin", -50000, -100000, -5000, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Axis.Limit.Position.MinValue = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}


		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("AXIS","PositionMax", 1200000, 10000, 1500000, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Axis.Limit.Position.MaxValue = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("AXIS","JogPositionMin", -1000, -10000, 0, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Axis.Limit.JogPosition.MinValue = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("AXIS","JogPositionMax", 1000, 0, 10000, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Axis.Limit.JogPosition.MaxValue = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("AXIS","DefaultAccel", 0.002, pParamSet->Axis.Limit.Accel.MinValue, pParamSet->Axis.Limit.Accel.MaxValue, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Axis.Default.dDefaultAccel = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("AXIS","DefaultDecel", 0.003, pParamSet->Axis.Limit.Decel.MinValue, pParamSet->Axis.Limit.Decel.MaxValue, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Axis.Default.dDefaultDecel = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("AXIS","EmergencyDecel", 0.0035, pParamSet->Axis.Limit.Decel.MinValue, pParamSet->Axis.Limit.Decel.MaxValue, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Axis.Default.dEmergencyDecel = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

        //2 (2)DRIVING_MARK_PARAM

		// Node Type

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadIntegerMinMaxVerification("MARK0","Type", 0, 0, 3, &nTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[0].Type = nTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
#if((OHT_NAME == OHT_NAME_STD_V82)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("MARK0","MarginToTarget", 200, 200, 500, &dTmpValue);
#else
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("MARK0","MarginToTarget", 100, 0, 500, &dTmpValue);
#endif
			if(bCheckParam)
			{
				pParamSet->Mark[0].Dist.dMarginToTarget = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("MARK0","DistFromFirstToSecond", 340, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[0].Dist.dDistFromFirstToSecond = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("MARK0","LengthOfSecond", 20, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[0].Dist.dLengthOfSecond = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("MARK0","AddDistAfterFirstMet", 310, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[0].Dist.dAddDistAfetrFirstMet = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("MARK0","AddDistAfterSecondMet", 10, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[0].Dist.dAddDistAfterSecondMet = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("MARK0","ForwardMoveDistLimit", 300, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[0].Dist.dForwardMoveDistLimit = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("MARK0","BackMoveDistLimit", 100, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[0].Dist.dBackMoveDistLimit = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("MARK0","MarkInPosLimit", 0.5, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[0].Dist.dMarkInPosLimit = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("MARK0","MinLengthToNext", 400, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[0].Dist.dMinLengthToNext = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("MARK0","IgnoreTagDist", 100, 0, 200, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[0].Dist.dIgnoreTagDist = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("MARK0","SpeedInFirstMet", 0.80, pParamSet->Axis.Limit.Speed.MinValue, pParamSet->Axis.Limit.Speed.MaxValue, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[0].Speed.dOfFirstMet = dTmpValue;//dSpeedInFirstMet = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("MARK0","SpeedInSecondMet", 0.10, pParamSet->Axis.Limit.Speed.MinValue, pParamSet->Axis.Limit.Speed.MaxValue, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[0].Speed.dOfSecondMet = dTmpValue;//dSpeedInSecondMet = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
#if((OHT_NAME == OHT_NAME_STD_V82)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("MARK0","AccelInFirstMet", 0.0025, 0.0025, pParamSet->Axis.Limit.Decel.MaxValue, &dTmpValue);
#else
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("MARK0","AccelInFirstMet", 0.0010, pParamSet->Axis.Limit.Decel.MinValue, pParamSet->Axis.Limit.Decel.MaxValue, &dTmpValue);
#endif
			if(bCheckParam)
			{
				pParamSet->Mark[0].Accel.dOfFirstMet = dTmpValue;//.dAccelInFirstMet = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
#if((OHT_NAME == OHT_NAME_STD_V82)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("MARK0","AccelInSecondMet", 0.0025, 0.0025, pParamSet->Axis.Limit.Decel.MaxValue, &dTmpValue);
#else
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("MARK0","AccelInSecondMet", 0.0005, pParamSet->Axis.Limit.Decel.MinValue, pParamSet->Axis.Limit.Decel.MaxValue, &dTmpValue);
#endif
			if(bCheckParam)
			{
				pParamSet->Mark[0].Accel.dOfSecondMet = dTmpValue;//.dAccelInSecondMet = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}


		// Tag Station

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadIntegerMinMaxVerification("MARK1","Type", 1, 0, 3, &nTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[1].Type = nTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK1","MarginToTarget", 100, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[1].Dist.dMarginToTarget = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK1","DistFromFirstToSecond", 140, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[1].Dist.dDistFromFirstToSecond = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK1","LengthOfSecond", 5, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[1].Dist.dLengthOfSecond = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK1","AddDistAfterFirstMet", 125, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[1].Dist.dAddDistAfetrFirstMet = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK1","AddDistAfterSecondMet", 0.5, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[1].Dist.dAddDistAfterSecondMet = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK1","ForwardMoveDistLimit", 300, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[1].Dist.dForwardMoveDistLimit = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK1","BackMoveDistLimit", 100, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[1].Dist.dBackMoveDistLimit = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK1","MarkInPosLimit", 0.5, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[1].Dist.dMarkInPosLimit = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK1","MinLengthToNext", 400, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[1].Dist.dMinLengthToNext = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK1","IgnoreTagDist", 180, 0, 200, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[1].Dist.dIgnoreTagDist = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK1","SpeedInFirstMet", 0.50, pParamSet->Axis.Limit.Speed.MinValue, pParamSet->Axis.Limit.Speed.MaxValue, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[1].Speed.dOfFirstMet = dTmpValue;//dSpeedInFirstMet = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK1","SpeedInSecondMet", 0.05, pParamSet->Axis.Limit.Speed.MinValue, pParamSet->Axis.Limit.Speed.MaxValue, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[1].Speed.dOfSecondMet = dTmpValue;//dSpeedInSecondMet = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
#if((OHT_NAME == OHT_NAME_STD_V82)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("MARK1","AccelInFirstMet", 0.0025, 0.0025, pParamSet->Axis.Limit.Decel.MaxValue, &dTmpValue);
#else
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("MARK1","AccelInFirstMet", 0.0010, pParamSet->Axis.Limit.Decel.MinValue, pParamSet->Axis.Limit.Decel.MaxValue, &dTmpValue);
#endif
			if(bCheckParam)
			{
				pParamSet->Mark[1].Accel.dOfFirstMet = dTmpValue;//.dAccelInFirstMet = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK1","AccelInSecondMet", 0.0005, pParamSet->Axis.Limit.Decel.MinValue, pParamSet->Axis.Limit.Decel.MaxValue, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[1].Accel.dOfSecondMet = dTmpValue;//.dAccelInSecondMet = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}


		// QR Left

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadIntegerMinMaxVerification("MARK2","Type", 2, 0, 3, &nTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[2].Type = nTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadIntegerMinMaxVerification("MARK2","MakerType", MAKER_TYPE_KEYENCE, 0, 4, &nTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[2].MakerType = nTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK2","MarginToTarget", 100, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[2].Dist.dMarginToTarget = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK2","DistFromFirstToSecond", 70, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[2].Dist.dDistFromFirstToSecond = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK2","LengthOfSecond", 0, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[2].Dist.dLengthOfSecond = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

 		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK2","AddDistAfterFirstMet", 50, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[2].Dist.dAddDistAfetrFirstMet = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

 		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK2","AddDistAfterSecondMet", 0, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[2].Dist.dAddDistAfterSecondMet = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK2","ForwardMoveDistLimit", 300, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[2].Dist.dForwardMoveDistLimit = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK2","BackMoveDistLimit", 100, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[2].Dist.dBackMoveDistLimit = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK2","MarkInPosLimit", 50, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[2].Dist.dMarkInPosLimit = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK2","MinLengthToNext", 400, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[2].Dist.dMinLengthToNext = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK2","IgnoreTagDist", 0, 0, 200, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[2].Dist.dIgnoreTagDist = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK2","SpeedInFirstMet", 0.05, pParamSet->Axis.Limit.Speed.MinValue, pParamSet->Axis.Limit.Speed.MaxValue, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[2].Speed.dOfFirstMet = dTmpValue;//dSpeedInFirstMet = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK2","SpeedInSecondMet", 0.05, pParamSet->Axis.Limit.Speed.MinValue, pParamSet->Axis.Limit.Speed.MaxValue, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[2].Speed.dOfSecondMet = dTmpValue;//dSpeedInSecondMet = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
#if((OHT_NAME == OHT_NAME_STD_V82)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("MARK2","AccelInFirstMet", 0.0025, 0.0025, pParamSet->Axis.Limit.Decel.MaxValue, &dTmpValue);
#else
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("MARK2","AccelInFirstMet", 0.0010, pParamSet->Axis.Limit.Decel.MinValue, pParamSet->Axis.Limit.Decel.MaxValue, &dTmpValue);
#endif
			if(bCheckParam)
			{
				pParamSet->Mark[2].Accel.dOfFirstMet = dTmpValue;//.dAccelInFirstMet = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK2","AccelInSecondMet", 0.0005, pParamSet->Axis.Limit.Decel.MinValue, pParamSet->Axis.Limit.Decel.MaxValue, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[2].Accel.dOfSecondMet = dTmpValue;//.dAccelInSecondMet = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}


		// QR Right
		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadIntegerMinMaxVerification("MARK3","Type", 3, 0, 3, &nTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[3].Type = nTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadIntegerMinMaxVerification("MARK3","MakerType", MAKER_TYPE_KEYENCE, 0, 4, &nTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[3].MakerType = nTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK3","MarginToTarget", 100, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[3].Dist.dMarginToTarget = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK3","DistFromFirstToSecond", 70, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[3].Dist.dDistFromFirstToSecond = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK3","LengthOfSecond", 0, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[3].Dist.dLengthOfSecond = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK3","AddDistAfterFirstMet", 50, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[3].Dist.dAddDistAfetrFirstMet = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK3","AddDistAfterSecondMet", 0, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[3].Dist.dAddDistAfterSecondMet = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK3","ForwardMoveDistLimit", 300, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[3].Dist.dForwardMoveDistLimit = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK3","BackMoveDistLimit", 100, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[3].Dist.dBackMoveDistLimit = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK3","MarkInPosLimit", 50, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[3].Dist.dMarkInPosLimit = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK3","MinLengthToNext", 400, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[3].Dist.dMinLengthToNext = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK3","IgnoreTagDist", 0, 0, 200, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[3].Dist.dIgnoreTagDist = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK3","SpeedInFirstMet", 0.05, pParamSet->Axis.Limit.Speed.MinValue, pParamSet->Axis.Limit.Speed.MaxValue, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[3].Speed.dOfFirstMet = dTmpValue;//dSpeedInFirstMet = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK3","SpeedInSecondMet", 0.05, pParamSet->Axis.Limit.Speed.MinValue, pParamSet->Axis.Limit.Speed.MaxValue, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[3].Speed.dOfSecondMet = dTmpValue;//dSpeedInSecondMet = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
#if((OHT_NAME == OHT_NAME_STD_V82)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("MARK3","AccelInFirstMet", 0.0025, 0.0025, pParamSet->Axis.Limit.Decel.MaxValue, &dTmpValue);
#else
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("MARK3","AccelInFirstMet", 0.0010, pParamSet->Axis.Limit.Decel.MinValue, pParamSet->Axis.Limit.Decel.MaxValue, &dTmpValue);
#endif
			if(bCheckParam)
			{
				pParamSet->Mark[3].Accel.dOfFirstMet = dTmpValue;//.dAccelInFirstMet = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

 		if(bSuccess)
		{
			bCheckParam =   pIniFile->ReadDoubleMinMaxVerification("MARK3","AccelInSecondMet", 0.0005, pParamSet->Axis.Limit.Decel.MinValue, pParamSet->Axis.Limit.Decel.MaxValue, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[3].Accel.dOfSecondMet = dTmpValue;//.dAccelInSecondMet = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}


		//2 (3)DRIVING_STEER_PARAM
 		if(bSuccess)
		{
			bCheckParam =   pIniFile->ReadIntegerMinMaxVerification("STEER","ChangeTime", 1000, 500, 1000, &nTmpValue);
			if(bCheckParam)
			{
				pParamSet->Steer.dwChangeTime = nTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
#if((OHT_NAME == OHT_NAME_STD_V82)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
			bCheckParam = pIniFile->ReadIntegerMinMaxVerification("STEER","MovingTorqueTime", 200, 200, 1000, &nTmpValue);
#else
			bCheckParam = pIniFile->ReadIntegerMinMaxVerification("STEER","MovingTorqueTime", 100, 0, 1000, &nTmpValue);
#endif
			if(bCheckParam)
			{
				pParamSet->Steer.dwMovingTorqueTime = nTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

 		if(bSuccess)
		{
			bCheckParam =   pIniFile->ReadIntegerMinMaxVerification("STEER","CompleteCheckTime", 100, 0, 1000, &nTmpValue);
			if(bCheckParam)
			{
				pParamSet->Steer.dwCompleteCheckTime = nTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

 		if(bSuccess)
		{
			bCheckParam =   pIniFile->ReadIntegerMinMaxVerification("STEER","CompleteLimitTime", 5000, 500, 60000, &nTmpValue);
			if(bCheckParam)
			{
				pParamSet->Steer.dwCompleteLimitTime = nTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		//2 (4)DRIVING_LINK_PARAM

 		if(bSuccess)
		{
			bCheckParam =   pIniFile->ReadDoubleMinMaxVerification("LINK","OutNodeAreaMargin", 500, 400, 600, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Link.dOutNodeAreaMargin = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

 		if(bSuccess)
		{
			bCheckParam =   pIniFile->ReadDoubleMinMaxVerification("LINK","NBranchMiddleAreaInMargin", 700, 500, 1000, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Link.dNBranchMiddleAreaInMargin = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		//2 (5)DRIVING_FRONT_DETECT_PARAM
 		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadIntegerMinMaxVerification("DETECT","DetectFailChatteringTime", 200, 0, 60000, &nTmpValue);
			if(bCheckParam)
			{
				pParamSet->FrontDetect.dwDetectFailChatteringTime = nTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

 		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadIntegerMinMaxVerification("DETECT","ObsFailChatteringTime", 200, 0, 60000, &nTmpValue);
			if(bCheckParam)
			{
				pParamSet->FrontDetect.dwObsFailChatteringTime = nTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

 		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadIntegerMinMaxVerification("DETECT","ObsTimeout", 30000, 0, 60000, &nTmpValue);
			if(bCheckParam)
			{
				pParamSet->FrontDetect.dwObsTimeout = nTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

 		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadIntegerMinMaxVerification("DETECT","ObsChangeTime", 2000, 0, 15000, &nTmpValue);
			if(bCheckParam)
			{
				pParamSet->FrontDetect.dwObsChangeTime = nTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

 		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("DETECT","ObsStraightDetectMargin",500.0, 0.0, 1000.0 , &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->FrontDetect.dObsStraightDetectMargin = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		//2 (5)DRIVING_UBG_FAIL3_ERROR_PARAM
 		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadBoolVerification("UBG_FAIL3_ERROR", "HourlyCheck", true, &bTmpValue);
			if(bCheckParam)
			{
				pParamSet->UbgFail3Err.bHourlyCheck = bTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

 		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadBoolVerification("UBG_FAIL3_ERROR", "WeeklyCheck", false, &bTmpValue);
			if(bCheckParam)
			{
				pParamSet->UbgFail3Err.bWeeklyCheck = bTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

 		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadIntegerMinMaxVerification("UBG_FAIL3_ERROR","HourCount", 4, 0, 100, &nTmpValue);
			if(bCheckParam)
			{
				pParamSet->UbgFail3Err.nHourCount = nTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

 		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadIntegerMinMaxVerification("UBG_FAIL3_ERROR","WeekCount", 10, 0, 100, &nTmpValue);
			if(bCheckParam)
			{
				pParamSet->UbgFail3Err.nWeekCount = nTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		//2 (5)Foup Cover PARAM
 		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadIntegerMinMaxVerification("FOUPCOVER","LineFoupChattering", 1000, 100, 1500, &nTmpValue);
			if(bCheckParam)
			{
				pParamSet->FoupCover.nLineFoupChattering = nTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

 		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadIntegerMinMaxVerification("FOUPCOVER","CurveFoupChattering", 3000, 100, 3500, &nTmpValue);
			if(bCheckParam)
			{
				pParamSet->FoupCover.nCurveFoupChattering = nTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

 		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadIntegerMinMaxVerification("FOUPCOVER","SPCurveFoupChattering", 3000, 100, 5000, &nTmpValue);
			if(bCheckParam)
			{
				pParamSet->FoupCover.nSPCurveFoupChattering = nTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		//2 (6)CID PARAM
 		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadIntegerMinMaxVerification("CID","CID_PAUSE_TIMEOVER", 30000, 1000, 60000, &nTmpValue);
			if(bCheckParam)
			{
				pParamSet->CID_PAUSE_TIMEOVER = nTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}


		//2 (6)이적재 Tag 정위치 InPos
 		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("STATION","StationMarkInPos", 2.0, 0.0, 3.0, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->StationMarkInPos = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		//2 (6)이적재 Tag 정위치 InPos
		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadIntegerMinMaxVerification("STATION","MapMakerCount_Driving", 50, 0, 500, &nTmpValue);
			if(bCheckParam)
			{
				pParamSet->MapMakerCount_Driving = nTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}


	   //2 (6)이적재 Tag 정위치 InPos
 		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadIntegerMinMaxVerification("STATION","MapMakerCount_Trans", 3, 0, 100, &nTmpValue);
			if(bCheckParam)
			{
				pParamSet->MapMakerCount_Trans = nTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}


		//2 (6)이적재 Tag 정위치 InPos
 		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("STATION","MapMakerMargin_Gap", 40.0, 0.0, 70.0, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->MapMakerMargin_Gap = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

 		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("STATION","ScatteredReflection", 120.0, 90.0, 150.0, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->ScatteredReflection = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

 		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("STATION","ScatteredReflectionMax", 600.0, 180.0, 700.0, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->ScatteredReflectionMax = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

 		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadBoolVerification("VHLLIFTER", "OutPosDir", false, &bTmpValue);
			if(bCheckParam)
			{
				pParamSet->bVHLLifterDir = bTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadIntegerMinMaxVerification("CID","CIDWaitingTimeout", 10, 0, 100, &nTmpValue);
			if(bCheckParam)
			{
				pParamSet->CIDWaitingTimeout = nTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		//파라미터 안정화 후 인터락 적용 유무 검토...
		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadIntegerMinMaxVerification("LG","MTLWaitingTimeout", LIFTER_PASS_TIME_OUT_MS, 1000, LIFTER_PASS_TIME_OUT_MS, &nTmpValue);
			if(bCheckParam)
			{
				pParamSet->LightGuide_TIME_OUT_MS_MTL = nTmpValue;
			}
			else
			{
				bSuccess = false;
			}
		}

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadIntegerMinMaxVerification("LG","VHLLIFTERWaitingTimeout", LIFTER_PASS_TIME_OUT_MS, 1000, LIFTER_PASS_TIME_OUT_MS, &nTmpValue);
			if(bCheckParam)
			{
				pParamSet->LightGuide_TIME_OUT_MS_VHLLifter = nTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadIntegerMinMaxVerification("LG","AUTODOORWaitingTimeout", LIFTER_PASS_TIME_OUT_MS, 1000, LIFTER_PASS_TIME_OUT_MS, &nTmpValue);
			if(bCheckParam)
			{
				pParamSet->LightGuide_TIME_OUT_MS_AutoDoor = nTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		delete pIniFile;

		if(bSuccess)
			Reload_QR_Data();

    }
	else
	{
       	bSuccess = false;
    }
	//AOHC-358 파라미터 적용 오류 시, 에러 발생
	if(bSuccess ==false)
	{
	  //	SOM_LOG ("loadparameterRecovery");
		bCheckDrivParam = true;
		bCheckParam = loadParameter("DataFiles\\Driving.ini", m_pParamSet);
		if(bCheckParam == false)

			OHTMainForm->m_CheckParamResult = ERR_PARADATA_LOAD_FAIL;
		else
			OHTMainForm->m_CheckParamResult = NO_ERR;

	}


    return bSuccess;
}


bool DrivingControl::saveParameter(char* szPath, DRIVING_PARAM_SET* pParamSet)
{
    bool bResult = false;

    LIniFile *m_lWriteIniFile;
    m_lWriteIniFile = NULL;
    m_lWriteIniFile = new LIniFile(szPath);


    if(!m_lWriteIniFile->GetIniFileExist())
    {
		delete m_lWriteIniFile;
		m_lWriteIniFile = NULL;
    }

    if(m_lWriteIniFile != NULL)
    {
        m_lWriteIniFile->DeleteIniFile();

        //1. [DRIVING_AXIS_PARAM]
//        m_lWriteIniFile->WriteDouble("AXIS","IdealGearRatio", pParamSet->Axis.GearRatio.dIdealGearRatio);
//        m_lWriteIniFile->WriteDouble("AXIS","Ideal2RealRatio", pParamSet->Axis.GearRatio.dIdeal2RealRatio);
		m_lWriteIniFile->WriteString("Version","IniVersion", pParamSet->Version);

        m_lWriteIniFile->WriteDouble("AXIS","AccelMin", pParamSet->Axis.Limit.Accel.MinValue);
		m_lWriteIniFile->WriteDouble("AXIS","AccelMax", pParamSet->Axis.Limit.Accel.MaxValue);
		m_lWriteIniFile->WriteDouble("AXIS","DecelMin", pParamSet->Axis.Limit.Decel.MinValue);
        m_lWriteIniFile->WriteDouble("AXIS","DecelMax", pParamSet->Axis.Limit.Decel.MaxValue);
        m_lWriteIniFile->WriteDouble("AXIS","SpeedMin", pParamSet->Axis.Limit.Speed.MinValue);
        m_lWriteIniFile->WriteDouble("AXIS","SpeedMax", pParamSet->Axis.Limit.Speed.MaxValue);
		m_lWriteIniFile->WriteDouble("AXIS","AbnormalMoveSpeedMargin", pParamSet->Axis.Limit.dAbnormalMoveSpeedMargin);
		m_lWriteIniFile->WriteDouble("AXIS","PositionMin", pParamSet->Axis.Limit.Position.MinValue);
        m_lWriteIniFile->WriteDouble("AXIS","PositionMax", pParamSet->Axis.Limit.Position.MaxValue);
        m_lWriteIniFile->WriteDouble("AXIS","JogPositionMin", pParamSet->Axis.Limit.JogPosition.MinValue);
        m_lWriteIniFile->WriteDouble("AXIS","JogPositionMax", pParamSet->Axis.Limit.JogPosition.MaxValue);
        m_lWriteIniFile->WriteDouble("AXIS","DefaultAccel", pParamSet->Axis.Default.dDefaultAccel);
        m_lWriteIniFile->WriteDouble("AXIS","DefaultDecel", pParamSet->Axis.Default.dDefaultDecel);
        m_lWriteIniFile->WriteDouble("AXIS","EmergencyDecel", pParamSet->Axis.Default.dEmergencyDecel);

        //2. [DRIVING_MARK_PARAM]

        //MARK0
        m_lWriteIniFile->WriteInteger("MARK0","Type", pParamSet->Mark[0].Type);
        m_lWriteIniFile->WriteDouble("MARK0","MarginToTarget", pParamSet->Mark[0].Dist.dMarginToTarget);
        m_lWriteIniFile->WriteDouble("MARK0","DistFromFirstToSecond", pParamSet->Mark[0].Dist.dDistFromFirstToSecond );
        m_lWriteIniFile->WriteDouble("MARK0","LengthOfSecond", pParamSet->Mark[0].Dist.dLengthOfSecond);
        m_lWriteIniFile->WriteDouble("MARK0","AddDistAfterFirstMet", pParamSet->Mark[0].Dist.dAddDistAfetrFirstMet);
        m_lWriteIniFile->WriteDouble("MARK0","AddDistAfterSecondMet", pParamSet->Mark[0].Dist.dAddDistAfterSecondMet);
        m_lWriteIniFile->WriteDouble("MARK0","ForwardMoveDistLimit", pParamSet->Mark[0].Dist.dForwardMoveDistLimit);
        m_lWriteIniFile->WriteDouble("MARK0","BackMoveDistLimit", pParamSet->Mark[0].Dist.dBackMoveDistLimit);
        m_lWriteIniFile->WriteDouble("MARK0","MarkInPosLimit", pParamSet->Mark[0].Dist.dMarkInPosLimit);
        m_lWriteIniFile->WriteDouble("MARK0","MinLengthToNext", pParamSet->Mark[0].Dist.dMinLengthToNext);
		m_lWriteIniFile->WriteDouble("MARK0","IgnoreTagDist", pParamSet->Mark[0].Dist.dIgnoreTagDist);
        m_lWriteIniFile->WriteDouble("MARK0","SpeedInFirstMet", pParamSet->Mark[0].Speed.dOfFirstMet);
        m_lWriteIniFile->WriteDouble("MARK0","SpeedInSecondMet",pParamSet->Mark[0].Speed.dOfSecondMet);
        m_lWriteIniFile->WriteDouble("MARK0","AccelInFirstMet", pParamSet->Mark[0].Accel.dOfFirstMet);
        m_lWriteIniFile->WriteDouble("MARK0","AccelInSecondMet", pParamSet->Mark[0].Accel.dOfSecondMet);

        //MARK1
        m_lWriteIniFile->WriteInteger("MARK1","Type", pParamSet->Mark[1].Type);
        m_lWriteIniFile->WriteDouble("MARK1","MarginToTarget", pParamSet->Mark[1].Dist.dMarginToTarget);
        m_lWriteIniFile->WriteDouble("MARK1","DistFromFirstToSecond", pParamSet->Mark[1].Dist.dDistFromFirstToSecond );
        m_lWriteIniFile->WriteDouble("MARK1","LengthOfSecond", pParamSet->Mark[1].Dist.dLengthOfSecond);
        m_lWriteIniFile->WriteDouble("MARK1","AddDistAfterFirstMet", pParamSet->Mark[1].Dist.dAddDistAfetrFirstMet);
        m_lWriteIniFile->WriteDouble("MARK1","AddDistAfterSecondMet", pParamSet->Mark[1].Dist.dAddDistAfterSecondMet);
        m_lWriteIniFile->WriteDouble("MARK1","ForwardMoveDistLimit", pParamSet->Mark[1].Dist.dForwardMoveDistLimit);
        m_lWriteIniFile->WriteDouble("MARK1","BackMoveDistLimit", pParamSet->Mark[1].Dist.dBackMoveDistLimit);
        m_lWriteIniFile->WriteDouble("MARK1","MarkInPosLimit", pParamSet->Mark[1].Dist.dMarkInPosLimit);
        m_lWriteIniFile->WriteDouble("MARK1","MinLengthToNext", pParamSet->Mark[1].Dist.dMinLengthToNext);
		m_lWriteIniFile->WriteDouble("MARK1","IgnoreTagDist", pParamSet->Mark[1].Dist.dIgnoreTagDist);
        m_lWriteIniFile->WriteDouble("MARK1","SpeedInFirstMet", pParamSet->Mark[1].Speed.dOfFirstMet);
        m_lWriteIniFile->WriteDouble("MARK1","SpeedInSecondMet",pParamSet->Mark[1].Speed.dOfSecondMet);
        m_lWriteIniFile->WriteDouble("MARK1","AccelInFirstMet", pParamSet->Mark[1].Accel.dOfFirstMet);
        m_lWriteIniFile->WriteDouble("MARK1","AccelInSecondMet", pParamSet->Mark[1].Accel.dOfSecondMet);

        //MARK2
		m_lWriteIniFile->WriteInteger("MARK2","Type", pParamSet->Mark[2].Type);
		m_lWriteIniFile->WriteInteger("MARK2","MakerType", pParamSet->Mark[2].MakerType);
        m_lWriteIniFile->WriteDouble("MARK2","MarginToTarget", pParamSet->Mark[2].Dist.dMarginToTarget);
        m_lWriteIniFile->WriteDouble("MARK2","DistFromFirstToSecond", pParamSet->Mark[2].Dist.dDistFromFirstToSecond );
        m_lWriteIniFile->WriteDouble("MARK2","LengthOfSecond", pParamSet->Mark[2].Dist.dLengthOfSecond);
        m_lWriteIniFile->WriteDouble("MARK2","AddDistAfterFirstMet", pParamSet->Mark[2].Dist.dAddDistAfetrFirstMet);
        m_lWriteIniFile->WriteDouble("MARK2","AddDistAfterSecondMet", pParamSet->Mark[2].Dist.dAddDistAfterSecondMet);
        m_lWriteIniFile->WriteDouble("MARK2","ForwardMoveDistLimit", pParamSet->Mark[2].Dist.dForwardMoveDistLimit);
        m_lWriteIniFile->WriteDouble("MARK2","BackMoveDistLimit", pParamSet->Mark[2].Dist.dBackMoveDistLimit);
        m_lWriteIniFile->WriteDouble("MARK2","MarkInPosLimit", pParamSet->Mark[2].Dist.dMarkInPosLimit);
        m_lWriteIniFile->WriteDouble("MARK2","MinLengthToNext", pParamSet->Mark[2].Dist.dMinLengthToNext);
		m_lWriteIniFile->WriteDouble("MARK2","IgnoreTagDist", pParamSet->Mark[2].Dist.dIgnoreTagDist);
        m_lWriteIniFile->WriteDouble("MARK2","SpeedInFirstMet", pParamSet->Mark[2].Speed.dOfFirstMet);
        m_lWriteIniFile->WriteDouble("MARK2","SpeedInSecondMet",pParamSet->Mark[2].Speed.dOfSecondMet);
        m_lWriteIniFile->WriteDouble("MARK2","AccelInFirstMet", pParamSet->Mark[2].Accel.dOfFirstMet);
        m_lWriteIniFile->WriteDouble("MARK2","AccelInSecondMet", pParamSet->Mark[2].Accel.dOfSecondMet);

        //MARK3
		m_lWriteIniFile->WriteInteger("MARK3","Type", pParamSet->Mark[3].Type);
		m_lWriteIniFile->WriteInteger("MARK3","MakerType", pParamSet->Mark[3].MakerType);
        m_lWriteIniFile->WriteDouble("MARK3","MarginToTarget", pParamSet->Mark[3].Dist.dMarginToTarget);
        m_lWriteIniFile->WriteDouble("MARK3","DistFromFirstToSecond", pParamSet->Mark[3].Dist.dDistFromFirstToSecond );
        m_lWriteIniFile->WriteDouble("MARK3","LengthOfSecond", pParamSet->Mark[3].Dist.dLengthOfSecond);
        m_lWriteIniFile->WriteDouble("MARK3","AddDistAfterFirstMet", pParamSet->Mark[3].Dist.dAddDistAfetrFirstMet);
        m_lWriteIniFile->WriteDouble("MARK3","AddDistAfterSecondMet", pParamSet->Mark[3].Dist.dAddDistAfterSecondMet);
        m_lWriteIniFile->WriteDouble("MARK3","ForwardMoveDistLimit", pParamSet->Mark[3].Dist.dForwardMoveDistLimit);
        m_lWriteIniFile->WriteDouble("MARK3","BackMoveDistLimit", pParamSet->Mark[3].Dist.dBackMoveDistLimit);
        m_lWriteIniFile->WriteDouble("MARK3","MarkInPosLimit", pParamSet->Mark[3].Dist.dMarkInPosLimit);
        m_lWriteIniFile->WriteDouble("MARK3","MinLengthToNext", pParamSet->Mark[3].Dist.dMinLengthToNext);
		m_lWriteIniFile->WriteDouble("MARK3","IgnoreTagDist", pParamSet->Mark[3].Dist.dIgnoreTagDist);
        m_lWriteIniFile->WriteDouble("MARK3","SpeedInFirstMet", pParamSet->Mark[3].Speed.dOfFirstMet);
        m_lWriteIniFile->WriteDouble("MARK3","SpeedInSecondMet",pParamSet->Mark[3].Speed.dOfSecondMet);
        m_lWriteIniFile->WriteDouble("MARK3","AccelInFirstMet", pParamSet->Mark[3].Accel.dOfFirstMet);
        m_lWriteIniFile->WriteDouble("MARK3","AccelInSecondMet", pParamSet->Mark[3].Accel.dOfSecondMet);

        //3. [DRIVING_STEER_PARAM]
        m_lWriteIniFile->WriteInteger("STEER","ChangeTime", pParamSet->Steer.dwChangeTime);
        m_lWriteIniFile->WriteInteger("STEER","MovingTorqueTime", pParamSet->Steer.dwMovingTorqueTime);
        m_lWriteIniFile->WriteInteger("STEER","CompleteCheckTime", pParamSet->Steer.dwCompleteCheckTime);
        m_lWriteIniFile->WriteInteger("STEER","CompleteLimitTime", pParamSet->Steer.dwCompleteLimitTime);

        //4. [DRIVING_LINK_PARAM]
        m_lWriteIniFile->WriteDouble("LINK","OutNodeAreaMargin", pParamSet->Link.dOutNodeAreaMargin);
        m_lWriteIniFile->WriteDouble("LINK","NBranchMiddleAreaInMargin", pParamSet->Link.dNBranchMiddleAreaInMargin);

        //5. [DRIVING_FRONT_DETECT_PARAM]
        m_lWriteIniFile->WriteInteger("DETECT","DetectFailChatteringTime", pParamSet->FrontDetect.dwDetectFailChatteringTime);
        m_lWriteIniFile->WriteInteger("DETECT","ObsFailChatteringTime", pParamSet->FrontDetect.dwObsFailChatteringTime);
		m_lWriteIniFile->WriteInteger("DETECT","ObsTimeout", pParamSet->FrontDetect.dwObsTimeout);
		m_lWriteIniFile->WriteInteger("DETECT","ObsChangeTime", pParamSet->FrontDetect.dwObsChangeTime);
        m_lWriteIniFile->WriteDouble("DETECT","ObsStraightDetectMargin", pParamSet->FrontDetect.dObsStraightDetectMargin);

		//2 (5)Foup Cover PARAM
		m_lWriteIniFile->WriteInteger("FOUPCOVER","LineFoupChattering", pParamSet->FoupCover.nLineFoupChattering);
		m_lWriteIniFile->WriteInteger("FOUPCOVER","CurveFoupChattering", pParamSet->FoupCover.nCurveFoupChattering);
		m_lWriteIniFile->WriteInteger("FOUPCOVER","SPCurveFoupChattering", pParamSet->FoupCover.nSPCurveFoupChattering);

		m_lWriteIniFile->WriteDouble("STATION","StationMarkInPos", pParamSet->StationMarkInPos);
		m_lWriteIniFile->WriteInteger("STATION","MapMakerCount_Driving", pParamSet->MapMakerCount_Driving);
		m_lWriteIniFile->WriteInteger("STATION","MapMakerCount_Trans", pParamSet->MapMakerCount_Trans);

		m_lWriteIniFile->WriteDouble("STATION","MapMakerMargin_Gap", pParamSet->MapMakerMargin_Gap);
		m_lWriteIniFile->WriteDouble("STATION","ScatteredReflection", pParamSet->ScatteredReflection);
		m_lWriteIniFile->WriteDouble("STATION","ScatteredReflectionMax", pParamSet->ScatteredReflectionMax);

		m_lWriteIniFile->WriteBool("VHLLIFTER","OutPosDir", pParamSet->bVHLLifterDir);

		m_lWriteIniFile->WriteInteger("CID","CIDWaitingTimeout", pParamSet->CIDWaitingTimeout);
		//2 (6)CID PARAM
		m_lWriteIniFile->WriteInteger("CID","CID_PAUSE_TIMEOVER", pParamSet->CID_PAUSE_TIMEOVER);//미적용으로 Write 부분은 주석 처리


		m_lWriteIniFile->WriteInteger("LG","MTLWaitingTimeout", pParamSet->LightGuide_TIME_OUT_MS_MTL);
		m_lWriteIniFile->WriteInteger("LG","VHLLIFTERWaitingTimeout", pParamSet->LightGuide_TIME_OUT_MS_VHLLifter);
		m_lWriteIniFile->WriteInteger("LG","AUTODOORWaitingTimeout", pParamSet->LightGuide_TIME_OUT_MS_AutoDoor);

		delete m_lWriteIniFile;
		bResult = true;
	}

	return bResult;
}

/**
@brief  Map Make 작업 List 초기화
*/
void DrivingControl::ClearMapMakingInfo()
{
	//MapMaker 쓰레기 Data 삭제
	EXECUTE_RESPONSE_MAPMAKING_INFO *pStationInfo=NULL; //저장할 Map 구조체
	int nCountOfList = m_ListOfTmpStationData.getCount();
	for(int n=0; n<nCountOfList; n++)
	{
		pStationInfo = m_ListOfTmpStationData.popFront();
		delete pStationInfo;
	}

	nCountOfList = m_ListOfMapData.getCount();
	for(int n=0; n<nCountOfList; n++)
	{
		pStationInfo = m_ListOfMapData.popFront();
		delete pStationInfo;
	}
}

/**
@brief  주행 명령(pDrivingInfo)이 들어어오면 InfoList 에 정보 추가
@author  ehoto
@date    2013.7.19
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
EXECUTE_ACK DrivingControl::setStationOffset(void *pDrivingInfo)
{
    //bool bSuccess = true;
    EXECUTE_ACK TmpExecuteAck = EXECUTE_ACK_ON_ERR;

    EXECUTE_DRIVING_INFO *pTmpDrivingInfo=(EXECUTE_DRIVING_INFO *)pDrivingInfo;

    ADD_LOG("D_39/%d/%6d/%d/%6X/%d/%6.1lf/%6d/%6d"
        , pTmpDrivingInfo->AddInfo.CmdType
        , m_PreviousArrivalInfo.Info.uStation
        , m_PreviousArrivalInfo.Info.MarkType
        , pTmpDrivingInfo->AddInfo.StationID
        , pTmpDrivingInfo->AddInfo.StationType
        , pTmpDrivingInfo->AddInfo.DistToStation
        , pTmpDrivingInfo->BasicInfo.StartNID
        , pTmpDrivingInfo->BasicInfo.EndNID
        );

    if( (pTmpDrivingInfo->AddInfo.CmdType==EXECUTE_DRIVING_CMD_SET_STATION_OFFSET) )
//	&&  (m_PreviousArrivalInfo.Info.MarkType!=MARK_TYPE_NODE)   )
	{

		//2  현재 위치 정리
		if (m_PreviousArrivalInfo.Info.MarkType!=MARK_TYPE_OFFSET)
		{
			m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.bMarked          = true;
			m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.MarkType    = pTmpDrivingInfo->AddInfo.StationType;
			m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode       = pTmpDrivingInfo->BasicInfo.StartNID;
			m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uStation    = pTmpDrivingInfo->AddInfo.StationID;
			m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNextNode   = pTmpDrivingInfo->BasicInfo.EndNID;
			m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset     = pTmpDrivingInfo->AddInfo.DistToStation;
			m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.uRealArrivedNode = pTmpDrivingInfo->BasicInfo.StartNID;
		}else
		{
			m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.bMarked          = false;
			m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.MarkType    = pTmpDrivingInfo->AddInfo.StationType;
			m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode       = pTmpDrivingInfo->BasicInfo.StartNID;
//			m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uStation    = pTmpDrivingInfo->AddInfo.StationID;
//			m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNextNode   = pTmpDrivingInfo->BasicInfo.EndNID;
			m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset     = pTmpDrivingInfo->AddInfo.DistToStation;
			m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.uRealArrivedNode = pTmpDrivingInfo->BasicInfo.StartNID;
        }

		//2 마크 정보로 정리
        m_InfoSet.Position.Mark.dFrontPosition  = m_pDrivingAxis->GetCurrentPosition();
        m_InfoSet.Position.Mark.dRearPosition   = m_pDrivingAxis->m_pSlaveAxis->GetCurrentPosition();
        m_InfoSet.Position.Mark.PositionStatus  = m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus;

        //2 마크 정보를 멤버변수로 저장
        setPreviousArrivalInfo(m_InfoSet.Position.Mark.PositionStatus);
        getPostionInfoOnMarked(m_InfoSet, &m_PositionInfo);

        ADD_LOG("D_40/%d/%d/%d/%6d/%6d/%6.1lf/%6d/%6.1lf/%6.1lf"
            , m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.bMarked
            , m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.MarkType
            , m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uStation
            , m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode
            , m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNextNode
            , m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset
            , m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.uRealArrivedNode
            , m_InfoSet.Position.Mark.dFrontPosition
            , m_InfoSet.Position.Mark.dRearPosition
            );

        TmpExecuteAck = EXECUTE_ACK_NO_ERR;
    }
    else
    {
        TmpExecuteAck = EXECUTE_ACK_NOT_AVAILABLE_CMD;
        ADD_LOG("D-53");
    }

    return TmpExecuteAck;
}


/**
@brief  주행 명령(pDrivingInfo)이 MapMake 인지 확인
@author  임태웅
@date    2013.9.1
@return MapMake면 true 반환, 아니면 false 반환
*/
bool DrivingControl::isMapMake(void *pDrivingInfo)
{
    bool bIsMapMake = false;
	EXECUTE_DRIVING_INFO *pTmpDrivingInfo=(EXECUTE_DRIVING_INFO *)pDrivingInfo;


	if(pTmpDrivingInfo->AddInfo.CmdType == EXECUTE_DRIVING_CMD_MAPMAKE)
    {
		bIsMapMake = true;

		memmove(&m_bMapMakeType, &(pTmpDrivingInfo->AddInfo.MapMakeType), 1);

    }

    return bIsMapMake;
}

/**
@brief  주행 명령(pDrivingInfo)이 MapMake 인지 확인
@author  임태웅
@date    2013.9.1
@return MapMake면 true 반환, 아니면 false 반환
*/
bool DrivingControl::isBackMove(void *pDrivingInfo)
{
    bool bIsBack = false;
	EXECUTE_DRIVING_INFO *pTmpDrivingInfo=(EXECUTE_DRIVING_INFO *)pDrivingInfo;


	if(pTmpDrivingInfo->AddInfo.CmdType == EXECUTE_DRIVING_CMD_GOBACK)
    {
		bIsBack = true;

	   //	memmove(&m_bMapMakeType, &(pTmpDrivingInfo->AddInfo.MapMakeType), 1);

    }

	return bIsBack;
}






/**
@brief  주행 명령(pDrivingInfo)이 들어어오면 InfoList 에 정보 추가
@author  ehoto
@date    2013.7.19
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
EXECUTE_ACK DrivingControl::makeCmdInfoLists(void *pDrivingInfo)
{
	const int nCount = 6;
    bool abSuccess[nCount] ={false,};
    bool bSuccess = true;
    EXECUTE_ACK TmpExecuteAck = EXECUTE_ACK_ON_ERR;

	EXECUTE_DRIVING_INFO *pTmpDrivingInfo=(EXECUTE_DRIVING_INFO *)pDrivingInfo;
    m_LastDrivingCmdInfo = *pTmpDrivingInfo;
    EXECUTE_DRIVING_ADD_INFO AddInfo = pTmpDrivingInfo->AddInfo;
	DRIVING_CMD_INFO_OF_PATH *pLastPathInfo = NULL;
	DRIVING_CMD_INFO_OF_PATH TmpPathInfo;
	DRIVING_CMD_INFO_OF_TARGET TmpTargetInfo;
	memset(&TmpTargetInfo, 0x00, sizeof(DRIVING_CMD_INFO_OF_TARGET));

//   ADD_LOG("D_41/%d/%d", 1, pTmpDrivingInfo->PathIndexNum);

	//1 TmpPathInfo 획득
//	ADD_LOG("D_42/%d",m_ClassifiedCmd.PathList.getCount());
	if(m_ClassifiedCmd.PathList.getCount()==0)
	{
		TmpPathInfo = pTmpDrivingInfo->BasicInfo;

//		if(m_PositionInfo.CurrNode != pTmpDrivingInfo->BasicInfo.StartNID)
//          	return EXECUTE_ACK_ON_ERR;


		if((pTmpDrivingInfo->PathIndexNum ==0) &&
		   (AddInfo.ProcessingGoInfo.IsStationStart ==true))
		{
			TmpPathInfo.dDistSumToEndNode = TmpPathInfo.dLength + AddInfo.ProcessingGoInfo.StationData_StartRunDistOfNextNode;
//			ADD_LOG("D_43/%d/%d",TmpPathInfo.dLength,AddInfo.ProcessingGoInfo.StationData_StartRunDistOfNextNode);
			if(AddInfo.ProcessingGoInfo.StationData_StartRunDistOfNextNode < POSITION_TO_CHECK_FIRST_NODE)
				TmpPathInfo.nCount = 1;
			else
				TmpPathInfo.nCount = 2;
		}
		else
		{
			TmpPathInfo.dDistSumToEndNode = TmpPathInfo.dLength;
			TmpPathInfo.nCount = 1;
		}

//		ADD_LOG("D_44/%f/%f/%f", TmpPathInfo.dDistSumToEndNode,TmpPathInfo.dLength,AddInfo.DistToStation);


    }
    else
	{

//		ADD_LOG("D_45/%d",m_ClassifiedCmd.PathList.getCount());
		pLastPathInfo = (DRIVING_CMD_INFO_OF_PATH*)m_ClassifiedCmd.PathList.referBack();

//      ADD_LOG("D_46/%X/%X/%X/%X"
//          , pLastPathInfo->StartNID, pLastPathInfo->EndNID
//          , pTmpDrivingInfo->BasicInfo.StartNID, pTmpDrivingInfo->BasicInfo.EndNID);

        // 연속되는 Path
        if( pLastPathInfo->EndNID==pTmpDrivingInfo->BasicInfo.StartNID)
        {
            TmpPathInfo = pTmpDrivingInfo->BasicInfo;
			TmpPathInfo.dDistSumToEndNode = pLastPathInfo->dDistSumToEndNode + TmpPathInfo.dLength;
            TmpPathInfo.nCount = pLastPathInfo->nCount + 1;
		}
        // 동일 Path도 아닌 경우
        else if(    (pLastPathInfo->StartNID!=pTmpDrivingInfo->BasicInfo.StartNID)
		 ||         (pLastPathInfo->EndNID!=pTmpDrivingInfo->BasicInfo.EndNID)
         )
        {
			return EXECUTE_ACK_ON_ERR;  // 이상 명령: 연속되지도 않고, 동일 Path에서 Station 이 변경 되는 명령도 아님
		}
    }


//  ADD_LOG("D_47/%d/%d", 2, TmpExecuteAck);


    //1 TmpTargetInfo 획득
	TmpTargetInfo.Type = AddInfo.StationType;


   //	ADD_LOG("D_48/%d", TmpTargetInfo.Type);
	if(TmpTargetInfo.Type==MARK_TYPE_NODE)
	{
		TmpTargetInfo.Node = TmpPathInfo.EndNID;
		TmpTargetInfo.dDistSumToNode = TmpPathInfo.dDistSumToEndNode;
		TmpTargetInfo.nCount = TmpPathInfo.nCount;
//		TmpTargetInfo.PassBoxIn = (AddInfo.FinalPortType == GO_FINAL_PORT_TYPE_PassBoxIn)?true:false;
	}
	else
	{
		TmpTargetInfo.Node = TmpPathInfo.StartNID;
		TmpTargetInfo.dDistSumToNode = TmpPathInfo.dDistSumToEndNode - TmpPathInfo.dLength;
		TmpTargetInfo.nCount = TmpPathInfo.nCount;
		TmpTargetInfo.Station = AddInfo.StationID;
		TmpTargetInfo.PhysicalStation = AddInfo.PhysicalID;
		TmpTargetInfo.dOffset = AddInfo.DistToStation;
		TmpTargetInfo.StationSafetyLevel = AddInfo.StationSafetyLevel;
		TmpTargetInfo.bIgnolOverRun = AddInfo.bIgnolOverRun;
		TmpTargetInfo.NextNode= TmpPathInfo.EndNID;
		TmpTargetInfo.dLength = TmpPathInfo.dLength;
		TmpTargetInfo.Steering = TmpPathInfo.Steering;

		TmpTargetInfo.dSTBOffset = AddInfo.STBOffset;
	}

//  ADD_LOG("D_49/%d/%d", 3, TmpExecuteAck);


	//1 명령 분류
	abSuccess[0] = makeList(&(m_ClassifiedCmd.NodeList), TmpPathInfo);
	abSuccess[1] = makeList(&(m_ClassifiedCmd.SteerList), TmpPathInfo);
	abSuccess[2] = makeList(&(m_ClassifiedCmd.DirectionList), TmpPathInfo);
	abSuccess[3] = makeList(&(m_ClassifiedCmd.SpeedlList), TmpPathInfo, TmpTargetInfo);
	abSuccess[4] = makeList(&(m_ClassifiedCmd.PathList), TmpPathInfo);
	abSuccess[5] = makeList(&(m_ClassifiedCmd.DivList), TmpPathInfo);

//  ADD_LOG("D_50/%d/%d", 4, TmpExecuteAck);



	//1 성공 여부 확인
	for(int n=0; n<nCount; n++)
	{
		bSuccess = bSuccess & abSuccess[n];
	}



//  ADD_LOG("D_51/%d/%d", 5, TmpExecuteAck);

	//1 최종 목적지 정보 입력
	if(bSuccess==true)
	{
		m_ClassifiedCmd.TargetInfo=TmpTargetInfo;
		TmpExecuteAck = EXECUTE_ACK_NO_ERR;
	}
	else
	{
		ADD_LOG("D_52/%d/%d/%d/%d/%d/%d", bSuccess, abSuccess[0], abSuccess[1], abSuccess[2], abSuccess[3], abSuccess[4]);
	}


//  ADD_LOG("D_53/%d/%d", 6, TmpExecuteAck);

	ADD_LOG("D_54/%d/%5.1lf/%d/%d/%5.1lf/%d/%d/%d/%5.1lf/%5.1lf/%d/%d/%5.1lf/%5.1lf/%d"
		, TmpPathInfo.nCount
		, TmpPathInfo.dSpeed
		, TmpPathInfo.Steering
		, TmpPathInfo.PreSteering
		, TmpPathInfo.dDistSumToEndNode
		, TmpPathInfo.EndNID
		, TmpTargetInfo.Station
		, TmpTargetInfo.PassBoxIn
		, TmpPathInfo.dLength
		, TmpTargetInfo.dOffset
		, m_ClassifiedCmd.PathList.getCount()
		, AddInfo.StationType
		, AddInfo.DistToStation
		, AddInfo.DistOffsetForStartFromStation
		, AddInfo.StationSafetyLevel
        );

	if(TmpTargetInfo.Station != 0)
	{
		m_mccparam.uTargetNode = TmpTargetInfo.Station;
	}
	else
	{
		m_mccparam.uTargetNode = TmpPathInfo.EndNID;
    }

//  ADD_LOG("D_55/%d/%d", 7, TmpExecuteAck);

	// CID 4분기 처리용 정보 get
	CID_4WAY_CONTROL_INFO.bLoadUnload = pTmpDrivingInfo->AddInfo.ProcessingGoInfo.IsStationEnd; // 이적재 유무. true : 이적재 한다. false : 이적재 하지 않음
	CID_4WAY_CONTROL_INFO.tmpLastCMDID = pTmpDrivingInfo->AddInfo.ProcessingGoInfo.EndNodeID;   // 최종 타겟

    return TmpExecuteAck;
}


/**
@brief  주행 명령(pDrivingInfo)이 들어어오면 InfoList 에 정보 추가
@author  ehoto
@date    2013.7.19
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
EXECUTE_ACK DrivingControl::makeCmdInfoListsBack(void *pDrivingInfo)
{
    const int nCount = 6;
    bool abSuccess[nCount] ={false,};
    bool bSuccess = true;
    EXECUTE_ACK TmpExecuteAck = EXECUTE_ACK_ON_ERR;

	EXECUTE_DRIVING_INFO *pTmpDrivingInfo=(EXECUTE_DRIVING_INFO *)pDrivingInfo;
    m_LastDrivingCmdInfo = *pTmpDrivingInfo;
    EXECUTE_DRIVING_ADD_INFO AddInfo = pTmpDrivingInfo->AddInfo;
	DRIVING_CMD_INFO_OF_PATH *pLastPathInfo = NULL;
	DRIVING_CMD_INFO_OF_PATH TmpPathInfo;
    DRIVING_CMD_INFO_OF_TARGET TmpTargetInfo;
	memset(&TmpTargetInfo, 0x00, sizeof(DRIVING_CMD_INFO_OF_TARGET));

//   ADD_LOG("D_56/%d/%d", 1, pTmpDrivingInfo->PathIndexNum);

	//1 TmpPathInfo 획득
	ADD_LOG("D_57/%d",m_ClassifiedCmd.PathList.getCount());
    if(m_ClassifiedCmd.PathList.getCount()==0)
	{
		TmpPathInfo = pTmpDrivingInfo->BasicInfo;
		TmpPathInfo.dDistSumToEndNode = -TmpPathInfo.dLength;
		TmpPathInfo.nCount = 1;

		ADD_LOG("D_58/%f/%f/%f", TmpPathInfo.dDistSumToEndNode,TmpPathInfo.dLength,AddInfo.DistToStation);
     }
    else
	{

		ADD_LOG("D_59/%d",m_ClassifiedCmd.PathList.getCount());
		pLastPathInfo = (DRIVING_CMD_INFO_OF_PATH*)m_ClassifiedCmd.PathList.referBack();

		// 연속되는 Path 기존 1-2, 2-3  3-4  ->  3-4 2-3 1-2   puting 2016 11 01
		if( pLastPathInfo->StartNID==pTmpDrivingInfo->BasicInfo.EndNID)
        {
            TmpPathInfo = pTmpDrivingInfo->BasicInfo;
			TmpPathInfo.dDistSumToEndNode = pLastPathInfo->dDistSumToEndNode - TmpPathInfo.dLength;
            TmpPathInfo.nCount = pLastPathInfo->nCount + 1;
		}
        // 동일 Path도 아닌 경우
        else if(    (pLastPathInfo->EndNID!=pTmpDrivingInfo->BasicInfo.EndNID)
		 ||         (pLastPathInfo->EndNID!=pTmpDrivingInfo->BasicInfo.StartNID)
         )
        {
            return EXECUTE_ACK_ON_ERR;  // 이상 명령: 연속되지도 않고, 동일 Path에서 Station 이 변경 되는 명령도 아님
        }
    }

    //1 TmpTargetInfo 획득
	TmpTargetInfo.Type = AddInfo.StationType;

//	ADD_LOG("D_60/%d", TmpTargetInfo.Type);
	if(TmpTargetInfo.Type==MARK_TYPE_NODE)
	{
//		TmpTargetInfo.Node = TmpPathInfo.EndNID;
//		TmpTargetInfo.dDistSumToNode = TmpPathInfo.dDistSumToEndNode;
//		TmpTargetInfo.nCount = TmpPathInfo.nCount;
  		return EXECUTE_ACK_ON_ERR;  // 이상 명령: 연속되지도 않고, 동일 Path에서 Station 이 변경 되는 명령도 아님

	}
	else
	{
		TmpTargetInfo.Node = TmpPathInfo.StartNID;
		TmpTargetInfo.dDistSumToNode = TmpPathInfo.dDistSumToEndNode;   //MTL 후진용
		TmpTargetInfo.nCount = TmpPathInfo.nCount;
		TmpTargetInfo.Station = AddInfo.StationID;
		TmpTargetInfo.dOffset = AddInfo.DistToStation;
		TmpTargetInfo.NextNode= TmpPathInfo.EndNID;
		TmpTargetInfo.dLength = TmpPathInfo.dLength;
		TmpTargetInfo.Steering = TmpPathInfo.Steering;

		TmpTargetInfo.dSTBOffset = AddInfo.STBOffset;
	}

	ADD_LOG("D_61/%d/%f/%f/%f",
	TmpTargetInfo.Station, TmpPathInfo.dDistSumToEndNode,TmpPathInfo.dLength,TmpTargetInfo.dOffset);


//  ADD_LOG("D_62/%d/%d", 3, TmpExecuteAck);


    //1 명령 분류
    abSuccess[0] = makeBackList(&(m_ClassifiedCmd.NodeList), TmpPathInfo);
    abSuccess[1] = makeList(&(m_ClassifiedCmd.SteerList), TmpPathInfo);
    abSuccess[2] = makeList(&(m_ClassifiedCmd.DirectionList), TmpPathInfo);
	abSuccess[3] = makeBackList(&(m_ClassifiedCmd.SpeedlList), TmpPathInfo, TmpTargetInfo);
	abSuccess[4] = makeBackList(&(m_ClassifiedCmd.PathList), TmpPathInfo);
	abSuccess[5] = makeList(&(m_ClassifiedCmd.DivList), TmpPathInfo);

//  ADD_LOG("D_63/%d/%d", 4, TmpExecuteAck);



    //1 성공 여부 확인
    for(int n=0; n<nCount; n++)
    {
        bSuccess = bSuccess & abSuccess[n];
    }



//  ADD_LOG("D_64/%d/%d", 5, TmpExecuteAck);

	//1 최종 목적지 정보 입력
    if(bSuccess==true)
    {
		m_ClassifiedCmd.TargetInfo=TmpTargetInfo;
		TmpExecuteAck = EXECUTE_ACK_NO_ERR;
    }
    else
    {
        ADD_LOG("D_65/%d/%d/%d/%d/%d/%d", bSuccess, abSuccess[0], abSuccess[1], abSuccess[2], abSuccess[3], abSuccess[4]);
    }


//  ADD_LOG("D_66/%d/%d", 6, TmpExecuteAck);

	m_InfoSet.EventAndState.Event.CmdAdded = true;

	ADD_LOG("D_67/%d/%5.1lf/%d/%d/%5.1lf/%d/%d/%d/%d/%d/%5.1lf/%5.1lf"
        , TmpPathInfo.nCount
        , TmpPathInfo.dSpeed
        , TmpPathInfo.Steering
        , TmpPathInfo.PreSteering
        , TmpPathInfo.dDistSumToEndNode
        , TmpPathInfo.EndNID
		, TmpTargetInfo.Station
        , TmpTargetInfo.PassBoxIn
        , m_ClassifiedCmd.PathList.getCount()
		, AddInfo.StationType
		, AddInfo.DistToStation
		, AddInfo.DistOffsetForStartFromStation
        );

//  ADD_LOG("D_68/%d/%d", 7, TmpExecuteAck);



    return TmpExecuteAck;
}


/**
@brief   파라미터를 업데이트 하는 함수
@author  임태웅
@date    2013.7.19
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
bool DrivingControl::updateParameter()
{
    DRIVING_PARAM_SET* pTmpParamSet;

    if(m_pTmpParamSet!=NULL)
    {
        pTmpParamSet = m_pParamSet;
        m_pParamSet = m_pTmpParamSet;
        m_pTmpParamSet = NULL;
        delete pTmpParamSet;
        return true;
    }
    else
    {
        return false;
    }
}

/**
@brief   StatusSet 정보를 초기화하는 함수
@author  임태웅
@date    2013.7.29
*/
void DrivingControl::initStatusSet()
{
    m_StatusSet.byStatus = STS_INIT;
    m_StatusSet.uError = NO_ERR;
    m_StatusSet.bIsOnProcess = false;
    m_StatusSet.uStep = 0;
}

/**
@brief   명령 정보를 초기화하는 함수
@author  임태웅
@date    2013.7.29
*/
void DrivingControl::initCommandSet()
{
    int nTestNum = 0;
    try
    {
        m_QuickCmd = EXECUTE_QUICK_CMD_NONE;
        nTestNum = 0;
        clearCmdInfoLists();
        nTestNum = 1;
    }
    catch(...)
    {
        ERR_LOG("initCommandSet Err Step : %d", nTestNum);
    }
}

/**
@brief   주행 관련 HW 정보를 초기화하는 함수
@author  임태웅
@date    2013.7.29
*/
void DrivingControl::initInfoSet()
{
    memset(&m_InfoSet, 0, sizeof(DRIVING_INFO_SET));

    // 최초 명령이 적용되기 위해 설정하는 초기 값
    m_InfoSet.Position.CmdRefInfo.dCmdSpeed = m_pParamSet->Axis.Limit.Speed.MaxValue;
    m_InfoSet.Position.CmdRefInfo.dSpeedDownPos = -1000;

	m_dPreNodecount = 0;
	m_bFirstNodeStep = false;

	DRIVING_HW_INFO_SET HwInfo = getHWInfo();
	m_InfoSet.HwInfo.IO = HwInfo.IO;

    m_InfoSet.Steer.FrontCmdDirection   = m_InfoSet.HwInfo.IO.SteerFrontDirCmd;
	m_InfoSet.Steer.RearCmdDirection    = m_InfoSet.HwInfo.IO.SteerRearDirCmd;

	m_pExecuteInfo->FlagMTLInfo.nTakeOut =0x00;
	m_pExecuteInfo->FlagMTLInfo.bTakeoutCycle  =false;
	m_pExecuteInfo->dCompensatedPosition = 0.0;

	//MCC Parameter 초기화
	m_mccparam.nFoupCoverDetectCount = 0;
	m_mccparam.nInnerFOUPDetectCount = 0;
	m_mccparam.nInnerFOUPNotDetectCount = 0;
	m_mccparam.nShiftHomeSenOffCount = 0;
	m_mccparam.nHoistHomeSenOffCount = 0;
	m_mccparam.nShutterFrontOpenCount = 0;
	m_mccparam.nShutterFrontCloseCount = 0;
	m_mccparam.nShutterRearOpenCount = 0;
	m_mccparam.nShutterRearCloseCount = 0;

	m_mccparam.dwSteerFrontTime = 0;
	m_mccparam.dwSteerRearTime = 0;
	m_mccparam.dwShutterFrontTime = 0;
	m_mccparam.dwShutterRearTime = 0;

	m_mccparam.nSteerFrontTime = 0;
	m_mccparam.nSteerRearTime = 0;
	m_mccparam.nShutterFrontTime = 0;
	m_mccparam.nShutterRearTime = 0;
	m_mccparam.bShutterFrontAlarm = 0;
	m_mccparam.bShutterRearAlarm = 0;

	m_mccparam.bSteerFrontLeftFlag = false;
	m_mccparam.bSteerRearLeftFlag = false;
	m_mccparam.bSteerFrontRightFlag = false;
	m_mccparam.bSteerRearRightFlag = false;
	m_mccparam.bDetectStatus = false;
	m_mccparam.bMarkStartFlag = false;
	m_mccparam.bBCRReadFail = false;
	m_mccparam.bFrontShutterFlag = false;
	m_mccparam.bRearShutterFlag = false;
	m_mccparam.bAbnormalStopFlag = false;

	m_mccparam.dwOBSDetectTime = 0;
	m_mccparam.dwUBGDetectTime = 0;

	m_mccparam.nCIDLinkOnTime = 0;

	m_mccparam.nCIDMapOffset = 0;
	m_mccparam.nCIDLinkOffset = 0;
	m_mccparam.nCIDLinkStartPosition = 0;

	m_mccparam.nCIDLinkNode = 0;
    m_mccparam.nCIDLinkStartNode = 0;
	m_mccparam.nCIDLinkNodeOffset = 0;

	m_mccparam.dUBGDetectStopDistance = 0.0;
	m_mccparam.dUBGDetectStopPoint = 0.0;

	m_mccparam.nPreCount = 0;
	m_mccparam.nNodeCount = 0;
	m_mccparam.nBCRTriggerCount = 0;
	m_mccparam.bFStopOnStartPos = false;

	m_mccparam.uSourceNode = 0;
	m_mccparam.uTargetNode = 0;

	m_mccparam.bSteerTimeCheckFlag = false;
	m_mccparam.dwSteerFTRQ0OnTime = 0;
	m_mccparam.dwSteerFTRQ0OffTime = 0;
	m_mccparam.dwSteerRTRQ0OnTime = 0;
	m_mccparam.dwSteerRTRQ0OffTime = 0;
	m_mccparam.dwSteerFDIROnTime = 0;
	m_mccparam.dwSteerFTDIROffTime = 0;
	m_mccparam.dwSteerRDIROnTime = 0;
	m_mccparam.dwSteerRDIROffTime = 0;
	m_mccparam.dwSteerFLeftOnTime = 0;
	m_mccparam.dwSteerFLeftOffTime = 0;
	m_mccparam.dwSteerFRightOnTime = 0;
	m_mccparam.dwSteerFRightOffTime = 0;
	m_mccparam.dwSteerRLeftOnTime = 0;
	m_mccparam.dwSteerRLeftOffTime = 0;
	m_mccparam.dwSteerRRightOnTime = 0;
	m_mccparam.dwSteerRRightOffTime = 0;

	m_mccparam.nSteerFrontHauntingCount = 0;
	m_mccparam.nSteerRearHauntingCount = 0;

	m_mccparam.bNodeDetectFlag = false;
	m_mccparam.dwNodeDetectDelay = 0;

	m_mccparam.cSteerFrontStatus = ' ';
	m_mccparam.cSteerRearStatus = ' ';

	m_mccparam.dMarkFirstDetectSpeed = 0.0;
	m_mccparam.dMarkSecondDetectSpeed = 0.0;

	m_mccparam.bMarkingOHTDetectStop = false;

	m_mccparam.nOBSMaxOnSteering = 0;
	m_mccparam.nOBSMinOnSteering = 8;
	m_mccparam.nUBGMaxOnSteering = 0;
	m_mccparam.nUBGMinOnSteering = 8;

	m_mccparam.nOHTDetectArea = 15;
	m_mccparam.nOHTDetectLevel = 0;
	m_mccparam.nOBSDetectArea = 15;
	m_mccparam.nOBSDetectLevel = 0;
	m_mccparam.dwOHTDetectAreaTime = timeGetTime();//0.0;
	m_mccparam.dwOHTDetectLevelTime = timeGetTime();//0.0;
	m_mccparam.dwOBSDetectAreaTime = timeGetTime();//0.0;
	m_mccparam.dwOBSDetectLevelTime = timeGetTime();//0.0;
	m_mccparam.dwOHTDetectLevelFailTime = timeGetTime();//0.0;
	m_mccparam.nPathSteering = 0;
	m_mccparam.bOHTDetectFail2Flag = false;

	memset(m_mccparam.cCarrierType, 0, 10);
	switch(m_pOHTMainStatus->StatusCommon.CarrierType)
	{
		case CARRIER_NOTDEFINED:
			sprintf(m_mccparam.cCarrierType,"None");
			break;
		case CARRIER_FOUP:
			sprintf(m_mccparam.cCarrierType,"FOUP");
			break;
		case CARRIER_POD:
			sprintf(m_mccparam.cCarrierType,"POD");
			break;
		case CARRIER_EUV:
			sprintf(m_mccparam.cCarrierType,"EUV");
			break;
		case CARRIER_MAC:
			sprintf(m_mccparam.cCarrierType,"MAC");
			break;
		case CARRIER_FOSB:
			sprintf(m_mccparam.cCarrierType,"FOSB");
			break;
	}

	m_mccparam.uPreNode = 0;
	m_mccparam.uFromStation = 0;

	m_mccparam.nHandInpositionOffCount = 0;
	m_mccparam.nHandAlarmOffCount = 0;
	m_mccparam.nHandRightGripOffCount = 0;
	m_mccparam.nHandLeftGripOffCount = 0;
	m_mccparam.nHandCloseOffCount = 0;
	m_mccparam.nHandOpenOffCount = 0;
	m_mccparam.nHandPIOOffCount = 0;

	m_bFDCMarkFailFlag = true;
	m_bFDCEarlyPathFlag = true;
	m_bFDCLatePathFlag = true;
}

/**
@brief   마지막 도착 정보(다음 출발의 기준점)를 초기화하는 함수
@author  임태웅
@date    2013.7.29
*/
void DrivingControl::initPreviousArrivalInfo()
{
    memset(&m_PreviousArrivalInfo, 0, sizeof(POSITION_STATUS));
}

/**
@brief   마지막 도착 정보(다음 출발의 기준점)를 설정하는 함수
@author  임태웅
@date    2013.7.29
*/
void DrivingControl::setPreviousArrivalInfo(POSITION_STATUS PositionStatus)
{
    m_PreviousArrivalInfo = PositionStatus;
}

/**
@brief   마지막 도착 정보를 초기화하는 함수
@author  임태웅
@date    2013.7.29
*/
void DrivingControl::setCompensationInfo(POSITION_STATUS PreviousArrivalInfo)
{
    double dPreArriveOffset = 0.0;  //default case: MARK_TYPE_NODE

    if(PreviousArrivalInfo.Info.MarkType!=MARK_TYPE_NODE)
    {
//      if(PreviousArrivalInfo.Info.uNode==PreviousArrivalInfo.uRealArrivedNode)
//      if(PreviousArrivalInfo.Info.uNextNode==PreviousArrivalInfo.uRealArrivedNode)
//      {
            dPreArriveOffset = PreviousArrivalInfo.Info.dOffset;      //puting 수정 할 것 ..... 빼기로 해서 .
//      }
    }
	//memset(&m_InfoSet.Position.Compensation,0x00, sizeof(DRIVING_COMPENSATION_INFO));

	m_InfoSet.Position.Compensation.dPreArriveOffset = dPreArriveOffset;
    m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus = PreviousArrivalInfo;
    m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.bMarked = false;

    ADD_LOG("D_69/%d/%5.1lf/%06d/%06d/%5.1lf/%06d/%06d"
		, PreviousArrivalInfo.Info.MarkType
        , PreviousArrivalInfo.Info.dOffset
        , PreviousArrivalInfo.Info.uNode
        , PreviousArrivalInfo.Info.uNextNode
        , m_InfoSet.Position.Compensation.dPreArriveOffset
        , m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode
        , m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNextNode
        );
}

/**
@brief   마지막 도착 정보를 초기화하는 함수
@author  임태웅
@date    2013.7.29
*/
//DRIVING_MARK_INFO DrivingControl::getMarkInfo(DRIVING_HW_INFO_SET HwInfo, POSITION_STATUS PositionStatus)
//{
//  DRIVING_MARK_INFO TmpMarkInfo;
//
//  TmpMarkInfo.PositionStatus = PositionStatus;
//  TmpMarkInfo.dFrontPosition = HwInfo.Axis1.dCurrPos;
//  TmpMarkInfo.dRearPosition = HwInfo.Axis2.dCurrPos;
//  TmpMarkInfo.uRealArrivedNode = PositionStatus.
//
//  return TmpMarkInfo;
//}

/**
@brief   명령으로 부터 Node Info List 정보를 만들어 냄
@author  ehoto
@date    2013.7.19
@param pList: 정보를 저장하는 List의 포인터
@param pDrivingInfo: 명령 정보의 포인터
@return 성공하면  NodeCount 반환, List에 명령이 없어 추가 못하면 -1 반환
*/
bool DrivingControl::checkCmdInfoNodeList(List<DRIVING_CMD_INFO_OF_NODE*> *pList, int CheckNodeID, CLASSIFIED_DRIVING_CHANGE* ChagneInfo)
{
	bool bSuccess = false;
    DRIVING_CMD_INFO_OF_NODE* pItem = NULL;

	int nCount = pList->getCount();


	if((nCount==0) || (CheckNodeID ==0))
		return bSuccess;

//	ChagneInfo->TargetInfo =m_ClassifiedCmd.TargetInfo;

	for(int Index =0; Index<nCount; Index++)
	{
		pItem = pList->refer(nCount-Index -1);
		//최초값 저장

		if(pItem->ID==CheckNodeID)
		{

			ChagneInfo->dEncoderFinal = pItem->dDistSum;
			ChagneInfo->nCheckNodeCount = pItem->nCount;

			ChagneInfo->TargetInfo.dDistSumToNode =pItem->dDistSum;
            ChagneInfo->TargetInfo.Node =  pItem->ID;
			ChagneInfo->TargetInfo.Type =MARK_TYPE_NODE;
			ChagneInfo->TargetInfo.nCount = pItem->nCount;

			bSuccess= true;

			ADD_LOG("D_70/%d",CheckNodeID);

			break;
		}else
		{
		 	m_pExecuteInfo->nNextNodeIDInfo =  pItem->ID;
        }

	}

    return bSuccess;
}


/**
@brief   명령으로 부터 Node Info List 정보를 만들어 냄
@author  ehoto
@date    2013.7.19
@param pList: 정보를 저장하는 List의 포인터
@param pDrivingInfo: 명령 정보의 포인터
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
bool DrivingControl::CancelList(List<DRIVING_CMD_INFO_OF_NODE*> *pList, CLASSIFIED_DRIVING_CHANGE DrivingInfo)
{
    int nListCount      = pList->getCount();
	bool bReturn = false;
	DRIVING_CMD_INFO_OF_NODE *pItem = NULL;
	DRIVING_CMD_INFO_OF_NODE *pTempItem = NULL;

	if(nListCount==0) return bReturn;

	pTempItem = new DRIVING_CMD_INFO_OF_NODE;

	for(int nTmpIndex = 0; nTmpIndex<nListCount; nTmpIndex++)
    {
        pItem   = pList->popBack();
        if(pItem!=NULL)
		{

            if(pItem->nCount < DrivingInfo.nCheckNodeCount)
			{
				pTempItem->nCount = DrivingInfo.nCheckNodeCount;
				pTempItem->dDistSum = DrivingInfo.dEncoderFinal;

				bReturn = true;

				pList->insertBack(pItem);
				pList->insertBack(pTempItem);

				ADD_LOG("D_71/%d/%d",pItem->nCount, DrivingInfo.nCheckNodeCount);
				return bReturn;
			}
			else if((pItem->nCount == DrivingInfo.nCheckNodeCount) || (nTmpIndex == (nListCount-1)))
			{
				pItem->nCount = DrivingInfo.nCheckNodeCount;
				pItem->dDistSum = DrivingInfo.dEncoderFinal;
				bReturn = true;

				pList->insertBack(pItem);
				ADD_LOG("D_72/%d/%d",pItem->nCount, DrivingInfo.nCheckNodeCount);
				delete pTempItem;
				return bReturn;
			}
			else
            {
//				pItem   = pList->popBack();
				pTempItem->ID = pItem->ID;
				pTempItem->Type = pItem->Type;
				pTempItem->dDistSum = pItem->dDistSum;
				pTempItem->nCount = pItem->nCount;
//				pTempItem->DivInfo = pItem->DivInfo;
//				memmove(pTempItem,pItem,sizeof(DRIVING_CMD_INFO_OF_PATH));
                delete pItem;
                pItem   = NULL;
			}

        }
	}

	delete pTempItem;
    return bReturn;

}
/**
@brief   명령으로 부터 Node Info List 정보를 만들어 냄
@author  ehoto
@date    2013.7.19
@param pList: 정보를 저장하는 List의 포인터
@param pDrivingInfo: 명령 정보의 포인터
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
bool DrivingControl::CancelList(List<DRIVING_CMD_INFO_OF_STEER*> *pList, CLASSIFIED_DRIVING_CHANGE DrivingInfo)
{
	int nListCount      = pList->getCount();
	bool bReturn = false;
	DRIVING_CMD_INFO_OF_STEER *pItem = NULL;
	DRIVING_CMD_INFO_OF_STEER *pTempItem = NULL;

	if(nListCount==0) return bReturn;

	pTempItem = new DRIVING_CMD_INFO_OF_STEER;

	for(int nTmpIndex = 0; nTmpIndex<nListCount; nTmpIndex++)
    {
		pItem   = pList->popBack();
        if(pItem!=NULL)
		{

		   if(pItem->nCount < DrivingInfo.nCheckNodeCount)
			{

				pTempItem->nCount = DrivingInfo.nCheckNodeCount;
				pTempItem->dDistSumToEndNode = DrivingInfo.dEncoderFinal;

				bReturn = true;

				pList->insertBack(pItem);
				pList->insertBack(pTempItem);
				ADD_LOG("D_73/%d/%d",pItem->nCount, DrivingInfo.nCheckNodeCount);
				return bReturn;
			}
			else if((pItem->nCount == DrivingInfo.nCheckNodeCount) || (nTmpIndex == (nListCount-1)))
			{
				pItem->nCount = DrivingInfo.nCheckNodeCount;
				pItem->dDistSumToEndNode = DrivingInfo.dEncoderFinal;
				bReturn = true;

				pList->insertBack(pItem);
				ADD_LOG("D_74/%d/%d",pItem->nCount, DrivingInfo.nCheckNodeCount);
				delete pTempItem;
				return bReturn;
			}
			else
            {
//				pItem   = pList->popBack();

				pTempItem->Type = pItem->Type;
				pTempItem->NextType = PATH_STEERING_NONE;
				pTempItem->dDistSumToEndNode = pItem->dDistSumToEndNode;
				pTempItem->nCount = pItem->nCount;

                delete pItem;
                pItem   = NULL;
            }
        }
	}


	delete pTempItem;
	return bReturn;


}
/**
@brief   명령으로 부터 Node Info List 정보를 만들어 냄
@author  ehoto
@date    2013.7.19
@param pList: 정보를 저장하는 List의 포인터
@param pDrivingInfo: 명령 정보의 포인터
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
bool DrivingControl::CancelList(List<DRIVING_CMD_INFO_OF_DIV*> *pList, CLASSIFIED_DRIVING_CHANGE DrivingInfo)
{
	int nListCount      = pList->getCount();
	bool bReturn = false;
	DRIVING_CMD_INFO_OF_DIV *pItem = NULL;
	DRIVING_CMD_INFO_OF_DIV *pTempItem = NULL;

	if(nListCount==0) return bReturn;

	pTempItem = new DRIVING_CMD_INFO_OF_DIV;

	for(int nTmpIndex = 0; nTmpIndex<nListCount; nTmpIndex++)
    {
		pItem   = pList->popBack();
        if(pItem!=NULL)
		{

		   if(pItem->nCount < DrivingInfo.nCheckNodeCount)
			{

				pTempItem->nCount = DrivingInfo.nCheckNodeCount;
				pTempItem->dDistSumToEndNode = DrivingInfo.dEncoderFinal;

				bReturn = true;

				pList->insertBack(pItem);
				pList->insertBack(pTempItem);
				ADD_LOG("D_75/%d/%d",pItem->nCount, DrivingInfo.nCheckNodeCount);
				return bReturn;
			}
			else if((pItem->nCount == DrivingInfo.nCheckNodeCount) || (nTmpIndex == (nListCount-1)))
			{
				pItem->nCount = DrivingInfo.nCheckNodeCount;
				pItem->dDistSumToEndNode = DrivingInfo.dEncoderFinal;
				bReturn = true;

				pList->insertBack(pItem);
                ADD_LOG("D_76/%d/%d",pItem->nCount, DrivingInfo.nCheckNodeCount);
				delete pTempItem;
				return bReturn;
			}
			else
            {
//				pItem   = pList->popBack();

				pTempItem->Type = pItem->Type;
				pTempItem->NextType = PATH_DIVERGENCE_NONE;
				pTempItem->dDistSumToEndNode = pItem->dDistSumToEndNode;
				pTempItem->nCount = pItem->nCount;

                delete pItem;
                pItem   = NULL;
            }
        }
    }

	delete pTempItem;
	return bReturn;


}

/**
@brief   명령으로 부터 Node Info List 정보를 만들어 냄
@author  ehoto
@date    2013.7.19
@param pList: 정보를 저장하는 List의 포인터
@param pDrivingInfo: 명령 정보의 포인터
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
bool DrivingControl::CancelList(List<DRIVING_CMD_INFO_OF_DIRECTION*> *pList, CLASSIFIED_DRIVING_CHANGE DrivingInfo)
{
	int nListCount      = pList->getCount();
	bool bReturn = false;
	DRIVING_CMD_INFO_OF_DIRECTION *pItem = NULL;
	DRIVING_CMD_INFO_OF_DIRECTION *pTempItem = NULL;

	if(nListCount==0) return bReturn;

	pTempItem = new DRIVING_CMD_INFO_OF_DIRECTION;

	for(int nTmpIndex = 0; nTmpIndex<nListCount; nTmpIndex++)
	{
		pItem   = pList->popBack();
		if(pItem!=NULL)
		{


			if(pItem->nCount < DrivingInfo.nCheckNodeCount)
			{
				pTempItem->nCount = DrivingInfo.nCheckNodeCount;
				pTempItem->dDistSumToEndNode = DrivingInfo.dEncoderFinal;

				bReturn = true;

				pList->insertBack(pItem);
				pList->insertBack(pTempItem);
				ADD_LOG("D_77/%d/%d",pItem->nCount, DrivingInfo.nCheckNodeCount);
				return bReturn;
			}
			else if((pItem->nCount == DrivingInfo.nCheckNodeCount) || (nTmpIndex == (nListCount-1)))
			{
				pItem->nCount = DrivingInfo.nCheckNodeCount;
				pItem->dDistSumToEndNode = DrivingInfo.dEncoderFinal;
				bReturn = true;

				pList->insertBack(pItem);
				ADD_LOG("D_78/%d/%d",pItem->nCount, DrivingInfo.nCheckNodeCount);
				delete pTempItem;
				return bReturn;
			}
			else
            {
//				pItem   = pList->popBack();
#if(USE_CHANGENODE == 1)
				pTempItem->UBGRegion = pItem->UBGRegion;
				pTempItem->ObstacleRegion = pItem->ObstacleRegion;
				pTempItem->nPBSIgnoreFlag = pItem->nPBSIgnoreFlag;
				pTempItem->nFollowsCommandType = pItem->nFollowsCommandType;
				pTempItem->dDistSumToEndNode = pItem->dDistSumToEndNode;
				pTempItem->nCount = pItem->nCount;

				//for change node
				pTempItem->NodeType = pItem->NodeType;
				pTempItem->OptDistance = pItem->OptDistance;
				pTempItem->OptDistanceAfter = pItem->OptDistanceAfter;
				pTempItem->OptUBGRegion = pItem->OptUBGRegion;
				pTempItem->OptObstacleRegion = pItem->OptObstacleRegion;
#else
				pTempItem->Type = pItem->Type;
				pTempItem->nPBSIgnoreFlag = pItem->nPBSIgnoreFlag;
				pTempItem->nFollowsCommandType = pItem->nFollowsCommandType;
				pTempItem->dDistSumToEndNode = pItem->dDistSumToEndNode;
				pTempItem->nCount = pItem->nCount;
#endif
                delete pItem;
                pItem   = NULL;
            }
		}
	}

	delete pTempItem;
	return bReturn;

}
/**
@brief   명령으로 부터 Node Info List 정보를 만들어 냄
@author  ehoto
@date    2013.7.19
@param pList: 정보를 저장하는 List의 포인터
@param pDrivingInfo: 명령 정보의 포인터
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
bool DrivingControl::CancelList(List<DRIVING_CMD_INFO_OF_SPEED*> *pList, CLASSIFIED_DRIVING_CHANGE DrivingInfo)
{
 	int nListCount      = pList->getCount();
	bool bReturn = false;
	DRIVING_CMD_INFO_OF_SPEED *pItem = NULL;
	DRIVING_CMD_INFO_OF_SPEED *pTempItem = NULL;

	if(nListCount==0) return bReturn;

	pTempItem = new DRIVING_CMD_INFO_OF_SPEED;

	for(int nTmpIndex = 0; nTmpIndex<nListCount; nTmpIndex++)
	{
		pItem   = pList->popBack();
		if(pItem!=NULL)
		{


			if(pItem->nCount < DrivingInfo.nCheckNodeCount)
			{
				pTempItem->nCount = DrivingInfo.nCheckNodeCount;
				pTempItem->dDistSumToFinalNode = DrivingInfo.dEncoderFinal;
				pTempItem->dDistSumToTarget = DrivingInfo.dEncoderFinal;

				bReturn = true;

				pList->insertBack(pItem);
				pList->insertBack(pTempItem);
				ADD_LOG("D_79/%d/%d",pItem->nCount, DrivingInfo.nCheckNodeCount);
				return bReturn;
			}
			else if((pItem->nCount == DrivingInfo.nCheckNodeCount) || (nTmpIndex == (nListCount-1)))
			{
				pItem->nCount = DrivingInfo.nCheckNodeCount;
				pItem->dDistSumToFinalNode = DrivingInfo.dEncoderFinal;
				pItem->dDistSumToTarget = DrivingInfo.dEncoderFinal;
				bReturn = true;

				pList->insertBack(pItem);

				ADD_LOG("D_80/%d/%d",pItem->nCount, DrivingInfo.nCheckNodeCount);
				delete pTempItem;
				return bReturn;
			}
			else
			{
//				pItem   = pList->popBack();

				pTempItem->dSpeed = pItem->dSpeed;
				pTempItem->dDistSumToFinalNode = pItem->dDistSumToFinalNode;
				pTempItem->nCount = pItem->nCount;
				pTempItem->MarkType = pItem->MarkType;
				pTempItem->dDistSumToTarget = pItem->dDistSumToTarget;
				pTempItem->dDecelDist = pItem->dDecelDist;

                delete pItem;
                pItem   = NULL;
			}

		}
	}

	delete pTempItem;
	return bReturn;

}
/**
@brief   명령으로 부터 Node Info List 정보를 만들어 냄
@author  ehoto
@date    2013.7.19
@param pList: 정보를 저장하는 List의 포인터
@param pDrivingInfo: 명령 정보의 포인터
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
bool DrivingControl::CancelList(List<DRIVING_CMD_INFO_OF_PATH*> *pList, CLASSIFIED_DRIVING_CHANGE DrivingInfo)
{
	int nListCount      = pList->getCount();
	bool bReturn = false;
	DRIVING_CMD_INFO_OF_PATH *pItem = NULL;
	DRIVING_CMD_INFO_OF_PATH *pTempItem = NULL;

	if(nListCount==0) return bReturn;

	pTempItem = new DRIVING_CMD_INFO_OF_PATH;

	for(int nTmpIndex = 0; nTmpIndex<nListCount; nTmpIndex++)
	{
		pItem   = pList->popBack();
		if(pItem!=NULL)
		{


			if(pItem->nCount < DrivingInfo.nCheckNodeCount)
			{
				pTempItem->nCount = DrivingInfo.nCheckNodeCount;
				pTempItem->dDistSumToEndNode = DrivingInfo.dEncoderFinal;

				bReturn = true;

				pList->insertBack(pItem);
				pList->insertBack(pTempItem);
				ADD_LOG("D_81/%d/%d",pItem->nCount, DrivingInfo.nCheckNodeCount);
				return bReturn;
			}
			else if((pItem->nCount == DrivingInfo.nCheckNodeCount) || (nTmpIndex == (nListCount-1)))
			{
				pItem->nCount = DrivingInfo.nCheckNodeCount;
				pItem->dDistSumToEndNode = DrivingInfo.dEncoderFinal;
				bReturn = true;

				pList->insertBack(pItem);
                ADD_LOG("D_82/%d/%d",pItem->nCount, DrivingInfo.nCheckNodeCount);
				delete pTempItem;
				return bReturn;
			}
			else
            {
//				pItem   = pList->popBack();

				pTempItem->StartNID = pItem->StartNID;
				pTempItem->EndNID = pItem->EndNID;
				pTempItem->StartNType = pItem->StartNType;
				pTempItem->EndNType = pItem->EndNType;
				pTempItem->StartType = pItem->StartType;
				pTempItem->NodeType = pItem->NodeType;
				pTempItem->dSpeed = pItem->dSpeed;
				pTempItem->dLength = pItem->dLength;
				pTempItem->dDistSumToEndNode = pItem->dDistSumToEndNode;
				pTempItem->nPBSIgnoreFlag = pItem->nPBSIgnoreFlag;
				pTempItem->nCount = pItem->nCount;
				pTempItem->Steering = pItem->Steering;
#if(USE_CHANGENODE == 1)
				pTempItem->UBGRegion = pItem->UBGRegion;
				pTempItem->ObstacleRegion = pItem->ObstacleRegion;
				pTempItem->PreSteering = pItem->PreSteering;
				pTempItem->DivInfo = pItem->DivInfo;

				//for change node
				pTempItem->NodeType = pItem->NodeType;
				pTempItem->OptDistance = pItem->OptDistance;
				pTempItem->OptDistanceAfter = pItem->OptDistanceAfter;
				pTempItem->OptUBGRegion = pItem->OptUBGRegion;
				pTempItem->OptObstacleRegion = pItem->OptObstacleRegion;
#else
				pTempItem->Direction = pItem->Direction;
				pTempItem->PreSteering = pItem->PreSteering;
				pTempItem->DivInfo = pItem->DivInfo;
#endif


//				memmove(pTempItem,pItem,sizeof(DRIVING_CMD_INFO_OF_PATH));
                delete pItem;
                pItem   = NULL;
            }
		}
	}

	delete pTempItem;
	return bReturn;

}

/**
@brief   명령으로 부터 Node Info List 정보를 만들어 냄
@author  ehoto
@date    2013.7.19
@param pList: 정보를 저장하는 List의 포인터
@param pDrivingInfo: 명령 정보의 포인터
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
bool DrivingControl::makeList(List<DRIVING_CMD_INFO_OF_NODE*> *pList, DRIVING_CMD_INFO_OF_PATH DrivingInfo)
{
    bool bSuccess = true;
    DRIVING_CMD_INFO_OF_NODE* pItem = NULL;

    int nCount = pList->getCount();

    if(nCount==0)
    {
        // 시작 Node 정보 입력
        pItem = NULL;
		pItem = new DRIVING_CMD_INFO_OF_NODE();
        pItem->ID = DrivingInfo.StartNID;
        pItem->Type = DrivingInfo.StartNType;
		pItem->dDistSum = 0;
		pItem->nCount = 0;
//		pItem->DivInfo = DrivingInfo.DivInfo;
//		if(DrivingInfo.NodeType ==SLOPE_NTYPE) pItem->SlopeInfo = NODE_SLOPE;
//		else	pItem->SlopeInfo = NODE_NORMAL;
        pItem->NodeType = DrivingInfo.NodeType;
		pList->insertBack(pItem);

        // 다음 Node 정보 입력
        pItem = NULL;
        pItem = new DRIVING_CMD_INFO_OF_NODE();
        pItem->ID = DrivingInfo.EndNID;
        pItem->Type = DrivingInfo.EndNType;
		pItem->dDistSum = DrivingInfo.dDistSumToEndNode;
		pItem->nCount = DrivingInfo.nCount;
//		pItem->DivInfo = PATH_DIVERGENCE_NONE;
//		if(DrivingInfo.NodeType ==SLOPE_NTYPE) pItem->SlopeInfo = NODE_SLOPE;
//		else	pItem->SlopeInfo = NODE_NORMAL;
		pItem->NodeType = DrivingInfo.NextNodeType;
        pList->insertBack(pItem);
    }
	else//if(nCount==0)
    {
        //2 1) 중복 명령 확인
		pItem = pList->referBack();
        if(pItem->ID==DrivingInfo.EndNID)
        {
        //2 마지막 Node는 같으나 이전 노드가 다른 경우
            if(nCount>1)
            {
                pItem = pList->refer(nCount-2);
                if(pItem->ID!=DrivingInfo.StartNID)
                {
                    bSuccess = false;
                    ERR_LOG("DrivingControl::makeList: 마지막 Node는 같으나 이전 노드가 다른 경우 [Curr(%d)!=StartNID%d]", pItem->ID, DrivingInfo.StartNID);
                }
            }
        //2 중복된 명령이면 Skip
            else//if(nCount>1)
            {
                // skip
            }//else of if(nCount>1)
		}
        //2 2) 중복이 아닐 경우
        else//if(pItem->ID==DrivingInfo->EndNID)
		{
        //2 비연속 명령 확인
            if(pItem->ID!=DrivingInfo.StartNID)
            {
                bSuccess = false;
                ERR_LOG("DrivingControl::makeList: 비연속 명령 [Curr(%X)!=StartNID%X]", pItem->ID, DrivingInfo.StartNID);
            }
        //2 정상 명령 (연속 명령 경우)
            else//if(pItem->ID!=DrivingInfo->StartNID)
			{

//				pItem->DivInfo = DrivingInfo.DivInfo;

                pItem = NULL;
                pItem = new DRIVING_CMD_INFO_OF_NODE();
                pItem->ID = DrivingInfo.EndNID;
                pItem->Type = DrivingInfo.EndNType;
                pItem->dDistSum = DrivingInfo.dDistSumToEndNode;
				pItem->nCount = DrivingInfo.nCount;
//				pItem->DivInfo = PATH_DIVERGENCE_NONE;
//				if(DrivingInfo.NodeType ==SLOPE_NTYPE) pItem->SlopeInfo = NODE_SLOPE;
//				else	pItem->SlopeInfo = NODE_NORMAL;
				pItem->NodeType = DrivingInfo.NextNodeType;
                pList->insertBack(pItem);
			}//else of if(pItem->ID!=DrivingInfo->StartNID)

        }//else of if(pItem->ID==DrivingInfo->EndNID)
    }//else of if(nCount==0)

    return bSuccess;
}
/**
@brief   명령으로 부터 Steer Info List 정보를 만들어 냄
@author  ehoto
@date    2013.7.19
@param pList: 정보를 저장하는 List의 포인터
@param pDrivingInfo: 명령 정보의 포인터
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
bool DrivingControl::makeList(List<DRIVING_CMD_INFO_OF_STEER*> *pList, DRIVING_CMD_INFO_OF_PATH DrivingInfo)
{
    bool bSuccess = true;
    DRIVING_CMD_INFO_OF_STEER* pItem;

    int nCount = pList->getCount();

    if(nCount==0)
    {
        // 시작 Node 정보 입력
        pItem = NULL;
        pItem = new DRIVING_CMD_INFO_OF_STEER();
        pItem->Type = DrivingInfo.Steering;
		pItem->NextType = DrivingInfo.PreSteering;
        pItem->dDistSumToEndNode = DrivingInfo.dDistSumToEndNode;
        pItem->nCount = DrivingInfo.nCount;
		pList->insertBack(pItem);
    }
    else//if(nCount==0)
    {
        //2 1) 중복 명령 확인
		pItem = pList->referBack();
        if(pItem->nCount==DrivingInfo.nCount)
        {
        //2 중복된 명령이면 Skip
            if(pItem->Type==DrivingInfo.Steering)
            {
				if(pItem->NextType!=DrivingInfo.PreSteering)
                {
					pItem->NextType=DrivingInfo.PreSteering;
                }
            }
            else
            {
                bSuccess = false;
            }
        }
        //2 2) 중복이 아닐 경우
        else//if(pItem->ID==DrivingInfo->EndNID)
        {
        //2 조향이 같을 경우
            if(pItem->Type==DrivingInfo.Steering)
            {
				pItem->NextType = DrivingInfo.PreSteering;
                pItem->dDistSumToEndNode = DrivingInfo.dDistSumToEndNode;
                pItem->nCount = DrivingInfo.nCount;
            }
        //2 조향이 다른 경우
            else
            {
                pItem = NULL;
                pItem = new DRIVING_CMD_INFO_OF_STEER();
                pItem->Type = DrivingInfo.Steering;
				pItem->NextType = DrivingInfo.PreSteering;
                pItem->dDistSumToEndNode = DrivingInfo.dDistSumToEndNode;
                pItem->nCount = DrivingInfo.nCount;
                pList->insertBack(pItem);
            }
        }//else of if(pItem->ID==DrivingInfo->EndNID)
    }//else of if(nCount==0)

    return bSuccess;
}

/**
@brief   명령으로 부터 Steer Info List 정보를 만들어 냄
@author  ehoto
@date    2013.7.19
@param pList: 정보를 저장하는 List의 포인터
@param pDrivingInfo: 명령 정보의 포인터
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
bool DrivingControl::makeList(List<DRIVING_CMD_INFO_OF_DIV*> *pList, DRIVING_CMD_INFO_OF_PATH DrivingInfo)
{
    bool bSuccess = true;
    DRIVING_CMD_INFO_OF_DIV* pItem;

    int nCount = pList->getCount();

//	ADD_LOG("D_83/%d/%d/%d/%d",DrivingInfo.StartNID, DrivingInfo.DivInfo,nCount,DrivingInfo.nCount);

    if(nCount==0)
    {
        // 시작 Node 정보 입력
        pItem = NULL;
        pItem = new DRIVING_CMD_INFO_OF_DIV();
		pItem->Type = DrivingInfo.DivInfo;
		pItem->NextType = DrivingInfo.PreDivInfo;
        pItem->dDistSumToEndNode = DrivingInfo.dDistSumToEndNode;
        pItem->nCount = DrivingInfo.nCount;
		pList->insertBack(pItem);
    }
    else//if(nCount==0)
    {
        //2 1) 중복 명령 확인
		pItem = pList->referBack();
        if(pItem->nCount==DrivingInfo.nCount)
        {
        //2 중복된 명령이면 Skip
			if(pItem->Type==DrivingInfo.DivInfo)
            {
				if(pItem->NextType!=DrivingInfo.PreDivInfo)
                {
					pItem->NextType=DrivingInfo.PreDivInfo;
                }
            }
            else
            {
                bSuccess = false;
            }
        }
        //2 2) 중복이 아닐 경우
        else//if(pItem->ID==DrivingInfo->EndNID)
        {
        //2 조향이 같을 경우
			if((pItem->Type==DrivingInfo.DivInfo)&&
			   (DrivingInfo.DivInfo ==PATH_DIVERGENCE_NONE))
            {
				pItem->NextType = DrivingInfo.DivInfo;
                pItem->dDistSumToEndNode = DrivingInfo.dDistSumToEndNode;
                pItem->nCount = DrivingInfo.nCount;
            }
        //2 조향이 다른 경우
            else
			{
				pItem->NextType = DrivingInfo.DivInfo;

                pItem = NULL;
                pItem = new DRIVING_CMD_INFO_OF_DIV();
				pItem->Type = DrivingInfo.DivInfo;
				pItem->NextType = DrivingInfo.DivInfo;
                pItem->dDistSumToEndNode = DrivingInfo.dDistSumToEndNode;
                pItem->nCount = DrivingInfo.nCount;
                pList->insertBack(pItem);
            }
        }//else of if(pItem->ID==DrivingInfo->EndNID)
    }//else of if(nCount==0)

    return bSuccess;
}

/**
@brief   명령으로 부터 Direction Info List 정보를 만들어 냄
@author  ehoto
@date    2013.7.19
@param pList: 정보를 저장하는 List의 포인터
@param pDrivingInfo: 명령 정보의 포인터
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
bool DrivingControl::makeList(List<DRIVING_CMD_INFO_OF_DIRECTION*> *pList, DRIVING_CMD_INFO_OF_PATH DrivingInfo)
{
    bool bSuccess = true;

    DRIVING_CMD_INFO_OF_DIRECTION *pItem = NULL;

    int nCount = pList->getCount();

    if(nCount==0)
    {
        // 시작 Node 정보 입력
        pItem = NULL;
		pItem = new DRIVING_CMD_INFO_OF_DIRECTION();
#if(USE_CHANGENODE == 1)
		pItem->UBGRegion = DrivingInfo.UBGRegion;
		pItem->ObstacleRegion = DrivingInfo.ObstacleRegion;
        pItem->dDistSumToEndNode = DrivingInfo.dDistSumToEndNode;
		pItem->nPBSIgnoreFlag = DrivingInfo.nPBSIgnoreFlag;
		pItem->nFollowsCommandType = DETECT_INFO_TYPE_BOTH;
        pItem->nCount = DrivingInfo.nCount;

		// for change node
		pItem->NodeType = DrivingInfo.NodeType;
		pItem->OptDistance = DrivingInfo.OptDistance;
		pItem->OptDistanceAfter = DrivingInfo.OptDistanceAfter;
		pItem->OptUBGRegion = DrivingInfo.OptUBGRegion;
		pItem->OptObstacleRegion = DrivingInfo.OptObstacleRegion;

		// edit change node information for station starting situtation!
		if(DrivingInfo.nCount == 1 &&
			(DrivingInfo.NodeType == OPT_TAG || DrivingInfo.NodeType == OPT_DISTANCE || DrivingInfo.NodeType == OPT_COMBO) &&
			m_LastDrivingCmdInfo.AddInfo.ProcessingGoInfo.IsStationStart == true)
		{
			double offset = m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset;
			if(offset < DrivingInfo.OptDistance)
			{
				pItem->OptDistance -= offset;
			}
			else
			{
				if(DrivingInfo.NodeType == OPT_TAG || DrivingInfo.NodeType == OPT_DISTANCE) // pattern already be changed
				{
					pItem->NodeType = NONE_TYPE;
					pItem->OptDistance = 0;
					pItem->OptDistanceAfter = 0;
					pItem->OptUBGRegion = PATH_DIRECTION_NO_USE;
					pItem->OptObstacleRegion = PATH_OBS_DIRECTION_NO_USE;

					pItem->UBGRegion = DrivingInfo.OptUBGRegion;
					pItem->ObstacleRegion = DrivingInfo.OptObstacleRegion;
				}
				else if(DrivingInfo.NodeType == OPT_COMBO)
				{
					double remainDistance = offset - DrivingInfo.OptDistance;
					if(remainDistance < DrivingInfo.OptDistanceAfter)
					{
						pItem->NodeType = OPT_DISTANCE;
						pItem->OptDistance = DrivingInfo.OptDistanceAfter - remainDistance;
						pItem->OptDistanceAfter = 0;
					}
					else  // pattern already be changed
					{
						pItem->NodeType = NONE_TYPE;
						pItem->OptDistance = 0;
						pItem->OptDistanceAfter = 0;
						pItem->OptUBGRegion = PATH_DIRECTION_NO_USE;
						pItem->OptObstacleRegion = PATH_OBS_DIRECTION_NO_USE;

						pItem->UBGRegion = DrivingInfo.OptUBGRegion;
						pItem->ObstacleRegion = DrivingInfo.OptObstacleRegion;
					}
				}
			}
			ADD_LOG("D_84/%d/%d/%d/%d/%d/%d/%d/%d/%d/%d/%f"
				, (int)DrivingInfo.NodeType, DrivingInfo.OptDistance, DrivingInfo.OptDistanceAfter, DrivingInfo.OptUBGRegion, DrivingInfo.OptObstacleRegion
				, (int)pItem->NodeType, pItem->OptDistance, pItem->OptDistanceAfter, pItem->OptUBGRegion, pItem->OptObstacleRegion,
				offset);
		}
#else
		pItem->Type = DrivingInfo.Direction;
		pItem->dDistSumToEndNode = DrivingInfo.dDistSumToEndNode;
		pItem->nPBSIgnoreFlag = DrivingInfo.nPBSIgnoreFlag;
		pItem->nFollowsCommandType = DETECT_INFO_TYPE_BOTH;
        pItem->nCount = DrivingInfo.nCount;
#endif


        pList->insertBack(pItem);
    }
    else//if(nCount==0)
    {
        //2 1) 중복 명령 확인
        pItem = pList->referBack();
        if(pItem->nCount==DrivingInfo.nCount)
        {
		//2 중복된 명령이면 Skip
#if(USE_CHANGENODE == 1)
             if(pItem->UBGRegion == DrivingInfo.UBGRegion && pItem->ObstacleRegion == DrivingInfo.ObstacleRegion &&
				pItem->OptUBGRegion == DrivingInfo.OptUBGRegion && pItem->OptObstacleRegion == DrivingInfo.OptObstacleRegion)
#else
            if(pItem->Type==DrivingInfo.Direction)
#endif
            {

            }
            else
            {
                bSuccess = false;
            }
        }
        //2 2) 중복이 아닐 경우
        else
        {
//        	ADD_LOG("D_85/%d/%x/%x",pItem->nPBSIgnoreFlag, pItem->Type, DrivingInfo.Direction);
#if(USE_CHANGENODE == 1)
            if(pItem->UBGRegion == DrivingInfo.UBGRegion && pItem->ObstacleRegion == DrivingInfo.ObstacleRegion &&
				pItem->OptUBGRegion == DrivingInfo.OptUBGRegion && pItem->OptObstacleRegion == DrivingInfo.OptObstacleRegion)
#else
			if(pItem->Type==DrivingInfo.Direction)
#endif
            {
            	if(pItem->nPBSIgnoreFlag == DrivingInfo.nPBSIgnoreFlag)
           		{
	                pItem->dDistSumToEndNode = DrivingInfo.dDistSumToEndNode;
    	            pItem->nCount = DrivingInfo.nCount;
           		}
				else
				{
	                pItem = NULL;
					pItem = new DRIVING_CMD_INFO_OF_DIRECTION();
#if(USE_CHANGENODE == 1)
					pItem->UBGRegion = DrivingInfo.UBGRegion;
					pItem->ObstacleRegion = DrivingInfo.ObstacleRegion;
	                pItem->dDistSumToEndNode = DrivingInfo.dDistSumToEndNode;
					pItem->nPBSIgnoreFlag = DrivingInfo.nPBSIgnoreFlag;
					pItem->nFollowsCommandType = DETECT_INFO_TYPE_ONLY_PBS;
	                pItem->nCount = DrivingInfo.nCount;

					// for change node
					pItem->NodeType = DrivingInfo.NodeType;
					pItem->OptDistance = DrivingInfo.OptDistance;
					pItem->OptDistanceAfter = DrivingInfo.OptDistanceAfter;
					pItem->OptUBGRegion = DrivingInfo.OptUBGRegion;
					pItem->OptObstacleRegion = DrivingInfo.OptObstacleRegion;
#else
	                pItem->Type = DrivingInfo.Direction;
	                pItem->dDistSumToEndNode = DrivingInfo.dDistSumToEndNode;
					pItem->nPBSIgnoreFlag = DrivingInfo.nPBSIgnoreFlag;
					pItem->nFollowsCommandType = DETECT_INFO_TYPE_ONLY_PBS;
	                pItem->nCount = DrivingInfo.nCount;
#endif

	                pList->insertBack(pItem);
				}
            }
            else
            {
            	if(pItem->nPBSIgnoreFlag == DrivingInfo.nPBSIgnoreFlag)
           		{
	                pItem = NULL;
					pItem = new DRIVING_CMD_INFO_OF_DIRECTION();
#if(USE_CHANGENODE == 1)
					pItem->UBGRegion = DrivingInfo.UBGRegion;
					pItem->ObstacleRegion = DrivingInfo.ObstacleRegion;
	                pItem->dDistSumToEndNode = DrivingInfo.dDistSumToEndNode;
					pItem->nPBSIgnoreFlag = DrivingInfo.nPBSIgnoreFlag;
					pItem->nFollowsCommandType = DETECT_INFO_TYPE_ONLY_UBG;
	                pItem->nCount = DrivingInfo.nCount;

					// for change node
					pItem->NodeType = DrivingInfo.NodeType;
					pItem->OptDistance = DrivingInfo.OptDistance;
					pItem->OptDistanceAfter = DrivingInfo.OptDistanceAfter;
					pItem->OptUBGRegion = DrivingInfo.OptUBGRegion;
					pItem->OptObstacleRegion = DrivingInfo.OptObstacleRegion;
#else
	                pItem->Type = DrivingInfo.Direction;
	                pItem->dDistSumToEndNode = DrivingInfo.dDistSumToEndNode;
					pItem->nPBSIgnoreFlag = DrivingInfo.nPBSIgnoreFlag;
					pItem->nFollowsCommandType = DETECT_INFO_TYPE_ONLY_UBG;
	                pItem->nCount = DrivingInfo.nCount;
#endif
					pList->insertBack(pItem);
           		}
				else
				{
					pItem = NULL;
					pItem = new DRIVING_CMD_INFO_OF_DIRECTION();
#if(USE_CHANGENODE == 1)
					pItem->UBGRegion = DrivingInfo.UBGRegion;
					pItem->ObstacleRegion = DrivingInfo.ObstacleRegion;
	                pItem->dDistSumToEndNode = DrivingInfo.dDistSumToEndNode;
					pItem->nPBSIgnoreFlag = DrivingInfo.nPBSIgnoreFlag;
					pItem->nFollowsCommandType = DETECT_INFO_TYPE_BOTH;
	                pItem->nCount = DrivingInfo.nCount;

					// for change node
					pItem->NodeType = DrivingInfo.NodeType;
					pItem->OptDistance = DrivingInfo.OptDistance;
					pItem->OptDistanceAfter = DrivingInfo.OptDistanceAfter;
					pItem->OptUBGRegion = DrivingInfo.OptUBGRegion;
					pItem->OptObstacleRegion = DrivingInfo.OptObstacleRegion;
#else
	                pItem->Type = DrivingInfo.Direction;
	                pItem->dDistSumToEndNode = DrivingInfo.dDistSumToEndNode;
					pItem->nPBSIgnoreFlag = DrivingInfo.nPBSIgnoreFlag;
					pItem->nFollowsCommandType = DETECT_INFO_TYPE_BOTH;
	                pItem->nCount = DrivingInfo.nCount;
#endif
	                pList->insertBack(pItem);
				}
            }
        }//else of if(pItem->ID==DrivingInfo->EndNID)
    }//else of if(nCount==0)

    return bSuccess;
}
/**
@brief   명령으로 부터 Speed Info List 정보를 만들어 냄
@author  ehoto
@date    2013.7.19
@param pList: 정보를 저장하는 List의 포인터
@param pDrivingInfo: 명령 정보의 포인터
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
bool DrivingControl::makeList(List<DRIVING_CMD_INFO_OF_SPEED*> *pList, DRIVING_CMD_INFO_OF_PATH DrivingInfo, DRIVING_CMD_INFO_OF_TARGET TargetInfo)
{
    bool bSuccess = true;

    DRIVING_CMD_INFO_OF_SPEED *pItem = NULL;
    double dDecel = m_pParamSet->Axis.Default.dDefaultDecel;

    int nCount = pList->getCount();

    if(nCount==0)
    {
        // 시작 Node 정보 입력
        pItem = NULL;
        pItem = new DRIVING_CMD_INFO_OF_SPEED();
        pItem->dSpeed = DrivingInfo.dSpeed;
        pItem->dDistSumToFinalNode = DrivingInfo.dDistSumToEndNode;
        pItem->nCount = DrivingInfo.nCount;
        pItem->MarkType = TargetInfo.Type;
        pItem->dDistSumToTarget = TargetInfo.dDistSumToNode + TargetInfo.dOffset;
        pItem->dDecelDist = (pItem->dSpeed*pItem->dSpeed)/(2*dDecel);   // 감속 거리 구하는 식 : S=(V^2)/(2*a)
        pList->insertBack(pItem);
    }
    else//if(nCount==0)
    {
        //2 1) 중복 명령 확인
        pItem = pList->referBack();
        if(pItem->nCount==DrivingInfo.nCount)
        {
        //2 중복된 명령이면 Skip (Target까지의 거리 확인)
            if(pItem->dDistSumToTarget==(TargetInfo.dDistSumToNode + TargetInfo.dOffset))
            {

            }
        //2 Target Station 거리가 가까워진 경우 에러 처리
            else if(pItem->dDistSumToTarget>(TargetInfo.dDistSumToNode + TargetInfo.dOffset))
            {
                bSuccess = false;
            }
        //2 Target Station 거리가 Next Node를 넘어간 경우 에러 처리
            else if(pItem->dDistSumToTarget>(TargetInfo.dDistSumToNode + TargetInfo.dLength))
            {
                bSuccess = false;
            }
        //2 Target Station 정보가 변경된 경우
            else
            {
                // 시작 Node 정보 입력
                pItem->dSpeed = DrivingInfo.dSpeed;
                pItem->dDistSumToFinalNode = DrivingInfo.dDistSumToEndNode;
                pItem->nCount = DrivingInfo.nCount;
                pItem->MarkType = TargetInfo.Type;
                pItem->dDistSumToTarget = TargetInfo.dDistSumToNode + TargetInfo.dOffset;
                pItem->dDecelDist = (pItem->dSpeed*pItem->dSpeed)/(2*dDecel);   // 감속 거리 구하는 식 : S=(V^2)/(2*a)
                pList->insertBack(pItem);
            }
        }
        //2 2) 중복이 아닐 경우
        else//if(pItem->ID==DrivingInfo->EndNID)
        {
        //2 속도가 같을 경우
            if(pItem->dSpeed==DrivingInfo.dSpeed)
            {
                pItem->dSpeed = DrivingInfo.dSpeed;
                pItem->dDistSumToFinalNode = DrivingInfo.dDistSumToEndNode;
                pItem->nCount = DrivingInfo.nCount;
                pItem->MarkType = TargetInfo.Type;
                pItem->dDistSumToTarget = TargetInfo.dDistSumToNode + TargetInfo.dOffset;
                pItem->dDecelDist = (pItem->dSpeed*pItem->dSpeed)/(2*dDecel);   // 감속 거리 구하는 식 : S=(V^2)/(2*a)
            }
        //2 속도가 다른 경우
            else
            {
                // 이전 명령 의 Type을 Node로 변경
                pItem->MarkType = MARK_TYPE_NODE;
                pItem->dDistSumToTarget = pItem->dDistSumToFinalNode;
                pItem->dDecelDist = (pItem->dSpeed*pItem->dSpeed)/(2*dDecel);   // 감속 거리 구하는 식 : S=(V^2)/(2*a)

                // 새 명령 정보 추가
                pItem = NULL;
                pItem = new DRIVING_CMD_INFO_OF_SPEED();
                pItem->dSpeed = DrivingInfo.dSpeed;
                pItem->dDistSumToFinalNode = DrivingInfo.dDistSumToEndNode;
                pItem->nCount = DrivingInfo.nCount;
                pItem->MarkType = TargetInfo.Type;
                pItem->dDistSumToTarget = TargetInfo.dDistSumToNode + TargetInfo.dOffset;
                pItem->dDecelDist = (pItem->dSpeed*pItem->dSpeed)/(2*dDecel);   // 감속 거리 구하는 식 : S=(V^2)/(2*a)
                pList->insertBack(pItem);
            }
        }//else of if(pItem->ID==DrivingInfo->EndNID)
    }//else of if(nCount==0)

    return bSuccess;
}
/**
@brief   명령으로 부터 Path Info List 정보를 만들어 냄
@author  ehoto
@date    2013.7.19
@param pList: 정보를 저장하는 List의 포인터
@param pDrivingInfo: 명령 정보의 포인터
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
bool DrivingControl::makeList(List<DRIVING_CMD_INFO_OF_PATH*> *pList, DRIVING_CMD_INFO_OF_PATH DrivingInfo)
{
    bool bSuccess = true;
    DRIVING_CMD_INFO_OF_PATH* pItem = NULL;

    int nCount = pList->getCount();

    if(nCount==0)
    {
		// 시작 Path 정보 입력
        pItem = NULL;
		pItem = new DRIVING_CMD_INFO_OF_PATH();
		*pItem = DrivingInfo;

		pList->insertBack(pItem);
	}
	else//if(nCount==0)
	{
		//2 1) 중복 명령 확인
		pItem = pList->referBack();
		if(pItem->EndNID==DrivingInfo.EndNID)
		{
		//2 마지막 Node는 같으나 이전 노드가 다른 경우
			if(pItem->StartNID!=DrivingInfo.StartNID)
			{
				bSuccess = false;
//              ERR_LOG("DrivingControl::makeList: 마지막 Node는 같으나 이전 노드가 다른 경우 [Curr(%X)!=StartNID%X]", pItem->ID, DrivingInfo.StartNID);
			}
		//2 중복된 명령이면 Skip
			else//if(nCount>1)
			{
				// skip
			}//else of if(nCount>1)
		}
		//2 2) 중복이 아닐 경우
		else//if(pItem->ID==DrivingInfo->EndNID)
		{
		//2 비연속 명령 확인
			if(pItem->EndNID!=DrivingInfo.StartNID)
			{
				bSuccess = false;
//              ERR_LOG("DrivingControl::makeList: 비연속 명령 [Curr(%X)!=StartNID%X]", pItem->ID, DrivingInfo.StartNID);
			}
		//2 정상 명령 (연속 명령 경우)
			else//if(pItem->ID!=DrivingInfo->StartNID)
			{
				pItem = NULL;
				pItem = new DRIVING_CMD_INFO_OF_PATH();
				*pItem = DrivingInfo;

				pList->insertBack(pItem);
			}//else of if(pItem->ID!=DrivingInfo->StartNID)

		}//else of if(pItem->ID==DrivingInfo->EndNID)
	}//else of if(nCount==0)

	return bSuccess;
}
////////후진기능을 위한 추가된 부분

/**
@brief   명령으로 부터 Node Info List 정보를 만들어 냄
@author  ehoto
@date    2013.7.19
@param pList: 정보를 저장하는 List의 포인터
@param pDrivingInfo: 명령 정보의 포인터
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
bool DrivingControl::makeBackList(List<DRIVING_CMD_INFO_OF_NODE*> *pList, DRIVING_CMD_INFO_OF_PATH DrivingInfo)
{
    bool bSuccess = true;
    DRIVING_CMD_INFO_OF_NODE* pItem = NULL;

    int nCount = pList->getCount();

    if(nCount==0)
    {
        // 시작 Node 정보 입력
        pItem = NULL;
		pItem = new DRIVING_CMD_INFO_OF_NODE();
		pItem->ID = DrivingInfo.EndNID;
		pItem->Type = DrivingInfo.EndNType;
		pItem->dDistSum = 0;
		pItem->nCount = 0;
//		pItem->DivInfo = DrivingInfo.DivInfo;
//		if(DrivingInfo.NodeType ==SLOPE_NTYPE) pItem->SlopeInfo = NODE_SLOPE;
//		else	pItem->SlopeInfo = NODE_NORMAL;
		pItem->NodeType = DrivingInfo.NodeType;
		pList->insertBack(pItem);

        // 다음 Node 정보 입력
        pItem = NULL;
        pItem = new DRIVING_CMD_INFO_OF_NODE();
		pItem->ID = DrivingInfo.StartNID;
		pItem->Type = DrivingInfo.StartNType;
		pItem->dDistSum = DrivingInfo.dDistSumToEndNode;
		pItem->nCount = DrivingInfo.nCount;
//		pItem->DivInfo = PATH_DIVERGENCE_NONE;
//		if(DrivingInfo.NodeType ==SLOPE_NTYPE) pItem->SlopeInfo = NODE_SLOPE;
//		else	pItem->SlopeInfo = NODE_NORMAL;
		pItem->NodeType = DrivingInfo.NodeType;
        pList->insertBack(pItem);
    }
	else//if(nCount==0)
    {
        //2 1) 중복 명령 확인
		pItem = pList->referBack();
//        if(pItem->ID==DrivingInfo.EndNID)
//        {
//        //2 마지막 Node는 같으나 이전 노드가 다른 경우
//            if(nCount>1)
//            {
//                pItem = pList->refer(nCount-2);
//                if(pItem->ID!=DrivingInfo.StartNID)
//                {
//                    bSuccess = false;
//                    ERR_LOG("DrivingControl::makeList: 마지막 Node는 같으나 이전 노드가 다른 경우 [Curr(%d)!=StartNID%d]", pItem->ID, DrivingInfo.StartNID);
//                }
//            }
//        //2 중복된 명령이면 Skip
//            else//if(nCount>1)
//            {
//                // skip
//            }//else of if(nCount>1)
//		}
		//2 2) 중복이 아닐 경우
		if(pItem->ID==DrivingInfo.EndNID)
		{
		//2 비연속 명령 확인
			if(pItem->ID!=DrivingInfo.EndNID)
			{
				bSuccess = false;
				ERR_LOG("DrivingControl::makeList: 비연속 명령 [Curr(%X)!=StartNID%X]", pItem->ID, DrivingInfo.StartNID);
			}
		//2 정상 명령 (연속 명령 경우)
			else//if(pItem->ID!=DrivingInfo->StartNID)
			{

//				pItem->DivInfo = DrivingInfo.DivInfo;

				pItem = NULL;
				pItem = new DRIVING_CMD_INFO_OF_NODE();
				pItem->ID = DrivingInfo.StartNID;
				pItem->Type = DrivingInfo.StartNType;
				pItem->dDistSum = DrivingInfo.dDistSumToEndNode;
				pItem->nCount = DrivingInfo.nCount;
//				pItem->DivInfo = PATH_DIVERGENCE_NONE;
//				if(DrivingInfo.NodeType ==SLOPE_NTYPE) pItem->SlopeInfo = NODE_SLOPE;
//				else	pItem->SlopeInfo = NODE_NORMAL;
				pItem->NodeType = DrivingInfo.NodeType;
				pList->insertBack(pItem);
			}//else of if(pItem->ID!=DrivingInfo->StartNID)

		}//else of if(pItem->ID==DrivingInfo->EndNID)
	}//else of if(nCount==0)

	return bSuccess;
}

/**
@brief   명령으로 부터 Speed Info List 정보를 만들어 냄
@author  수정 필요
@date    2013.7.19
@param pList: 정보를 저장하는 List의 포인터
@param pDrivingInfo: 명령 정보의 포인터
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
bool DrivingControl::makeBackList(List<DRIVING_CMD_INFO_OF_SPEED*> *pList, DRIVING_CMD_INFO_OF_PATH DrivingInfo, DRIVING_CMD_INFO_OF_TARGET TargetInfo)
{
	bool bSuccess = true;

	DRIVING_CMD_INFO_OF_SPEED *pItem = NULL;
	double dDecel = m_pParamSet->Axis.Default.dDefaultDecel;

	int nCount = pList->getCount();

	if(nCount==0)
	{
		// 시작 Node 정보 입력
		pItem = NULL;
		pItem = new DRIVING_CMD_INFO_OF_SPEED();
		pItem->dSpeed = DrivingInfo.dSpeed;
		pItem->dDistSumToFinalNode = DrivingInfo.dDistSumToEndNode;
		pItem->nCount = DrivingInfo.nCount;
		pItem->MarkType = TargetInfo.Type;
		pItem->dDistSumToTarget = TargetInfo.dDistSumToNode + TargetInfo.dOffset;
		pItem->dDecelDist = (pItem->dSpeed*pItem->dSpeed)/(2*dDecel);   // 감속 거리 구하는 식 : S=(V^2)/(2*a)
		pList->insertBack(pItem);
    }
    else//if(nCount==0)
    {
        //2 1) 중복 명령 확인
        pItem = pList->referBack();
        if(pItem->nCount==DrivingInfo.nCount)
        {
        //2 중복된 명령이면 Skip (Target까지의 거리 확인)
            if(pItem->dDistSumToTarget==(TargetInfo.dDistSumToNode + TargetInfo.dOffset))
            {

			}
		//2 Target Station 거리가 가까워진 경우 에러 처리 부호 반대
			else if(pItem->dDistSumToTarget < (TargetInfo.dDistSumToNode + TargetInfo.dOffset))
			{
				bSuccess = false;
			}
		//2 Target Station 거리가 Next Node를 넘어간 경우 에러 처리  부호 반대
            else if(pItem->dDistSumToTarget < (TargetInfo.dDistSumToNode + TargetInfo.dLength))
            {
                bSuccess = false;
            }
        //2 Target Station 정보가 변경된 경우
            else
            {
                // 시작 Node 정보 입력
                pItem->dSpeed = DrivingInfo.dSpeed;
                pItem->dDistSumToFinalNode = DrivingInfo.dDistSumToEndNode;
                pItem->nCount = DrivingInfo.nCount;
                pItem->MarkType = TargetInfo.Type;
                pItem->dDistSumToTarget = TargetInfo.dDistSumToNode + TargetInfo.dOffset;
                pItem->dDecelDist = (pItem->dSpeed*pItem->dSpeed)/(2*dDecel);   // 감속 거리 구하는 식 : S=(V^2)/(2*a)
                pList->insertBack(pItem);
            }
        }
        //2 2) 중복이 아닐 경우
        else//if(pItem->ID==DrivingInfo->EndNID)
        {
        //2 속도가 같을 경우
            if(pItem->dSpeed==DrivingInfo.dSpeed)
            {
                pItem->dSpeed = DrivingInfo.dSpeed;
                pItem->dDistSumToFinalNode = DrivingInfo.dDistSumToEndNode;
                pItem->nCount = DrivingInfo.nCount;
                pItem->MarkType = TargetInfo.Type;
                pItem->dDistSumToTarget = TargetInfo.dDistSumToNode + TargetInfo.dOffset;
                pItem->dDecelDist = (pItem->dSpeed*pItem->dSpeed)/(2*dDecel);   // 감속 거리 구하는 식 : S=(V^2)/(2*a)
            }
        //2 속도가 다른 경우
            else
            {
                // 이전 명령 의 Type을 Node로 변경
                pItem->MarkType = MARK_TYPE_NODE;
                pItem->dDistSumToTarget = pItem->dDistSumToFinalNode;
                pItem->dDecelDist = (pItem->dSpeed*pItem->dSpeed)/(2*dDecel);   // 감속 거리 구하는 식 : S=(V^2)/(2*a)

                // 새 명령 정보 추가
                pItem = NULL;
                pItem = new DRIVING_CMD_INFO_OF_SPEED();
                pItem->dSpeed = DrivingInfo.dSpeed;
                pItem->dDistSumToFinalNode = DrivingInfo.dDistSumToEndNode;
                pItem->nCount = DrivingInfo.nCount;
                pItem->MarkType = TargetInfo.Type;
                pItem->dDistSumToTarget = TargetInfo.dDistSumToNode + TargetInfo.dOffset;
                pItem->dDecelDist = (pItem->dSpeed*pItem->dSpeed)/(2*dDecel);   // 감속 거리 구하는 식 : S=(V^2)/(2*a)
                pList->insertBack(pItem);
            }
        }//else of if(pItem->ID==DrivingInfo->EndNID)
    }//else of if(nCount==0)

    return bSuccess;
}
/**
@brief   명령으로 부터 Path Info List 정보를 만들어 냄
@author  ehoto
@date    2013.7.19
@param pList: 정보를 저장하는 List의 포인터
@param pDrivingInfo: 명령 정보의 포인터
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
bool DrivingControl::makeBackList(List<DRIVING_CMD_INFO_OF_PATH*> *pList, DRIVING_CMD_INFO_OF_PATH DrivingInfo)
{
    bool bSuccess = true;
    DRIVING_CMD_INFO_OF_PATH* pItem = NULL;

    int nCount = pList->getCount();

    if(nCount==0)
    {
		// 시작 Path 정보 입력
        pItem = NULL;
		pItem = new DRIVING_CMD_INFO_OF_PATH();
		*pItem = DrivingInfo;

		pList->insertBack(pItem);
	}
	else//if(nCount==0)
	{
		//2 1) 중복 명령 확인
		pItem = pList->referBack();
		if(pItem->EndNID==DrivingInfo.EndNID)
		{
		//2 마지막 Node는 같으나 이전 노드가 다른 경우
			if(pItem->StartNID!=DrivingInfo.StartNID)
			{
				bSuccess = false;
//              ERR_LOG("DrivingControl::makeList: 마지막 Node는 같으나 이전 노드가 다른 경우 [Curr(%X)!=StartNID%X]", pItem->ID, DrivingInfo.StartNID);
			}
		//2 중복된 명령이면 Skip
			else//if(nCount>1)
			{
				// skip
			}//else of if(nCount>1)
		}
		//2 2) 중복이 아닐 경우
		else//if(pItem->ID==DrivingInfo->EndNID)
		{
		//2 비연속 명령 확인
			if(pItem->StartNID!=DrivingInfo.EndNID)
			{
				bSuccess = false;
//              ERR_LOG("DrivingControl::makeList: 비연속 명령 [Curr(%X)!=StartNID%X]", pItem->ID, DrivingInfo.StartNID);
			}
		//2 정상 명령 (연속 명령 경우)
			else//if(pItem->ID!=DrivingInfo->StartNID)
			{
				pItem = NULL;
				pItem = new DRIVING_CMD_INFO_OF_PATH();
				*pItem = DrivingInfo;

				pList->insertBack(pItem);
			}//else of if(pItem->ID!=DrivingInfo->StartNID)

		}//else of if(pItem->ID==DrivingInfo->EndNID)
	}//else of if(nCount==0)

	return bSuccess;
}




/**
@brief   위치 정보 확인 및 지나간 Classified List 정리
@author  임태웅
@date    2013.08.05
@param HwInfo 입력되는 HW 정보
@param pInfoSet 변경되는 상태 정보
@return 에러 없으면 0반환, 있으면 에러 코드 반환
*/
UINT DrivingControl::checkPosition(DRIVING_HW_INFO_SET HwInfo, DRIVING_INFO_SET *pInfoSet)
{

	//거리값 확인용
	static int nPrenodeInfo = 0;
  //	static double m_dPreNodecountPosition = 0.0;

    UINT nTmpError = NO_ERR;
    double dNodeDistOffset = 0.0;

//	//김태균 20151216
	int tmpCurrenrtNodeID = (int)m_PositionInfo.CurrNode;
//	int tmpCurrenrtNextID = 0;
//	int tmpCurrentCMDID = 0;

	double dSpeedDownPos    = pInfoSet->Position.CmdRefInfo.dSpeedDownPos;//getSpeedDownPos();

	int nDetectStatus = pHWSet->m_pOHTDetect->GetStatus(); //DETECT_AND_STOP

	DRIVING_CMD_INFO_OF_NODE* pPreNodeInfo = getNodeInfo(HwInfo.Node.nPreCheckCount);
	DRIVING_CMD_INFO_OF_PATH* pPrePathInfo = getPathInfo(HwInfo.Node.nPreCheckCount);
	DRIVING_CMD_INFO_OF_NODE* pNodeInfo = getNodeInfo(HwInfo.Node.nNodeCount);
	DRIVING_CMD_INFO_OF_PATH* pPathInfo = getPathInfo(HwInfo.Node.nNodeCount);

	PATH_DIVERGENCE_INFO NodeDivInfo = NULL;
	PATH_DIVERGENCE_INFO NextDivInfo = NULL;


	DRIVING_INFO_SET PreInfoSet = *pInfoSet;

	bool    bSteerFrontLeft = pInfoSet->HwInfo.IO.SteerFrontLeftInOn;
    bool    bSteerFrontRight    = pInfoSet->HwInfo.IO.SteerFrontRightInOn;
    bool    bSteerRearLeft      = pInfoSet->HwInfo.IO.SteerRearLeftInOn;
    bool    bSteerRearRight = pInfoSet->HwInfo.IO.SteerRearRightInOn;

	if(pNodeInfo==NULL)
    {
        ADD_LOG("D_86/%d/%d/%d"
            , HwInfo.Node.nNodeCount
            , pInfoSet->HwInfo.Node.nNodeCount
			, m_ClassifiedCmd.NodeList.getCount());
		ADD_FDC_LOG("ERR/%d/1/5/%06d/%06d/%d/%d/%06d",
					ERR_NOTFIND_NODE,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pExecuteInfo->ExecutePositionInfo.NextNode,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					m_pOHTMainStatus->StatusCommon.ExistFoup,
					m_pOHTMainStatus->StatusCommon.StopStationID);
        return ERR_NOTFIND_NODE;// 에러 처리 : 명령에 없는 노드 Count 실시
	}

    if( (m_PreviousArrivalInfo.Info.MarkType==MARK_TYPE_NODE)
    &&  (HwInfo.Node.nNodeCount==0))
    {
		dNodeDistOffset = m_pParamSet->Mark[0].Dist.dAddDistAfterSecondMet;
    }

	//FirtNode에서 강제로 노드카운트 1개 Up 거리값 확인.(타겟노드가 바로 앞이 아닐 경우)
	if(m_bIsFirstNodeCountAdd ==false)
	{
		if((HwInfo.Node.nNodeCount==0)
		&& (HwInfo.IO.NodeOn ==ON)
		&& (HwInfo.Axis1.dCurrPos <100.0)//40.0)
		)
		{

			if((pNodeInfo->ID  != m_ClassifiedCmd.TargetInfo.Node)
			&&(pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.MarkType !=MARK_TYPE_NODE)
//			&& (m_PreviousArrivalInfo.Info.MarkType!=MARK_TYPE_NODE)
			&& (pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset > 300.0))
			{
				ADD_LOG("D_87/%d/%d/%d/%f",pNodeInfo->ID,m_ClassifiedCmd.TargetInfo.Node,pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.MarkType,pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset);
				m_pDrivingAxis->SetFirstNodeCountAdd();
				m_bIsFirstNodeCountAdd = true;
			}
		}
	}
    //1 HW
	pInfoSet->HwInfo = HwInfo;



//  if((pInfoSet->HwInfo.IO.ObsStatus!=DETECT_NONE)||(pInfoSet->HwInfo.IO.DetectStatus!=DETECT_NONE))
//  {
//      ADD_LOG("D_88/%d/%d"
//          , pInfoSet->HwInfo.IO.ObsStatus
//          , pInfoSet->HwInfo.IO.DetectStatus);
//  }
    //1 Position
    //2 TargetPosition
    pInfoSet->Position.CurrentAndTarget.TargetPosition.MarkType     = m_ClassifiedCmd.TargetInfo.Type;
    pInfoSet->Position.CurrentAndTarget.TargetPosition.uNode        = m_ClassifiedCmd.TargetInfo.Node;
    pInfoSet->Position.CurrentAndTarget.TargetPosition.uNextNode    = m_ClassifiedCmd.TargetInfo.NextNode;
    pInfoSet->Position.CurrentAndTarget.TargetPosition.uStation     = m_ClassifiedCmd.TargetInfo.Station;
    pInfoSet->Position.CurrentAndTarget.TargetPosition.dOffset      = m_ClassifiedCmd.TargetInfo.dOffset;

	//AOHC-196 사전 로그 추가
	m_DiagManager->IncreasePreviosDiagMax(PREVIOS_DIAG_FOLOWF_MAX, abs(m_pDrivingAxis->GetFollowing_Axis1()));
	//ADD_LOG("D_89/%6..1lf/%d",HwInfo.Axis1.dFollowError,(DWORD)HwInfo.Axis1.dFollowError);
	//2 Compensation
	if(((m_bFirstNodeStep == true) && (HwInfo.Node.dNodePosition > 100.0)) || (m_bFirstNodeStep == false) || (HwInfo.Axis1.dCurrPos > 200.0))
	{
		if(m_bFirstNodeStep == true) m_bFirstNodeStep = false;     // FirstNodeStop과 타이밍 이슈 제거로 인해 추가 puting

		if((HwInfo.Node.nNodeCount!=m_dPreNodecount) && (m_dPreNodecountPosition != HwInfo.Node.dNodePosition))
		{

			getFrontObservationNodeCount(HwInfo.Node.nNodeCount);

			m_RunOffsetDistance = 0.0;
			pInfoSet->Position.Compensation.dDistErrorSum       = HwInfo.Node.dNodePosition - pNodeInfo->dDistSum
																+ m_InfoSet.Position.Compensation.dPreArriveOffset;
			pInfoSet->Position.Compensation.dLinkDistError      = pInfoSet->Position.Compensation.dDistErrorSum
																- PreInfoSet.Position.Compensation.dDistErrorSum;
			//pInfoSet->Position.Compensation.dPreArriveOffset = // 처음 명령 인가 시 설정
			pInfoSet->Position.Compensation.dWearRatio          = 1.0
																+ pInfoSet->Position.Compensation.dDistErrorSum/pNodeInfo->dDistSum;



			try{
				if(HwInfo.Node.nNodeCount > 1)
				{
					DRIVING_CMD_INFO_OF_PATH* pTestPathInfo = getPathInfo(HwInfo.Node.nNodeCount-1);
					if(pTestPathInfo!=NULL)
					{
							ADD_LOG("D_90/%06f/%06f/%06f/%06f/%06f/%d/%d/%d/%d/%06f/%06f/%06f/%06f",
							pNodeInfo->dDistSum,
							pInfoSet->Position.Compensation.dPreArriveOffset,
							pInfoSet->Position.Compensation.dDistErrorSum,
							HwInfo.Node.dNodePosition, HwInfo.Axis1.dCurrPos,
							m_Dectect_Dir,m_Dectect_OBS_Dir ,nPrenodeInfo,
							pNodeInfo->ID,m_dPreNodecountPosition, HwInfo.Node.dNodePosition,
							pTestPathInfo->dLength,(HwInfo.Node.dNodePosition-m_dPreNodecountPosition));

							//AOHC-253 모니터링 로그 주행 오차 발생 로깅
							if((HwInfo.Node.dNodePosition-m_dPreNodecountPosition)- pTestPathInfo->dLength  < -100.0) //너무 일찍 나타나거나
							{
								 m_DiagManager->IncreasePreviosDiagCount(PREVIOS_DIAG_MAP_DGAP);   //사전로그
								 ADD_MD_LOG("MAP_DGAP_EARLY N:%d~%d, Diff:%5.1lf, MapDist: %5.1lf , RealDist : %5.1lf, PreSpeed:%5.1lf, CurSpeed:%5.1lf",    nPrenodeInfo,pNodeInfo->ID,((HwInfo.Node.dNodePosition-m_dPreNodecountPosition)- pTestPathInfo->dLength),pTestPathInfo->dLength,(HwInfo.Node.dNodePosition-m_dPreNodecountPosition),m_dPreNodecountSpeed,pPathInfo->dSpeed);
							}
							else if((HwInfo.Node.dNodePosition-m_dPreNodecountPosition) - pTestPathInfo->dLength > 100.0)//너무 일찍 나타나거나
							{
								m_DiagManager->IncreasePreviosDiagCount(PREVIOS_DIAG_MAP_DGAP);   //사전로그
								ADD_MD_LOG("MAP_DGAP_LATE N:%d~%d, Diff:%5.1lf, MapDist: %5.1lf , RealDist : %5.1lf, PreSpeed:%5.1lf, CurSpeed:%5.1lf",    nPrenodeInfo,pNodeInfo->ID,(pTestPathInfo->dLength - (HwInfo.Node.dNodePosition-m_dPreNodecountPosition)),pTestPathInfo->dLength,(HwInfo.Node.dNodePosition-m_dPreNodecountPosition),m_dPreNodecountSpeed,pPathInfo->dSpeed);
							}

							SEND_WARN("MCC/12/1/6/%06d/%06d/%d/%d/%06d/%06f",
										m_pOHTMainStatus->StatusCommon.CurNodeID,
										m_pExecuteInfo->ExecutePositionInfo.NextNode,
										m_pOHTMainStatus->StatusCommon.CurNodeOffset,
										m_pOHTMainStatus->StatusCommon.ExistFoup,
										m_pOHTMainStatus->StatusCommon.StopStationID,
										pInfoSet->Position.Compensation.dLinkDistError);
					}
				}
				else
				{
					ADD_LOG("D_91/%06f/%06f/%06f/%06f/%06f/%d/%d",
					pNodeInfo->dDistSum,
					pInfoSet->Position.Compensation.dPreArriveOffset,
					pInfoSet->Position.Compensation.dDistErrorSum,
					HwInfo.Node.dNodePosition, HwInfo.Axis1.dCurrPos,
					m_Dectect_Dir,m_Dectect_OBS_Dir);

					SEND_WARN("MCC/12/1/6/%06d/%06d/%d/%d/%06d/%06f",
								m_pOHTMainStatus->StatusCommon.CurNodeID,
								m_pExecuteInfo->ExecutePositionInfo.NextNode,
								m_pOHTMainStatus->StatusCommon.CurNodeOffset,
								m_pOHTMainStatus->StatusCommon.ExistFoup,
								m_pOHTMainStatus->StatusCommon.StopStationID,
								pInfoSet->Position.Compensation.dLinkDistError);
				}



			}catch(...)
			{

			}

			nPrenodeInfo = pNodeInfo->ID;
			m_dPreNodecountPosition  = HwInfo.Node.dNodePosition;
			m_dPreNodecountSpeed =HwInfo.Axis1.dSpeed;
			m_dPreNodecount = HwInfo.Node.nNodeCount;
		}
	}

	//3 PreCheck Sensor 난반사에 의한 에러 처리 추가.(일반 주행시만 확인)
	//if((HwInfo.Node.nPreCheckCount!=PreInfoSet.HwInfo.Node.nPreCheckCount) && (m_dPrePrecheckNodecountPosition != HwInfo.Node.dPreCheckPosition))
	/*
   if(m_dPrePrecheckNodecountPosition != HwInfo.Node.dPreCheckPosition)
	{
		try{
			if((HwInfo.Node.nPreCheckCount > 2) &&(HwInfo.Node.nPreCheckCount!=PreInfoSet.HwInfo.Node.nPreCheckCount))
			{
				DRIVING_CMD_INFO_OF_PATH* pTest2PathInfo = getPathInfo(HwInfo.Node.nPreCheckCount-1);
				if(pTest2PathInfo!=NULL)
				{
					ADD_LOG("D_92/%06f/%06f/%06f/%06f"
					,m_dPrePrecheckNodecountPosition, HwInfo.Node.dPreCheckPosition, pTest2PathInfo->dLength,(HwInfo.Node.dPreCheckPosition-m_dPrePrecheckNodecountPosition));

					m_dCheckPrecheckNodecountPosition =  pTest2PathInfo->dLength - (HwInfo.Node.dPreCheckPosition-m_dPrePrecheckNodecountPosition);
				}
			}
		}catch(...)
		{

		}

		m_dPrePrecheckNodecountPosition  = HwInfo.Node.dPreCheckPosition;
	}
   */

	if(m_dPrePrecheckNodecountPosition != HwInfo.Node.dPreCheckPosition)
    {
        try{
            if(HwInfo.Node.nPreCheckCount > 2)
            {
				//if(HwInfo.Node.nPreCheckCount!=PreInfoSet.HwInfo.Node.nPreCheckCount)
				if(HwInfo.Node.nPreCheckCount!=m_nPrePreCount)   //  m_nPrePreCount 이전 노드의 Precount 저장값
				{
                    DRIVING_CMD_INFO_OF_PATH* pTest2PathInfo = getPathInfo(HwInfo.Node.nPreCheckCount-1);
					if(pTest2PathInfo!=NULL)
                    {
                        ADD_LOG("D_92/%06f/%06f/%06f/%06f"
						,m_dPrePrecheckNodecountPosition, HwInfo.Node.dPreCheckPosition, pTest2PathInfo->dLength,(HwInfo.Node.dPreCheckPosition-m_dPrePrecheckNodecountPosition));

						m_dCheckPrecheckNodecountPosition =  pTest2PathInfo->dLength - (HwInfo.Node.dPreCheckPosition-m_dPrePrecheckNodecountPosition);
					}
					m_dPrePrecheckNodecountPosition  = HwInfo.Node.dPreCheckPosition;
					m_nPrePreCount = HwInfo.Node.nPreCheckCount;
				}
            }
			else
			{
				m_dPrePrecheckNodecountPosition  = HwInfo.Node.dPreCheckPosition;
				m_nPrePreCount = HwInfo.Node.nPreCheckCount;
			}
		}catch(...)
		{

		}
    }

	pInfoSet->Position.Compensation.dCompensatedPosition    = HwInfo.Axis1.dCurrPos
															- pInfoSet->Position.Compensation.dDistErrorSum;
//															- pInfoSet->Position.Compensation.dPreArriveOffset;


	//2 CurrPositionStatus
    //pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.bMarked; // Mark 마무리서 처리
    //pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.uRealArrivedNode = // Mark 마무리서 처리
    //pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.MarkType = // Mark 마무리서 처리
    pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.uNode       = pNodeInfo->ID;
    pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.uNextNode   = (pPathInfo!=NULL)?pPathInfo->EndNID:0;
    //pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.uStation = // Mark 마무리서 처리
	pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset     = pInfoSet->Position.Compensation.dCompensatedPosition
																			- pNodeInfo->dDistSum + dNodeDistOffset
																			+ pInfoSet->Position.Compensation.dPreArriveOffset;

//	m_RunOffsetDistance = dNodeDistOffset - pNodeInfo->dDistSum - pInfoSet->Position.Compensation.dDistErrorSum + HwInfo.Node.dNodePosition; //ㅋㅋㅋㅋ

//
//	ADD_LOG("D_93/%06f/%06f",
//			pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset,
//			pInfoSet->Position.Compensation.dCompensatedPosition);


    //pInfoSet->Position.Mark.dFrontPosition = // Mark 마무리서 처리
    //pInfoSet->Position.Mark.dRearPosition = // Mark 마무리서 처리
    //pInfoSet->Position.Mark.PositionStatus = // Mark 마무리서 처리

    //pInfoSet->Position.CmdRefInfo.dCmdSpeed = // 명령 인가 시점 설정
    //pInfoSet->Position.CmdRefInfo.dRefSpeed = // 명령 인가 시점 설정
    //pInfoSet->Position.CmdRefInfo.nCount = // 명령 인가 시점 설정
    //pInfoSet->Position.CmdRefInfo.dDist = // 명령 인가 시점 설정
    //pInfoSet->Position.CmdRefInfo.dSpeedDownPos = // 명령 인가 시점 설정


    //1 임시
    if(m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uStation!=0)
    {
        if( (PreInfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode!=pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.uNode)
        ||  (pInfoSet->HwInfo.Node.nNodeCount>0)
        ||  (pInfoSet->HwInfo.Node.nPreCheckCount>0)
        )
        {
            if(m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uStation!=0)
            {
                m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uStation = 0;
            }
        }
    }

	//2 Steer
    // Steer
    //pInfoSet->Steer.PathSteer = (pPathInfo!=NULL)?pPathInfo->Steering:0;
    //pInfoSet->Steer.PathDirection = (pPathInfo!=NULL)?pPathInfo->Direction:0;
    //pInfoSet->Steer.FrontPosition = getSteerPosition(HwInfo.IO.SteerFrontLeftInOn, HwInfo.IO.SteerFrontRightInOn);
    //pInfoSet->Steer.FrontCmdDirection = // 명령 인가 시점 설정
    //pInfoSet->Steer.FrontMoving = // 명령 인가 시점 설정
    //pInfoSet->Steer.RearPosition = getSteerPosition(HwInfo.IO.SteerRearLeftInOn, HwInfo.IO.SteerRearLeftInOn);
    //pInfoSet->Steer.RearCmdDirection = // 명령 인가 시점 설정
    //pInfoSet->Steer.RearMoving = // 명령 인가 시점 설정

    //2 Time
    //pInfoSet->Time.Steer.SteeringChangeCmded.bFlag = // 명령 인가 시점 설정
    //pInfoSet->Time.Steer.SteeringChangeCmded.dwTime = // 명령 인가 시점 설정
    //pInfoSet->Time.Steer.SteeringNotMatch.bFlag = // 에러 확인 시점 설정
    //pInfoSet->Time.Steer.SteeringNotMatch.dwTime = // 에러 확인 시점 설정
    //
    //pInfoSet->Time.Steer.FrontSteeringArrived.bFlag =
    //pInfoSet->Time.Steer.FrontSteeringArrived.dwTime =
    //
    //pInfoSet->Time.Steer.RearSteeringArrived.bFlag =
    //pInfoSet->Time.Steer.RearSteeringArrived.dwTime =
    //
    //pInfoSet->Time.Steer.FrontSteeringDeparted.bFlag =
    //pInfoSet->Time.Steer.FrontSteeringDeparted.dwTime =
    //
    //pInfoSet->Time.Steer.RearSteeringDeparted.bFlag =
    //pInfoSet->Time.Steer.RearSteeringDeparted.dwTime =


    //pInfoSet->Time.FrontObserve.OHTDetectFail.bFlag =
    //pInfoSet->Time.FrontObserve.OHTDetectFail.dwTime =
    //pInfoSet->Time.FrontObserve.OBSDetectFail.bFlag =
    //pInfoSet->Time.FrontObserve.OBSDetectFail.dwTime =
    //pInfoSet->Time.FrontObserve.OBSDetect.bFlag =
    //pInfoSet->Time.FrontObserve.OBSDetect.dwTime =

    //pInfoSet->Time.Stop.OnAbnormalStop.bFlag =
    //pInfoSet->Time.Stop.OnAbnormalStop.dwTime =

    //2 Events & States
    // Event

	pInfoSet->EventAndState.Event.CmdAdded = ((memcmp(&(PreInfoSet.Position.CurrentAndTarget.TargetPosition)
                                                , &(pInfoSet->Position.CurrentAndTarget.TargetPosition)
												, sizeof(POSITION_INFO)))==0)   ?false:true;

//	pInfoSet->EventAndState.Event.TargetChanged = pInfoSet->EventAndState.Event.CmdAdded;
	pInfoSet->EventAndState.Event.PreCheck = (PreInfoSet.HwInfo.Node.nPreCheckCount<pInfoSet->HwInfo.Node.nPreCheckCount)?true:false;
	pInfoSet->EventAndState.Event.Check = (PreInfoSet.HwInfo.Node.nNodeCount<pInfoSet->HwInfo.Node.nNodeCount)?true:false;
	pInfoSet->EventAndState.Event.SpeedDownPassed = (   (pInfoSet->HwInfo.Axis1.dCurrPos>=pInfoSet->Position.CmdRefInfo.dSpeedDownPos)
//                                                  &&  (PreInfoSet.HwInfo.Axis1.dCurrPos<pInfoSet->Position.CmdRefInfo.dSpeedDownPos))
													&& (PreInfoSet.EventAndState.State.SpeedDownPassed==false))
													?true:false;

	//pInfoSet->EventAndState.Event.FrontSteerMoved
	//pInfoSet->EventAndState.Event.RearSteerMoved
	//pInfoSet->EventAndState.Event.FrontSteerCompleted
	//pInfoSet->EventAndState.Event.AllCompleted
	//pInfoSet->EventAndState.Event.PushedByGuide
	//pInfoSet->EventAndState.Event.StopWithNoReason
	//pInfoSet->EventAndState.Event.DistNotMatch

	pInfoSet->EventAndState.Event.MarkCmd = (   (isMarkArea()==true)
												&& (pInfoSet->EventAndState.State.MarkArea==false))
												?true:false;

	//State
	pInfoSet->EventAndState.State.NodePreChecked = (pInfoSet->HwInfo.Node.nNodeCount<pInfoSet->HwInfo.Node.nPreCheckCount)?true:false;
	//pInfoSet->EventAndState.State.OutInNodeDiffSteer  // Axis 명령 시
	//pInfoSet->EventAndState.State.SteerMoving
	//pInfoSet->EventAndState.State.SteerFrontCompleted
	//pInfoSet->EventAndState.State.SteerAllCompleted
	//pInfoSet->EventAndState.State.SteerChangeAreaByGuide
	//pInfoSet->EventAndState.State.StopByFrontDetect
	//pInfoSet->EventAndState.State.SpeedDownByFrontDetect
	pInfoSet->EventAndState.State.SpeedDownPassed   = (pInfoSet->HwInfo.Axis1.dCurrPos>=pInfoSet->Position.CmdRefInfo.dSpeedDownPos)
													?true:false;
	pInfoSet->EventAndState.State.MarkArea = (pInfoSet->EventAndState.State.MarkArea==true)?true:isMarkArea();
	pInfoSet->EventAndState.State.DualStageStbArea = (pInfoSet->EventAndState.State.MarkArea==true)?true:isDualStageArea();
//	EnterCriticalSection(&OHTMainForm->m_CS);
	m_pExecuteInfo->dCompensatedPosition   = HwInfo.Axis1.dCurrPos
											- pInfoSet->Position.Compensation.dDistErrorSum;


	m_pExecuteInfo->FlagInitPositon.dDrivingInitPosition = pNodeInfo->dDistSum
														   - m_InfoSet.Position.Compensation.dPreArriveOffset;
	if(m_pExecuteInfo->FlagInitPositon.dDrivingInitPosition <0.0 )
		m_pExecuteInfo->FlagInitPositon.dDrivingInitPosition = 0.0;



	try
	{                                 //11(114node) , 현재 분기정보, 다음분기정보
		int TempNodeCount = 0;
		if(getDivergenceInfo(HwInfo.Node.nNodeCount, &NodeDivInfo, &NextDivInfo,&TempNodeCount)==true)
		{
			m_pExecuteInfo->nCheckDivInfo  =   NodeDivInfo;  //분기 정보 갱신
			cRunNextDivInfo = NextDivInfo;

			DRIVING_CMD_INFO_OF_NODE* pTempNodeInfo = getNodeInfo(TempNodeCount);
			if(pNodeInfo != NULL) nRunNextNodeID = pTempNodeInfo->ID;
//			ADD_LOG("D_94/%d/%d/%d",pNodeInfo->ID,NodeDivInfo,NextDivInfo);
		}

//		DRIVING_CMD_INFO_OF_NODE* pNextNodeInfo = getNodeInfo(HwInfo.Node.nNodeCount+1);
//		if(pNextNodeInfo != NULL)
//		{
//			nRunNextNodeID = pNextNodeInfo->ID;
//		}

	}catch(...)
	{
		ADD_LOG("D-54");

	}

	m_pExecuteInfo->bSpeedDownFlag =  (pInfoSet->HwInfo.Axis1.dCurrPos>=pInfoSet->Position.CmdRefInfo.dSpeedDownPos)
									   ?true:false;

	m_pExecuteInfo->FlagRunningPositon =true;
//	LeaveCriticalSection(&OHTMainForm->m_CS);


	//autodoor test
	if(((pNodeInfo->NodeType == AUTODOOR_LEFT) || (pNodeInfo->NodeType == AUTODOOR_RIGHT)) && (m_nPreAutoDoorNode != pNodeInfo->ID))
	{
		m_iLifterPrePass = VHL_ELEVETOR_PREPASS_STEP_NONE;
		m_nPreAutoDoorNode = pNodeInfo->NodeType;
		ADD_LOG("m_nPreAutoDoorNode : %06d, pNodeInfo->ID : %d",m_nPreAutoDoorNode, pNodeInfo->ID);
	}
	//AOHC-582 MTL Auto Take In/Out 통신 초기화 처리 개선
	if(pNodeInfo->ID == m_nMTLNextNode)
	{
		m_nElevetorRideStep = VHL_ELEVETOR_RIDE_CTRL_STEP_CID_INIT;
		m_iLifterPrePass = VHL_ELEVETOR_PREPASS_STEP_NONE;
		if(m_nMTLCheckCurNode2 != pNodeInfo->ID)
		{
			AnsiString strLogTmp;
			strLogTmp.sprintf("[MTL 통신 초기화 처리] CurrNode : %06d, m_nMTLNextNode : %06d, m_nMTLCheckCurNode2 : %06d",pNodeInfo->ID, m_nMTLNextNode,m_nMTLCheckCurNode2);
			ADD_CID_LOG(strLogTmp);
			m_nMTLCheckCurNode2 = pNodeInfo->ID;
		}
	}
	if((m_PositionInfo.NextNode != pNodeInfo->ID)&&((pNodeInfo->NodeType == MTL_STOP_LEFT) || (pNodeInfo->NodeType == MTL_STOP_RIGTH)))
	{
		m_nMTLNextNode = m_PositionInfo.NextNode;
		if(m_nMTLCheckCurNode != pNodeInfo->ID)
		{
			AnsiString strLogTmp;
			strLogTmp.sprintf("[MTL 통신 초기화 : Next Node 찾기]CurNode : %06d, CurNode NodeType : %d, m_nMTLNextNode : %d, m_nMTLCheckCurNode : %d",pNodeInfo->ID,pNodeInfo->NodeType,m_PositionInfo.NextNode,m_nMTLCheckCurNode);
			ADD_CID_LOG(strLogTmp);
			m_nMTLCheckCurNode = pNodeInfo->ID;
		}
	}

	try
	{
		AnsiString strLogTmp;

		// 리프터 IN앞의 노드 (Pre Node) 이면서, 진입허가가 떨어지지 않은 경우
		// Status Machine 실행



		if(((pNodeInfo->NodeType == LIFTPRE_NTYPE_RIGHT) || (pNodeInfo->NodeType == LIFTPRE_NTYPE_LEFT)))
		{
			// strLogTmp.sprintf("[LIFTER-PRE] ==> PRE NODE!!  node id : %d",tmpCurrenrtNodeID);
			// ADD_CID_LOG(strLogTmp);
//			ADD_LOG("D_95/%d/%d/%d",pNodeInfo->NodeType, m_IsLifterCheck, m_iLifterPrePass);

			if((m_iLifterPrePass != VHL_ELEVETOR_PREPASS_STEP_COMPLETE) && (m_IsLifterCheck == true))
			{
				// ADD_CID_LOG("[LIFTER-PRE] ==> execute pre!");
				executePreEvevetor(pNodeInfo->NodeType);
			}
			else
			{
				// ADD_CID_LOG("[LIFTER-PRE] ==> execute NONE!");
			}
		}
		//MTL 연동
		else if((pNodeInfo->NodeType == MTL_SEL_ON_LEFT) || (pNodeInfo->NodeType == MTL_SEL_ON_RIGHT))
//		&& (m_IsMTLCheck == true))
		{
			if((m_iLifterPrePass != VHL_ELEVETOR_PREPASS_STEP_COMPLETE) && (m_IsMTLCheck ==true))
			{
//				ADD_LOG("D_96/%d",pNodeInfo->NodeType);
				executePreEvevetor(pNodeInfo->NodeType);
			}
			else
			{
				// ADD_CID_LOG("[LIFTER-PRE] ==> execute NONE!");
			}
		}
		//일반 구간에서 Lift Step이 초기화 상태가 아니면 초기화 처리
		else if((pNodeInfo->NodeType == NONE_TYPE) || (pNodeInfo->NodeType == SLOPE_NTYPE))
		{
			if((m_iLifterPrePass != VHL_ELEVETOR_PREPASS_STEP_NONE) &&(m_nElevetorRideStep == VHL_ELEVETOR_RIDE_CTRL_STEP_CID_INIT))
			{
				ADD_CID_LOG("[LifterStep]Init");
           		m_nElevetorRideStep = VHL_ELEVETOR_RIDE_CTRL_STEP_CID_INIT;
				m_iLifterPrePass = VHL_ELEVETOR_PREPASS_STEP_NONE;

			}
		}
	}
	catch(...)
	{
		ADD_LOG("D-55");
	}

	// ============================================================================

	//1 현재 위치 이전 명령 처리
	if(pInfoSet->HwInfo.Node.nNodeCount!=PreInfoSet.HwInfo.Node.nNodeCount)
	{
		clearCmdInfoListsLessThan(pInfoSet->HwInfo.Node.nNodeCount);
	}

	if(nTmpError == NO_ERR)  nTmpError = checkJobChange(pInfoSet);


	if((m_mccparam.nPreCount + 1) == HwInfo.Node.nPreCheckCount)
	{
		ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,NODE DETECT PRE,-,%s,%06d,%06d,%06d,%d,%3.3lf",
					m_defualtparam->VHLName,m_mccparam.cCarrierType,
					m_mccparam.uSourceNode,
					m_mccparam.uTargetNode,
					m_pExecuteInfo->ExecutePositionInfo.CurrNode,
					m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
					HwInfo.Axis1.dSpeed);

		m_mccparam.uPreNode = m_pOHTMainStatus->StatusCommon.CurNodeID;
	}

	if((m_mccparam.nNodeCount + 1) == HwInfo.Node.nNodeCount)
	{
		m_mccparam.dwNodeDetectDelay = timeGetTime();
		m_mccparam.bNodeDetectFlag = true;
	}

	if((m_mccparam.bNodeDetectFlag == true) && (OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwNodeDetectDelay)> 50))
	{
		if((bSteerFrontRight == true) && (bSteerFrontLeft == false))
			m_mccparam.cSteerFrontStatus = 'R';
		else if((bSteerFrontRight == false) && (bSteerFrontLeft == true))
			m_mccparam.cSteerFrontStatus = 'L';
		else if((bSteerFrontRight == false) && (bSteerFrontLeft == false))
			m_mccparam.cSteerFrontStatus = 'N';
		else if((bSteerFrontRight == true) && (bSteerFrontLeft == true))
			m_mccparam.cSteerFrontStatus = 'B';

		if((bSteerRearRight == true) && (bSteerRearLeft == false))
			m_mccparam.cSteerRearStatus = 'R';
		else if((bSteerRearRight == false) && (bSteerRearLeft == true))
			m_mccparam.cSteerRearStatus = 'L';
		else if((bSteerRearRight == false) && (bSteerRearLeft == false))
			m_mccparam.cSteerRearStatus = 'N';
		else if((bSteerRearRight == true) && (bSteerRearLeft == true))
			m_mccparam.cSteerRearStatus = 'B';

		int nBCRReadID = HwInfo.Node.nBcrId;

		if(nBCRReadID == 0)
		{
			nBCRReadID = -1;
		}

		ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,NODE DETECT,-,%s,%06d,%06d,%06d,%d,%3.3lf,DistSum,%6.1lf,PreCheckCount,%d,NodeCount,%d,Compensation,%6.1lf,Steer Front,%c,Steer Rear,%c,Front Rear Position Difference,%6.1lf,Pre Node,%06d,Driving Accel,%3.3lf,Driving Decel,%3.3lf,Driving Target Speed,%3.3lf,Driving BCR Readed ID,%06d,From Station,%06d",
					m_defualtparam->VHLName,m_mccparam.cCarrierType,
					m_mccparam.uSourceNode,
					m_mccparam.uTargetNode,
					m_pExecuteInfo->ExecutePositionInfo.CurrNode,
					m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
					HwInfo.Axis1.dSpeed,
					pNodeInfo->dDistSum,HwInfo.Node.nPreCheckCount,HwInfo.Node.nNodeCount,
					pInfoSet->Position.Compensation.dLinkDistError,m_mccparam.cSteerFrontStatus,m_mccparam.cSteerRearStatus,
					HwInfo.Axis1.dCurrPos - HwInfo.Axis2.dCurrPos,
					m_mccparam.uPreNode,
					pInfoSet->Control.Axis.Dynamic.dAccel,pInfoSet->Control.Axis.Dynamic.dDecel,pInfoSet->Control.Axis.Dynamic.dSpeed,
					nBCRReadID,
					m_mccparam.uFromStation);
		m_mccparam.bNodeDetectFlag = false;
		m_mccparam.uFromStation = 0;
	}

	m_mccparam.nPreCount = HwInfo.Node.nPreCheckCount;
	m_mccparam.nNodeCount = HwInfo.Node.nNodeCount;

//	if(pNodeInfo->ID == 127)    //PSTB Test용
//	{
//		if(m_pExecuteInfo->FlagPreTrans.nPIOID != 0)
//		{
//			nTmpError = ExeCmdEQPIOOpen(OHTMainForm->Get_EQPIO_Type(), m_pExecuteInfo->FlagPreTrans.nPIOID, m_pExecuteInfo->FlagPreTrans.nPIOChannel, m_pExecuteInfo->FlagPreTrans.nPIOCS);
//			ADD_LOG("사전 PIO 연결 시도 PIOID = %d", m_pExecuteInfo->FlagPreTrans.nPIOID);
//		}
//		else
//			ADD_LOG("nPIOID = 0");
//	}

	return nTmpError;

}

/**
@brief   위치 정보 확인 및 지나간 Classified List 정리
@author  임태웅
@date    2013.08.05
@param HwInfo 입력되는 HW 정보
@param pInfoSet 변경되는 상태 정보
@return 에러 없으면 0반환, 있으면 에러 코드 반환
*/
UINT DrivingControl::checkBackPosition(DRIVING_HW_INFO_SET HwInfo, DRIVING_INFO_SET *pInfoSet)
{

    UINT nTmpError = NO_ERR;
    double dNodeDistOffset = 0.0;

	double dSpeedDownPos    = pInfoSet->Position.CmdRefInfo.dSpeedDownPos;//getSpeedDownPos();

	int nDetectStatus = pHWSet->m_pOHTDetect->GetStatus(); //DETECT_AND_STOP

	DRIVING_CMD_INFO_OF_NODE* pNodeInfo = getNodeInfo(HwInfo.Node.nNodeCount);
	DRIVING_CMD_INFO_OF_PATH* pPathInfo = getPathInfo(HwInfo.Node.nNodeCount);

	PATH_DIVERGENCE_INFO NodeDivInfo = NULL;
	PATH_DIVERGENCE_INFO NextDivInfo = NULL;


	DRIVING_INFO_SET PreInfoSet = *pInfoSet;

	if(pNodeInfo==NULL)
	{

		ADD_LOG("D_97/%d/%d/%d"
			, HwInfo.Node.nNodeCount
			, pInfoSet->HwInfo.Node.nNodeCount
			, m_ClassifiedCmd.NodeList.getCount());
		ADD_FDC_LOG("ERR/%d/2/5/%06d/%06d/%d/%d/%06d",
				ERR_NOTFIND_NODE,
				m_pOHTMainStatus->StatusCommon.CurNodeID,
				m_pExecuteInfo->ExecutePositionInfo.NextNode,
				m_pOHTMainStatus->StatusCommon.CurNodeOffset,
				m_pOHTMainStatus->StatusCommon.ExistFoup,
				m_pOHTMainStatus->StatusCommon.StopStationID);
        return ERR_NOTFIND_NODE;// 에러 처리 : 명령에 없는 노드 Count 실시
	}

    if( (m_PreviousArrivalInfo.Info.MarkType==MARK_TYPE_NODE)
    &&  (HwInfo.Node.nNodeCount==0)
	)
    {
        dNodeDistOffset = m_pParamSet->Mark[0].Dist.dAddDistAfterSecondMet;
    }


	//1 HW
	pInfoSet->HwInfo = HwInfo;

//	ADD_LOG("D_98/%d/%06f", HwInfo.Node.nNodeCount,HwInfo.Axis1.dCurrPos);

    //1 Position
    //2 TargetPosition
	pInfoSet->Position.CurrentAndTarget.TargetPosition.MarkType     = m_ClassifiedCmd.TargetInfo.Type;
    pInfoSet->Position.CurrentAndTarget.TargetPosition.uNode        = m_ClassifiedCmd.TargetInfo.Node;
    pInfoSet->Position.CurrentAndTarget.TargetPosition.uNextNode    = m_ClassifiedCmd.TargetInfo.NextNode;
    pInfoSet->Position.CurrentAndTarget.TargetPosition.uStation     = m_ClassifiedCmd.TargetInfo.Station;
    pInfoSet->Position.CurrentAndTarget.TargetPosition.dOffset      = m_ClassifiedCmd.TargetInfo.dOffset;

	//2 Compensation
	if(HwInfo.Node.dNodePosition!=PreInfoSet.HwInfo.Node.dNodePosition)
	{
		m_RunOffsetDistance = 0.0;
		pInfoSet->Position.Compensation.dDistErrorSum       = 0;
		pInfoSet->Position.Compensation.dLinkDistError      = 0;
        //pInfoSet->Position.Compensation.dPreArriveOffset = // 처음 명령 인가 시 설정
        pInfoSet->Position.Compensation.dWearRatio          = 1.0;

		ADD_LOG("D_99/%06f/%06f/%06f/%06f/%06f",
			pNodeInfo->dDistSum,
			pInfoSet->Position.Compensation.dPreArriveOffset,
			pInfoSet->Position.Compensation.dDistErrorSum,
			HwInfo.Node.dNodePosition, HwInfo.Axis1.dCurrPos);

		pInfoSet->EventAndState.Event.CmdAdded==true;

	}

	pInfoSet->Position.Compensation.dCompensatedPosition    = HwInfo.Axis1.dCurrPos
															- pInfoSet->Position.Compensation.dDistErrorSum;
//															- pInfoSet->Position.Compensation.dPreArriveOffset;


	//2 CurrPositionStatus
	if(HwInfo.Node.nBcrId!=0)
	{
		ADD_LOG("D_100/%d",HwInfo.Node.nBcrId);
		pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.uNode       = HwInfo.Node.nBcrId;
	}
	pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.uNextNode   = 0;
    //pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.uStation = // Mark 마무리서 처리
	pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset     = pInfoSet->Position.Compensation.dCompensatedPosition
																			- HwInfo.Node.dNodePosition;



    //1 임시
    if(m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uStation!=0)
    {
        if( (PreInfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode!=pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.uNode)
        ||  (pInfoSet->HwInfo.Node.nNodeCount>0)
        ||  (pInfoSet->HwInfo.Node.nPreCheckCount>0)
        )
        {
			if(m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uStation!=0)
			{
				m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uStation = 0;
			}
		}
	}


    // Event

	pInfoSet->EventAndState.Event.CmdAdded = ((memcmp(&(PreInfoSet.Position.CurrentAndTarget.TargetPosition)
												, &(pInfoSet->Position.CurrentAndTarget.TargetPosition)
												, sizeof(POSITION_INFO)))==0)   ?false:true;
//	pInfoSet->EventAndState.Event.TargetChanged = pInfoSet->EventAndState.Event.CmdAdded;
//	pInfoSet->EventAndState.Event.Check = (PreInfoSet.HwInfo.Node.nNodeCount<pInfoSet->HwInfo.Node.nNodeCount)?true:false;
//	pInfoSet->EventAndState.Event.SpeedDownPassed = (   (pInfoSet->HwInfo.Axis1.dCurrPos>=pInfoSet->Position.CmdRefInfo.dSpeedDownPos)
////                                                  &&  (PreInfoSet.HwInfo.Axis1.dCurrPos<pInfoSet->Position.CmdRefInfo.dSpeedDownPos))
//													&& (PreInfoSet.EventAndState.State.SpeedDownPassed==false))
//													?true:false;

	pInfoSet->EventAndState.Event.MarkCmd = (   (isMarkArea()==true)
												&& (pInfoSet->EventAndState.State.MarkArea==false))
												?true:false;

	//State
//	pInfoSet->EventAndState.State.SpeedDownPassed   = (pInfoSet->HwInfo.Axis1.dCurrPos>=pInfoSet->Position.CmdRefInfo.dSpeedDownPos)
//													?true:false;
	pInfoSet->EventAndState.State.MarkArea = (pInfoSet->EventAndState.State.MarkArea==true)?true:isMarkArea();
//	EnterCriticalSection(&OHTMainForm->m_CS);
	m_pExecuteInfo->dCompensatedPosition   = HwInfo.Axis1.dCurrPos
											- pInfoSet->Position.Compensation.dDistErrorSum;


	m_pExecuteInfo->FlagInitPositon.dDrivingInitPosition = pNodeInfo->dDistSum
														   - m_InfoSet.Position.Compensation.dPreArriveOffset;


	try
	{
		int TempNodeCount = 0;
		if(getDivergenceInfo(HwInfo.Node.nNodeCount, &NodeDivInfo, &NextDivInfo, &TempNodeCount)==true)
		{
			m_pExecuteInfo->nCheckDivInfo  =   NodeDivInfo;  //분기 정보 갱신
			cRunNextDivInfo = NextDivInfo;

			DRIVING_CMD_INFO_OF_NODE* pTempNodeInfo = getNodeInfo(TempNodeCount);
			if(pNodeInfo != NULL) nRunNextNodeID = pTempNodeInfo->ID;
		}

//		DRIVING_CMD_INFO_OF_NODE* pNextNodeInfo = getNodeInfo(HwInfo.Node.nNodeCount+1);
//		if(pNextNodeInfo != NULL)
//		{
//			nRunNextNodeID = pNextNodeInfo->ID;
//		}

	}catch(...)
	{
		ADD_LOG("D-56");
		ADD_LOG("D_101/%x",&pPathInfo->DivInfo);

	}

	m_pExecuteInfo->bSpeedDownFlag =  (pInfoSet->HwInfo.Axis1.dCurrPos>=pInfoSet->Position.CmdRefInfo.dSpeedDownPos)
									   ?true:false;

	m_pExecuteInfo->FlagRunningPositon =true;


	// ============================================================================

	//1 현재 위치 이전 명령 처리
	if(pInfoSet->HwInfo.Node.nNodeCount!=PreInfoSet.HwInfo.Node.nNodeCount)
	{
		clearCmdInfoListsLessThan(pInfoSet->HwInfo.Node.nNodeCount);
	}

	//1 경로변경/삭제 처리 명령 처리
	if(m_pExecuteInfo->FlagPathChange.bPathChange == true)
	{

	m_pExecuteInfo->FlagPathChange.cResult = FAIL;
	m_pExecuteInfo->FlagPathChange.bPathChange =false;



	ADD_LOG("D-57");

	}



	return nTmpError;

}



// CID Select ON
#define CID_SELECT_BEFORE_DELAY	3	// spec 2ms
//void DrivingControl::CID_LR_ON(bool LightGuideDirectionIsLeft)
//{
//	CID_OPERATION_MODE_CID();
//	Sleep(CID_SELECT_BEFORE_DELAY);
//
//	if(LightGuideDirectionIsLeft == true) 	// left
//		CID_SELECT_DIRECTION_LEFT();
//	else
//		CID_SELECT_DIRECTION_RIGHT();
//}


/*
	CID Information Get Function
	shkim.
	CID 동작에 필요한 정보를 가져온다.
*/
void DrivingControl::getCID_Info(CID_CTRL_INFO* Info, int nCurrentNodeID)
{
	Info->nDetectStatus = m_InfoSet.HwInfo.IO.DetectStatus;

	Info->tmpCurrentNodeID = (int)m_PositionInfo.CurrNode;
	Info->tmpPreNodeID = (int)m_PositionInfo.CurrPreCheckNode;
	Info->tmpNextNodeID = (int)m_PositionInfo.NextNode;
	Info->tmpCurrentCMDID = (int)m_PositionInfo.CurrCommandedNode;
	Info->tmpCurrentStationID = (int)m_PositionInfo.CurrStation;
	Info->uLimitNode = (m_InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType==MARK_TYPE_NODE)
						? m_InfoSet.Position.CurrentAndTarget.TargetPosition.uNode
                        : m_InfoSet.Position.CurrentAndTarget.TargetPosition.uNextNode;
	Info->CMD_StationID = (m_InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType==MARK_TYPE_NODE)
                           ? 0 : m_InfoSet.Position.CurrentAndTarget.TargetPosition.uStation;
	Info->Safety_Level = 0;
	#if 0  //Map 기반
	if(m_InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType==MARK_TYPE_TAG_STATION
		|| m_InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType==MARK_TYPE_QR_STATION_LEFT
		|| m_InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType==MARK_TYPE_QR_STATION_RIGHT)
	{
		STATION_DATA *pSData  =NULL; //Station 정보
		pSData = OHTMainForm->GetStationDataManager()->Find(m_InfoSet.Position.CurrentAndTarget.TargetPosition.uStation);
		//ADD_LOG("D_102/%d/%d", Info->Safety_Level, pSData->Safety_Level);
		if (pSData != NULL)
		{
			Info->Safety_Level = pSData->Safety_Level;
			//ADD_LOG("D_103/%d/%d", Info->Safety_Level, pSData->Safety_Level);
		}
	}
	#else //OCS 기반

	Info->Safety_Level = m_ClassifiedCmd.TargetInfo.StationSafetyLevel;

	if(m_InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType!=MARK_TYPE_NODE)
		Info->bIgnolOverRun = m_ClassifiedCmd.TargetInfo.bIgnolOverRun;
	else
		Info->bIgnolOverRun = false;

	//ADD_LOG("D_104/%d", m_ClassifiedCmd.TargetInfo.StationSafetyLevel);
	#endif
	Info->CIDStopNode1_arr = OHTMainForm->GetMap()->FindNodeIndexFromCIDStop_1(Info->tmpCurrentNodeID);
	Info->CIDStopNode2_arr = OHTMainForm->GetMap()->FindNodeIndexFromCIDStop_2(Info->tmpCurrentNodeID);
	Info->CIDStartNode1_arr = OHTMainForm->GetMap()->FindNodeIndexFromCIDStart_1(Info->tmpCurrentNodeID);
	Info->CIDStartNode2_arr = OHTMainForm->GetMap()->FindNodeIndexFromCIDStart_2(Info->tmpCurrentNodeID);
	Info->CIDResetNode_arr = OHTMainForm->GetMap()->FindNodeIndexFromCIDReset(Info->tmpCurrentNodeID);
	Info->CIDResetNode_Pre_arr = OHTMainForm->GetMap()->FindNodeIndexFromCIDReset(Info->tmpPreNodeID);
	try{
		if (Info->CIDStopNode1_arr != INDEX_NONE)
		{
		  Info->CIDStopNode1 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStopNode1_arr].StopNode1;
		  Info->CIDResetNode1 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStopNode1_arr].ResetNode;
		  Info->LayoutType_Stop1 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStopNode1_arr].LayoutType;
		}
		if (Info->CIDStopNode2_arr != INDEX_NONE)
		{
		  Info->CIDStopNode2 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStopNode2_arr].StopNode2;
		  Info->CIDResetNode2 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStopNode2_arr].ResetNode;
		  Info->LayoutType_Stop2 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStopNode2_arr].LayoutType;
		}

		if (Info->CIDResetNode_arr != INDEX_NONE)
		{
		  Info->CIDResetNode = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDResetNode_arr].ResetNode;
		  Info->CIDResetNodeType = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDResetNode_arr].ResetNodeType;
		  Info->LayoutType_Reset = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDResetNode_arr].LayoutType;
		}
		//Left
		if (Info->CIDStartNode1_arr != INDEX_NONE)
		{
			Info->tmpStartNode1_1 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStartNode1_arr].CommStartNode1_1;
			Info->tmpStartNode1_2 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStartNode1_arr].CommStartNode1_2;
			Info->tmpStartNode1_3 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStartNode1_arr].CommStartNode1_3;
			Info->tmpStartNode1_4 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStartNode1_arr].CommStartNode1_4;
			Info->tmpStartNode1_5 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStartNode1_arr].CommStartNode1_5;

			Info->tmpStopNode1 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStartNode1_arr].StopNode1;
//			Info->tmpCIDResetNode1 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStartNode1_arr].ResetNode;
//			Info->tmpCIDResetNodeType1 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStartNode1_arr].ResetNodeType;
			Info->tmpResetNode1 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStartNode1_arr].ResetNode;
			Info->tmpResetNodeType1 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStartNode1_arr].ResetNodeType;
			Info->CommStartNode1_Offset = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStartNode1_arr].CommStartNode1_Offset;
		}
		//Right
		if (Info->CIDStartNode2_arr != INDEX_NONE)
		{
			Info->tmpStartNode2_1 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStartNode2_arr].CommStartNode2_1;
			Info->tmpStartNode2_2 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStartNode2_arr].CommStartNode2_2;
			Info->tmpStartNode2_3 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStartNode2_arr].CommStartNode2_3;
			Info->tmpStartNode2_4 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStartNode2_arr].CommStartNode2_4;
			Info->tmpStartNode2_5 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStartNode2_arr].CommStartNode2_5;

			Info->tmpStopNode2 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStartNode2_arr].StopNode2;
//			Info->tmpCIDResetNode2 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStartNode2_arr].ResetNode;
//			Info->tmpCIDResetNodeType2 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStartNode2_arr].ResetNodeType;
			Info->tmpResetNode2 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStartNode2_arr].ResetNode;
			Info->tmpResetNodeType2 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStartNode2_arr].ResetNodeType;
			Info->CommStartNode2_Offset = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStartNode2_arr].CommStartNode2_Offset;
		}
		if(Info->CIDResetNode_Pre_arr != INDEX_NONE)
		{
			Info->CIDResetNode_Pre = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDResetNode_Pre_arr].ResetNode;
			Info->CIDResetNodeType_Pre = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDResetNode_Pre_arr].ResetNodeType;
		}

		// 4분기 처리용 정보
		Info->bLoadUnload 	= CID_4WAY_CONTROL_INFO.bLoadUnload;	// 이적재 유무. true : 이적재 한다. false : 이적재 하지 않음
		Info->tmpLastCMDID 	= CID_4WAY_CONTROL_INFO.tmpLastCMDID;	// 최종 타겟
		Info->NodeDivInfo 	= CID_4WAY_CONTROL_INFO.NodeDivInfo;	// 현재 노드의 분기정보
		Info->NextDivInfo 	= CID_4WAY_CONTROL_INFO.NextDivInfo;	// 다음 노드의 분기정보

   }
   catch(...)
   {
		ADD_LOG("D-58");
   }
}



// CID노드의 Stop Node이거나 지나버렸을 경우의 처리
bool DrivingControl::NormalCid_Return(CID_CTRL_INFO* Info)
{
	unsigned int CIDResetNode_arr = INDEX_NONE;
	int CIDResetNode = 0;
	int CIDResetNodeType = 0;

	//현재 노드가 리셋 노드인데 최초 cid 동작시 리셋노드와 다른경우 현재 노드 기준으로 완료 처리.
	if (Info->CIDResetNode_arr != INDEX_NONE && m_tmpCurrentResetNode != Info->CIDResetNode && Info->CIDResetNodeType != Common_Reset_tag)
	{
		m_tmpCurrentResetNode = Info->CIDResetNode;
		ADD_LOG("C_1/%d/%d", Info->CIDResetNode, m_tmpCurrentResetNode);
	}
//	ADD_LOG("C_2/%d/%d/%d", Info->tmpPreNodeID, Info->tmpCurrentNodeID, m_tmpCurrentResetNode);
	CIDResetNode_arr = OHTMainForm->GetMap()->FindNodeIndexFromCIDReset(Info->tmpPreNodeID);
	if (CIDResetNode_arr != INDEX_NONE)
	{
	  CIDResetNode = OHTMainForm->GetCID_STD()->m_NodeArray[CIDResetNode_arr].ResetNode;
	  CIDResetNodeType = OHTMainForm->GetCID_STD()->m_NodeArray[CIDResetNode_arr].ResetNodeType;
	  Info->CIDResetNodeType = CIDResetNodeType;
//	  ADD_LOG("C_3/%d/%d/%d", Info->tmpPreNodeID, Info->tmpCurrentNodeID, m_tmpCurrentResetNode);
	}

	//OHT 링크를 시도하고 있고 현재 내위치가 리셋노드이며 노멀, 경사로 리셋노드이면
//	if((pHWSet->m_pCID->IsLinking() == true)&&((Info->CIDResetNode_arr != INDEX_NONE)
//		&&((Info->CIDResetNodeType == Normal_Reset_tag)
//		||(Info->CIDResetNodeType == Slope_Rear_Reset_tag))))
// CID ResetNode PreChcek 이후 Statino Tag Mark시 PreCheck에서 반납하지 않고 Front만나야 반납
	//ADD_LOG("D_105/%d/%d");
	if (pHWSet->m_pCID->IsLinking() == true && (Info->CIDResetNode_arr != INDEX_NONE || CIDResetNode_arr != INDEX_NONE) &&
		//(Info->tmpCurrentNodeID == m_tmpCurrentResetNode) &&
		(Info->tmpPreNodeID == m_tmpCurrentResetNode) &&
	   //	((m_pOHTMainStatus->FinalStationOfPathSearch != 0) ? Info->tmpCurrentNodeID == m_tmpCurrentResetNode : Info->tmpPreNodeID == m_tmpCurrentResetNode) &&
		(Info->CIDResetNodeType == Normal_Reset_tag || Info->CIDResetNodeType == Slope_Rear_Reset_tag))
	{
		if(pHWSet->m_pCID->ISCidOperatingMode() == ON)  // 합류부 CID 또는 Slope로 사용 시 ‘1’  MTL, Lifter 등 다른 영역에서 사용 시 ‘0’
		{
			pHWSet->m_pCID->Set_CID_Monitor_Cmd(1);	// CID Monitoring ID:124 (OHT -> CID). M Command.
		}
		pHWSet->m_pCID->CID_Occup_compt(1);
		Sleep(20);

		m_CIDMonitoringFlag = true;
		m_CIDComptFlag = true;
		m_bsecond = false;
		m_Igro_CIDStatusPuaseFlag = false;
		m_CIDComptTryFlag = true;

		ADD_LOG("C_4/%d/%d/%d/%d/%d/%d/%d"
		, Info->tmpCurrentNodeID, Info->tmpNextNodeID, Info->tmpCurrentCMDID, Info->CIDStopNode1
		, Info->CIDStopNode2, Info->CIDResetNode, Info->CIDResetNodeType);
		//ADD_LOG("D_106/%d/%d");
		IO_INFO_CID();

		return true;
	}
	else
	{
		// ADD_LOG("C-6");

		static int nTmpCurNodeId115 = 0;
		if(nTmpCurNodeId115 != Info->tmpCurrentNodeID)
		{
			nTmpCurNodeId115 = Info->tmpCurrentNodeID;
			ADD_LOG("C-7");
			ADD_LOG("C_5/%d/%d/%d", Info->CIDResetNode, Info->CIDResetNodeType, m_tmpCurrentResetNode);
		}
		return false;
	}
}


// COMMON NODE의 처리
// (Common노드 Tag를 만났을때의 반납처리)
bool DrivingControl::CommonCid_Return(CID_CTRL_INFO* Info, DRIVING_INFO_SET *pInfoSet)
{
	unsigned int CIDResetNode_arr = INDEX_NONE;
	int CIDResetNode = 0;
	int CIDResetNodeType = 0;

	//현재 노드가 리셋 노드인데 최초 cid 동작시 리셋노드와 다른경우 현재 노드 기준으로 완료 처리. 리셋 못하는 경우 이상동작 대비.
	if (Info->CIDResetNode_arr != INDEX_NONE && m_tmpCurrentResetNode != Info->CIDResetNode && Info->CIDResetNodeType != Common_Reset_tag)
	{
		m_tmpCurrentResetNode = Info->CIDResetNode;
		ADD_LOG("C_6/%d/%d", Info->CIDResetNode, m_tmpCurrentResetNode);
	}

	CIDResetNode_arr = OHTMainForm->GetMap()->FindNodeIndexFromCIDReset(Info->tmpPreNodeID);
	if (CIDResetNode_arr != INDEX_NONE)
	{
	  CIDResetNode = OHTMainForm->GetCID_STD()->m_NodeArray[CIDResetNode_arr].ResetNode;
	  CIDResetNodeType = OHTMainForm->GetCID_STD()->m_NodeArray[CIDResetNode_arr].ResetNodeType;
	  Info->CIDResetNodeType = CIDResetNodeType;
	}

	if(Info->tmpCurrentNodeID == 142)
	ADD_LOG("C_7/%d/%d/%d/%d/%d/%d/%d",

			pInfoSet->Steer.FrontMoving, pInfoSet->Steer.RearMoving, pHWSet->m_pCID->IsLinking(),
			m_bsecond, Info->CIDResetNode_arr, Info->CIDResetNodeType, m_CIDComptFlag);

	//조향 변경 중에는 CID 동작을 잠시 멈춤. Front & Rear all false
//	if((pInfoSet->Steer.FrontMoving == false)&&(pInfoSet->Steer.RearMoving == false)&&(pHWSet->m_pCID->IsLinking() == true)
//		&&(m_bsecond==false)&&(Info->CIDResetNode_arr != INDEX_NONE)
//	&&(Info->CIDResetNodeType == Common_Reset_tag)&&(m_CIDComptFlag == false))
//	if ((pHWSet->m_pCID->IsLinking() == true)
//		&&(m_bsecond==false)&&(Info->CIDResetNode_arr != INDEX_NONE)
//		&&(Info->CIDResetNodeType == Common_Reset_tag)&&(m_CIDComptFlag == false))
// CID ResetNode PreChcek 이후 Statino Tag Mark시 PreCheck에서 반납하지 않고 Front만나야 반납
	//ADD_LOG("D_107/%d/%d");
	if (pHWSet->m_pCID->IsLinking() == true && (Info->CIDResetNode_arr != INDEX_NONE || CIDResetNode_arr != INDEX_NONE) &&
		//(Info->tmpCurrentNodeID == m_tmpCurrentResetNode) &&
		(((m_pOHTMainStatus->FinalStationOfPathSearch != 0) && (Info->tmpCurrentNodeID == m_tmpCurrentResetNode)) || ((m_pOHTMainStatus->FinalStationOfPathSearch == 0) && (Info->tmpPreNodeID == m_tmpCurrentResetNode))) &&
		(Info->CIDResetNodeType == Common_Reset_tag))
		{
			if(pHWSet->m_pCID->ISCidOperatingMode() == ON) // 합류부 CID 또는 Slope로 사용 시 ‘1’  MTL, Lifter 등 다른 영역에서 사용 시 ‘0’
			{
				pHWSet->m_pCID->Set_CID_Monitor_Cmd(2);		// CID Monitoring ID:124 (OHT -> CID). M Command.
			}
			// pHWSet->m_pCID->CID_Common_Occup_compt();	// 통과완료 bit 1세트 & Common Tag bit 1세트
			pHWSet->m_pCID->CID_Occup_compt(2);				// 통과완료 bit 1세트 Only
			Sleep(20);

			m_CIDMonitoringFlag = true;
			m_CIDComptFlag = true;
			m_bsecond = true;
			m_Igro_CIDStatusPuaseFlag = false;
			m_CIDComptTryFlag = true;
			ADD_LOG("C_8/%d/%d/%d/%d/%d",
				Info->tmpCurrentNodeID, Info->tmpNextNodeID, Info->tmpCurrentCMDID,Info->CIDResetNode_arr, Info->CIDResetNodeType);
			//ADD_LOG("D_108/%d/%d");
			IO_INFO_CID();

			return true;
		}

	else
		{
			static int nTmpCurNodeId114 = 0;
			if(nTmpCurNodeId114 != Info->tmpCurrentNodeID)
			{
				nTmpCurNodeId114 = Info->tmpCurrentNodeID;
				ADD_LOG("C-8");
				ADD_LOG("C_9/%d/%d/%d", Info->CIDResetNode, Info->CIDResetNodeType, m_tmpCurrentResetNode);
			}
			return false;
		}
}


unsigned char DrivingControl::CID_ID_FIND(unsigned char* CID_UniqueID)
{
	unsigned char iReturn=8;
	unsigned char i=0;
	for(i=0 ; i<8 ; i++)
	{
		if(memcmp(m_Diag_CID_R_ID[(m_Diag_CID_index+1+i) & 0x7],CID_UniqueID,6)==0)
		{
			iReturn = (m_Diag_CID_index+1+i) & 0x7;
			break;
		}
	}
	return iReturn;
}

//void DrivingControl::CID_ID_Buffer_Clear(unsigned char index)
//{
//	memset(&m_Diag_CID_R_ID[index][0],'0',6);
//	memset(&m_Diag_ResetNode[index],0,sizeof(int));
//	memset(&m_Diag_StopNode[index],0,sizeof(int));
//}



void DrivingControl::CID_Monitor_Status(CID_CTRL_INFO* Info,double dSpeedOfNow)
{
	int iReceivedByte = 0;
	unsigned char index_tmp = 0; //AOHC-288

	CID_Monitoring_PKT 	RECV_PKT_Monitor;
	CID_Status_PKT 		RECV_PKT_Status;
	CID_NameSet_PKT		RECV_PKT_Name;

	char TempBuffer[10240];

	DWORD   dwCIDMonitoringTrigerTime  = timeGetTime();

//	if((m_CIDMonitoringFlag == false) && (m_CIDStatusFlag == false) && (m_CIDNameReadFlag == false))

	if((m_IsLifterCheck ==true) || (m_IsMTLCheck ==true) ||(m_IsAutoDoorCheck == true))
	{
		//ADD_LOG("C-9");
		return;		// not need check
	}

	if (bCountOfCID_Delay > CID_SERIAL_CMD_DELAY_TURN)
	{
		iReceivedByte = pHWSet->m_pCID->ReadData((char *)&TempBuffer, (char)OPC_SERIAL_INIT_ETX);
		//ADD_LOG("C_10/%d",iReceivedByte);

		if(iReceivedByte > 1)
		{

			if((TempBuffer[1] == 'S') && (sizeof(RECV_PKT_Status) ==  iReceivedByte))
			{
				memcpy(&RECV_PKT_Status, &TempBuffer, iReceivedByte);
				ADD_LOG("C_11/%c/%c/%c",RECV_PKT_Status.BODY.Setting[0], RECV_PKT_Status.BODY.Setting[1], RECV_PKT_Status.BODY.Setting[2]);
				bCountOfCID_Delay = 0;

				if(iReceivedByte == sizeof(CID_Status_PKT))
				{
					m_pExecuteInfo->FlagCIDInfo.bCIDErrorFlag = true;	// TaskControl::JudgeCIDError() Enable.
					m_pExecuteInfo->FlagCIDInfo.cCIDStateResult = CID_MONITOR_INFO_GET_STATUS;
					m_pExecuteInfo->FlagCIDInfo.sCIDStatus[0] = RECV_PKT_Status.BODY.Setting[0];
					m_pExecuteInfo->FlagCIDInfo.sCIDStatus[1] = RECV_PKT_Status.BODY.Setting[1];
					m_pExecuteInfo->FlagCIDInfo.sCIDStatus[2] = RECV_PKT_Status.BODY.Setting[2];


					m_pExecuteInfo->FlagCIDMonitoring.bCIDFlag = true;	// TaskControl::UpdateCIDStatusDiagData() Enable  진단서버에도 보내기 위함..
					m_pExecuteInfo->FlagCIDMonitoring.nStopNodeID = m_Diag_StopNode[m_Diag_CID_index];
					m_pExecuteInfo->FlagCIDMonitoring.nResetNodeID = m_Diag_ResetNode[m_Diag_CID_index];
					m_pExecuteInfo->FlagCIDMonitoring.cResult = CID_MONITOR_INFO_GET_STATUS;

					m_CIDStatusFlag = false;

					m_sCIDStatus[0]=RECV_PKT_Status.BODY.Setting[0];
					m_sCIDStatus[1]=RECV_PKT_Status.BODY.Setting[1];
					m_sCIDStatus[2]=RECV_PKT_Status.BODY.Setting[2];
				}
				else
				{
					m_pExecuteInfo->FlagCIDInfo.bCIDErrorFlag = true;
					m_pExecuteInfo->FlagCIDInfo.cCIDStateResult = CID_MONITOR_INFO_GET_FAIL;
					m_CIDStatusFlag = false;
					ADD_LOG("C-10");
				}
			}
			else if((TempBuffer[1] == 'M') && (sizeof(RECV_PKT_Monitor) ==  iReceivedByte))
			{
				ADD_LOG("C_12/%d",iReceivedByte);

				memcpy(&RECV_PKT_Monitor, &TempBuffer, iReceivedByte);

				// if(bMonitorDataRead == true)
				{
					memcpy(&TEST_PKT_Monitor, &TempBuffer, iReceivedByte);	// save for cid light check function
					//bMonitorDataRead = false;
					ADD_LOG("D_109/%c/%c/%c/%c/%c/%c",
						TEST_PKT_Monitor.BODY.CIDR_FirstLinkLevel[0], TEST_PKT_Monitor.BODY.CIDR_FirstLinkLevel[1], TEST_PKT_Monitor.BODY.CIDR_FirstLinkLevel[2],
						TEST_PKT_Monitor.BODY.CIDO_FirstLinkLevel[0], TEST_PKT_Monitor.BODY.CIDO_FirstLinkLevel[1], TEST_PKT_Monitor.BODY.CIDO_FirstLinkLevel[2]);
				}

				bCountOfCID_Delay = 0;

				if(iReceivedByte == sizeof(CID_Monitoring_PKT))
				{
					//memcpy(&RECV_PKT_Monitor, &TempBuffer, iReceivedByte);
					m_CIDMonitoringFlag 	= false;
					//bCountOfCID_Delay = 0;
					dwCIDMonitoringTrigerTime  = timeGetTime();

					m_pExecuteInfo->FlagCIDMonitoring.bCIDFlag = true;	// TaskControl::UpdateCIDStatusDiagData() Enable

					index_tmp = CID_ID_FIND(RECV_PKT_Monitor.BODY.CID_UniqueID);
					m_pExecuteInfo->FlagCIDMonitoring.nStopNodeID = m_Diag_StopNode[index_tmp];
					m_pExecuteInfo->FlagCIDMonitoring.nResetNodeID = m_Diag_ResetNode[index_tmp];

//					ADD_LOG("C_13/%d/%d/%d", Info->tmpPreNodeID, Info->tmpCurrentNodeID, m_tmpCurrentResetNode);
					ADD_LOG("C_14/%d/%d", index_tmp, m_Diag_CID_index);

					m_pExecuteInfo->FlagCIDMonitoring.cResult = CID_MONITOR_INFO_GET_MONITORING;

					if(	m_sCIDStatus[0]!=0 ||
						m_sCIDStatus[1]!=0 ||
						m_sCIDStatus[2]!=0)
					{
						m_pExecuteInfo->FlagCIDMonitoring.cResult = CID_MONITOR_INFO_GET_SUCCESS;
					}

					memmove((char*)m_pExecuteInfo->FlagCIDMonitoring.cMonitoring, (char*)&RECV_PKT_Monitor.BODY ,sizeof(CID_Monitoring_BODY));

					//ADD_LOG("C_15/%d", iReceivedByte);
					ADD_LOG("C_16/%d/%d/%c/%c/%c/%c/%c/%c/%c/%c/%c/%c/%c/%c",
						m_pExecuteInfo->FlagCIDMonitoring.nStopNodeID, m_pExecuteInfo->FlagCIDMonitoring.nResetNodeID,
						RECV_PKT_Monitor.BODY.OHTID[0], RECV_PKT_Monitor.BODY.OHTID[1], RECV_PKT_Monitor.BODY.OHTID[2],
						RECV_PKT_Monitor.BODY.OHTID[3], RECV_PKT_Monitor.BODY.OHTID[4], RECV_PKT_Monitor.BODY.OHTID[5],
						RECV_PKT_Monitor.BODY.CID_UniqueID[0], RECV_PKT_Monitor.BODY.CID_UniqueID[1], RECV_PKT_Monitor.BODY.CID_UniqueID[2],
						RECV_PKT_Monitor.BODY.CID_UniqueID[3], RECV_PKT_Monitor.BODY.CID_UniqueID[4], RECV_PKT_Monitor.BODY.CID_UniqueID[5]);
					ADD_LOG("C_17/%c/%c/%c/%c/%c/%c",
						m_Diag_CID_R_ID[index_tmp][0], m_Diag_CID_R_ID[index_tmp][1], m_Diag_CID_R_ID[index_tmp][2],
						m_Diag_CID_R_ID[index_tmp][3], m_Diag_CID_R_ID[index_tmp][4], m_Diag_CID_R_ID[index_tmp][5]);

					ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,CID MONITOR,-,FOUP,%06d,%06d,%06d,%d,%6.1lf,CID R First Link Level,%c%c%c,CID R FiberError,%c%c,CID R RFError,%c%c,CID R Max Current,%c%c%c,CID R Max Voltage,%c%c%c,CID R Max Temp,%c%c,CID R Noise,%c%c%c,CID O First Link Level,%c%c%c,CID O FiberError,%c%c,CID O RFError,%c%c,CID ID,%c%c%c%c%c%c,CID Status,%c%c%c",
									m_defualtparam->VHLName,
									m_mccparam.uSourceNode,
									m_mccparam.uTargetNode,
									m_pExecuteInfo->ExecutePositionInfo.CurrNode,
									m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
									dSpeedOfNow,
									RECV_PKT_Monitor.BODY.CIDR_FirstLinkLevel[0],RECV_PKT_Monitor.BODY.CIDR_FirstLinkLevel[1],RECV_PKT_Monitor.BODY.CIDR_FirstLinkLevel[2],
									RECV_PKT_Monitor.BODY.FiberError_Per[0],RECV_PKT_Monitor.BODY.FiberError_Per[1],
									RECV_PKT_Monitor.BODY.RFError_Per[0],RECV_PKT_Monitor.BODY.RFError_Per[1],
									RECV_PKT_Monitor.BODY.CIDR_MAXCurrent[0],RECV_PKT_Monitor.BODY.CIDR_MAXCurrent[1],RECV_PKT_Monitor.BODY.CIDR_MAXCurrent[2],
									RECV_PKT_Monitor.BODY.CIDR_MAXVoltage[0],RECV_PKT_Monitor.BODY.CIDR_MAXVoltage[1],RECV_PKT_Monitor.BODY.CIDR_MAXVoltage[2],
									RECV_PKT_Monitor.BODY.CIDR_MAXTemp[0],RECV_PKT_Monitor.BODY.CIDR_MAXTemp[1],
									RECV_PKT_Monitor.BODY.CIDR_StandbyFiberNoise[0],RECV_PKT_Monitor.BODY.CIDR_StandbyFiberNoise[1],RECV_PKT_Monitor.BODY.CIDR_StandbyFiberNoise[2],
									RECV_PKT_Monitor.BODY.CIDO_FirstLinkLevel[0],RECV_PKT_Monitor.BODY.CIDO_FirstLinkLevel[1],RECV_PKT_Monitor.BODY.CIDO_FirstLinkLevel[2],
									RECV_PKT_Monitor.BODY.CIDO_FiberCommError[0],RECV_PKT_Monitor.BODY.CIDO_FiberCommError[1],
									RECV_PKT_Monitor.BODY.CIDO_RFCommError[0],RECV_PKT_Monitor.BODY.CIDO_RFCommError[1],
									RECV_PKT_Monitor.BODY.CID_UniqueID[0], RECV_PKT_Monitor.BODY.CID_UniqueID[1], RECV_PKT_Monitor.BODY.CID_UniqueID[2],
									RECV_PKT_Monitor.BODY.CID_UniqueID[3], RECV_PKT_Monitor.BODY.CID_UniqueID[4], RECV_PKT_Monitor.BODY.CID_UniqueID[5],
									m_sCIDStatus[0],m_sCIDStatus[1],m_sCIDStatus[2]);

					if(RECV_PKT_Monitor.BODY.CIDR_FirstLinkLevel[0] < '2' || RECV_PKT_Monitor.BODY.CIDO_FirstLinkLevel[0] < '2')
					{
						CID_MONITOR_LOG("%c%c%c%c%c%c/%c%c%c%c%c%c/CID-R:%c%c%c0/CID-O:%c%c%c0",
							RECV_PKT_Monitor.BODY.OHTID[0], RECV_PKT_Monitor.BODY.OHTID[1], RECV_PKT_Monitor.BODY.OHTID[2],
							RECV_PKT_Monitor.BODY.OHTID[3], RECV_PKT_Monitor.BODY.OHTID[4], RECV_PKT_Monitor.BODY.OHTID[5],
							RECV_PKT_Monitor.BODY.CID_UniqueID[0], RECV_PKT_Monitor.BODY.CID_UniqueID[1], RECV_PKT_Monitor.BODY.CID_UniqueID[2],
							RECV_PKT_Monitor.BODY.CID_UniqueID[3], RECV_PKT_Monitor.BODY.CID_UniqueID[4], RECV_PKT_Monitor.BODY.CID_UniqueID[5],
							RECV_PKT_Monitor.BODY.CIDR_FirstLinkLevel[0], RECV_PKT_Monitor.BODY.CIDR_FirstLinkLevel[1], RECV_PKT_Monitor.BODY.CIDR_FirstLinkLevel[2],
							RECV_PKT_Monitor.BODY.CIDO_FirstLinkLevel[0], RECV_PKT_Monitor.BODY.CIDO_FirstLinkLevel[1], RECV_PKT_Monitor.BODY.CIDO_FirstLinkLevel[2]);
					}
					//CID_ID_Buffer_Clear(index_tmp);

					//2022.11.30 sseung 버전관리 시스템 CID-O Version 저장
					if(OHTMainForm->Version_Info.CID_O_ver=="" && !(RECV_PKT_Monitor.BODY.CIDO_FW_Ver[0]=='0' && RECV_PKT_Monitor.BODY.CIDO_FW_Ver[1]=='0' && RECV_PKT_Monitor.BODY.CIDO_FW_Ver[2]=='0'))
					{
						OHTMainForm->Version_Info.CID_O_ver.sprintf("%c.%c.%c", RECV_PKT_Monitor.BODY.CIDO_FW_Ver[0], RECV_PKT_Monitor.BODY.CIDO_FW_Ver[1], RECV_PKT_Monitor.BODY.CIDO_FW_Ver[2]);
						OHTMainForm->Version_Info.CID_O_DATE.sprintf(OHTMainForm->strVersion_Date.c_str());
						ERR_LOG("CID Ver = %s", OHTMainForm->Version_Info.CID_O_ver);
					}
				}
				else
				{
					m_pExecuteInfo->FlagCIDMonitoring.bCIDFlag = true;
					m_pExecuteInfo->FlagCIDMonitoring.cResult = CID_MONITOR_INFO_GET_FAIL;
					m_CIDMonitoringFlag 	= false;
					ADD_LOG("C-11");
				}
				m_sCIDStatus[0] = 0;
				m_sCIDStatus[1] = 0;
				m_sCIDStatus[2] = 0;
			}
			else if((TempBuffer[1] == 'O') && (sizeof(RECV_PKT_Name) ==  iReceivedByte))
			{
				memcpy(&RECV_PKT_Name, &TempBuffer, iReceivedByte);
				bCountOfCID_Delay = 0;
				m_CIDNameReadFlag = false;

				unsigned char	Display_OHTNAME[7] ={0,};
				memcpy(&Display_OHTNAME, RECV_PKT_Name.OHTNAME, 6);
//				Display_OHTNAME[6] = '\n';
				ADD_LOG("C_18/%s", Display_OHTNAME);

				pHWSet->m_pCID->Set_CID_Name_Setting(true);

				// ADD_LOG("C_19/%s", RECV_PKT_Name.OHTNAME);
			}
			else if(TempBuffer[1] == 'L' && TempBuffer[2] == '=' && TempBuffer[3] == 'O' && TempBuffer[4] == 'D' && TempBuffer[5] == '8')
			{
				ADD_LOG("C-12");
				pHWSet->m_pCID->Save_CID_O_Data();
			}
			else
			{
				//ADD_LOG("C-13");
				//CID_O Log
				bCountOfCID_Delay = 0;
			}

			m_CIDMonitoringFlag= false;
			m_CIDNameReadFlag = false;
			m_CIDStatusFlag = false;
		}
		else
		{
			bCountOfCID_Delay = 0;	// 수신된 데이터가 없으면 다시 CID_SERIAL_CMD_DELAY_TURN 만큼 기다려본다
		}
	}
	else
	{
		bCountOfCID_Delay++;
	}


}



// CID-R장애여부를 판단하여 문제 있는경우 보고
// I4 = 1로 들어오면 시리얼로 S명령을 줘서 OCS로 정보를 전송해야 한다
void DrivingControl::CID_R_Status_Chk()
{
	 if ((pHWSet->m_pCID->IsLinkOK() == true
#if(OHT_NAME == OHT_NAME_STD_V81S)
	 || pHWSet->m_pCID->IsVHLRegistrationFull() == true // 고속화 OHT VHLRegistrationFull 되었는지도 확인
#endif
	 ) &&(pHWSet->m_pCID->ISCidStatusOn() == true)&&(m_CIDStatusFlag == false)
	 &&(m_pExecuteInfo->FlagCIDNotuse.bCIDUse == false)&&(m_Igro_CIDStatusPuaseFlag == false))
	 {
		try
		{
			pHWSet->m_pCID->Set_CID_Status_Cmd();
			// m_CIDMonitoringFlag = true;		// is bug shkim
			m_CIDStatusFlag = true;

//			EnterCriticalSection(&OHTMainForm->m_CS);
//			m_pExecuteInfo->FlagCIDInfo.bCIDErrorFlag = true;
//			LeaveCriticalSection(&OHTMainForm->m_CS);
//			pHWSet->m_pCID->CID_Status_Pause(m_CID_Status_Pause);
			//CID 이상상태일때 일시정지 하는 부분 ==>>추후에 꼭 활성화 필요
//			m_CIDStatusPauseFlag = true; // I4 == 1로 정지 설정
			ADD_LOG("C-14");
		}
		catch(...)
		{
			ADD_LOG("C-15");
		}
	 }
}

/*
( m_Igro_CIDStatusPuaseFlag )

	- 초기값 false
	- 노멀, 경사로 리셋노드 처리시 false
	- common 리셋노드 처리시 false
	- 작업변경 방향전환 처리시 false

	- CID_OCS_Resume_Cmd_Chk()
	  OCS로 보고한 Pause에 대한 Resume명령을 받아 재주행 시에 ture가 됨

	(사용)
	- CID-R 장애여부 보고시 조건으로 사용 : false일때 보고

	=> 즉, CID-R 보고 플래그로서, 장애발생시 계속 보고하다가, Resume명령 받으면 보고를 멈춤. 다음 리셋노드 만나면 false가 되어 보고

(FlagCIDNotuse.bCIDUse)
	- CID사용유무 설정값

*/

// CID호기번호 설정
UINT DrivingControl::setCID_VHL_Name(char* OHTNAME)
{
	CID_NameSet_PKT NameSet_PKT;

	NameSet_PKT.STX = OPC_SERIAL_INIT_STX;
	NameSet_PKT.CMD = 'O';
	NameSet_PKT.SEP = '=';

	memcpy(&NameSet_PKT.OHTNAME,  OHTNAME, 	sizeof(NameSet_PKT.OHTNAME));

	// sum바로 앞까지 바이트수가 9바이트
	CheckSum((char*)& NameSet_PKT, 9, (char*)&NameSet_PKT.SUM);
	NameSet_PKT.ETX = OPC_SERIAL_INIT_ETX;

	m_CIDNameReadFlag = true;

	return SEND_SERIAL_NOT_CLEAR((char*)&NameSet_PKT, sizeof(CID_NameSet_PKT));
}


// CID호기번호 확인요청
//UINT DrivingControl::requestCID_VHL_Name()
//{
//	CID_Name_Request_PKT NameGet_PKT;
//
//	NameGet_PKT.STX = OPC_SERIAL_INIT_STX;
//	NameGet_PKT.CMD = 'O';
//
//	// sum바로 앞까지 바이트수가 2바이트
//	CheckSum((char*)& NameGet_PKT, 2, (char*)&NameGet_PKT.SUM);
//	NameGet_PKT.ETX = OPC_SERIAL_INIT_ETX;
//
//	return SEND_SERIAL((char*)&NameGet_PKT, sizeof(CID_Name_Request_PKT));
//}

/**
@brief   Find Nearest CID Stop, Reset
@author  KJD
@date    2017.09.15
*/

int DrivingControl::CID_Find_Stop_Reset(int callNum, DRIVING_HW_INFO_SET HwInfo, int* StopNode, int* ResetNode, bool *TargetCID)
{
	unsigned int CIDStopNode1_arr, CIDStopNode2_arr, CIDResetNode_arr, TotalCount;
	DRIVING_CMD_INFO_OF_NODE* pStopNode;
	DRIVING_CMD_INFO_OF_NODE* pResetNode;
	CIDStopNode1_arr = INDEX_NONE;
	CIDStopNode2_arr = INDEX_NONE;
	CIDResetNode_arr = INDEX_NONE;
	static int tmpStopNode = 0;
	static int tmpResetNode = 0;
	bool bfindCID = false;

	//return 0;
	try{
		TotalCount = m_ClassifiedCmd.NodeList.getCount();
	}
	catch(...)
	{
		ADD_LOG("C-16");
	}

    //마지막 CID인지 아닌지 판단하는 부분 추가..
	for(int i = 0 ; i < TotalCount ; i++)
	{
		try{
			pStopNode = getNodeInfo(HwInfo.Node.nNodeCount+i);
			if(pStopNode != NULL)
			{
				CIDStopNode1_arr = OHTMainForm->GetMap()->FindNodeIndexFromCIDStop_1(pStopNode->ID);
				CIDStopNode2_arr = OHTMainForm->GetMap()->FindNodeIndexFromCIDStop_2(pStopNode->ID);
				//ADD_LOG("C_20/%d", pStopNode->ID);

			}else
			{
				//.CID 감지 이후에 확인된 이후에 CID 없는 구간이 존재하는지 확인.
				if(bfindCID == true)
				{
					*TargetCID = false;
//					ADD_LOG("C_TargetCID1");
					return 0;
				}
			}

		}
		catch(...)
		{
			ADD_LOG("C-17");
		}

		//stop을 찾은 경우 다음 노드가 Reset인지 확인
		if(bfindCID ==false)
		{
		if(CIDStopNode1_arr != INDEX_NONE || CIDStopNode2_arr != INDEX_NONE)
		{
			try{
				if(i<TotalCount-1)
				{
					pResetNode = getNodeInfo(HwInfo.Node.nNodeCount+i+1);
					if(pResetNode != NULL)
					{
						//ADD_LOG("C_21/%d", pResetNode->ID);
						CIDResetNode_arr = OHTMainForm->GetMap()->FindNodeIndexFromCIDReset(pResetNode->ID);
					}
					//Stop 다음 Reset인 경우 노드정보 리턴
					if(CIDResetNode_arr != INDEX_NONE)
					{
						if(pResetNode != NULL)
						{
							*StopNode = pStopNode->ID;
							*ResetNode = pResetNode->ID;

							if(tmpStopNode != *StopNode || tmpResetNode != *ResetNode)
							{
								ADD_LOG("C_22/%d/%d/%d/%d/%d", pStopNode->ID, pResetNode->ID, i, TotalCount, callNum);
								tmpStopNode = pStopNode->ID;
								tmpResetNode = pResetNode->ID;
							}
						}
							bfindCID=true;//return 0;

					}
				}
				else
				{
					if(m_pExecuteInfo->nNextNodeIDInfo != 0)
					{
						*StopNode = pStopNode->ID;
						*ResetNode = m_pExecuteInfo->nNextNodeIDInfo;

						if(tmpStopNode != *StopNode || tmpResetNode != *ResetNode)
						{
							ADD_LOG("C_23/%d/%d/%d/%d/%d", pStopNode->ID, m_pExecuteInfo->nNextNodeIDInfo, i, TotalCount, callNum);
							tmpStopNode = pStopNode->ID;
							tmpResetNode = m_pExecuteInfo->nNextNodeIDInfo;
						}
							bfindCID=true;//return 0;

					}
					else
					{
						*StopNode = pStopNode->ID;
						*ResetNode = 0;
						*TargetCID = true;
//                            ADD_LOG("C_TargetCID2");
						return 0;
					}
				}
			}
			catch(...)
			{
				ADD_LOG("C-18");
			}
		}
	}
	}
	//전체 경로에서 Stop, Reset을 못찾은 경우
	*TargetCID = true;
//	ADD_LOG("C_TargetCID3");
	if(bfindCID ==false)
	{
		*StopNode = 0;
		*ResetNode = 0;
		return 1;
	}else
	{
		return 0;
	}
}

/**
@brief   진행 경로의 CID Stop Node, Reset Node 찾는 함수
@author  KYH
@date    2018.05.29
*/

//int DrivingControl::CID_Find_Stop_Reset_Change(int callNum, DRIVING_HW_INFO_SET HwInfo, int* StopNode, int* ResetNode, int Num)
//{
//	unsigned int CIDStopNode1_arr, CIDStopNode2_arr, CIDResetNode_arr, TotalCount;
//	DRIVING_CMD_INFO_OF_NODE* pStopNode;
//	DRIVING_CMD_INFO_OF_NODE* pResetNode;
//	CIDStopNode1_arr = INDEX_NONE;
//	CIDStopNode2_arr = INDEX_NONE;
//	CIDResetNode_arr = INDEX_NONE;
//	static int tmpStopNode = 0;
//	static int tmpResetNode = 0;
//	//return 0;
//	try{
//		TotalCount = m_ClassifiedCmd.NodeList.getCount();
//	}
//	catch(...)
//	{
//		ADD_LOG("C-19");
//	}
//	for(int i = 0 ; i < TotalCount ; i++)
//	{
//		try{
//			pStopNode = getNodeInfo(HwInfo.Node.nNodeCount+i);
//
//			/*
//			static int nTmpCurNodeId01502 = 0;
//			if(nTmpCurNodeId01502 >= 40)
//			{
//				ADD_LOG("D_110/%d", pStopNode->ID);
//                nTmpCurNodeId01502 = 0;
//			}
//            nTmpCurNodeId01502++;
//			*/
//
//			if(pStopNode != NULL)
//			{
//				CIDStopNode1_arr = OHTMainForm->GetMap()->FindNodeIndexFromCIDStop_1(pStopNode->ID);
//				CIDStopNode2_arr = OHTMainForm->GetMap()->FindNodeIndexFromCIDStop_2(pStopNode->ID);
//				//ADD_LOG("C_24/%d", pStopNode->ID);
//			}
//		}
//		catch(...)
//		{
//			ADD_LOG("C-20");
//		}
//		//stop을 찾은 경우 다음 노드가 Reset인지 확인
//		if(CIDStopNode1_arr != INDEX_NONE || CIDStopNode2_arr != INDEX_NONE)
//		{
//			try{
//				if(i<TotalCount-1)
//				{
//					pResetNode = getNodeInfo(HwInfo.Node.nNodeCount+i+1);
//					if(pResetNode != NULL)
//					{
//						//ADD_LOG("C_25/%d", pResetNode->ID);
//						CIDResetNode_arr = OHTMainForm->GetMap()->FindNodeIndexFromCIDReset(pResetNode->ID);
//					}
//					//Stop 다음 Reset인 경우 노드정보 리턴
//					if(CIDResetNode_arr != INDEX_NONE)
//					{
//						if(pResetNode != NULL)
//						{
//							*StopNode = pStopNode->ID;
//							*ResetNode = pResetNode->ID;
//							if(tmpStopNode != *StopNode || tmpResetNode != *ResetNode)
//							{
//								ADD_LOG("C_26/%d/%d/%d/%d/%d", pStopNode->ID, pResetNode->ID, i, TotalCount, callNum);
//								tmpStopNode = pStopNode->ID;
//								tmpResetNode = pResetNode->ID;
//							}
//						}
//						return 0;
//					}
//					else
//					{
//						*StopNode = pStopNode->ID;
//						*ResetNode = -1;
//						return -1;
//					}
//				}
//				else
//				{
//					*StopNode = pStopNode->ID;
//					*ResetNode = 0;
//					return 0;
//				}
//			}
//			catch(...)
//			{
//				ADD_LOG("C-21");
//			}
//		}
//	}
//	//전체 경로에서 Stop, Reset을 못찾은 경우
//	*StopNode = 0;
//	*ResetNode = 0;
//	return 1;
//}



// CID Control Main Function
#define DEF_CID_INFO_NONE	-1
int DrivingControl::checkCID(DRIVING_HW_INFO_SET HwInfo, DRIVING_INFO_SET *pInfoSet)
{
	int nError = NO_ERR;	// CONTROL_CID()'s result;
	static int nPreviousNodeID = 0;
	static int nPreviousCurrNodeOffset=0;
	int nCurrentNodeID = (int)m_PositionInfo.CurrNode;

//	if(Info.tmpPreNodeID != Info.tmpCurrentNodeID)
//	{
//		ADD_LOG("C_27/%d/%d",Info.tmpPreNodeID, Info.tmpCurrentNodeID);
//	}

	if(nPreviousCurrNodeOffset != m_PositionInfo.CurrNodeOffset)
	{
//		ADD_LOG("C_28/%d/%d", m_PositionInfo.CurrNode, m_PositionInfo.CurrNodeOffset);
		nPreviousCurrNodeOffset = m_PositionInfo.CurrNodeOffset;
	}
	else
	{}
	// ---------- NameSet -------------
	// OHT의 호기명을 CID-O에 Write하는 함수로 한번만 실행해주면 된다
	static bool bNameWrite = false;
	try{

	if(bNameWrite == false)
	{
		setCID_VHL_Name(m_defualtparam->VHLName);
		bNameWrite = true;
	}
	// ---------------------------------

	m_bCIDNotUse = false;
	memset(&Info, 0, sizeof(CID_CTRL_INFO));
	#if 0
	DRIVING_CMD_INFO_OF_NODE* pPreNodeInfo = getNodeInfo(pInfoSet->HwInfo.Node.nPreCheckCount);
	if(pPreNodeInfo != NULL)
	{
		nCurrentNodeID = (int)pPreNodeInfo->ID;
	}
	else
	{
		nCurrentNodeID = (int)m_PositionInfo.CurrNode;
	}
	#endif
	getCID_Info(&Info, nCurrentNodeID);


	// test code(2016.11.25)  //////////////////////
	static int nTmpCurNodeId00 = 0;
	if(nTmpCurNodeId00 != Info.tmpCurrentNodeID)
	{
		nTmpCurNodeId00 = Info.tmpCurrentNodeID;
		ADD_LOG("C_29/%d/%d/%d/%d/%d/%d",
			Info.tmpCurrentNodeID, Info.CIDStopNode1, Info.CIDStopNode2, Info.CIDResetNode1, Info.CIDResetNode2, Info.CIDResetNodeType);

		ADD_LOG("C_30/%d/%d/%d/%d/%d/%d/%d/%d/%d/%d",
			Info.tmpStartNode1_1, Info.tmpStartNode1_2, Info.tmpStartNode1_3, Info.tmpStartNode1_4, Info.tmpStartNode1_5, Info.tmpStartNode2_1, Info.tmpStartNode2_2, Info.tmpStartNode2_3, Info.tmpStartNode2_4, Info.tmpStartNode2_5);

		ADD_LOG("C_31/%d/%d/%d/%d/%d",
					m_nCidControlStep, Info.tmpNextNodeID, Info.tmpCurrentCMDID, pHWSet->m_pCID->IsLinking(), m_CIDComptTryFlag);

		//IO_INFO_CID_ALL();

	}
	///////////////////////////////////////////////////////


	// Manual모드이다가 AutoMode로 전환했을때 한번만 state를 바꿔준다
	if(pHWSet->m_pCID->NeedTO_executeCID_Reset() == true)
	{
		m_nCidControlStep = CID_STEP_CONNECTING;
		ADD_LOG("C-22");
		pHWSet->m_pCID->CID_Out_PASS_Compt(ON);
		Sleep(20);
    	pHWSet->m_pCID->CID_Output_Clear(1);// 들어오는지 확인..
		IO_INFO_CID();
	}

	// 현재 상태가 Abnormal비트가 켜져 있는지 보고 켜져있으면 끈다 ,<= 내용 맞는건지...
	// (check CID로 들어온 경우는 Auto Mode 또는 Manual Mode인데 TP 사이클 명령을 받은 경우이며
	//	이 경우 사용자의 수동 조작으로 움직이는 것이 아니므로 꺼야 한다)  ==> [질문]
	if (pHWSet->m_pCID->ISCidManualMode() == true)
	{
		Manual_CID(MANUAL_CID_ABNORMAL_MODE_OFF);
		ADD_LOG("C-23");
	}


	// Common Tag Clear
	if(m_CID_COMMON_bit_off_need == true)
	{
		if(pHWSet->m_pCID->IsCommonTag() == true)
		{
			pHWSet->m_pCID->CID_Out_Common_Tag(1, false);	// Common Tag Off
			m_CID_COMMON_bit_off_need = false;
			ADD_LOG("C-24");
			nTmpCurNodeId00 = 0;// 로그 출력 하기위해
		}
		else
		{
			ADD_LOG("C-25");
			return NO_ERR;
		}
	}


	// Lifter, MTL 구간(Op. Mode = 0)과 일반 합류 구간(Op. Mode = 1) 구분
	// CID 구간인 경우 ControlCID 동작
	// 그외 구간인 경우 Lifter 구간 확인 하여, CID_Output_Clear 시킴
	if ((Info.tmpCurrentNodeID == Info.tmpStartNode2_1)	||(Info.tmpCurrentNodeID == Info.tmpStartNode2_2)
		||(Info.tmpCurrentNodeID == Info.tmpStartNode2_3)	||(Info.tmpCurrentNodeID == Info.tmpStartNode2_4)
		||(Info.tmpCurrentNodeID == Info.tmpStartNode2_5)	||(Info.tmpCurrentNodeID == Info.tmpResetNode2)

		||(Info.tmpCurrentNodeID == Info.tmpStartNode1_1)	||(Info.tmpCurrentNodeID == Info.tmpStartNode1_2)
		||(Info.tmpCurrentNodeID == Info.tmpStartNode1_3)	||(Info.tmpCurrentNodeID == Info.tmpStartNode1_4)
		||(Info.tmpCurrentNodeID == Info.tmpStartNode1_5)	||(Info.tmpCurrentNodeID == Info.tmpResetNode1)
		||(m_nCidControlStep == CID_STEP_CHECKING_PATH)
		||(m_nCidControlStep == CID_STEP_OCCUPYING_PATH)
		||(m_nCidControlStep == CID_STEP_WAITING_FOR_PATH)
	   	||(m_nCidControlStep == CID_STEP_ABNORMAL)		//CID_STEP_ABNORMAL 인 경우 현재 노드가 Reset인 경우 처리하는 부분이 존재.
														//현재 노드가 Reset 인 경우 or CID_STEP_ABNORMAL 인 경우 controlCID 호출이 되어야 함.
														//공용 노드인 경우는 start 노드에 포함되어 져서 controlCID이 호출 됨.
		||(m_nCidControlStep == CID_STEP_COMPLETION))
	{
		nError = controlCID(&Info, executeCID_NONE, pInfoSet, HwInfo);
	}
	else if ((pHWSet->m_pCID->IsOutputAllOff() != true) || (pHWSet->m_pCID->IsInputAllOff() != true))
	{
		DRIVING_CMD_INFO_OF_NODE* pNodeInfo = getNodeInfo(pInfoSet->HwInfo.Node.nNodeCount);
		if(pNodeInfo!=NULL)
		{

			if(pNodeInfo->NodeType == NONE_TYPE ||
				pNodeInfo->NodeType == OPT_TAG ||
				pNodeInfo->NodeType == OPT_DISTANCE ||
				pNodeInfo->NodeType == OPT_COMBO)
			{
				ADD_LOG("C_32/%d",pNodeInfo->NodeType);
				//리프터 구간 아닌 경우 실행 방지
				//NodeType이 일반노드 인 경우 실행
				if(pHWSet->m_pCID->IsLinkOK() == true)
					pHWSet->m_pCID->CID_Occup_compt(3);

				Sleep(20);
				pHWSet->m_pCID->CID_Output_Clear(2);
				ADD_LOG("C-26");

				m_bsecond = false;
				m_CID_Pause = false;
				m_CIDComptFlag = false;  // cid 완료 처리 Flag
				m_CIDComptTryFlag = false;  // cid 완료 처리 시도 Flag
				m_CID_COMMON_bit_off_need = false;
//				m_CIDMonitoringFlag = false;
				m_CIDLinkFlag = false;
//				m_CIDStatusFlag = false;
				m_CIDStatusPauseFlag = false;
				m_CIDPauseTime = 0;
				m_CID_Status_Pause = false;
				m_Igro_CIDStatusPuaseFlag = false;
				m_bLinkFail = false;
				m_bLinkDisconnected = false;
				m_bInitialLink = false;
				m_CIDDirection = CID_DIRECTION_NOT_LINK;
				m_bCIDNotUse = false;
				m_CIDOperationStarted = false;  // 2016. 12. 23 추가
				m_job_change_flag_no_cid_area = false; //0: not change 1 : change
				m_job_change_flag_exception_CommonTag = false;
				m_CurrCIDStartnode = 0;
				m_sCIDStatus[0]=0;
				m_sCIDStatus[1]=0;
				m_sCIDStatus[2]=0;

				bCountOfCID_Delay    = 0;
				bCountOfCIDLink    = 0; 	   //링크 연결 관련
				m_job_change_without_link_complete = false;
				bCountOfCIDDualOccup	= 0;  //동시진입 관련
				bCountOfCIDComptACK    = 0;  //완료처리 응답 관련

				bDirCIDChage = false;		// 방향전환 전에 완료처리를 함을 나타내는 변수
				tmpStopID = 0;

//				m_CIDNameReadFlag = false;
				m_tmpCurrentResetNode = 0;
				m_tmpCurrentStopNode = 0;
				m_nCIDTerminateCount = 0;

				m_nCidControlStep = CID_STEP_CONNECTING;
			}
		}
	}
	// CID 구간이 아닌 위치에서 감속정지시 주행재개 명령 처리 부분
	else if(m_pExecuteInfo->FlagCIDReport.bCIDStop == true
		&& m_CID_Pause == true
		&& m_pExecuteInfo->FlagCIDInfo.cMoveResult == true
		&& m_pExecuteInfo->FlagCIDInfo.bMoveRestart == true)
	{
		m_pExecuteInfo->FlagCIDInfo.bMoveRestart = false;
		pHWSet->m_pCID->CID_Occup_Resume(&m_CID_Pause);
		m_pExecuteInfo->FlagCIDReport.bCIDInterlock= false;
		m_pExecuteInfo->FlagCIDReport.bCIDStop = false;

		m_nCidControlStep = CID_STEP_COMPLETION;
		ADD_LOG("C-27");
	}
	else
	{
		//NOP
	}
	}catch(...)
         ADD_LOG("C-28");


	// ---- Monitoring & Status ----
	//CID_Monitor_Status(&Info);	// M(CID Monitoring ID:124), S(Status bit), O(Name) Command's Response Read.
	CID_R_Status_Chk();		// CID상태 확인. If Status bit=1, S Command Send function

	return nError;
}

void DrivingControl::DrivingCMDExuteFunc(bool bFlag)
{
	m_pExecuteInfo->FlagCmdExcute.bCmdDrivingCMDExcute = bFlag;
}


CID_DIRECTION DrivingControl::CID_Direction_Chk(CID_CTRL_INFO* Info, DRIVING_INFO_SET *pInfoSet, int CID_NearestResetNode, int  CID_NearestStopNode)
{

	// DIRECTION RIGHT
	if(	(Info->CIDStartNode2_arr != INDEX_NONE)&& (Info->CIDResetNode_arr == INDEX_NONE) &&
		(Info->tmpNextNodeID != 0) &&
		((Info->tmpNextNodeID == Info->tmpStartNode2_1) ||(Info->tmpNextNodeID == Info->tmpStartNode2_2)
	   ||(Info->tmpNextNodeID == Info->tmpStartNode2_3)||(Info->tmpNextNodeID == Info->tmpStartNode2_4)
	   ||(Info->tmpNextNodeID == Info->tmpStartNode2_5)||(Info->tmpNextNodeID == Info->tmpResetNode2)) &&
	   (Info->tmpStopNode2 == CID_NearestStopNode &&
			Info->tmpResetNode2 == CID_NearestResetNode &&
			m_pExecuteInfo->FlagCIDNotuse.bCIDUse == false))
	{


		if (Info->tmpStopNode2 == CID_NearestStopNode &&
			Info->tmpResetNode2 == CID_NearestResetNode &&
			m_pExecuteInfo->FlagCIDNotuse.bCIDUse == false)
		{
			m_CIDLinkFlag = true;
			m_bsecond = false;
			bDirCIDChage = false;
			m_bCIDNotUse = false;
			ADD_LOG("C-29");
			return CID_DIRECTION_RIGHT;	// Cid Direction is Right
		}
		else if (Info->tmpStopNode2 == CID_NearestStopNode &&
			Info->tmpResetNode2 == CID_NearestResetNode &&
			m_pExecuteInfo->FlagCIDNotuse.bCIDUse == true)  // <- m_pExecuteInfo->FlagCIDNotuse.bCIDUse == true 조건으로 들어오지 않음...
		{
			m_bCIDNotUse = true;
			ADD_LOG("C_33/%d/%d/%d/%d/%d",
				Info->tmpCurrentNodeID, Info->tmpStopNode2, Info->tmpResetNode2,
				CID_NearestStopNode, CID_NearestResetNode);
			return CID_DIRECTION_NOT_LINK;
		}
		else if (Info->tmpStopNode2 != CID_NearestStopNode ||
			Info->tmpResetNode2 != CID_NearestResetNode)
		{
			m_bCIDNotUse = false;
			static int nTmpCurNodeId1704121 = 0;
			if(nTmpCurNodeId1704121 != Info->tmpCurrentNodeID)
			{
				nTmpCurNodeId1704121 = Info->tmpCurrentNodeID;
				ADD_LOG("C_34/%d/%d/%d/%d/%d",
					Info->tmpCurrentNodeID, Info->tmpStopNode2, Info->tmpResetNode2,
					CID_NearestStopNode, CID_NearestResetNode);
			}
			return CID_DIRECTION_NOT_LINK;
		}
		else
		{
			m_bCIDNotUse = false;
			ADD_LOG("C-30");
			return CID_DIRECTION_NOT_LINK;
		}
	}

	// DIRECTION LEFT
	else if((Info->CIDStartNode1_arr != INDEX_NONE)&& (Info->CIDResetNode_arr == INDEX_NONE) &&
		(Info->tmpNextNodeID != 0) &&
		((Info->tmpNextNodeID == Info->tmpStartNode1_1) ||(Info->tmpNextNodeID == Info->tmpStartNode1_2)
	   ||(Info->tmpNextNodeID == Info->tmpStartNode1_3)||(Info->tmpNextNodeID == Info->tmpStartNode1_4)
       ||(Info->tmpNextNodeID == Info->tmpStartNode1_5)||(Info->tmpNextNodeID == Info->tmpResetNode1)) &&
       (Info->tmpStopNode1 == CID_NearestStopNode &&
			Info->tmpResetNode1 == CID_NearestResetNode &&
			m_pExecuteInfo->FlagCIDNotuse.bCIDUse == false))
	{
		if (Info->tmpStopNode1 == CID_NearestStopNode &&
			Info->tmpResetNode1 == CID_NearestResetNode &&
			m_pExecuteInfo->FlagCIDNotuse.bCIDUse == false)
		{
			m_CIDLinkFlag = true;	// 링크 시도중이다
			m_bsecond = false;
			bDirCIDChage = false;	// 방향전환 완료여부 (true : 진행중. false : 완료함)
			m_bCIDNotUse = false;
			ADD_LOG("C-31");
			return CID_DIRECTION_LEFT;
		}
		else if (Info->tmpStopNode1 == CID_NearestStopNode &&
			Info->tmpResetNode1 == CID_NearestResetNode &&
			m_pExecuteInfo->FlagCIDNotuse.bCIDUse == true) // <- m_pExecuteInfo->FlagCIDNotuse.bCIDUse == true 조건으로 들어오지 않음...
		{
			m_bCIDNotUse = true;
			ADD_LOG("C_35/%d/%d/%d/%d/%d",
				Info->tmpCurrentNodeID, Info->tmpStopNode1, Info->tmpResetNode1,
				CID_NearestStopNode, CID_NearestResetNode);
			return CID_DIRECTION_NOT_LINK;
		}
		else if (Info->tmpStopNode1 != CID_NearestStopNode ||
			Info->tmpResetNode1 != CID_NearestResetNode)
		{
			static int nTmpCurNodeId1704122 = 0;
			if(nTmpCurNodeId1704122 != Info->tmpCurrentNodeID)
			{
				nTmpCurNodeId1704122 = Info->tmpCurrentNodeID;
				ADD_LOG("C_36/%d/%d/%d/%d/%d",
					Info->tmpCurrentNodeID, Info->tmpStopNode1, Info->tmpResetNode1,
					CID_NearestStopNode, CID_NearestResetNode);
			}
			m_bCIDNotUse = false;
			return CID_DIRECTION_NOT_LINK;
		}
		else
		{
			m_bCIDNotUse = false;
			ADD_LOG("C-32");
			return CID_DIRECTION_NOT_LINK;
		}

	}
	else if((pInfoSet->Steer.FrontMoving == false)&&(pInfoSet->Steer.RearMoving == false)&&(pHWSet->m_pCID->IsLinking() == false)
			&&(pHWSet->m_pCID->IsLinkOK() == false)
			&& ((Info->CIDResetNode_arr != INDEX_NONE)&&(Info->CIDResetNodeType == Common_Reset_tag)&&(Info->CIDStartNode2_arr != INDEX_NONE)
			&& (Info->tmpNextNodeID != 0)

			&& ((Info->tmpNextNodeID == Info->tmpStartNode2_1)||(Info->tmpNextNodeID == Info->tmpStartNode2_2)||
				(Info->tmpNextNodeID == Info->tmpStartNode2_3)||(Info->tmpNextNodeID == Info->tmpStartNode2_4)||
				(Info->tmpNextNodeID == Info->tmpStartNode2_5)
		 	   ||Info->tmpNextNodeID == Info->tmpResetNode2)))
	{
		if (Info->tmpStopNode2 == CID_NearestStopNode &&
			Info->tmpResetNode2 == CID_NearestResetNode &&
			m_pExecuteInfo->FlagCIDNotuse.bCIDUse == false)
		{
			m_bsecond = true;
	   		m_CIDLinkFlag = true;
	   		bDirCIDChage = false;
			m_bCIDNotUse = false;
			ADD_LOG("C-33");
			return CID_DIRECTION_COMMON_RIGHT;
		}
		else if (Info->tmpStopNode2 == CID_NearestStopNode &&
			Info->tmpResetNode2 == CID_NearestResetNode &&
			m_pExecuteInfo->FlagCIDNotuse.bCIDUse == true)
		{
			m_bCIDNotUse = true;
			ADD_LOG("C_37/%d/%d/%d/%d/%d",
			Info->tmpCurrentNodeID, Info->tmpStopNode2, Info->tmpResetNode2,
			CID_NearestStopNode, CID_NearestResetNode);
			return CID_DIRECTION_NOT_LINK;
		}
		else if (Info->tmpStopNode2 != CID_NearestStopNode ||
			Info->tmpResetNode2 != CID_NearestResetNode)
		{
			static int nTmpCurNodeId1704123 = 0;
			if(nTmpCurNodeId1704123 != Info->tmpCurrentNodeID)
			{
				nTmpCurNodeId1704123 = Info->tmpCurrentNodeID;
				ADD_LOG("C_38/%d/%d/%d/%d/%d",
					Info->tmpCurrentNodeID, Info->tmpStopNode2, Info->tmpResetNode2,
					CID_NearestStopNode, CID_NearestResetNode);
			}
			m_bCIDNotUse = false;
			return CID_DIRECTION_NOT_LINK;
		}
		else
		{
			m_bCIDNotUse = false;
			ADD_LOG("C-34");
			return CID_DIRECTION_NOT_LINK;
		}
	}
	else if((pInfoSet->Steer.FrontMoving == false)&&(pInfoSet->Steer.RearMoving == false)&&(pHWSet->m_pCID->IsLinking() == false)
			&&(pHWSet->m_pCID->IsLinkOK() == false)
			&& ((Info->CIDResetNode_arr != INDEX_NONE)&&(Info->CIDResetNodeType == Common_Reset_tag)&&(Info->CIDStartNode1_arr != INDEX_NONE)
			&& (Info->tmpNextNodeID != 0)
			&&((Info->tmpNextNodeID == Info->tmpStartNode1_1)||(Info->tmpNextNodeID == Info->tmpStartNode1_2)||
			   (Info->tmpNextNodeID == Info->tmpStartNode1_3)||(Info->tmpNextNodeID == Info->tmpStartNode1_4)||
			   (Info->tmpNextNodeID == Info->tmpStartNode1_5)
	          ||Info->tmpNextNodeID == Info->tmpResetNode1)))
	{
		if (Info->tmpStopNode1 == CID_NearestStopNode &&
			Info->tmpResetNode1 == CID_NearestResetNode &&
			m_pExecuteInfo->FlagCIDNotuse.bCIDUse == false)
		{
			m_bsecond = true;
			m_CIDLinkFlag = true;
			bDirCIDChage = false;
			m_bCIDNotUse = false;
			ADD_LOG("C-35");
			return CID_DIRECTION_COMMON_LEFT;
		}
		else if (Info->tmpStopNode1 == CID_NearestStopNode &&
			Info->tmpResetNode1 == CID_NearestResetNode &&
			m_pExecuteInfo->FlagCIDNotuse.bCIDUse == true)
		{
			m_bCIDNotUse = true;
			ADD_LOG("C_39/%d/%d/%d/%d/%d",
				Info->tmpCurrentNodeID, Info->tmpStopNode1, Info->tmpResetNode1,
				CID_NearestStopNode, CID_NearestResetNode);
			return CID_DIRECTION_NOT_LINK;
		}
		else if (Info->tmpStopNode1 != CID_NearestStopNode ||
			Info->tmpResetNode1 != CID_NearestResetNode)
		{
			static int nTmpCurNodeId1704124 = 0;
			if(nTmpCurNodeId1704124 != Info->tmpCurrentNodeID)
			{
				nTmpCurNodeId1704124 = Info->tmpCurrentNodeID;
				ADD_LOG("C_40/%d/%d/%d/%d/%d",
					Info->tmpCurrentNodeID, Info->tmpStopNode1, Info->tmpResetNode1,
					CID_NearestStopNode, CID_NearestResetNode);
			}
			m_bCIDNotUse = false;
			return CID_DIRECTION_NOT_LINK;
		}
		else
		{
			m_bCIDNotUse = false;
			ADD_LOG("C-36");
			return CID_DIRECTION_NOT_LINK;
		}
	}
	else
	{
		//m_pExecuteInfo->FlagCIDNotuse.bCIDUse == true 인 경우 모두 else로 진입 함...
		//m_bCIDNotUse = false로 변경하는게 맞는지...

		static int nTmpCurNodeId15 = 0;
		if(nTmpCurNodeId15 != Info->tmpCurrentNodeID)
		{
			nTmpCurNodeId15 = Info->tmpCurrentNodeID;
			ADD_LOG("C-37");
			ADD_LOG("D_111/%d/%d", Info->tmpCurrentNodeID, Info->tmpNextNodeID);
			ADD_LOG("D_112/%d/%d", Info->tmpStopNode1, Info->tmpStopNode2);
			ADD_LOG("D_113/%d/%d", Info->tmpResetNode1, Info->tmpResetNode2);
			ADD_LOG("D_114/%d/%d", Info->tmpStartNode1_1, Info->tmpStartNode1_2);
			ADD_LOG("D_115/%d/%d", Info->tmpStartNode2_1, Info->tmpStartNode2_2);
			ADD_LOG("D_116/%d", m_pExecuteInfo->FlagCIDNotuse.bCIDUse);
			ADD_LOG("D_117/%d/%d/%d/%d" , Info->CIDStartNode1_arr, Info->CIDStartNode2_arr, Info->CIDResetNode_arr, Info->CIDResetNodeType);
			ADD_LOG("D_118/%d/%d",CID_NearestStopNode, CID_NearestResetNode);
		}
		m_bCIDNotUse = false;
		return CID_DIRECTION_NOT_LINK;
	}

}
/**
@brief   CID link 시작이 안되는 경우 100ms에 해당하는 거리로 변환하는 함수.
@author  KJD
@date    2017.01.09
*/

int DrivingControl::CID_Comm_Time2Dist(CID_CTRL_INFO* Info)
{
	int rDist=0;
	int NodeIndex = 0;
	NodeIndex = OHTMainForm->GetMap()->FindNodeIndex(Info->tmpCurrentNodeID);
	if(Info->tmpNextNodeID == OHTMainForm->GetMap_STD()->m_NodeArray[NodeIndex].LeftNodeID)
	{
		rDist = OHTMainForm->GetMap_STD()->m_NodeArray[NodeIndex].LeftNodeSpeed * 0.1;
	}
	else if(OHTMainForm->GetMap_STD()->m_NodeArray[NodeIndex].RightNodeID)
	{
		rDist = OHTMainForm->GetMap_STD()->m_NodeArray[NodeIndex].RightNodeSpeed * 0.1;
	}
	else
	{
		// node 정보를 못찾거나 한 경우
		// 3.3m/s 로 기준으로 정의
		// 5m/s 구간도 CID 합류 부는 3.3ms로 설정됨..
		rDist = 330;
	}
	if(Info->CIDResetNode == Info->tmpCurrentNodeID)
	{
		rDist += 200;//공용태그 간격 보상
	}
	return rDist;
}

/**
@brief   CID 관련 제어를 위한 함수
@author  Kunjin
@date    2016.11.23
*/
int DrivingControl::controlCID(CID_CTRL_INFO* Info, executeCID_CMD iCmd, DRIVING_INFO_SET *pInfoSet, DRIVING_HW_INFO_SET HwInfo)
{
	int nError = NO_ERR;
	static unsigned char CID_NotLinkCount = 0;
	static unsigned char CID_SendForStatusCount = 0;
	static bool bResumedbyOCS = false;//임시 생성 - 실제 OCS 결과 값 받아오는 경우 처리 이전 사용
	static unsigned int ResumedbyOCS_count = 0;//임시 생성 - delay 생성을 위해 link 신호 수신 전 식간 확보
	static unsigned int CID_ResetNode = 0;
	static unsigned int CID_StopNode = 0;
	static int CID_NearestResetNode = 0;
	static int CID_NearestStopNode = 0;
	static bool CID_NearestTargetCID = false;
	unsigned int CIDResetNode_arr = INDEX_NONE;
	static int CID_Occup_Count = 0;	//동일 경로 작업 변경시 Occup 반납 Count
	static int CID_Occup_Release_Status = 0;	//동일 경로 작업 변경시 Occup 반납 유무 상태  0: 초기값, 1 : 점유 반납 후 동작
	static int CID_Status_Check = 0;  // CID 상태 보고 보고 완료시 1

	double  dSpeedOfNow = pInfoSet->HwInfo.Axis1.dSpeed;
												//CID-R 자체 delay 30ms oht 2cycle? max 62ms?
	// Status bit check 후 On 이면, CID 상태 정보 취득///////////
//	CID_R_Status_Chk();

	////////////////////////////////////////////////


	static int nLinkFailureCount = 0;

	static int  OverrunCheckCurrentNodeID = 0;



	PATH_INFO	*pPathInfo	= NULL;
    int  nPathIndex = 0;
	// 1. Link 여부 확인(확인용... disconnected의 경우 CID-O에서 auto retry)
	if ((pHWSet->m_pCID->IsLinking() == true && m_bInitialLink == true)
		&& ((pHWSet->m_pCID->IsLinkOK() == false && m_nCidControlStep != CID_STEP_COMPLETION && m_nCidControlStep != CID_STEP_CONNECTING)
			|| (pHWSet->m_pCID->IsLinkOK() == false && m_nCidControlStep == CID_STEP_COMPLETION && m_CIDComptTryFlag == false)))
	{
		if (nLinkFailureCount > 10)
		{
			ERR_LOG("[CID] Critical Connection Lost...(Step : %d), Current Node : %d)",m_nCidControlStep, Info->tmpCurrentNodeID);
			m_bLinkDisconnected = true;
			m_nCidControlStep = CID_STEP_ABNORMAL;
		}
		else
			nLinkFailureCount++;
	}
	else
	{
		// Do nothing
		nLinkFailureCount = 0;
		//ADD_LOG("C_41/%d", Info->tmpCurrentNodeID);
	}

	// 2. 작업 변경 시 CID-O 제어

	if (m_CIDOperationStarted == true &&
//	   (CID_ResetNode != CID_NearestResetNode) && //ResetNodeID가 변경된 경우에만 작업변경.
		(((m_pExecuteInfo->bChangeResult == true || m_job_change_flag_no_cid_area == true) && m_nCidControlStep == CID_STEP_COMPLETION && m_CIDComptTryFlag == false)  // 작업 변경 Flag On 필요
		|| ((m_pExecuteInfo->bChangeResult == true || m_job_change_flag_no_cid_area == true) && m_nCidControlStep != CID_STEP_COMPLETION && m_nCidControlStep != CID_STEP_CONNECTING)))
	{
		CID_Find_Stop_Reset(1, HwInfo, &CID_NearestStopNode, &CID_NearestResetNode, &CID_NearestTargetCID);
		//Stopnode에서 작업 변경인 경우
		//ResetNode 변경이 없는 경우 작업 변경 무시 처리
		if((Info->CIDStopNode1 == Info->tmpCurrentNodeID || Info->CIDStopNode2 == Info->tmpCurrentNodeID)
		&& (CID_ResetNode == CID_NearestResetNode))
		{
			m_pExecuteInfo->bChangeResult = false;
			static int nTmpCurNodeId1025 = 0;
			if(nTmpCurNodeId1025 != Info->tmpCurrentNodeID)
			{
				nTmpCurNodeId1025 = Info->tmpCurrentNodeID;
				ADD_LOG("C-38");
				//ADD_LOG("D_119/%d/%d", CID_ResetNode, CID_NearestResetNode);
			}
		}
		if(m_pExecuteInfo->bChangeResult == true)
		{
			if(CID_ResetNode != CID_NearestResetNode && CID_NearestResetNode != 0)//ResetNodeID가 변경된 경우에만 작업변경.
			{
//				//kyh Link 되기전에 작업변경 시 확인 조건 추가
//				if(pHWSet->m_pCID->IsLinking() == true && pHWSet->m_pCID->IsLinkOK() == false && bResumedbyOCS == false
//					&& (m_nCidControlStep == CID_STEP_CHECKING_PATH || m_nCidControlStep == CID_STEP_WAITING_FOR_PATH))
//				{
//					static int nTmpCurNodeId19100101 = 0;
//					if(nTmpCurNodeId19100101 != Info->tmpCurrentNodeID)
//					{
//						nTmpCurNodeId19100101 = Info->tmpCurrentNodeID;
//						ADD_LOG("C_42/%d/%d", CID_ResetNode, CID_NearestResetNode);
//					}
//				}
//				else
//				{
//					if(m_bLinkFail == true && m_CID_Pause == true && pHWSet->m_pCID->IsLinkOK() == true)  //kyh DecelStop 이후 Link 되었을때 처리
//					{
//						m_bLinkFail = false;
//
//						pHWSet->m_pCID->CID_Occup_Resume(&m_CID_Pause);
//						ADD_LOG("C-39");
//						m_pExecuteInfo->FlagCIDReport.bCIDStop = false;
//						bResumedbyOCS = false;
//					}

					ADD_LOG("C_43/%d/%d", CID_ResetNode, CID_NearestResetNode);
					DRIVING_CMD_INFO_OF_NODE* pPreNodeInfo = getNodeInfo(pInfoSet->HwInfo.Node.nPreCheckCount);

					int nCurrentNodeID;
					if(pPreNodeInfo != NULL)
					{
						nCurrentNodeID = (int)pPreNodeInfo->ID;
					}
					else
					{
						nCurrentNodeID = (int)m_PositionInfo.CurrNode;
					}
					getCID_Info(Info, nCurrentNodeID);


					CID_DIRECTION tempCIDDirection = CID_DIRECTION_NOT_LINK;
						//CID_Find_Stop_Reset(HwInfo, &CID_NearestStopNode, &CID_NearestResetNode);
						tempCIDDirection = CID_Direction_Chk(Info, pInfoSet, CID_NearestResetNode, CID_NearestStopNode);

					//진행 방향이 변경 된 경우만 완료 처리
					if ((m_CIDDirection != tempCIDDirection)
						&& (m_CIDDirection != CID_DIRECTION_NOT_LINK))
						//&& (tempCIDDirection != CID_DIRECTION_NOT_LINK))
					{
						// Select Off 전 완료 처리 후 COMPLETION step으로 이동
						pHWSet->m_pCID->CID_Occup_compt(4); // 통과 완료 bit ON
						m_CIDComptTryFlag = true;
						Sleep(20);
						if(pHWSet->m_pCID->ISCompletion_On() == false)
						{
							ADD_LOG("C-40");
							pHWSet->m_pCID->CID_Occup_compt(5); // 통과 완료 bit ON
							Sleep(20);
						}
						if(pHWSet->m_pCID->ISCompletionACK_On() == false)
						{
							ADD_LOG("C-41");
							nEnforcedSelectOffNodeID = CID_NearestResetNode;
							//Sleep(20);  //Sleep제거
						}

						m_nCidControlStep = CID_STEP_COMPLETION;
						//tempCIDDirection = CID_DIRECTION_NOT_LINK;
						//link 안된 경우 작업 변경 처리 조건 추가
						if(pHWSet->m_pCID->IsLinkOK() == false)
						{
							m_job_change_without_link_complete = true;
						}

						if(m_pExecuteInfo->FlagCIDReport.bCIDStop == true)
						{
							//m_pExecuteInfo->FlagCIDReport.bCIDStop = false;
							ADD_LOG("C-42");
						}
						ADD_LOG("C-43");

						//작업 변경 관련 Flag 처리
						//m_bJobChange = false;
						m_pExecuteInfo->bChangeResult = false;    //false 시점 확인
						m_job_change_flag_no_cid_area = false;
						m_job_change_flag_exception_CommonTag = true;
//						if (Info->tmpPreNodeID == m_tmpCurrentResetNode && Info->CIDResetNodeType == Common_Reset_tag)
//						{
//							m_job_change_flag_exception_CommonTag = false; // kyh Common CID 처리
//						}
//						else
//						{
//							m_job_change_flag_exception_CommonTag = true; // kyh Common CID 미처리
//						}

						ADD_LOG("C-44");
						ADD_LOG("C_44/%d/%d/%d/%d/%d/%d", Info->tmpCurrentNodeID, Info->tmpNextNodeID, Info->tmpStopNode1, Info->tmpStopNode2, Info->tmpResetNode1, Info->tmpResetNode2);
						ADD_LOG("C_45/%d/%d", tempCIDDirection, m_CIDDirection);
							//ADD_LOG("C_46/%d/%d", m_pExecuteInfo->FlagCIDNotuse.nStopNodeID, m_pExecuteInfo->FlagCIDNotuse.nResetNodeID);
					}

					else
					{
						//ADD_LOG("C-45");

						if (!((Info->tmpCurrentNodeID == Info->tmpStartNode2_1)	||(Info->tmpCurrentNodeID == Info->tmpStartNode2_2)
						||(Info->tmpCurrentNodeID == Info->tmpStartNode2_3)	||(Info->tmpCurrentNodeID == Info->tmpStartNode2_4)
						||(Info->tmpCurrentNodeID == Info->tmpStartNode2_5)	||(Info->tmpCurrentNodeID == Info->tmpResetNode2)

						||(Info->tmpCurrentNodeID == Info->tmpStartNode1_1)	||(Info->tmpCurrentNodeID == Info->tmpStartNode1_2)
						||(Info->tmpCurrentNodeID == Info->tmpStartNode1_3)	||(Info->tmpCurrentNodeID == Info->tmpStartNode1_4)
						||(Info->tmpCurrentNodeID == Info->tmpStartNode1_5)	||(Info->tmpCurrentNodeID == Info->tmpResetNode1)))
						{
							pHWSet->m_pCID->CID_Occup_compt(6); // 통과 완료 bit ON
							m_CIDComptTryFlag = false;

							m_nCidControlStep = CID_STEP_CONNECTING;
							// tempCIDDirection = CID_DIRECTION_NOT_LINK;
							ADD_LOG("C-46");

						}
						static int nTmpCurNodeId21 = 0;
						if(nTmpCurNodeId21 != Info->tmpCurrentNodeID)
						{
							nTmpCurNodeId21 = Info->tmpCurrentNodeID;
							ADD_LOG("C-47");
							ADD_LOG("C_47/%d/%d/%d/%d/%d/%d", Info->tmpCurrentNodeID, Info->tmpNextNodeID, Info->tmpStopNode1, Info->tmpStopNode2, Info->tmpResetNode1, Info->tmpResetNode2);
							ADD_LOG("C_48/%d/%d", tempCIDDirection, m_CIDDirection);
								//ADD_LOG("C_49/%d/%d", m_pExecuteInfo->FlagCIDNotuse.nStopNodeID, m_pExecuteInfo->FlagCIDNotuse.nResetNodeID);
						}
						//작업 변경 Flag set 이후 바로 신규 경로가 들어오지는 않음...
						//m_pExecuteInfo->bChangeResult = false;    //false 시점 확인
						//m_job_change_flag_no_cid_area = false;
					}

			}
			else if(CID_NearestResetNode == 0)//ResetNodeID가 0인 경우 처리 : 점유만 반납
			{
				static int nTmpCurNodeId01500 = 0;
				if(nTmpCurNodeId01500 != Info->tmpCurrentNodeID)
				{
					nTmpCurNodeId01500 = Info->tmpCurrentNodeID;
					ADD_LOG("C_50/%d/%d/%d/%d", CID_ResetNode, CID_NearestResetNode, Info->tmpCurrentNodeID, Info->tmpNextNodeID);
					ADD_LOG("C_51/%d/%d/%d/%d", Info->CIDStopNode1, Info->CIDResetNode1, Info->CIDStopNode2, Info->CIDResetNode2);
				}
				static int nTmpCurNodeId01501 = 0;
				if(nTmpCurNodeId01501 != Info->tmpNextNodeID)
				{
					nTmpCurNodeId01501 = Info->tmpNextNodeID;
					ADD_LOG("C_52/%d/%d/%d/%d", CID_ResetNode, CID_NearestResetNode, Info->tmpCurrentNodeID, Info->tmpNextNodeID);
					ADD_LOG("C_53/%d/%d/%d/%d", Info->CIDStopNode1, Info->CIDResetNode1, Info->CIDStopNode2, Info->CIDResetNode2);
				}

				int nCurrentNodeID = (int)m_PositionInfo.CurrNode;
				getCID_Info(Info, nCurrentNodeID);

				/*
				int FindStopNodeID;
				int FindResetNodeID;

				CID_Find_Stop_Reset_Change(4, HwInfo, &FindStopNodeID, &FindResetNodeID, 1);

				if(((Info->tmpNextNodeID != 0) || (Info->tmpNextNodeID != Info->tmpCurrentNodeID)) && //Stop Node 정지상태가 아닐때
					((((Info->tmpCurrentNodeID == Info->CIDStopNode1) || (Info->tmpCurrentNodeID == Info->tmpStartNode1_1) || (Info->tmpCurrentNodeID == Info->tmpStartNode1_2) || (Info->tmpCurrentNodeID == Info->tmpStartNode1_3) || (Info->tmpCurrentNodeID == Info->tmpStartNode1_4)) && (Info->tmpNextNodeID != Info->CIDResetNode1)) ||
					((Info->tmpCurrentNodeID == Info->CIDStopNode2) || (Info->tmpCurrentNodeID == Info->tmpStartNode2_1) || (Info->tmpCurrentNodeID == Info->tmpStartNode2_2) || (Info->tmpCurrentNodeID == Info->tmpStartNode2_3) || (Info->tmpCurrentNodeID == Info->tmpStartNode2_4) && (Info->tmpNextNodeID != Info->CIDResetNode2))))
					//CID 영역이 아닌 곳으로 작업변경이 왔을때
				*/

				if (CID_Compare_List(HwInfo) == true)
				{
//					//kyh Link 되기전에 작업변경 시 확인 조건 추가
//					if(pHWSet->m_pCID->IsLinking() == true && pHWSet->m_pCID->IsLinkOK() == false && bResumedbyOCS == false
//						&& (m_nCidControlStep == CID_STEP_CHECKING_PATH || m_nCidControlStep == CID_STEP_WAITING_FOR_PATH))
//					{
//						static int nTmpCurNodeId19100102 = 0;
//						if(nTmpCurNodeId19100102 != Info->tmpCurrentNodeID)
//						{
//							nTmpCurNodeId19100102 = Info->tmpCurrentNodeID;
//							ADD_LOG("C_54/%d/%d/%d/%d", CID_ResetNode, CID_NearestResetNode, Info->tmpCurrentNodeID, Info->tmpNextNodeID);
//                    	}
//					}
//					else
//					{
//						if((m_bLinkFail == true && m_CID_Pause == true && pHWSet->m_pCID->IsLinkOK() == true) || (bResumedbyOCS == true)) //kyh DecelStop 이후 Link || 주행재개 처리
//						{
//							m_bLinkFail = false;
//
//							pHWSet->m_pCID->CID_Occup_Resume(&m_CID_Pause);
//							ADD_LOG("C-48");
//							m_pExecuteInfo->FlagCIDReport.bCIDStop = false;
//							bResumedbyOCS = false;
//						}

						ADD_LOG("C_55/%d/%d/%d/%d", CID_ResetNode, CID_NearestResetNode, Info->tmpCurrentNodeID, Info->tmpNextNodeID);

						CID_DIRECTION tempCIDDirection = CID_DIRECTION_NOT_LINK;
						//CID_Find_Stop_Reset(HwInfo, &CID_NearestStopNode, &CID_NearestResetNode);
						tempCIDDirection = CID_Direction_Chk(Info, pInfoSet, CID_NearestResetNode, CID_NearestStopNode);
						//진행 방향이 변경 된 경우만 완료 처리
						if ((m_CIDDirection != tempCIDDirection)
							&& (m_CIDDirection != CID_DIRECTION_NOT_LINK))
							//&& (tempCIDDirection != CID_DIRECTION_NOT_LINK))
						{
							// Select Off 전 완료 처리 후 COMPLETION step으로 이동
							pHWSet->m_pCID->CID_Occup_compt(12); // 통과 완료 bit ON
							m_CIDComptTryFlag = true;
							Sleep(20);
							if(pHWSet->m_pCID->ISCompletion_On() == false)
							{
								ADD_LOG("C-49");
								pHWSet->m_pCID->CID_Occup_compt(13); // 통과 완료 bit ON
								Sleep(20);
							}
							if(pHWSet->m_pCID->ISCompletionACK_On() == false)
							{
								ADD_LOG("C-50");
								nEnforcedSelectOffNodeID = CID_NearestResetNode;
								//Sleep(20);  //Sleep제거
							}

							m_nCidControlStep = CID_STEP_COMPLETION;
							// tempCIDDirection = CID_DIRECTION_NOT_LINK;
							// link 안된 경우 작업 변경 처리 조건 추가
							if(pHWSet->m_pCID->IsLinkOK() == false)
							{
								m_job_change_without_link_complete = true;
							}

							if(m_pExecuteInfo->FlagCIDReport.bCIDStop == true)
							{
								//m_pExecuteInfo->FlagCIDReport.bCIDStop = false;
								ADD_LOG("C-51");
							}
							ADD_LOG("C-52");

							//작업 변경 관련 Flag 처리
							//m_bJobChange = false;
							m_pExecuteInfo->bChangeResult = false;    //false 시점 확인
							m_job_change_flag_no_cid_area = false;
							m_job_change_flag_exception_CommonTag = true;
//							if (Info->tmpPreNodeID == m_tmpCurrentResetNode && Info->CIDResetNodeType == Common_Reset_tag)
//							{
//								m_job_change_flag_exception_CommonTag = false; // kyh Common CID 처리
//							}
//							else
//							{
//								m_job_change_flag_exception_CommonTag = true; // kyh Common CID 미처리
//							}
//						}
					}
				}
			}
		}
	}
	else if (m_CIDOperationStarted == false && m_pExecuteInfo->bChangeResult == true)
	{
		//CID 구간 진입 전 작업 변경으로 진행 방향이 변경된 경우 CID 방향을 검사할 기준이 없음..
		//m_job_change_flag_no_cid_area로 진입 전 작업 변경 설정..
		//m_pExecuteInfo->bChangeResult = false 하면 안됨..

		//before
		//m_pExecuteInfo->bChangeResult = false;
		//after
		m_job_change_flag_no_cid_area = true;
		static int nTmpCurNodeId01031 = 0;
		if(nTmpCurNodeId01031 != Info->tmpCurrentNodeID)
		{
			nTmpCurNodeId01031 = Info->tmpCurrentNodeID;
			ADD_LOG("C-53");
		}
	}

	// bChangeResult에 의한 처리가 되지 않은 경우
	// Stop Tag에서 Next Node가 현재 동작 중인 CID-O의 방향과 다른 경우 완료 처리 후 CID-O 방향 전환
	else if ( m_CIDOperationStarted == true && m_pExecuteInfo->bChangeResult == false && m_CIDComptTryFlag == false)
	{

		// Right에서 Left로 전환이 필요한 겅우
		if ((pHWSet->m_pCID->IsLinking_Right() == true && pHWSet->m_pCID->IsLinking_Left() == false
			&& Info->CIDResetNode_arr == INDEX_NONE && Info->CIDStopNode1_arr != INDEX_NONE
			&& Info->tmpNextNodeID == Info->CIDResetNode1 && Info->tmpNextNodeID != 0
			&& Info->CIDStopNode2 != 0)
			||
		// Left에서 Right로 전환이 필요한 겅우
			(pHWSet->m_pCID->IsLinking_Left() == true && pHWSet->m_pCID->IsLinking_Right() == false
			&& Info->CIDResetNode_arr == INDEX_NONE && Info->CIDStopNode2_arr != INDEX_NONE
			&& Info->tmpNextNodeID == Info->CIDResetNode2 && Info->tmpNextNodeID != 0
			&& Info->CIDStopNode1 != 0))
		{
			pHWSet->m_pCID->CID_Occup_compt(7); // 통과 완료 bit ON
			m_CIDComptTryFlag = true;

			m_nCidControlStep = CID_STEP_COMPLETION;
//			tempCIDDirection = CID_DIRECTION_NOT_LINK;
			ADD_LOG("C-54");
			ADD_LOG("C_56/%d/%d", Info->tmpCurrentNodeID, Info->tmpNextNodeID);
		}
	}


/*
	if(m_pExecuteInfo->bChangeResult == true)
	{
		ADD_LOG("C-55");
		ADD_LOG("D_120/%d/%d",m_nCidControlStep, m_CIDComptTryFlag);

		m_pExecuteInfo->bChangeResult = false;
	}
*/


	if(m_Continue_CID_MODE)
	{
		m_Continue_CID_MODE=0;
		m_CIDOperationStarted = true;
		nEnforcedSelectOffNodeID = 0;
		ResumedbyOCS_count = 0;
		CID_NotLinkCount = 0;
		CID_SendForStatusCount = 0;
		m_pExecuteInfo->FlagCIDReport.bCIDInterlock = false;
		m_pExecuteInfo->FlagCIDReport.bCIDStop= false;
		m_nCIDTerminateCount = 0;
		// 완료 처리해야 할 Reset Node (2016.12.14)
		m_tmpCurrentResetNode = m_Continue_CID_MODE_ResetNode;
		//m_tmpCurrentStopNode = ?;//필요한가 ??
		Info->tmpCurrentResetNodeType = m_Continue_CID_MODE_ResetNodeType;

		m_Diag_CID_index = (m_Diag_CID_index+1) & 0x7;

		m_Diag_ResetNode[m_Diag_CID_index] = m_tmpCurrentResetNode;
		m_Diag_StopNode[m_Diag_CID_index] = m_tmpCurrentStopNode;
		int tmp_index = OHTMainForm->GetMap()->FindNodeIndexFromCIDReset(m_tmpCurrentResetNode);
		if(tmp_index != INDEX_NONE)
		{
			memcpy(m_Diag_CID_R_ID[m_Diag_CID_index], OHTMainForm->GetCID_STD()->m_NodeArray[tmp_index].LayoutID, 6);
			ADD_LOG("C_57/%c/%c/%c/%c/%c/%c/%d/%d/%d",
			m_Diag_CID_R_ID[m_Diag_CID_index][0], m_Diag_CID_R_ID[m_Diag_CID_index][1], m_Diag_CID_R_ID[m_Diag_CID_index][2],
			m_Diag_CID_R_ID[m_Diag_CID_index][3], m_Diag_CID_R_ID[m_Diag_CID_index][4], m_Diag_CID_R_ID[m_Diag_CID_index][5], m_Diag_ResetNode[m_Diag_CID_index], m_Diag_StopNode[m_Diag_CID_index], m_Diag_CID_index);
		}
		m_bInitialLink = true;

	}

	// 3. CID Step(Connecting, Checking, Occupying, Waiting, Completion, Abnormal)
	switch(m_nCidControlStep)
	{
	// CID-O, CID-R Connection을 위한 Step
	case CID_STEP_CONNECTING:
        //최종 목적지가 현재 노드인 경우 CID 동작을 안하기 위함.

		m_CIDOperationStarted = true;
		nEnforcedSelectOffNodeID = 0;
		ResumedbyOCS_count = 0;
		CID_NotLinkCount = 0;
		CID_SendForStatusCount = 0;
		if(pHWSet->m_pCID->GetCIDPause() == false) // Pause 상태일 때 Interlock 정보 초기화 X
		    m_pExecuteInfo->FlagCIDReport.bCIDInterlock = false;
		m_pExecuteInfo->FlagCIDReport.bCIDStop = false;
		m_CIDPauseTime = 0;
		m_job_change_flag_exception_CommonTag = false;
		m_job_change_without_link_complete = false;
		CID_NearestResetNode = 0;
		CID_NearestStopNode = 0;
		CID_NearestTargetCID = false;
		CID_Occup_Count = 0;
		CID_Occup_Release_Status = 0;
		CID_Status_Check = 0;
		memset(&CID_Save_Node, 0, sizeof(CID_Save_Node));

		//tmpPreNodeID is ResetTag, tmpCurrentNodeID is StopTag 이면 완료 상태.
		if(Info->CIDResetNode_Pre_arr != INDEX_NONE)
		{
			if(Info->tmpPreNodeID == OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDResetNode_Pre_arr].ResetNode
				&& Info->tmpCurrentNodeID != Info->tmpPreNodeID
				&& (Info->tmpCurrentNodeID == Info->CIDStopNode1 || Info->tmpCurrentNodeID == Info->CIDStopNode2))
			{
//				ADD_LOG("C_58/%d/%d", Info->tmpPreNodeID, Info->tmpCurrentNodeID);
				break;
			}
		}

		if(Info->tmpCurrentNodeID == Info->tmpStartNode1_1 || Info->tmpCurrentNodeID == Info->tmpStartNode2_1)
		{
			m_CurrCIDStartnode = Info->tmpCurrentNodeID;
			static int nTmpCurNodeId01093 = 0;
			if(nTmpCurNodeId01093 != Info->tmpCurrentNodeID)
			{
				nTmpCurNodeId01093 = Info->tmpCurrentNodeID;
				ADD_LOG("C_59/%d", m_CurrCIDStartnode);
			}
		}

		IO_INFO_CID();
		m_nCIDTerminateCount = 0;
		// Output, Input 초기화(All off) 여부 확인
		// if (pHWSet->m_pCID->IsOutputAllOff() == true && pHWSet->m_pCID->IsInputAllOff() == true)

		CID_Find_Stop_Reset(2, HwInfo, &CID_NearestStopNode, &CID_NearestResetNode, &CID_NearestTargetCID);
		m_CIDDirection = CID_Direction_Chk(Info, pInfoSet, CID_NearestResetNode, CID_NearestStopNode);

		CID_Save_Start_Stop_Reset(Info); // CID Select ON 할때 위치값 저장

#if(OHT_NAME == OHT_NAME_STD_V81S)
		pHWSet->m_pCID->VHLRegistrationDeniedinit(); //[고속 OHT] VHL 6대 초과 확인 변수 초기화
		if (pHWSet->m_pCID->IsImmediateLinkReqON() == true)
		{
			pHWSet->m_pCID->Immediate_Link_Req_OFF();
			Sleep(20);
		}
#endif

		// CID Slope 처리
#if 0
		// Stop node 기준 CID LayoutType이 Slope 이면, Stop node 기준 방향으로 설정 하여 CID 동작 하도록 함.
		if(Info->LayoutType_Stop1 == CID_LAYOUT_TYPE_SLOPE || Info->LayoutType_Stop2 == CID_LAYOUT_TYPE_SLOPE)
		{
			if(Info->CIDStopNode1_arr != INDEX_NONE && Info->tmpCurrentNodeID == Info->CIDStopNode1)
			{
				m_CIDDirection = CID_DIRECTION_LEFT;
				ADD_LOG("C-56");
			}
			else if(Info->CIDStopNode2_arr != INDEX_NONE && Info->tmpCurrentNodeID == Info->CIDStopNode2)
			{
				m_CIDDirection = CID_DIRECTION_RIGHT;
				ADD_LOG("C-57");
			}
			else
			{
				m_CIDDirection = CID_DIRECTION_NOT_LINK;
				ADD_LOG("C-58");
			}
		}
#endif

		if((pHWSet->m_pCID->IsLinking() == false)&&(pHWSet->m_pCID->IsLinkOK() == false))
		{
			// Select On(LEFT)
			if (m_CIDDirection == CID_DIRECTION_LEFT || m_CIDDirection == CID_DIRECTION_COMMON_LEFT)
			{
				if(pHWSet->m_pCID->Is_Operation_On() == true)
				{
					static int nTmpCurNodeId14 = 0;
					if(nTmpCurNodeId14 != Info->tmpCurrentNodeID)
					{
						nTmpCurNodeId14 = Info->tmpCurrentNodeID;
						ADD_LOG("C_60/%d/%d/%d/%d", Info->tmpCurrentNodeID, Info->tmpNextNodeID, Info->tmpStopNode1, Info->tmpResetNode1);
						ADD_LOG("C_61/%d/%d/%d", m_pExecuteInfo->FlagCIDNotuse.nStopNodeID, m_pExecuteInfo->FlagCIDNotuse.nResetNodeID, m_pExecuteInfo->FlagCIDNotuse.bCIDUse);
					}
					// OCS로부터 CID-R 비정상 상태 정보 취득
					// 해당 CID-R의 Stop Node ID와 Reset Node ID를 통과 예정인 Stop/Reset Node ID와 비교

					{

						// 완료 처리해야 할 Reset Node (2016.12.14)
						m_tmpCurrentResetNode = Info->tmpResetNode1;
						m_tmpCurrentStopNode = Info->tmpStopNode1;
						Info->tmpCurrentResetNodeType = Info->tmpResetNodeType1;

						m_Diag_CID_index = (m_Diag_CID_index+1) & 0x7;

						m_Diag_ResetNode[m_Diag_CID_index] = m_tmpCurrentResetNode;
						m_Diag_StopNode[m_Diag_CID_index] = m_tmpCurrentStopNode;

						int tmp_index = OHTMainForm->GetMap()->FindNodeIndexFromCIDReset(m_tmpCurrentResetNode);
						if(tmp_index != INDEX_NONE)
						{
							memcpy(m_Diag_CID_R_ID[m_Diag_CID_index], OHTMainForm->GetCID_STD()->m_NodeArray[tmp_index].LayoutID, 6);
							ADD_LOG("C_62/%c/%c/%c/%c/%c/%c/%d/%d/%d",
							m_Diag_CID_R_ID[m_Diag_CID_index][0], m_Diag_CID_R_ID[m_Diag_CID_index][1], m_Diag_CID_R_ID[m_Diag_CID_index][2],
							m_Diag_CID_R_ID[m_Diag_CID_index][3], m_Diag_CID_R_ID[m_Diag_CID_index][4], m_Diag_CID_R_ID[m_Diag_CID_index][5], m_Diag_ResetNode[m_Diag_CID_index], m_Diag_StopNode[m_Diag_CID_index], m_Diag_CID_index);
						}

						if((m_CIDDirection == CID_DIRECTION_COMMON_LEFT) && (m_PositionInfo.CurrNodeOffset < 200))
						{
							ADD_LOG("C-59");
						}
						else
						{
							if(CID_Fiber_Monitoring)
							{
								int FromNode = 0, ToNode = 0;
								int CID_Fiber_Distance = 0;
								bool bNBranch = false;
								// tmpStartNode1_1 ~ tmpStartNode1_2
								FromNode =  Info->tmpStartNode1_1;
								ToNode =  Info->tmpStartNode1_2;
								ADD_LOG("TEST-1-1, From: %d, To: %d",FromNode, ToNode);
								nPathIndex = OHTMainForm->GetMap()->GetPathIndex(FromNode, ToNode);
								ADD_LOG("TEST-1-1, index %d",nPathIndex);

								if(nPathIndex !=-1)
								{
									pPathInfo = &(OHTMainForm->GetMap()->m_PathArray[nPathIndex]);
									CID_Fiber_Distance += pPathInfo->Distance;
								}

								// tmpStartNode1_2 ~ tmpStartNode1_3
								FromNode = Info->tmpStartNode1_2;
								ToNode =  Info->tmpStartNode1_3;
								ADD_LOG("TEST-1-2, From: %d To: %d",FromNode, ToNode);
								nPathIndex = OHTMainForm->GetMap()->GetPathIndex(FromNode, ToNode);
								ADD_LOG("TEST-1-2, index %d",nPathIndex);

								if(nPathIndex !=-1)
								{
									pPathInfo = &(OHTMainForm->GetMap()->m_PathArray[nPathIndex]);
									CID_Fiber_Distance += pPathInfo->Distance;
								}

								// tmpStartNode1_3 ~ tmpStartNode1_4
								FromNode = Info->tmpStartNode1_3;
								ToNode =  Info->tmpStartNode1_4;
								ADD_LOG("TEST-1-3, From: %d To: %d",FromNode, ToNode);
								nPathIndex = OHTMainForm->GetMap()->GetPathIndex(FromNode, ToNode);
								ADD_LOG("TEST-1-3, index %d",nPathIndex);
								if(nPathIndex !=-1)
								{
									pPathInfo = &(OHTMainForm->GetMap()->m_PathArray[nPathIndex]);
									CID_Fiber_Distance += pPathInfo->Distance;
								}

								// tmpStartNode1_4 ~ tmpStartNode1_5
								FromNode = Info->tmpStartNode1_4;
								ToNode =  Info->tmpStartNode1_5;
								ADD_LOG("TEST-1-4, From: %d To: %d",FromNode, ToNode);
								nPathIndex = OHTMainForm->GetMap()->GetPathIndex(FromNode, ToNode);
								ADD_LOG("TEST-1-4, index %d",nPathIndex);

								if(nPathIndex !=-1)
								{
									pPathInfo = &(OHTMainForm->GetMap()->m_PathArray[nPathIndex]);
									CID_Fiber_Distance += pPathInfo->Distance;
								}

								//stop~ ResetNode
								FromNode = Info->tmpStopNode1;
								ToNode =  Info->tmpResetNode1;
								ADD_LOG("TEST-1-5, From: %d To: %d",FromNode, ToNode);
								nPathIndex = OHTMainForm->GetMap()->GetPathIndex(FromNode, ToNode);
								ADD_LOG("TEST-1-5, index %d",nPathIndex);

								if(nPathIndex !=-1)
								{
									ADD_LOG("[CID_TEST_LEFT] Stop :%d, Reset: %d", FromNode, ToNode);
									pPathInfo = &(OHTMainForm->GetMap()->m_PathArray[nPathIndex]);
									CID_Fiber_Distance += pPathInfo->Distance;

									BYTE UBGRegion = pPathInfo->UBGRegion;
									if(UBGRegion == 0x04)
									{
										bNBranch = true;

									}
								}
								CID_Fiber_Distance -= Info->CommStartNode1_Offset;

								if(bNBranch)
								{

										ADD_LOG("[CID_TEST] It is N Branch %d -> %d",
										CID_Fiber_Distance,
										CID_Fiber_Distance/2);
										CID_Fiber_Distance/=2;
										pHWSet->m_pCID->Set_CID_NBranch_Length(CID_Fiber_Distance);
								}

								ADD_LOG("[CID_TEST_LEFT] Distance : %d", CID_Fiber_Distance);
								ADD_LOG("[CID_TEST_LEFT] Node 1_1: %d, Node 1_2: %d,Node 1_3: %d,Node 1_4: %d,Node 1_5: %d",
								 Info->tmpStartNode1_1,Info->tmpStartNode1_2,Info->tmpStartNode1_3,Info->tmpStartNode1_4, Info->tmpStartNode1_5);


								pHWSet->m_pCID->Set_CID_Monitor_FiberLength_Cmd(CID_Fiber_Distance);
								ADD_LOG("Set_CID_Monitor_FiberLength_Cmd");
							}

							pHWSet->m_pCID->Left_Link();
							m_ntempNodeOffset = m_PositionInfo.CurrNodeOffset;

							if(Info->tmpCurrentNodeID == Info->tmpStartNode1_1)
								m_CID_Offet_Target = Info->CommStartNode1_Offset;
							m_nCidControlStep = CID_STEP_CHECKING_PATH;

							//작업 변경 시 사용.
							CID_ResetNode = CID_NearestResetNode;

							ADD_LOG("C_63/%d/%d", Info->tmpCurrentNodeID, m_CID_Offet_Target);
							m_mccparam.dwCIDLinkOnTime = timeGetTime();
							m_mccparam.nCIDLinkStartPosition = pInfoSet->HwInfo.Axis1.dCurrPos;
							m_mccparam.nCIDLinkStartNode = Info->tmpCurrentNodeID;

							ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,CID LINK,Start,FOUP,%06d,%06d,%06d,%d,%6.1lf,CID Link Direction,%d",
										m_defualtparam->VHLName,
										m_mccparam.uSourceNode,
										m_mccparam.uTargetNode,
										m_pExecuteInfo->ExecutePositionInfo.CurrNode,
										m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
										dSpeedOfNow,
										m_CIDDirection);
						}
					}
				}else
				{
					pHWSet->m_pCID->CID_Operation_On();
				}
			}
			// Select On(RIGHT)
			else if ((m_CIDDirection == CID_DIRECTION_RIGHT) || (m_CIDDirection == CID_DIRECTION_COMMON_RIGHT))
			{
				if(pHWSet->m_pCID->Is_Operation_On() == true)
				{
					// OCS로부터 CID-R 비정상 상태 정보 취득
					// 해당 CID-R의 Stop Node ID와 Reset Node ID를 통과 예정인 Stop/Reset Node ID와 비교
					static int nTmpCurNodeId15 = 0;
					if(nTmpCurNodeId15 != Info->tmpCurrentNodeID)
					{
						nTmpCurNodeId15 = Info->tmpCurrentNodeID;
						ADD_LOG("C_64/%d/%d/%d/%d", Info->tmpCurrentNodeID, Info->tmpNextNodeID, Info->tmpStopNode2, Info->tmpResetNode2);
						ADD_LOG("C_65/%d/%d/%d", m_pExecuteInfo->FlagCIDNotuse.nStopNodeID, m_pExecuteInfo->FlagCIDNotuse.nResetNodeID, m_pExecuteInfo->FlagCIDNotuse.bCIDUse);
					}

					{

						// 완료 처리해야 할 Reset Node (2016.12.14)
						m_tmpCurrentResetNode = Info->tmpResetNode2;
						m_tmpCurrentStopNode = Info->tmpStopNode2;
						Info->tmpCurrentResetNodeType = Info->tmpResetNodeType2;

						m_Diag_CID_index = (m_Diag_CID_index+1) & 0x7;

						m_Diag_ResetNode[m_Diag_CID_index] = m_tmpCurrentResetNode;
						m_Diag_StopNode[m_Diag_CID_index] = m_tmpCurrentStopNode;
						int tmp_index = OHTMainForm->GetMap()->FindNodeIndexFromCIDReset(m_tmpCurrentResetNode);
						if(tmp_index != INDEX_NONE)
						{
							memcpy(m_Diag_CID_R_ID[m_Diag_CID_index], OHTMainForm->GetCID_STD()->m_NodeArray[tmp_index].LayoutID, 6);
							ADD_LOG("C_66/%c/%c/%c/%c/%c/%c/%d/%d/%d",
							m_Diag_CID_R_ID[m_Diag_CID_index][0], m_Diag_CID_R_ID[m_Diag_CID_index][1], m_Diag_CID_R_ID[m_Diag_CID_index][2],
							m_Diag_CID_R_ID[m_Diag_CID_index][3], m_Diag_CID_R_ID[m_Diag_CID_index][4], m_Diag_CID_R_ID[m_Diag_CID_index][5], m_Diag_ResetNode[m_Diag_CID_index], m_Diag_StopNode[m_Diag_CID_index], m_Diag_CID_index);
						}

						if((m_CIDDirection == CID_DIRECTION_COMMON_RIGHT) && (m_PositionInfo.CurrNodeOffset < 200))
						{
							ADD_LOG("C-60");
						}
						else
						{
							if(CID_Fiber_Monitoring)
							{
								int FromNode = 0, ToNode = 0;
								int CID_Fiber_Distance = 0;
								bool bNBranch =false;

								// tmpStartNode2_1 ~ tmpStartNode2_2
								FromNode =  Info->tmpStartNode2_1;
								ToNode =  Info->tmpStartNode2_2;
								ADD_LOG("TEST-2-1, From: %d To: %d",FromNode, ToNode);
								nPathIndex = OHTMainForm->GetMap()->GetPathIndex(FromNode, ToNode);
								ADD_LOG("TEST-2-1, index %d",nPathIndex);

								if(nPathIndex !=-1)
								{
									pPathInfo = &(OHTMainForm->GetMap()->m_PathArray[nPathIndex]);
									CID_Fiber_Distance += pPathInfo->Distance;
								}

								// tmpStartNode2_2 ~ tmpStartNode2_3
								FromNode = Info->tmpStartNode2_2;
								ToNode =  Info->tmpStartNode2_3;
								ADD_LOG("TEST-2-2, From: %d To: %d",FromNode, ToNode);
								nPathIndex = OHTMainForm->GetMap()->GetPathIndex(FromNode, ToNode);
								ADD_LOG("TEST-2-2, index %d",nPathIndex);
								if(nPathIndex !=-1)
								{
									pPathInfo = &(OHTMainForm->GetMap()->m_PathArray[nPathIndex]);
									CID_Fiber_Distance += pPathInfo->Distance;
								}

								// tmpStartNode2_3 ~ tmpStartNode2_4
								FromNode = Info->tmpStartNode2_3;
								ToNode =  Info->tmpStartNode2_4;
								ADD_LOG("TEST-2-3, From: %d To: %d",FromNode, ToNode);
								nPathIndex = OHTMainForm->GetMap()->GetPathIndex(FromNode, ToNode);
								ADD_LOG("TEST-2-3, index %d",nPathIndex);
								if(nPathIndex !=-1)
								{
									pPathInfo = &(OHTMainForm->GetMap()->m_PathArray[nPathIndex]);
									CID_Fiber_Distance += pPathInfo->Distance;
								}

								// tmpStartNode2_4 ~ tmpStartNode2_5
								FromNode = Info->tmpStartNode2_4;
								ToNode =  Info->tmpStartNode2_5;
								ADD_LOG("TEST-2-4, From: %d To: %d",FromNode, ToNode);
								nPathIndex = OHTMainForm->GetMap()->GetPathIndex(FromNode, ToNode);
								ADD_LOG("TEST-2-4, index %d",nPathIndex);
								if(nPathIndex !=-1)
								{
									pPathInfo = &(OHTMainForm->GetMap()->m_PathArray[nPathIndex]);
									CID_Fiber_Distance += pPathInfo->Distance;
								}


								//stop~ ResetNode
								FromNode = Info->tmpStopNode2;
								ToNode =  Info->tmpResetNode2;
								ADD_LOG("TEST-2-5, From: %d To: %d",FromNode, ToNode);
								nPathIndex = OHTMainForm->GetMap()->GetPathIndex(FromNode, ToNode);
								ADD_LOG("TEST-2-5, index %d",nPathIndex);

								if(nPathIndex !=-1)
								{
									ADD_LOG("[HJH, CID_TEST_RIGHT] Stop :%d, Reset: %d", FromNode, ToNode);
									pPathInfo = &(OHTMainForm->GetMap()->m_PathArray[nPathIndex]);
									CID_Fiber_Distance += pPathInfo->Distance;

									BYTE UBGRegion = pPathInfo->UBGRegion;
									if(UBGRegion == 0x04)
									{
										bNBranch = true;

									}
								}
								CID_Fiber_Distance -= Info->CommStartNode2_Offset;

								if(bNBranch)
								{
									ADD_LOG("[CID_TEST] It is N Branch %d -> %d",
										CID_Fiber_Distance,
										CID_Fiber_Distance/2);
										CID_Fiber_Distance/=2;
										pHWSet->m_pCID->Set_CID_NBranch_Length(CID_Fiber_Distance);
								}
								ADD_LOG("[CID_RIGHT] Distance : %d", CID_Fiber_Distance);
								ADD_LOG("[CID_RIGHT] Node 2_1: %d, Node 2_2: %d,Node 2_3: %d,Node 2_4: %d,Node 2_5: %d",
								 Info->tmpStartNode2_1, Info->tmpStartNode2_2, Info->tmpStartNode2_3, Info->tmpStartNode2_4, Info->tmpStartNode2_5);


								pHWSet->m_pCID->Set_CID_Monitor_FiberLength_Cmd(CID_Fiber_Distance);
								ADD_LOG("Set_CID_Monitor_FiberLength_Cmd");
							}
							pHWSet->m_pCID->Right_Link();
							m_ntempNodeOffset = m_PositionInfo.CurrNodeOffset;

							if(Info->tmpCurrentNodeID == Info->tmpStartNode2_1)
								m_CID_Offet_Target = Info->CommStartNode2_Offset;
							m_nCidControlStep = CID_STEP_CHECKING_PATH;

							//작업 변경 시 사용.
							CID_ResetNode = CID_NearestResetNode;

							ADD_LOG("C_67/%d/%d", Info->tmpCurrentNodeID, m_CID_Offet_Target);
							m_mccparam.dwCIDLinkOnTime = timeGetTime();
							m_mccparam.nCIDLinkStartNode = Info->tmpCurrentNodeID;

							ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,CID LINK,Start,FOUP,%06d,%06d,%06d,%d,%6.1lf,CID Link Direction,%d",
										m_defualtparam->VHLName,
										m_mccparam.uSourceNode,
										m_mccparam.uTargetNode,
										m_pExecuteInfo->ExecutePositionInfo.CurrNode,
										m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
										dSpeedOfNow,
										m_CIDDirection);
						}
					}
				}else
				{
					pHWSet->m_pCID->CID_Operation_On();
				}
			}
			else if (m_bCIDNotUse == true)
			{
			   	m_nCidControlStep = CID_STEP_ABNORMAL;
				ADD_LOG("C-61");
			}
			// No info.
			else
			{
				m_tmpCurrentResetNode = 0; 	// 추가(2016. 12. 20)
				m_tmpCurrentStopNode = 0;

				static int nTmpCurNodeId5 = 0;
				if(nTmpCurNodeId5 != Info->tmpCurrentNodeID)
				{
					nTmpCurNodeId5 = Info->tmpCurrentNodeID;
					IO_INFO_CID();
					ADD_LOG("C_68/%d", Info->tmpCurrentNodeID);
				}
			}
		}
		else
		{
			IO_INFO_CID_ALL();
			static int nTmpCurNodeId6 = 0;
			if(nTmpCurNodeId6 != Info->tmpCurrentNodeID)
			{
				nTmpCurNodeId6 = Info->tmpCurrentNodeID;
				ADD_LOG("C_69/%d", Info->tmpCurrentNodeID);
			}

			// CID_DIRECTION_COMMON_LEFT, CID_DIRECTION_COMMON_RIGHT
			if((m_CIDDirection == CID_DIRECTION_LEFT) || (m_CIDDirection == CID_DIRECTION_RIGHT))
			{
//				pHWSet->m_pCID->CID_Out_Left_Select(OFF);
//				pHWSet->m_pCID->CID_Out_Right_Select(OFF);
				IO_INFO_CID_ALL();
			}
		}
		break;

	// CID 연결 시도 후 정보를 확인하는 step
	case CID_STEP_CHECKING_PATH:
		IO_INFO_CID();

		// 0. 한번 점유 후 점유해제 상태 처리 추가
		if(CID_Occup_Release_Status == 1)
		{
			CID_Find_Stop_Reset(3, HwInfo, &CID_NearestStopNode, &CID_NearestResetNode, &CID_NearestTargetCID);
			CID_DIRECTION temp_CIDDirection = CID_Direction_Chk(Info, pInfoSet, CID_NearestResetNode, CID_NearestStopNode);
			if(CID_NearestResetNode != 0
			   && temp_CIDDirection != CID_DIRECTION_NOT_LINK
			   && (temp_CIDDirection&0x01) != (m_CIDDirection&0x01)) // 0,2: Left, 1,3: Right
			{
				// 리셋노드 0 인 상태에서 방향 변경시
				// 통과완료 처리 및 CID_STEP_CONNECTING으로 변경
				ADD_LOG("C-62");
				m_nCidControlStep = CID_STEP_CONNECTING;
				pHWSet->m_pCID->CID_Occup_compt(20);
				Sleep(20);
				pHWSet->m_pCID->TerminateCID(20);
				break;
			}
			else if(CID_NearestResetNode != 0
			   && temp_CIDDirection != CID_DIRECTION_NOT_LINK
			   && (temp_CIDDirection&0x01) == (m_CIDDirection&0x01))
			{
				// 리셋노드 0 인 상태에서 동일 방향 주행시
				ADD_LOG("C-63");
			}
			else
			{
				break;
			}
		}

		// 1. Link 완료 확인 후 Interlock 수신 여부 확인
		if (pHWSet->m_pCID->IsLinking() == true && pHWSet->m_pCID->IsLinkOK() == true)
		{
			m_bInitialLink = true;
#if(OHT_NAME == OHT_NAME_STD_V81S)
			// [고속 OHT] Link 완료 후 즉시 연결 요청 output OFF, 2019.6.4
			if (pHWSet->m_pCID->IsImmediateLinkReqON() == true)
			{
				pHWSet->m_pCID->Immediate_Link_Req_OFF();
			}
#endif
			//ADD_LOG("C_70/%d/%d",Info->uLimitNode, m_tmpCurrentResetNode);
			// 1-1. Interlock 미수신한 경우
			if (m_CID_Pause == false && pHWSet->m_pCID->IsInterlock_ON() == false)
			{
				unsigned int CurrentNodeType = 0;
				unsigned int NextNodeType = 0;
		 		if((Info->tmpResetNodeType1 == Slope_Rear_Reset_tag)||(Info->tmpResetNodeType2 == Slope_Rear_Reset_tag))
				{
					//m_nCidControlStep = CID_STEP_OCCUPYING_PATH;
					m_nCidControlStep = CID_STEP_COMPLETION;//slope rear 인 경우 선행 VHL이동을 막기 위한 점유를 할 필요가 없으므로, CID_STEP_COMPLETION 으로 변경
					ADD_LOG("C_71/%d", Info->tmpCurrentNodeID);
		 		}
#if 0
				// 현재 노드가 Stop이고, 다음 노드가 Reset이 아닌 경우 CID_STEP_COMPLETION 으로 변경
				else if((Info->tmpCurrentNodeID == Info->CIDStopNode1 && Info->tmpNextNodeID != Info->CIDResetNode1) ||
					(Info->tmpCurrentNodeID == Info->CIDStopNode2 && Info->tmpNextNodeID != Info->CIDResetNode2))
				{
					m_nCidControlStep = CID_STEP_COMPLETION;//CID_STEP_COMPLETION 과 CID_STEP_CHECKING_PATH를 반복 동작 함..
					ADD_LOG("C_72/%d/%d", Info->tmpCurrentNodeID, Info->tmpNextNodeID);

				}
#endif
				// 목적지에 따라 STEP_OCCUPYING으로 이동 여부 결정
				// 목적지가 Reset Tag이거나 상위이면 OCCUPYING으로 이동, Stop Tag이거나 하위이면 CHECKING에 머무름  AOHC-353
				else if ((checkCommandTarget4CID(Info, CID_NearestTargetCID) == false) && (Info->nDetectStatus != DETECT_AND_STOP))
				{
					m_nCidControlStep = CID_STEP_OCCUPYING_PATH;
					ADD_LOG("C_73/%d/%d", Info->tmpCurrentNodeID,Info->tmpCurrentCMDID);
//						m_nCidControlStep = m_nCidControlStep;

					m_mccparam.nCIDLinkOnTime = OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwCIDLinkOnTime);
					m_mccparam.nCIDMapOffset = m_CID_Offet_Target;
					m_mccparam.nCIDLinkOffset = pInfoSet->HwInfo.Axis1.dCurrPos - m_mccparam.nCIDLinkStartPosition;
					m_mccparam.nCIDLinkNode = m_pExecuteInfo->ExecutePositionInfo.CurrNode;
					m_mccparam.nCIDLinkNodeOffset = m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset;
				}
				else if(Info->uLimitNode == m_tmpCurrentResetNode)
				{
					//stop 과 reset 사이 스테이션이 목적지일 경우 점유
					//if(Info->Safety_Level == 0x00)//Safety_Level 0 만 점유 할 경우 주석 해제
					if(Info->bIgnolOverRun==false)
					{
						m_nCidControlStep = CID_STEP_OCCUPYING_PATH;
						ADD_LOG("C_74/%d/%d/%d", Info->tmpCurrentNodeID,Info->tmpCurrentCMDID, Info->bIgnolOverRun);
					}
					else//stop 과 reset 사이 스테이션이 목적지이나 bIgnolOverRun 1인 경우 미점유
					{
						//CID_STEP_COMPLETION or waitting
						//m_nCidControlStep = CID_STEP_COMPLETION; //CID_STEP_WAITING_FOR_PATH;
						if(OverrunCheckCurrentNodeID != Info->tmpCurrentNodeID)
						{
							ADD_LOG("C_75/%d/%d/%d", Info->tmpCurrentNodeID,Info->tmpCurrentCMDID, Info->bIgnolOverRun);
							OverrunCheckCurrentNodeID  = Info->tmpCurrentNodeID;
						}

					}
				}
				else
				{
					static int nTmpCurNodeId4 = 0;
					if(nTmpCurNodeId4 != Info->tmpCurrentNodeID)
					{
						nTmpCurNodeId4 = Info->tmpCurrentNodeID;
						ADD_LOG("C_76/%d/%d", Info->tmpCurrentNodeID,Info->tmpCurrentCMDID);
					}
				}
			}
			// 1-2. Interlock 수신한 경우  AOHC-353
			else if (m_CID_Pause == false && pHWSet->m_pCID->IsInterlock_ON() == true)
			{
				m_CIDPauseTime = timeGetTime();
				if (checkCommandTarget4CID(Info, CID_NearestTargetCID) == false && Info->nDetectStatus != DETECT_AND_STOP)
				{
					pHWSet->m_pCID->CID_Occup_Pause(&m_CID_Pause);
					//CID_R_Status_Chk 함수 수행 내용이 들어감.
					pHWSet->m_pCID->Set_CID_Status_Cmd();
					m_CIDStatusFlag = true;
					m_CIDStatusPauseFlag = true;
					m_pExecuteInfo->FlagCIDReport.bCIDInterlock = true;
					m_nCidControlStep = CID_STEP_WAITING_FOR_PATH;
					//ADD_LOG("C_77/%d/%d", Info->tmpCurrentNodeID, Info->tmpCurrentCMDID);
					ERR_LOG("[CID] Connection Completed..Paused due to Interlock1(Step:CID_STEP_CHECKING_PATH, Current Node : %d, CMDID : %d)", Info->tmpCurrentNodeID, Info->tmpCurrentCMDID);
				}
				else if(Info->uLimitNode == m_tmpCurrentResetNode)
				{
					//stop 과 reset 사이 스테이션이 목적지일 경우 정지
					//if(Info->Safety_Level == 0x00)//Safety_Level 0 만 점유 할 경우 주석 해제
					if(Info->bIgnolOverRun==false)
					{
						pHWSet->m_pCID->CID_Occup_Pause(&m_CID_Pause);
						//CID_R_Status_Chk 함수 수행 내용이 들어감.
						pHWSet->m_pCID->Set_CID_Status_Cmd();
						m_CIDStatusFlag = true;
						m_CIDStatusPauseFlag = true;
						m_pExecuteInfo->FlagCIDReport.bCIDInterlock = true;
						m_nCidControlStep = CID_STEP_WAITING_FOR_PATH;
						//ADD_LOG("C_78/%d/%d", Info->tmpCurrentNodeID, Info->tmpCurrentCMDID);
						ERR_LOG("[CID] Connection Completed..Paused due to Interlock2(Step:CID_STEP_CHECKING_PATH, Current Node : %d, CMDID : %d)", Info->tmpCurrentNodeID, Info->tmpCurrentCMDID);
					}
					else//stop 과 reset 사이 스테이션이 목적지이나 Safety_Level이 1인 경우 미정지
					{
						static int nTmpCurNodeId0819_1 = 0;
						if(nTmpCurNodeId0819_1 != Info->tmpCurrentNodeID)
						{
							nTmpCurNodeId0819_1 = Info->tmpCurrentNodeID;

							ADD_LOG("C_79/%d/%d", Info->tmpCurrentNodeID, Info->tmpCurrentCMDID);
						}
					}
				}
				else
				{
					static int nTmpCurNodeId0103 = 0;
					if(nTmpCurNodeId0103 != Info->tmpCurrentNodeID)
					{
						nTmpCurNodeId0103 = Info->tmpCurrentNodeID;
						ADD_LOG("C_80/%d/%d", Info->tmpCurrentNodeID, Info->tmpCurrentCMDID);
					}
				}
			}
			// 1-1. Interlock 미수신한 경우 CID pause flag를 변경.
			else if (m_CID_Pause == true && pHWSet->m_pCID->IsInterlock_ON() == false)
			{
				pHWSet->m_pCID->CID_Occup_Resume(&m_CID_Pause);
				m_CIDStatusFlag = false;
				m_CIDStatusPauseFlag = false;
				m_pExecuteInfo->FlagCIDReport.bCIDInterlock = false;
			}
			else
			{
				static int nTmpCurNodeId01151 = 0;
				if(nTmpCurNodeId01151 != Info->tmpCurrentNodeID)
				{
					nTmpCurNodeId01151 = Info->tmpCurrentNodeID;
					ADD_LOG("C_81/%d/%d", Info->tmpCurrentNodeID, Info->tmpCurrentCMDID);
				}
			}
		}
 #if(OHT_NAME == OHT_NAME_STD_V81S)
// [고속 OHT] 등록 대기 기능, 2019.6.4
		else if (pHWSet->m_pCID->IsLinking() == true && pHWSet->m_pCID->IsLinkOK() == false &&
			pHWSet->m_pCID->IsVHLRegistrationFull() == true)
		{
			// 등록 대기 (CID-O에서 OHT와 무관하게 연결 시도 -> 우선순위대로 연결 성립)
			// 기능 검증 후 Log 삭제할 것
			static int nTmpCurNodeId_test= 0;
			if (nTmpCurNodeId_test != Info->tmpCurrentNodeID)
			{
				nTmpCurNodeId_test = Info->tmpCurrentNodeID;
				ADD_LOG("D_121/%d", Info->tmpCurrentNodeID);
			}
			// 통과 허가를 받은 경우  AOHC-353
			if (checkCommandTarget4CID(Info, CID_NearestTargetCID) == false && Info->nDetectStatus != DETECT_AND_STOP)
			{
				if (pHWSet->m_pCID->IsImmediateLinkReqON() == false)
				{
					pHWSet->m_pCID->Immediate_Link_Req_ON();
				}

				//if (m_CID_Pause == false && pHWSet->m_pCID->IsInterlock_ON() == true)
				if (m_CID_Pause == false)
				{
					pHWSet->m_pCID->CID_Occup_Pause(&m_CID_Pause);
					ADD_LOG("D-59");
					m_nCidControlStep = CID_STEP_WAITING_FOR_PATH;
				}
			}
			//[고속 OHT] KYH 점유 없이 StopNode 이후 Station 이동 부분 처리 (Safety Level)
			else if(Info->uLimitNode == m_tmpCurrentResetNode)
			{
				//stop 과 reset 사이 스테이션이 목적지일 경우 정지
				//if(Info->Safety_Level == 0x00)//Safety_Level 0 만 점유 할 경우 주석 해제
				if(Info->bIgnolOverRun==false)
				{
					if (pHWSet->m_pCID->IsImmediateLinkReqON() == false) //[고속 OHT] KYH O8을 추가가 맞는지 확인 필요
					{
						pHWSet->m_pCID->Immediate_Link_Req_ON();
					}

					pHWSet->m_pCID->CID_Occup_Pause(&m_CID_Pause);
					//CID_R_Status_Chk 함수 수행 내용이 들어감.
					pHWSet->m_pCID->Set_CID_Status_Cmd();
					m_CIDStatusFlag = true;
					m_CIDStatusPauseFlag = true;
					m_pExecuteInfo->FlagCIDReport.bCIDInterlock = true;
					m_nCidControlStep = CID_STEP_WAITING_FOR_PATH;
					//ADD_LOG("C_82/%d/%d", Info->tmpCurrentNodeID, Info->tmpCurrentCMDID);
					ERR_LOG("[CID_KYH] Connection Completed..Paused due to Interlock4(Step:CID_STEP_CHECKING_PATH, Current Node : %d, CMDID : %d)", Info->tmpCurrentNodeID, Info->tmpCurrentCMDID);
				}
				else//stop 과 reset 사이 스테이션이 목적지이나 Safety_Level이 1인 경우 미정지
				{
					static int nTmpCurNodeId0819_1 = 0;
					if(nTmpCurNodeId0819_1 != Info->tmpCurrentNodeID)
					{
						nTmpCurNodeId0819_1 = Info->tmpCurrentNodeID;

						ADD_LOG("D_122/%d/%d", Info->tmpCurrentNodeID, Info->tmpCurrentCMDID);
					}
				}
			}
			else if (m_CID_Pause == true && pHWSet->m_pCID->IsInterlock_ON() == false)
			{
				pHWSet->m_pCID->CID_Occup_Resume(&m_CID_Pause);
				m_CIDStatusFlag = false;
				m_CIDStatusPauseFlag = false;
				m_pExecuteInfo->FlagCIDReport.bCIDInterlock = false;
			   ADD_LOG("D-60");
			}
			else
			{
				//ADD_LOG("D-61");
			}
		}

		// [고속 OHT] 등록 대기 중 I5가 순간적으로 Off 되는 경우 (I1=0, I5=0) -> (I1=0, I5=1) -> (I1=0, I5=0), 2019.6.4
		else if (pHWSet->m_pCID->IsLinking() == true && pHWSet->m_pCID->IsLinkOK() == false &&
			pHWSet->m_pCID->IsVHLRegistrationFull() == false && pHWSet->m_pCID->IsVHLRegistrationDenied() == true)
		{
			// 개발 검증용 log(추후 삭제 요망)
			static int nTmpCurNodeId_test1 = 0;
			if (nTmpCurNodeId_test1 != Info->tmpCurrentNodeID)
			{
				nTmpCurNodeId_test1 = Info->tmpCurrentNodeID;
				ADD_LOG("D_123/%d", Info->tmpCurrentNodeID);
			}
						 // AOHC-353
			if (checkCommandTarget4CID(Info, CID_NearestTargetCID) == false && Info->nDetectStatus != DETECT_AND_STOP)
			{
				if (m_CID_Pause == false)
				{
					if (pHWSet->m_pCID->IsImmediateLinkReqON() == false) //[고속 OHT] KYH O8을 추가가 맞는지 확인 필요
					{
						pHWSet->m_pCID->Immediate_Link_Req_ON();
					}

					pHWSet->m_pCID->CID_Occup_Pause(&m_CID_Pause);
					ADD_LOG("D-62");
					m_nCidControlStep = CID_STEP_WAITING_FOR_PATH;
				}
			}
		}
#endif

		// CID-O, CID-R 간 연결이 아직 미성립
		else if (pHWSet->m_pCID->IsLinking() == true && pHWSet->m_pCID->IsLinkOK() == false
#if(OHT_NAME == OHT_NAME_STD_V81S)
		 && pHWSet->m_pCID->IsVHLRegistrationFull() == false && pHWSet->m_pCID->IsVHLRegistrationDenied() == false
#endif
		 )
		{
		   //	m_bInitialLink = false;
			static int nTmpCurNodeId = 0;
			if (nTmpCurNodeId != Info->tmpCurrentNodeID)
			{
				nTmpCurNodeId = Info->tmpCurrentNodeID;
				ADD_LOG("C_83/%d", Info->tmpCurrentNodeID);
//				ADD_LOG("C_84/%d/%d", m_PositionInfo.CurrNodeOffset, m_CID_Offet_Target);

			}
			int tmp_dist = CID_Comm_Time2Dist(Info);

			if (((Info->tmpCurrentNodeID == Info->tmpStartNode1_1)||(Info->tmpCurrentNodeID == Info->tmpStartNode2_1))
			&& ((m_CID_Offet_Target + tmp_dist + 100) < (m_PositionInfo.CurrNodeOffset - m_ntempNodeOffset)) //CID 시작 offset 거리 + 맵 속도 기반 200ms 기준 거리 + Tag margin 200(common normal 동일값 적용)
			&& m_bInitialLink == false)
			{
				if(m_MoniCFNode != Info->tmpCurrentNodeID)
				{
					m_DiagManager->IncreasePreviosDiagCount(PREVIOS_DIAG_CF); //사전 로그
					if(Info->tmpCurrentNodeID == Info->tmpStartNode1_1)
					{
						ADD_MD_LOG("CF Dis Left Fail  Cur N:%d, Start N : %d",Info->tmpCurrentNodeID ,Info->tmpStartNode1_1 );
					}
				   else if(Info->tmpCurrentNodeID == Info->tmpStartNode2_1)
				   {
						ADD_MD_LOG("CF Dis Right Fail Cur N:%d, Start N : %d",Info->tmpCurrentNodeID ,Info->tmpStartNode2_1 );
				   }

				   m_MoniCFNode =  Info->tmpCurrentNodeID ;

				}

			}

			// 일정 거리 내 Link가 되지 않은 경우 감속 정지 후 OCS 보고(CID 무시 신호 조건 추가 필요)
			// Link 거리 기준 Start1에서 맵 속도 기준으로 100ms 이동 해도 통신이 안된 경우.

			//ADD_LOG("C_85/%d/%d/%d", m_PositionInfo.CurrNodeOffset, m_CID_Offet_Target, tmp_dist);
			if (((Info->tmpCurrentNodeID == Info->tmpStartNode1_1)||(Info->tmpCurrentNodeID == Info->tmpStartNode2_1))
				&& ((m_CID_Offet_Target + tmp_dist + 200) < (m_PositionInfo.CurrNodeOffset - m_ntempNodeOffset)) //CID 시작 offset 거리 + 맵 속도 기반 200ms 기준 거리 + Tag margin 200(common normal 동일값 적용)
				&& m_bInitialLink == false)
//				&& (m_CID_Offet_Target + 2000 < (m_PositionInfo.CurrNodeOffset - m_ntempNodeOffset)) && m_bInitialLink == false)
				//2000->1000 길이 검토
				//startx_1이 stop노드인 경우 거리 변경 필수
			{
				m_bLinkFail = true;
				pHWSet->m_pCID->CID_Occup_Pause(&m_CID_Pause);
				//CID_R_Status_Chk 함수 수행 내용이 들어감.
				pHWSet->m_pCID->Set_CID_Status_Cmd();
				m_CIDStatusFlag = true;
				m_CIDStatusPauseFlag = true;
				m_pExecuteInfo->FlagCIDReport.bCIDStop= true;
				//m_CIDStatusFlag = true;

				m_nCidControlStep = CID_STEP_WAITING_FOR_PATH;

				ADD_LOG("C_86/%d", Info->tmpCurrentNodeID);
				ADD_LOG("C_87/%d/%d/%d/%d", m_PositionInfo.CurrNodeOffset, m_CID_Offet_Target, tmp_dist, m_CID_Offet_Target+tmp_dist+100);
				ADD_LOG("D_124/%d/%d", Info->tmpStartNode1_1, Info->tmpStartNode2_1);
				ERR_LOG("[CID_ERR] CID_OFFSET/NID/%d/NextNID/%d/Encoder Reading/%d/Map Offset/%d", Info->tmpCurrentNodeID, Info->tmpNextNodeID, m_PositionInfo.CurrNodeOffset, m_CID_Offet_Target);

			}
			else if((m_CIDDirection == CID_DIRECTION_LEFT) && (Info->tmpCurrentNodeID != Info->tmpStartNode1_1) && m_bInitialLink == false ||
					(m_CIDDirection == CID_DIRECTION_RIGHT) && (Info->tmpCurrentNodeID != Info->tmpStartNode2_1) && m_bInitialLink == false)
			{
				//CID link 시작이 start node 1이 아닌 경우 시간으로 판단 100ms


				if(m_MoniCFNode2 != Info->tmpCurrentNodeID)
				{
					m_DiagManager->IncreasePreviosDiagCount(PREVIOS_DIAG_CF); //사전 로그
					if(m_CIDDirection == CID_DIRECTION_LEFT)
					{
                    	ADD_MD_LOG("CF LEFT FAIL Cur N:%d, Start N : %d",Info->tmpCurrentNodeID ,Info->tmpStartNode1_1 );
					}
				   else if(m_CIDDirection == CID_DIRECTION_RIGHT)
				   {
						ADD_MD_LOG("CF RIGHT FAIL Cur N:%d, Start N : %d",Info->tmpCurrentNodeID ,Info->tmpStartNode2_1 );
				   }

				   m_MoniCFNode2 = Info->tmpCurrentNodeID;

				}

				CID_NotLinkCount++;
				if(CID_NotLinkCount>13) //16ms*15 = 240ms, set 0 in CID_STEP_CONNECTING step, 추후 8로 변경
				{
					m_bLinkFail = true;
					pHWSet->m_pCID->CID_Occup_Pause(&m_CID_Pause);
					m_pExecuteInfo->FlagCIDReport.bCIDStop = true;

					m_nCidControlStep = CID_STEP_WAITING_FOR_PATH;

					ADD_LOG("C_88/%d", Info->tmpCurrentNodeID);
					ADD_LOG("D_125/%d/%d", Info->tmpStartNode1_1, Info->tmpStartNode2_1);

				}
			}
			else
			{
				//NOP
			}

		}

		// Select Off 상태인 경우 : CONNECTING step으로 이동
		else
		{
			ADD_LOG("C_89/%d", Info->tmpCurrentNodeID);
			if(pHWSet->m_pCID->IsLinking_Right() == false && pHWSet->m_pCID->IsLinking_Left() == false)
			{
				if(m_tmpCurrentResetNode == Info->tmpCurrentNodeID)
				{
					m_nCidControlStep = CID_STEP_CONNECTING;
				}
			}
		}

		// 2. 완료 처리 (Checking Step에서 Reset Tag를 만난 경우 완료 처리 필요)
		if ((m_CIDComptTryFlag == false && pHWSet->m_pCID->IsLinkOK() == true) &&
			(m_CurrCIDStartnode != Info->tmpCurrentNodeID)&&	//Reset Tag 가 공용인 경우 start 1 node 배제 하기 위함..
			((NormalCid_Return(Info) == true) 				    // normal, slope
			  || (CommonCid_Return(Info, pInfoSet) == true))) 	// common
		{
			IO_INFO_CID();
			m_nCidControlStep = CID_STEP_COMPLETION;
			ADD_LOG("C_90/%d", Info->tmpCurrentNodeID);
		}
/*
		// L/G type CID에 의해 이전 Step(CID_STEP_CONNECTING)에서 비정상적으로 넘어온 경우에 대한 처리
		// Path, current command, current position,,,
		else if ()
		{
			m_nCidControlStep = CID_STEP_CONNECTING;

		}
*/
		break;

	case CID_STEP_WAITING_FOR_PATH:
		IO_INFO_CID();
		// 앞의 CID_STEP_CHECKING_PATH 스텝에서 IsLinkOK() 를 확인하고 왔으므로
		// 불필요한 조건인지 검토가 필요
		// ([질문] 인터락 들어와서 정지중 링크가 끊어지는 경우가 있을런지)
		// ([질문] 대기중 링크가 끊어져버리면 어떻게 대응해야 하는 것인지)
		if (m_bLinkFail == false && m_CID_Pause == true && pHWSet->m_pCID->IsLinkOK() == true && pHWSet->m_pCID->IsInterlock_ON() == true)
		{
			// 이 경우 여기서 계속 기다린다 (state변경 불필요)

			static int nTmpCurNodeId3 = 0;
			if(nTmpCurNodeId3 != Info->tmpCurrentNodeID)
			{
				nTmpCurNodeId3 = Info->tmpCurrentNodeID;
				ADD_LOG("C_91/%d", Info->tmpCurrentNodeID);
			}
#if(OHT_NAME == OHT_NAME_STD_V81S)
			// [고속 OHT] 통과허가 반납에 대한 예외처리 필요, 2019. 6.27
			// [고속 OHT] KYH O8로 CID Link 시도중 통과허가 반납된 상황. StopNode까지 이동하도록 처리
			// CID 반납처리 구현  AOHC-353
			if(checkCommandTarget4CID(Info, CID_NearestTargetCID) == true && pHWSet->m_pCID->IsImmediateLinkReqON() == true)
			{
				//pHWSet->m_pCID->CID_Occup_Resume(&m_CID_Pause);
				//m_pExecuteInfo->FlagCIDReport.bCIDStop = false;

				// 2019.7.1 o8을 통해 할당받은 ID(110_2)에 대한 반납 필요

				pHWSet->m_pCID->CID_Occup_compt(21);
				Sleep(20);
				m_CIDComptFlag = true;
				m_CIDComptTryFlag = true;
				m_job_change_flag_exception_CommonTag = true; // CommonTag 일경우 처리

				m_nCidControlStep = CID_STEP_COMPLETION;
				ADD_LOG("D-63");
			}
#endif
			if(m_CIDStatusPauseFlag == true)
			{
				CID_SendForStatusCount++;
				if(CID_SendForStatusCount>187)//16ms*187 = 2992
				{
					CID_SendForStatusCount=0;
					m_pExecuteInfo->FlagCIDInfo.bCIDErrorFlag = true;

					//pHWSet->m_pCID->Set_CID_Status_Cmd();
					//m_CIDStatusFlag = true;
				}
				//인터락 원인이 CID-R Status가 전원OFF 이면, 에러발생
				//시간은 default 30초, parameter
				DRIVING_HW_INFO_SET TmpHwInfo;
				if( m_StatusSet.bIsOnProcess==true)
				{
					TmpHwInfo = m_InfoSet.HwInfo;
			    }
			    else
				{
					TmpHwInfo = getHWInfo();
				}

				if(((m_sCIDStatus[2]&0x02) == 0x02) && TmpHwInfo.IO.DetectStatus!=DETECT_AND_STOP)
				{
					int tmp_CIDPauseTime = timeGetTime();
					if(OHTUTILITY::PreventOverflowGetTimeMs(m_CIDPauseTime) > m_pParamSet->CID_PAUSE_TIMEOVER && m_CIDPauseTime != 0)     //20191104 KDS
					{
						ADD_LOG("C_92/%d/%d/%d/%d/%d/%d", m_sCIDStatus[0], m_sCIDStatus[1], m_sCIDStatus[2], tmp_CIDPauseTime, m_CIDPauseTime, m_pParamSet->CID_PAUSE_TIMEOVER);
						//nError = ERR_CID_CONNECTION_OFF_INTERLOCK_ON;//에러발생 미적용
					}
				}
			}
			else
			{

			}
		}
		else if (m_bLinkFail == false && m_CID_Pause == true && pHWSet->m_pCID->IsLinkOK() == true && pHWSet->m_pCID->IsInterlock_ON() == false)
		{
			// Interlock off 1회 확인 후 paused 상태 off 전환(2회 확인 여부 검토 필요)
			pHWSet->m_pCID->CID_Occup_Resume(&m_CID_Pause);
			m_pExecuteInfo->FlagCIDReport.bCIDInterlock = false;
			m_pExecuteInfo->FlagCIDReport.bCIDStop = false;
			m_nCidControlStep = CID_STEP_CHECKING_PATH;
			ADD_LOG("C_93/%d", Info->tmpCurrentNodeID);
		}
		else
		{
			static int nTmpCurNodeId01092 = 0;
			if(nTmpCurNodeId01092 != Info->tmpCurrentNodeID)
			{
				nTmpCurNodeId01092 = Info->tmpCurrentNodeID;
				ADD_LOG("C-64");
			}
		}



		// 2. OCS에 의한 기동 재개(Link 불가로 감속 정지 ->  OCS 보고 -> Waiting step으로 넘어온 경우)
		// 2-1. Link 연결된 경우
		if (m_bLinkFail == true && m_CID_Pause == true && pHWSet->m_pCID->IsLinkOK() == true && bResumedbyOCS == true)
		{
			m_bLinkFail = false;

			pHWSet->m_pCID->CID_Occup_Resume(&m_CID_Pause);
			m_pExecuteInfo->FlagCIDReport.bCIDInterlock= false;
			m_pExecuteInfo->FlagCIDReport.bCIDStop = false;
			m_nCidControlStep = CID_STEP_CHECKING_PATH;
			ADD_LOG("C-65");
			ResumedbyOCS_count = 0;
			bResumedbyOCS = false;
		}
		else if (m_bLinkFail == true && m_CID_Pause == true && pHWSet->m_pCID->IsLinkOK() == false && bResumedbyOCS == true)
		{
			// Select Off 전 완료 처리 후 COMPLETION step으로 이동
			pHWSet->m_pCID->CID_Occup_compt(8); // 통과 완료 bit ON
			m_CIDComptTryFlag = true;

			//Link fail시 데드락 지점(2000sec)로 인해 주석처리.
//			pHWSet->m_pCID->SendReq_CID_O();
//			Sleep(50);
//          pHWSet->m_pCID->Save_CID_O_Data();

			pHWSet->m_pCID->CID_Occup_Resume(&m_CID_Pause);
			m_pExecuteInfo->FlagCIDReport.bCIDInterlock= false;
			m_pExecuteInfo->FlagCIDReport.bCIDStop = false;
			m_nCidControlStep = CID_STEP_COMPLETION;
			ADD_LOG("C-66");
			ResumedbyOCS_count = 0;
			bResumedbyOCS = false;
		}
		else
		{
			if(pHWSet->m_pCID->IsInterlock_ON() != true)
			{
				ResumedbyOCS_count++;
				//if(ResumedbyOCS_count > 300)
				//{
					//카운트 후 강제 OCS resume 임시용
					//bResumedbyOCS = true;
					//ADD_LOG("C-67");
				//}
				//CID Bypass신호가 늦게 들어올 경우는 자동 주행 재개
				if(m_pExecuteInfo->FlagCIDNotuse.bCIDUse== true)
				{
					bResumedbyOCS = true;
					ADD_LOG("C-68");
				}
				if ((m_pExecuteInfo->FlagCIDInfo.cMoveResult == true)&&(m_pExecuteInfo->FlagCIDInfo.bMoveRestart == true))
				{
					m_pExecuteInfo->FlagCIDInfo.bMoveRestart = false;
					m_CIDStatusPauseFlag = false;
					bResumedbyOCS = true;
					ADD_LOG("C-69");
				}
				// 자동 주행 재개 - 링크 연결이 성공한 경우, 1초 후 자동 주행재개처리.
				if (pHWSet->m_pCID->IsLinkOK() == true && ResumedbyOCS_count > 65)
				{
					bResumedbyOCS = true;
					ADD_LOG("C-70");
				}
				if(m_CIDStatusPauseFlag == true)
				{
					CID_SendForStatusCount++;
					if(CID_SendForStatusCount>187)//16ms*187 = 2992
					{
						CID_SendForStatusCount=0;
						m_pExecuteInfo->FlagCIDInfo.bCIDErrorFlag = true;
					}
				}
				else
				{

				}
			}
		}
#if(OHT_NAME == OHT_NAME_STD_V81S)
		// [고속 OHT] 연결 불가로 waiting step으로 넘어온 경우에 대한 처리, 2019.6.4
		if (pHWSet->m_pCID->IsLinkOK() == false && pHWSet->m_pCID->IsVHLRegistrationFull() == true)
		{
			// 우선 log만 확인, 검증 완료 후 log 삭제 필요
			if (1)  // 등록 불가 시 paused 상태에 대한 처리, count 후 보낼지..기동 재개 후 보낼지 등
			{
				//pHWSet->m_pCID->CID_Occup_Resume(&m_CID_Pause);
				//m_nCidControlStep = CID_STEP_CHECKING_PATH;
				ADD_LOG("D_126/%d", Info->tmpCurrentNodeID);
			}
		}
		else if (pHWSet->m_pCID->IsLinkOK() == false && pHWSet->m_pCID->IsVHLRegistrationFull() == false &&
					pHWSet->m_pCID->IsVHLRegistrationDenied() == true)
		{
			if (1)  // 등록 불가 시 paused 상태에 대한 처리, count 후 보낼지..기동 재개 후 보낼지 등
			{
				//pHWSet->m_pCID->CID_Occup_Resume(&m_CID_Pause);
				//m_nCidControlStep = CID_STEP_CHECKING_PATH;
				ADD_LOG("D_127/%d", Info->tmpCurrentNodeID);
			}
		}
#endif
		break;

	case CID_STEP_OCCUPYING_PATH:
		if(pHWSet->m_pCID->IsLinkOK() == true && pHWSet->m_pCID->IsInterlock_ON() == false
			&& pHWSet->m_pCID->ISCompletionACK_On() == false  // Check Input
			&& pHWSet->m_pCID->IsOccupying() == false)	 // 점유 Off 상태
		{
			if ((Info->tmpResetNodeType1 == Slope_Rear_Reset_tag)||(Info->tmpResetNodeType2 == Slope_Rear_Reset_tag))
			{
				m_nCidControlStep = CID_STEP_COMPLETION;
				ADD_LOG("C_94/%d", Info->tmpCurrentNodeID);
			}
			// 현재 노드가 Stop이고, 다음 노드가 Reset이 아닌 경우 CID_STEP_COMPLETION 으로 변경
			else if((Info->tmpCurrentNodeID == Info->CIDStopNode1 && Info->tmpNextNodeID != Info->CIDResetNode1) &&
				(Info->tmpCurrentNodeID == Info->CIDStopNode2 && Info->tmpNextNodeID != Info->CIDResetNode2))
			{
				m_nCidControlStep = CID_STEP_COMPLETION;
				//nEnforcedSelectOffNodeID = Info->tmpNextNodeID;
				nEnforcedSelectOffNodeID = Info->tmpCurrentNodeID;
				ADD_LOG("C_95/%d/%d", Info->tmpCurrentNodeID, Info->tmpNextNodeID);
				ADD_LOG("C_96/%d/%d/%d/%d", Info->CIDStopNode1, Info->CIDResetNode1, Info->CIDStopNode2, Info->CIDResetNode2);
			}
		/*
			else if(Info->nDetectStatus == DETECT_AND_STOP)
			{
				ADD_LOG("C_97/%d"
						, Info->tmpCurrentNodeID);
			}
		*/
			else
			{
				pHWSet->m_pCID->CID_Occup_OK();//한번만 신호 보냄...
				Sleep(20);
				//확인 후 재시도 추가
				if(pHWSet->m_pCID->IS_Occup_On()==FALSE)
				{
					pHWSet->m_pCID->CID_Occup_OK();
				}
				m_nCidControlStep = CID_STEP_COMPLETION;
				ADD_LOG("C_98/%d/%d", Info->tmpCurrentNodeID, Info->tmpNextNodeID);

			}
		}
		else if(pHWSet->m_pCID->IsLinkOK() == true && pHWSet->m_pCID->IsInterlock_ON() == true)//true시 동작 추가 : CID_STEP_CHECKING_PATH로 전환
		{
			m_nCidControlStep = CID_STEP_CHECKING_PATH;
		}
		else
		{
		}

		break;

	case CID_STEP_COMPLETION:
		IO_INFO_CID();

		// 1. 대차 감지 시 합류점유 반납
		if (m_CIDComptTryFlag == false // 완료 처리 전이고,
			&& (pHWSet->m_pCID->IsLinkOK() == true && pHWSet->m_pCID->IsInterlock_ON() == false
			&& Info->nDetectStatus == DETECT_AND_STOP && pHWSet->m_pDrivingAxis->IsRunning() == false))
		{
			// 다음 이동할 노드가 ResetNode 이면
			// Stop Tag, Reset Tag 사이에 위치한 경우 합류 점유 반납하지 않음
			if (Info->tmpNextNodeID == m_tmpCurrentResetNode)
			{
				static int nTmpCurNodeId6 = 0;
				if(nTmpCurNodeId6 != Info->tmpCurrentNodeID)
				{
					nTmpCurNodeId6 = Info->tmpCurrentNodeID;
					ADD_LOG("C-71");
					ADD_LOG("C_99/%d/%d/%d",
					Info->tmpCurrentNodeID, Info->CIDResetNode1, Info->CIDResetNode2);
				}
			}
			// 다음 이동할 노드가 ResetNode 아니면
			// Start Tag에 위치한 경우 (Stop Tag 이전에 정차한 경우) 합류 점유 반납
			else
			{
				pHWSet->m_pCID->CID_Occup_return(1);
				m_nCidControlStep = CID_STEP_CHECKING_PATH;

				static int nTmpCurNodeId7 = 0;
				if(nTmpCurNodeId7 != Info->tmpCurrentNodeID)
				{
					nTmpCurNodeId7 = Info->tmpCurrentNodeID;
					ADD_LOG("C-72");
					ADD_LOG("C_100/%d/%d/%d",
						Info->tmpCurrentNodeID, Info->CIDResetNode1, Info->CIDResetNode2);
				}
				break;
			}

		}

		// 2. Interlock On
		// 2-1. 경사로 후방 광 Fiber 구간에서 Interlock On 시 정지
		if ((m_CIDComptTryFlag == false)
			&& ((Info->tmpResetNodeType1 == Slope_Rear_Reset_tag)||(Info->tmpResetNodeType2 == Slope_Rear_Reset_tag)))
		{
			if(pHWSet->m_pCID->IsLinkOK() == true && pHWSet->m_pCID->IsInterlock_ON() == true
				&& pHWSet->m_pDrivingAxis->IsRunning() == true)
			{
				pHWSet->m_pCID->CID_Occup_Pause(&m_CID_Pause);
				m_pExecuteInfo->FlagCIDReport.bCIDInterlock= true;
				m_nCidControlStep = CID_STEP_WAITING_FOR_PATH;
				ADD_LOG("C-73");
				break;
			}
		}
		// 2-2. 일반 합류 구간 내 동시 진입
		else if ((m_CIDComptTryFlag == false)
			&& (pHWSet->m_pCID->IsLinkOK() == true && pHWSet->m_pCID->IsInterlock_ON() == true
				&& pHWSet->m_pCID->IsOccupying() == true && pHWSet->m_pDrivingAxis->IsRunning() == true))
		{
			nError = ERR_CID_OCCUP_ON_INTERLOCK_ON;
			ADD_LOG("C_101/%d", Info->tmpCurrentNodeID);
			pHWSet->m_pCID->SendReq_CID_O();
			ADD_FDC_LOG("ERR/%d/1/5/%06d/%06d/%d/%d/%06d",
					ERR_CID_OCCUP_ON_INTERLOCK_ON,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pExecuteInfo->ExecutePositionInfo.NextNode,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					m_pOHTMainStatus->StatusCommon.ExistFoup,
					m_pOHTMainStatus->StatusCommon.StopStationID);
			break;
		}
		// 2-3. 일반 합류 구간 내 합류 미점유 상태에서 Interlock On  (재확인 후 삭제)
		else if ((m_CIDComptTryFlag == false)
			&& (pHWSet->m_pCID->IsLinkOK() == true && pHWSet->m_pCID->IsInterlock_ON() == true
				&& pHWSet->m_pCID->IsOccupying() == false && pHWSet->m_pDrivingAxis->IsRunning() == true))
		{
			pHWSet->m_pCID->CID_Occup_Pause(&m_CID_Pause);
			m_pExecuteInfo->FlagCIDReport.bCIDInterlock= true;
			m_nCidControlStep = CID_STEP_WAITING_FOR_PATH;
			ADD_LOG("C_102/%d", Info->tmpCurrentNodeID);
			break;
		}
		// 2-4. 작업변경 없이 VHL이 CID 점유 후 목적지가 Stopnode로 변경시 CID 점유 반납 처리.
		else if( (m_CIDComptTryFlag == false) &&
		        (Info->tmpNextNodeID != m_tmpCurrentResetNode) &&
				(Info->tmpCurrentNodeID == Info->tmpCurrentCMDID) &&
				(Info->tmpCurrentNodeID == Info->CIDStopNode1 || Info->tmpCurrentNodeID == Info->CIDStopNode2))
		{
			pHWSet->m_pCID->CID_Occup_return(2);
			m_nCidControlStep = CID_STEP_CHECKING_PATH;

			static int nTmpCurNodeId8 = 0;
			if(nTmpCurNodeId8 != Info->tmpCurrentNodeID)
			{
				nTmpCurNodeId8 = Info->tmpCurrentNodeID;
				ADD_LOG("C_103/%d", Info->tmpCurrentNodeID);
				ADD_LOG("C_104/%d/%d/%d/%d/%d",
					Info->tmpCurrentNodeID, Info->CIDStopNode1, Info->CIDStopNode2, Info->CIDResetNode1, Info->CIDResetNode2);
			}
			break;
		}
		else if (m_CIDComptTryFlag == false)
		{
			static int nTmpCurNodeId2 = 0;
			if(nTmpCurNodeId2 != Info->tmpCurrentNodeID)
			{
				nTmpCurNodeId2 = Info->tmpCurrentNodeID;
				ADD_LOG("C_105/%d", Info->tmpCurrentNodeID);
			}
		}
		else
		{
			static int nTmpCurNodeId20171113 = 0;
			if(nTmpCurNodeId20171113 != Info->tmpCurrentNodeID)
			{
				nTmpCurNodeId20171113 = Info->tmpCurrentNodeID;
				ADD_LOG("C-74");
			}
		}

		// 3. 완료 처리(통과 완료 bit 'On' 전송)
		nError = completeCIDComm(Info, pInfoSet);
		if (CID_Status_Check == 0)
		{
			CID_Status_Check = 1;
			if(pHWSet->m_pCID->ISCidOperatingMode() == ON)    // 합류부 CID 또는 Slope로 사용 시 ‘1’  MTL, Lifter 등 다른 영역에서 사용 시 ‘0’
			{
				pHWSet->m_pCID->Clear_CID_Status_Cmd(); //CID 정상 상태 보고
			}
		}

		break;

	case CID_STEP_ABNORMAL:
		IO_INFO_CID();
		// 1. Link 최초 연결 후 Link 장애 발생한 경우 처리
		if (m_bCIDNotUse == false && m_bInitialLink == true && m_bLinkDisconnected == true)
		{
			// 1-1. Reconnected...
			if (pHWSet->m_pCID->IsLinkOK() == true)
			{
				m_bLinkDisconnected = false;
				nLinkFailureCount = 0;
				m_nCidControlStep = CID_STEP_CHECKING_PATH;
				ADD_LOG("C-75");
				break;
			}
			// 1-2. 재연결이 되지 않은 상태로 Reset Tag까지 주행한 경우, 완료 처리
			//      (연결이 되었으나 CID-O의 Link 입력 이상한 경우를 위한 처리)
			else if (Info->CIDResetNode_arr != INDEX_NONE &&
				(Info->CIDResetNodeType == Normal_Reset_tag ||
				Info->CIDResetNodeType == Common_Reset_tag ||
				Info->CIDResetNodeType == Slope_Rear_Reset_tag))
			{
				pHWSet->m_pCID->CID_Occup_compt(9); // 통과 완료 bit ON
				Sleep(20);
				//m_CIDComptTryFlag = true;
				//m_nCidControlStep = CID_STEP_COMPLETION;
				ADD_LOG("C-76");

				if (Info->CIDResetNodeType == Common_Reset_tag)
				{
					pHWSet->m_pCID->CID_Out_Common_Tag(11, true);	// Common Tag On
					ADD_LOG("C-77");
					m_CID_COMMON_bit_off_need = true;
					Sleep(10);
				}
				m_bLinkDisconnected = false;

				pHWSet->m_pCID->TerminateCID(4);	// Pass Ok. CID All Off // bReadyOperation -> on
				bCountOfCIDComptACK = 0;

				m_CIDDirection = CID_DIRECTION_NOT_LINK;
				m_CIDComptFlag = false;
				m_CIDComptTryFlag = false;
				m_bInitialLink = false;
				m_bCIDNotUse = false;
				m_CIDOperationStarted = false;
				m_job_change_flag_no_cid_area = false;
				m_pExecuteInfo->bChangeResult = false;
				m_ntempNodeOffset = 0;


				m_pExecuteInfo->bChangeResult = false;    //false 시점 확인

				ADD_LOG("C_106/%d" , bCountOfCIDComptACK);
				m_nCidControlStep = CID_STEP_CONNECTING;

				break;
			}
		}

		// Link 장애 시 COMPLETION step을 거쳐 Abnormal로 넘어온 경우 처리
		// Outputs(Select, 점유, 완료, Abnormal, Mode) reset 후 대기
		if (m_bCIDNotUse == false && (m_bLinkFail == true || m_bLinkDisconnected == true)
			&& m_CIDComptTryFlag == false
			&& (Info->CIDResetNode_arr != INDEX_NONE &&
				(Info->CIDResetNodeType == Normal_Reset_tag ||
				Info->CIDResetNodeType == Common_Reset_tag ||
				Info->CIDResetNodeType == Slope_Rear_Reset_tag)))
		{
			m_bLinkFail = false;
			m_bLinkDisconnected = false;
			m_bInitialLink = false;
			m_CIDComptTryFlag = false;
			if (Info->CIDResetNodeType == Common_Reset_tag)
			{
				pHWSet->m_pCID->CID_Out_Common_Tag(2, true);	// Common Tag On
				ADD_LOG("C-78");
				m_CID_COMMON_bit_off_need = true;
			}
			m_nCidControlStep = CID_STEP_CONNECTING;
			ADD_LOG("C_107/%d", Info->tmpCurrentNodeID);
			ERR_LOG("[CID] Arrived at Reset Tag after Link Failure..Move to CONNECTING step(Step:CID_STEP_ABNORMAL, Current Node : %d)", Info->tmpCurrentNodeID);
			break;
		}
		else if (Info->CIDResetNode_arr != INDEX_NONE &&
				(Info->CIDResetNodeType == Normal_Reset_tag ||
				Info->CIDResetNodeType == Common_Reset_tag ||
				Info->CIDResetNodeType == Slope_Rear_Reset_tag))
		{
			ADD_LOG("C_108/%d/%d/%d/%d/%d",
					m_bCIDNotUse, m_bLinkFail, m_bLinkDisconnected, m_CIDComptTryFlag, Info->CIDResetNodeType);
			ERR_LOG("[CID] Abnormal Step, else if...m_bCIDNotUse: %d, m_bLinkFail: %d, m_bLinkDisconnected: %d, m_CIDComptTryFlag: %d, CIDResetNodeType: %d",
					m_bCIDNotUse, m_bLinkFail, m_bLinkDisconnected, m_CIDComptTryFlag, Info->CIDResetNodeType);
			m_bLinkFail = false;
			m_bLinkDisconnected = false;
			m_bInitialLink = false;
			m_CIDComptTryFlag = false;
			if (Info->CIDResetNodeType == Common_Reset_tag)
			{
				 //해당 처리시 다음 CID에 연결되는 현상 제거
				//  pHWSet->m_pCID->CID_Out_Common_Tag(3, true);	// Common Tag On
				//	ADD_LOG("C-79");
			    //  m_CID_COMMON_bit_off_need = true;
			}
			m_nCidControlStep = CID_STEP_CONNECTING;
			break;
		}
		else
		{
			//CIDResetNodeType 이 Slope_Front_Reset_tag 인 경우
			//CIDResetNodeType 이 없는 경우 진입하게 됨.(현재 노드가 Reset 노드가 아닌경우)
			static int nTmpCurNodeId01042 = 0;
			if(nTmpCurNodeId01042 != Info->tmpCurrentNodeID)
			{
				nTmpCurNodeId01042 = Info->tmpCurrentNodeID;
				ADD_LOG("C_109/%d/%d/%d/%d/%d",
					m_bCIDNotUse, m_bLinkFail, m_bLinkDisconnected, m_CIDComptTryFlag, Info->CIDResetNodeType);
			}
		}


		// 합류 점유한 채로 대차 감지 중 Link 신호가 비정상적으로 Off 된 경우 처리(2016.11.25)
		if (m_bCIDNotUse == false && m_bLinkDisconnected == true && pHWSet->m_pCID->IsOccupying() == true &&
			Info->nDetectStatus == DETECT_AND_STOP && pHWSet->m_pDrivingAxis->IsRunning() == false)
		{

			// write code here...
			m_CIDComptTryFlag = false;
			//
			static int nTmpCurNodeId7 = 0;
			if(nTmpCurNodeId7 != Info->tmpCurrentNodeID)
			{
				nTmpCurNodeId7 = Info->tmpCurrentNodeID;
				ADD_LOG("C_110/%d", Info->tmpCurrentNodeID);
			}

		}

		// CID 무시 신호 수신 시 Abnormal Step에서의 처리   [용도는 ??]
		// 무시 신호는 모든 리셋 Tag 만날시 처리
		if (m_bCIDNotUse == true
			&& (Info->CIDResetNode_arr != INDEX_NONE &&
				(Info->CIDResetNodeType == Normal_Reset_tag ||
				Info->CIDResetNodeType == Common_Reset_tag ||
				Info->CIDResetNodeType == Slope_Front_Reset_tag ||
				Info->CIDResetNodeType == Slope_Rear_Reset_tag)))
		{
			m_nCidControlStep = CID_STEP_CONNECTING;
			m_bCIDNotUse = false;
			m_bLinkFail = false;
			m_bLinkDisconnected = false;
			m_bInitialLink = false;
			m_CIDComptTryFlag = false;
			ADD_LOG("C_111/%d", Info->tmpCurrentNodeID);
		}
		break;

	default:
		break;
	}

	return nError;
}


/**
@brief   합류부 통과 시 CID 완료 처리를 위한 함수
@author  Kunjin
@date    2016.11.24
*/
int DrivingControl::completeCIDComm(CID_CTRL_INFO* Info, DRIVING_INFO_SET *pInfoSet)
{
	int nError = 0;

	double  dSpeedOfNow = pInfoSet->HwInfo.Axis1.dSpeed;

	if (m_CIDComptTryFlag == false &&			// 완료시도 하지 않은 상태이면
		(m_CurrCIDStartnode != Info->tmpCurrentNodeID || m_CurrCIDStartnode != Info->tmpPreNodeID)) // 공용 노드인 경우 처리 추가. 현재노드가 start_1 노드가 아니면 수행 함.
	{
		if((NormalCid_Return(Info) == true)				// normal, slope
			|| (CommonCid_Return(Info, pInfoSet) == true)) 	// common
		{
			IO_INFO_CID();
			nEnforcedSelectOffNodeID = Info->tmpNextNodeID;

			ADD_LOG("C_112/%d/%d/%d", Info->tmpCurrentNodeID, Info->tmpPreNodeID, m_CIDComptTryFlag);
		}
		else
		{
			static int nTmpCurNodeId14 = 0;
			if(nTmpCurNodeId14 != Info->tmpCurrentNodeID)
			{
				nTmpCurNodeId14 = Info->tmpCurrentNodeID;
				ADD_LOG("C_113/%d/%d/%d/%d",
					Info->tmpCurrentNodeID, Info->CIDResetNode, Info->CIDResetNodeType, m_tmpCurrentResetNode);
			}
		}
	}
	else
	{
		static int nTmpCurNodeId0109 = 0;
		if(nTmpCurNodeId0109 != Info->tmpCurrentNodeID)
		{
			nTmpCurNodeId0109 = Info->tmpCurrentNodeID;
			ADD_LOG("C_114/%d/%d" ,m_CIDComptTryFlag, nEnforcedSelectOffNodeID);
		}
		// Link 장애 시 감속 정지 후 OCS 기동 재개로 COMPLETION step으로 넘어온 경우 처리
		if (m_bLinkFail == true || m_bLinkDisconnected == true)
		{
			if (m_nCIDTerminateCount > 5)
			{
				if(m_pExecuteInfo->FlagCIDReport.bCIDStop == true)
				{
					m_pExecuteInfo->FlagCIDReport.bCIDStop = false;
					pHWSet->m_pCID->CID_Occup_Resume(&m_CID_Pause);
					ADD_LOG("C-80");
				}
				pHWSet->m_pCID->TerminateCID(1);
				m_bCIDNotUse = false;
				m_CIDComptTryFlag = false;
//				m_bInitialLink = false;
				nEnforcedSelectOffNodeID = 0;
				m_nCIDTerminateCount = 0;
				m_ntempNodeOffset = 0;

				m_CIDOperationStarted = false;
				m_job_change_flag_no_cid_area = false;
				m_pExecuteInfo->bChangeResult = false;
				m_CIDDirection = CID_DIRECTION_NOT_LINK;
				m_nCidControlStep = CID_STEP_ABNORMAL;

				ADD_LOG("C_115/%d", pHWSet->m_pCID->ISCompletionACK_On());
				ADD_LOG("C_116/%d", Info->tmpCurrentNodeID);
			}
			else
				m_nCIDTerminateCount++;
		}


		// 통과 완료 bit를 on 했지만 꺼져 있는 경우
		else if ((m_CurrCIDStartnode != Info->tmpCurrentNodeID || m_CurrCIDStartnode != Info->tmpPreNodeID) && // 공용 노드인 경우 처리 추가. 현재노드가 start_1 노드가 아니면 수행 함.
			(pHWSet->m_pCID->ISCompletionACK_On() == false && pHWSet->m_pCID->ISCompletion_On() == false))
		{
			if((NormalCid_Return(Info) == true) 				// normal, slope
				|| (CommonCid_Return(Info, pInfoSet) == true))	// common
			{
				IO_INFO_CID();
				pHWSet->m_pCID->CID_Occup_compt(10);
				ADD_LOG("C_117/%d", Info->tmpCurrentNodeID);
			}
		}

		// 합류부 점유 반납 후 CID-R ACK 확인
		else if (pHWSet->m_pCID->ISCompletionACK_On() == true)	// 완료처리 시작후 점유해제 ACK를 받음
		{
			IO_INFO_CID();
			//  AOHC-383
			if (((Info->CIDResetNodeType == Common_Reset_tag) && (Info->CIDResetNodeType_Pre == Common_Reset_tag))  || Info->CIDResetNodeType_Pre == Common_Reset_tag)
			{
				if(m_job_change_flag_exception_CommonTag == false)//작업변경시 완료처리는 common 처리 안하기 위함
				{
				pHWSet->m_pCID->CID_Out_Common_Tag(4, true);	// Common Tag On
				ADD_LOG("C-81");
				m_CID_COMMON_bit_off_need = true;
				Sleep(10);
				}
				else
				{
					ADD_LOG("C-82");
				}
			}

			pHWSet->m_pCID->TerminateCID(2);	// Pass Ok. CID All Off // bReadyOperation -> on

			m_CIDDirection = CID_DIRECTION_NOT_LINK;
			m_CIDComptFlag = false;
			m_CIDComptTryFlag = false;
			m_bInitialLink = false;
			m_bCIDNotUse = false;
			m_CIDOperationStarted = false;
			m_job_change_flag_no_cid_area = false;
			m_pExecuteInfo->bChangeResult = false;
			m_ntempNodeOffset = 0;

			nEnforcedSelectOffNodeID = 0;

			m_pExecuteInfo->bChangeResult = false;	  //false 시점 확인

			ADD_LOG("C_118/%d" , bCountOfCIDComptACK);

			bCountOfCIDComptACK = 0;

			memset(&CID_Save_Node, 0, sizeof(CID_Save_Node));

			m_nCidControlStep = CID_STEP_CONNECTING;
			//IO_INFO_CID_ALL(); IO_INFO_CID와 동일 로그 중복 출력

			int mcc_CID_Link_During_Time = OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwCIDLinkOnTime) - m_mccparam.nCIDLinkOnTime;
			int mcc_CID_Link_During_Dist = pInfoSet->HwInfo.Axis1.dCurrPos - m_mccparam.nCIDLinkStartPosition - m_mccparam.nCIDLinkOffset;

			ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,CID LINK,End,%s,%06d,%06d,%06d,%d,%3.3lf,CID Link Start Node,%d,CID Link Node,%d,CID Link Node Offset,%d,CID Link Time,%d,Map CID Link Offset,%d,CID Link Distance,%d,CID Link Moving Distance,%d,CID Link Moving Time,%d",
									m_defualtparam->VHLName,m_mccparam.cCarrierType,
									m_mccparam.uSourceNode,
									m_mccparam.uTargetNode,
									m_pExecuteInfo->ExecutePositionInfo.CurrNode,
									m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
									dSpeedOfNow,
									m_mccparam.nCIDLinkStartNode,
									m_mccparam.nCIDLinkNode,
									m_mccparam.nCIDLinkNodeOffset,
									m_mccparam.nCIDLinkOnTime,
									m_mccparam.nCIDMapOffset,
									m_mccparam.nCIDLinkOffset,
									mcc_CID_Link_During_Time,
									mcc_CID_Link_During_Dist);

			m_mccparam.nCIDLinkStartNode = 0;
			m_mccparam.nCIDLinkNode = 0;
			m_mccparam.nCIDLinkNodeOffset = 0;
			m_mccparam.nCIDLinkOnTime = 0;
			m_mccparam.nCIDMapOffset = 0;
			m_mccparam.nCIDLinkOffset = 0;
		}

		// 통과 완료 처리에 대한 ACK 미수신 시 강제로 Select Off 필요(시간 or 위치 조건)
		// Common Tag의 경우 일반 Reset Tag보다 빨리 Select off 필요  //  AOHC-383
		else if ((m_CurrCIDStartnode != Info->tmpCurrentNodeID &&	//Reset Tag 가 공용인 경우 start 1 node 배제 하기 위함..
				  bCountOfCIDComptACK > 10 && (((Info->CIDResetNodeType == Common_Reset_tag) && (Info->CIDResetNodeType_Pre == Common_Reset_tag))  || Info->CIDResetNodeType_Pre == Common_Reset_tag ))//Prenode 로 변경하면서 bCountOfCIDComptACK을 5에서 10으로 변경
			|| (Info->tmpCurrentNodeID == nEnforcedSelectOffNodeID)//Info->tmpCurrentNodeID 가 다음 노드로 변경 되므로 Info->CIDResetNodeType은 알 수 없음...
			//nEnforcedSelectOffNodeID를 작업 변경 시 현재 리셋노드로 넣도록 함.  [CID] CID_Occup_compt(5).. ACK delay
			)
			// 다음 노드 가긴 전 처리 검토 필요.. !!
			// bCountOfCIDComptACK > 50 && Info->CIDResetNodeType == Normal_Reset_tag) 이런식으로..
//			|| (Info->CIDResetNodeType == Normal_Reset_tag && Info->tmpCurrentNodeID == nEnforcedSelectOffNodeID))
		{
			IO_INFO_CID();

			pHWSet->m_pCID->CID_Occup_compt(11);
			Sleep(20);

			if (Info->CIDResetNodeType == Normal_Reset_tag || Info->CIDResetNodeType_Pre == Normal_Reset_tag)
			{
				ADD_LOG("C-83");
			}
			// Common Tag 인 경우 Common Tag bit 'On'  //  AOHC-383
			else if (((Info->CIDResetNodeType == Common_Reset_tag) && (Info->CIDResetNodeType_Pre == Common_Reset_tag)) || Info->CIDResetNodeType_Pre == Common_Reset_tag)
			{
				if(m_job_change_flag_exception_CommonTag == false)//작업변경시 완료처리는 common 처리 안하기 위함
				{
				pHWSet->m_pCID->CID_Out_Common_Tag(5, true);	// Common Tag On
				Sleep(10);
				ADD_LOG("C-84");
				m_CID_COMMON_bit_off_need = true;
				}
				else
				{
					ADD_LOG("C-85");
				}
			}
			else
			{
				ADD_LOG("C-86");
			}

			ADD_LOG("C_119/%d/%d/%d/%d" , Info->tmpCurrentNodeID, nEnforcedSelectOffNodeID, m_CurrCIDStartnode, bCountOfCIDComptACK);


			pHWSet->m_pCID->TerminateCID(3);

			memset(&CID_Save_Node, 0, sizeof(CID_Save_Node));

			m_nCidControlStep = CID_STEP_CONNECTING;
			m_CIDDirection = CID_DIRECTION_NOT_LINK;
			bCountOfCIDComptACK = 0;
			m_CIDComptFlag = false;
			m_CIDComptTryFlag = false;
			m_bInitialLink = false;
			m_bCIDNotUse = false;
			m_CIDOperationStarted = false;
			m_job_change_flag_no_cid_area = false;
			m_pExecuteInfo->bChangeResult = false;
			m_ntempNodeOffset = 0;


			nEnforcedSelectOffNodeID = 0;

			ADD_LOG("C_120/%d" , bCountOfCIDComptACK);
			ADD_LOG("C_121/%d" , m_nCidControlStep);
		}
		else if(m_job_change_without_link_complete == true)
		{
			pHWSet->m_pCID->TerminateCID(5);	// Pass Ok. CID All Off // bReadyOperation -> on

			m_CIDDirection = CID_DIRECTION_NOT_LINK;
			m_CIDComptFlag = false;
			m_CIDComptTryFlag = false;
			m_bInitialLink = false;
			m_bCIDNotUse = false;
			m_CIDOperationStarted = false;
			m_job_change_flag_no_cid_area = false;
			m_pExecuteInfo->bChangeResult = false;
			m_ntempNodeOffset = 0;

			nEnforcedSelectOffNodeID = 0;

			m_pExecuteInfo->bChangeResult = false;	  //false 시점 확인


			m_job_change_without_link_complete = false;

			ADD_LOG("C_122/%d", bCountOfCIDComptACK);

			bCountOfCIDComptACK = 0;
			m_nCidControlStep = CID_STEP_CONNECTING;

			memset(&CID_Save_Node, 0, sizeof(CID_Save_Node));
		}
		else
			bCountOfCIDComptACK++;
	}
	return nError;
}


// AOHC-353
bool DrivingControl::checkCommandTarget4CID(CID_CTRL_INFO* Info, bool TargetCID)
{
	// Command target이 Reset Tag를 넘지 않는 경우 true 호출
	bool bCMDTarget = false;
	if (((Info->CIDStartNode1_arr != INDEX_NONE)
		&& ((Info->tmpCurrentCMDID == Info->tmpStartNode1_1)
		|| (Info->tmpCurrentCMDID == Info->tmpStartNode1_2)
		|| (Info->tmpCurrentCMDID == Info->tmpStartNode1_3)
		|| (Info->tmpCurrentCMDID == Info->tmpStartNode1_4)
		|| (Info->tmpCurrentCMDID == Info->tmpStartNode1_5)))
		|| ((Info->CIDStartNode2_arr != INDEX_NONE)
		&& ((Info->tmpCurrentCMDID == Info->tmpStartNode2_1)
		|| (Info->tmpCurrentCMDID == Info->tmpStartNode2_2)
		|| (Info->tmpCurrentCMDID == Info->tmpStartNode2_3)
		|| (Info->tmpCurrentCMDID == Info->tmpStartNode2_4)
		|| (Info->tmpCurrentCMDID == Info->tmpStartNode2_5))))
	{
		//CMDID(목적지)가 StartNode라도, ResetNode가 경로상에 있을경우 false 처리.
		/*
        문제점 : CMDID가 현재의 Stop위치면 점유 안함..
            제자리 돌기인 경우, CMDID가 현재 위치더라도 1개인 경우, 최초 합류 이동시 점유, 도착시 미점유로 처리가 되어야함..
		 목적지에 따라 Link 연결 시도하는 부분과 조합하여 처리 가능..경로상 STOP, Reset 유무
		 오버런에 의해서 여기에 타면안되는데 탈경우 처리 방안
		*/
		//bCMDTarget = true;
		// reset node 정보가 0인경우는 안타게 처리.
#if(OHT_NAME == OHT_NAME_STD_V81S)
		bCMDTarget = true;     //CID_STEP_WAITING_FOR_PATH의 if(checkCommandTarget4CID(Info,CID_NearestResetNode) == true && pHWSet->m_pCID->IsImmediateLinkReqON() == true) 방안 마련 필요.
#else

//		if((Info->uLimitNode == m_tmpCurrentResetNode) && (Info->bIgnolOverRun==true))
//		{
//
//		}
//		else  다시 처리할것..마지막 CID인지 아닌지 판단하는 부분 추가할것..
        //마지막 CID 경우만 확인할것.
		if(TargetCID ==false)
		{
			bCMDTarget = false;
			ERR_LOG("[Check]AOHC-353");
		}
		else
			bCMDTarget = true;   //기존


		//ADD_LOG("C_Test/%d/%d/%d/%d/%d/%d/%d/%d",nNearestResetNode , m_pExecuteInfo->nNextNodeIDInfo,Info->tmpResetNode1,Info->tmpResetNode2,Info->tmpCurrentCMDID,m_tmpCurrentResetNode,Info->uLimitNode,TargetCID);
		//[10:30:11.890]C_Test/124/0/142/124/123/124/124/0
#endif

	}
	return bCMDTarget;



}




// 변화가 있다 - return true, 없다 - return false
bool DrivingControl::IO_INFO_CID(void)
{

	AnsiString strLogTmp;  	// strLogTmp.sprintf
	static AnsiString strBeforeLog;


#if(OHT_NAME == OHT_NAME_STD_V81S)
	strLogTmp.sprintf("C_132/%d/%d/%d/%d/%d/%d/%d/%d/%d/%d/%d/%d/%d",
			pHWSet->m_pCID->IsLinkOK(), 		pHWSet->m_pCID->IsInterlock_ON(),
			pHWSet->m_pCID->ISCompletionACK_On(),	pHWSet->m_pCID->ISCidStatusOn(),   pHWSet->m_pCID->IsVHLRegistrationFull(),

			pHWSet->m_pCID->IsLinking_Left(),		pHWSet->m_pCID->IsLinking_Right(),	pHWSet->m_pCID->IsOccupying(),
			pHWSet->m_pCID->ISCompletion_On(),	pHWSet->m_pCID->ISCidManualMode(),
			pHWSet->m_pCID->ISCidOperatingMode(),	pHWSet->m_pCID->ISCommonTagMode(), pHWSet->m_pCID->IsLinkRequest());
#else
	strLogTmp.sprintf("C_133/%d/%d/%d/%d/%d/%d/%d/%d/%d/%d/%d",
			pHWSet->m_pCID->IsLinkOK(), 		pHWSet->m_pCID->IsInterlock_ON(),
			pHWSet->m_pCID->ISCompletionACK_On(),	pHWSet->m_pCID->ISCidStatusOn(),

			pHWSet->m_pCID->IsLinking_Left(),		pHWSet->m_pCID->IsLinking_Right(),	pHWSet->m_pCID->IsOccupying(),
			pHWSet->m_pCID->ISCompletion_On(),	pHWSet->m_pCID->ISCidManualMode(),
			pHWSet->m_pCID->ISCidOperatingMode(),	pHWSet->m_pCID->ISCommonTagMode());
#endif
	if(strBeforeLog != strLogTmp)
	{
		strBeforeLog = strLogTmp;
		ADD_LOG(strLogTmp.c_str());
		return true;
	}
	else
	{
		return false;
	}
}

void DrivingControl::IO_INFO_CID_ALL(void)
{

	AnsiString strLogTmp;  	// strLogTmp.sprintf
    static AnsiString strBeforeLog;

	strLogTmp.sprintf("C_134/%d/%d/%d/%d/%d/%d/%d/%d/%d/%d/%d",
			pHWSet->m_pCID->IsLinkOK(), 		pHWSet->m_pCID->IsInterlock_ON(),
			pHWSet->m_pCID->ISCompletionACK_On(),	pHWSet->m_pCID->ISCidStatusOn(),

			pHWSet->m_pCID->IsLinking_Left(),		pHWSet->m_pCID->IsLinking_Right(),	pHWSet->m_pCID->IsOccupying(),
			pHWSet->m_pCID->ISCompletion_On(),	pHWSet->m_pCID->ISCidManualMode(),
			pHWSet->m_pCID->ISCidOperatingMode(),	pHWSet->m_pCID->ISCommonTagMode());

	if(strBeforeLog != strLogTmp)
	{
		strBeforeLog = strLogTmp;
		ADD_LOG(strLogTmp.c_str());

	}

}

/**
@brief   진행 경로의 CID Start Node, Stop Node, Reset Node 저장하는 함수
@author  KYH
@date    2018.07.03
*/
void DrivingControl::CID_Save_Start_Stop_Reset(CID_CTRL_INFO* Info)
{
	//ADD_LOG("D-64");
	if ((m_CIDDirection == 0) || (m_CIDDirection == 2)) // CID Left
	{
		if(Info->tmpStartNode1_1 != INDEX_NONE)
		{
			CID_Save_Node[0] = Info->tmpStartNode1_1;
			CID_Save_Node[1] = Info->tmpStartNode1_2;
			CID_Save_Node[2] = Info->tmpStartNode1_3;
			CID_Save_Node[3] = Info->tmpStartNode1_4;
			CID_Save_Node[4] = Info->tmpStartNode1_5;
			CID_Save_Node[5] = Info->tmpResetNode1;
			ADD_LOG("C_123/%d", CID_Save_Node[5]);
			//ADD_LOG("D_128/%d/%d/%d/%d/%d/%d", CID_Save_Node[0], CID_Save_Node[1], CID_Save_Node[2], CID_Save_Node[3], CID_Save_Node[4], CID_Save_Node[5]);
		}
	}
	else if ((m_CIDDirection == 1) || (m_CIDDirection == 3)) // CID Right
	{
		if(Info->tmpStartNode2_1 != INDEX_NONE)
		{
			CID_Save_Node[0] = Info->tmpStartNode2_1;
			CID_Save_Node[1] = Info->tmpStartNode2_2;
			CID_Save_Node[2] = Info->tmpStartNode2_3;
			CID_Save_Node[3] = Info->tmpStartNode2_4;
			CID_Save_Node[4] = Info->tmpStartNode2_5;
			CID_Save_Node[5] = Info->tmpResetNode2;
			ADD_LOG("C_124/%d", CID_Save_Node[5]);
			//ADD_LOG("D_129/%d/%d/%d/%d/%d/%d", CID_Save_Node[0], CID_Save_Node[1], CID_Save_Node[2], CID_Save_Node[3], CID_Save_Node[4], CID_Save_Node[5]);
		}
	}
	else // CID_DIRECTION_NOT_LINK
	{
	}
}

/**
@brief   동일 CID인지 판단 하는 함수
@author  KYH
@date    2018.07.10
*/
bool DrivingControl::CID_Compare_List(DRIVING_HW_INFO_SET HwInfo)
{
	bool CIDChangeReturn = false;
	int CIDArrayCount = 0;
	unsigned int TotalCount = 0;
	DRIVING_CMD_INFO_OF_NODE* pCIDListNode;
	unsigned int CIDListNodeID = 0;
	int NodeListCount = 0;

	DRIVING_CMD_INFO_OF_NODE* pCurrentNodeID = getNodeInfo(HwInfo.Node.nNodeCount);
	unsigned int nCurrentNodeID = pCurrentNodeID->ID;

	for (int i = 0; i < 5; i++) // 현재 노드와 동일 CID 위치 파악
	{
		if (nCurrentNodeID == CID_Save_Node[i])
		{
			CIDArrayCount = i;
			//ADD_LOG("D_130/%d/%d/%d" , nCurrentNodeID, CID_Save_Node[i], i);
			break;
		}
		else
		{
		}
	}

	try
	{
		TotalCount = m_ClassifiedCmd.NodeList.getCount() -1;
		//ADD_LOG("D_131/%d", TotalCount);
	}
	catch(...)
	{
		ADD_LOG("C-87");
	}

	for (int i = CIDArrayCount; i < 6; i++) // 현재노드부터 CID 영역의 남은 경로 비교
	{
		if (CID_Save_Node[i] == 0)
		{
			// CID StartNode가 0일경우 Pass
			//ADD_LOG("D-65");
		}
		else
		{
			pCIDListNode = getNodeInfo(HwInfo.Node.nNodeCount + NodeListCount);
			CIDListNodeID = pCIDListNode->ID;
			if (CIDListNodeID == CID_Save_Node[i])
			{
				// 기존 경로와 CID가 동일
				//ADD_LOG("D_132/%d/%d", TotalCount, NodeListCount);
			}
			else
			{
				CIDChangeReturn = true;
				//ADD_LOG("D_133/%d/%d/%d/%d", CIDListNodeID, CID_Save_Node[i], i, NodeListCount);
				static unsigned int nTmpCurNodeId19112101 = 0;
				if(nTmpCurNodeId19112101 != nCurrentNodeID)
				{
					nTmpCurNodeId19112101 = nCurrentNodeID;
					ADD_LOG("C_125/%d/%d", CIDListNodeID, CID_Save_Node[i]);
				}
				break;
			}

			if (TotalCount == NodeListCount) // 자신의 마지막 Count일 경우 (자신의 경로가 변경 전 CID 영역과 동일한 크기거나  짧은 경우)
			{
				CIDChangeReturn = false;
				//ADD_LOG("D_134/%d/%d/%d/%d", CIDListNodeID, CID_Save_Node[i], TotalCount, NodeListCount);
				static unsigned int nTmpCurNodeId19112102 = 0;
				if(nTmpCurNodeId19112102 != nCurrentNodeID)
				{
					nTmpCurNodeId19112102 = nCurrentNodeID;
					ADD_LOG("C_126/%d/%d", CIDListNodeID, CID_Save_Node[i]);
                }
				break;
			}
			NodeListCount++;
		}
	}
	//ADD_LOG("D-66");

	static unsigned int nTmpCurNodeId01510 = 0;
	if(nTmpCurNodeId01510 != nCurrentNodeID)
	{
		nTmpCurNodeId01510 = nCurrentNodeID;
		ADD_LOG("C-88");
	}

	return CIDChangeReturn;
}



/*
	OHT가 Manual모드일때 처리하는 함수이다
	Auto일 때에는 CID Status머신이 통합 처리하지만,
	Manual일 때에는 이 함수로 정리하여 처리하도록 한다
*/
UINT DrivingControl::Manual_CID(int iManualCtrl)
{
	DRIVING_HW_INFO_SET TmpHwInfo;

	static int iDelayCnt = 0;
	static unsigned char ManualSteerStatus = 0;//0 : 초기값, 1 : 명령과 센서값이 다른 경우 발생

	//조향
	//bool    bSteerFrontLeft = TmpHwInfo.IO.SteerFrontLeftInOn;
	//bool    bSteerFrontRight    = TmpHwInfo.IO.SteerFrontRightInOn;
	unsigned char SteerFront;
	unsigned char SteerRear;
	unsigned char SteerCmdFront;
	unsigned char SteerCmdRear;

	SteerFront = pHWSet->m_pSteer->GetFrontPos();
	SteerRear = pHWSet->m_pSteer->GetRearPos();
	SteerCmdFront = pHWSet->m_pSteer->GetFrontCmd();
	SteerCmdRear = pHWSet->m_pSteer->GetRearCmd();

	switch(iManualCtrl)
	{
		case MANUAL_CID_MODE: 	// Operation Mode를 CID로 변경
		{
			CID_OPERATION_MODE_CID();
			ADD_LOG("C-89");
		}
		break;

		case MANUAL_CID_SETTING: 	// Abnormal 세트 (O5는 1로 설정)
		{
			 pHWSet->m_pCID->CID_Manual_Mode_On();
			 ADD_LOG("C-90");
		}
		break;

		// 조향정보를 감시한다
		// Left or Right설정 (Left = O1, Right = O2) : AllOff후 해당방향을 켠다
		// 조향 정보를 알수 없는 경우 LH, RH 모두 On 가능한 동작인지 확인 필요...
		case MANUAL_CID_DIRECTION_CHK:
		{
			ADD_LOG("C_127/%d", SteerFront, SteerRear);
			if( SteerFront == SteerRear &&
				(SteerFront == HW_STEER_DIRECTION_RIGHT || SteerFront == HW_STEER_DIRECTION_LEFT))
			{
				if (SteerFront == HW_STEER_DIRECTION_RIGHT)
				{
					if(pHWSet->m_pCID->IsLinking_Left() == true)
					{
						pHWSet->m_pCID->CID_Out_PASS_Compt(ON);
						Sleep(20);
						pHWSet->m_pCID->CID_Out_PASS_Compt(OFF);

						pHWSet->m_pCID->CID_Out_Left_Select(OFF);
						pHWSet->m_pCID->CID_Occup_return(3);
						Sleep(20);

						ADD_LOG("C-91");
					}

					pHWSet->m_pCID->Right_Link();
					ADD_LOG("C-92");
				}
				else if(SteerFront == HW_STEER_DIRECTION_LEFT)
				{
					if(pHWSet->m_pCID->IsLinking_Right() == true)
					{
						pHWSet->m_pCID->CID_Out_PASS_Compt(ON);
						Sleep(20);
						pHWSet->m_pCID->CID_Out_PASS_Compt(OFF);

						pHWSet->m_pCID->CID_Out_Right_Select(OFF);
						pHWSet->m_pCID->CID_Occup_return(4);
						Sleep(20);
						ADD_LOG("C-93");
					}

					pHWSet->m_pCID->Left_Link();
					ADD_LOG("C-94");
				}
				else
				{
					//NOP
				}

				if(SteerCmdFront != SteerFront &&
					ManualSteerStatus == 1)
				{
					if(SteerFront == HW_STEER_DIRECTION_LEFT)
					{
						pHWSet->m_pSteer->SetFrontDirection(HW_STEER_DIRECTION_CMD_LEFT);
						pHWSet->m_pSteer->SetRearDirection(HW_STEER_DIRECTION_CMD_LEFT);
						ADD_LOG("C-95");
						ManualSteerStatus = 0;
					}
					else if(SteerFront == HW_STEER_DIRECTION_RIGHT)
					{
						pHWSet->m_pSteer->SetFrontDirection(HW_STEER_DIRECTION_CMD_RIGHT);
						pHWSet->m_pSteer->SetRearDirection(HW_STEER_DIRECTION_CMD_RIGHT);
						ADD_LOG("C-96");
						ManualSteerStatus = 0;
					}
					else
					{
						//NOP
					}

				}
			}
			else	//SteerFront != SteerRear
			{
				if(SteerCmdFront != SteerFront ||
					SteerCmdRear != SteerRear)
				{
					ADD_LOG("C-97");
					pHWSet->m_pCID->CID_Out_Right_Select(ON);
					pHWSet->m_pCID->CID_Out_Left_Select(ON);

					ManualSteerStatus = 1;
				}
			}


		}
		break;

		// 점유를 켠다 (O3 = 1).
		// 조향확인 단계 (MANUAL_CID_DIRECTION_CHK) 로 이동하여 반복 진행한다
		case MANUAL_CID_RESERVED_ON:
		{
			pHWSet->m_pCID->CID_Occup_OK();
			ADD_LOG("C-98");

		}
		break;

		case MANUAL_CID_RESERVED_OFF:
		{
			// pHWSet->m_pCID->CID_Output_Clear();
			pHWSet->m_pCID->CID_Occup_return(5);
			ADD_LOG("C-99");
		}
		break;

		case MANUAL_CID_ABNORMAL_MODE_ON:
		{
			pHWSet->m_pCID->CID_Manual_Mode_On();
			ADD_LOG("C-100");
		}
		break;

		case MANUAL_CID_ABNORMAL_MODE_OFF:
		{
			pHWSet->m_pCID->CID_Manual_Mode_Off();
			ADD_LOG("C-101");
		}
		break;

		case MANUAL_CID_LEFT_SELECT:
		{
			pHWSet->m_pCID->CID_Out_Right_Select(OFF);
			pHWSet->m_pCID->CID_Out_Left_Select(ON);
			ADD_LOG("C-102");
		}
		break;

		case MANUAL_CID_RIGHT_SELECT:
		{
			pHWSet->m_pCID->CID_Out_Left_Select(OFF);
			pHWSet->m_pCID->CID_Out_Right_Select(ON);
			ADD_LOG("C-103");
		}
		break;

		case MANUAL_CID_COMMON_TAG:
		{
			pHWSet->m_pCID->CID_Out_Common_Tag(6, true);	// Common Tag On
			Sleep(30);
			pHWSet->m_pCID->CID_Out_Common_Tag(7, false);	// Common Tag Off
		}
		break;
	}
}



#define OBS_DETECT_COUNT_LIMIT_FOR_STEER		20

/**
@brief    조향 상태 설정 및 명령 생성
@author  임태웅
@date    2013.08.06
@param pInfoSet 입력/변경되는 상태 정보
@param pSteerCtrl 조향 명령 정보
@return 에러 없으면 0반환, 있으면 에러 코드 반환
*/
UINT DrivingControl::checkSteer(DRIVING_INFO_SET *pInfoSet)
{
	UINT nTmpError = NO_ERR;

	DWORD dwCurrTime = timeGetTime();

	CTRL_INFO_OF_STEER SteerCtrl;
	memset(&SteerCtrl, 0, sizeof(CTRL_INFO_OF_STEER));

	CTRL_INFO_OF_STEER* pSteerCtrl = &(pInfoSet->Control.Steer);

	int nPreCheckCount = ((pInfoSet->HwInfo.Node.nPreCheckCount-pInfoSet->HwInfo.Node.nNodeCount)>1)
							?(pInfoSet->HwInfo.Node.nNodeCount+1)
							:(pInfoSet->HwInfo.Node.nPreCheckCount);

	DRIVING_CMD_INFO_OF_PATH* pPathInfo = getPathInfo(pInfoSet->HwInfo.Node.nNodeCount);

	//2 처음 시작할 때 PreCheck가 Node 를 넘어가있는 경우:
	//2 PreCheck 가 감지 되지 않아 무언 정지가 생길 수 있다.  이 경우 PreCheckCount 를 강제로 1로 만들어 준다
	if( (nPreCheckCount==0)
	&&  (pInfoSet->Position.bPreCheckIsOverFirstNode==true)
	)
	{
		nPreCheckCount=1;
	}

	//에러 발생으로 조향명령 미발생
	if(fabs(m_dCheckPrecheckNodecountPosition) > DIST_MARGIN_OF_NODE)
		return nTmpError;

	bool bSteerChangeAreaByGuide = isSteerChangeAreaByGuide();  // N분기 가이드 레일에 의해 조향이 변경되는 구간

	bool bCmdExist          = false;    // 조향 명령이 있을 경우
	bool bCmdStart[2]       = {false,}; // 조향 명령을 실시한 경우
	bool bTorqueDown[2] = {false,}; // 토크 변경을 실시한 경우
	bool bCmdArrived[2] = {false,}; // 조향이 명령 위치에 도달한 경우
	bool bCmdFinish[2]      = {false,}; // 전후 각각 조향 명령이 완료한 경우 ( 채터링 포함)
	bool bCmdCompleted      = false;    // 조향 명령 완료한 경우 ( 채터링 포함)

	bool bTorqueTraction[2] = {false,}; // Traction 토크로 변경 인가 여부
	static bool bTorqueTractionStart[2] = {false,}; // Traction 토크로 변경 명령 실행 flag

	bool bTorqueObstacle[2] = {false,}; 			// Obstacle 토크로 변경 인가 여부
	bool bTorqueObstacleEnd[2] = {false,}; 			// Obstacle 토크 종료
	static bool bTorqueObstacleStart[2] = {false,}; // Obstacle 토크로 변경 명령 실행 flag
	static HW_STEER_TORQUE SteerTorque4Obstacle[2] = {HW_STEER_TORQUE_STOP, HW_STEER_TORQUE_STOP};
	static int nObsDetectCntForSteer = 0;

	double  dSpeedOfNow                 = pInfoSet->HwInfo.Axis1.dSpeed;              //m_pDrivingAxis->GetCurrentPosition(); //미보정 현재 위치


	STEER_HW_INFO_CMD SteerCmd = STEER_HW_INFO_CMD_LEFT;

	int FromNode = 0, ToNode = 0;
	int CID_Fiber_Distance = 0;
	bool bNBranch = false;

	//1  명령 생성 가능성 확인
	if(bSteerChangeAreaByGuide==false)
	{
		bCmdExist = getSteerCmd(nPreCheckCount,&SteerCmd);  // EndNode Count 사용
//      ADD_LOG("D_135/%d/%d/%d",bCmdExist, nPreCheckCount, SteerCmd);
	}
	else
	{
		bCmdExist = getSteerCmdOnNBranch(&SteerCmd);
	}

	//1 상태 반영
	pInfoSet->Steer.PathSteer = (pPathInfo!=NULL)?pPathInfo->Steering:STEERING_NONE;
//	pInfoSet->Steer.PathDirection = (pPathInfo!=NULL)?pPathInfo->Direction:PATH_DIRECTION_NO_USE;
	pInfoSet->Steer.FrontPosition = getSteerPosition(pInfoSet->HwInfo.IO.SteerFrontLeftInOn, pInfoSet->HwInfo.IO.SteerFrontRightInOn);
	pInfoSet->Steer.RearPosition = getSteerPosition(pInfoSet->HwInfo.IO.SteerRearLeftInOn, pInfoSet->HwInfo.IO.SteerRearRightInOn);

	if(bCmdExist==true)
	{
//		if(SteerCmd!=pInfoSet->HwInfo.IO.SteerFrontDirCmd) //pInfoSet->Steer.FrontCmdDirection)
//		{
//			pInfoSet->Steer.FrontCmdDirection = SteerCmd;
//			pInfoSet->Steer.FrontMoving = true;
//			bCmdStart[0] = true;
//		}

		if((SteerCmd!=pInfoSet->HwInfo.IO.SteerFrontDirCmd) || (SteerCmd!=pInfoSet->HwInfo.IO.SteerRearDirCmd))//pInfoSet->Steer.RearCmdDirection)
		{

			pInfoSet->Steer.FrontCmdDirection = SteerCmd;
			pInfoSet->Steer.FrontMoving = true;
			bCmdStart[0] = true;

			pInfoSet->Steer.RearCmdDirection = SteerCmd;
			pInfoSet->Steer.RearMoving = true;
			bCmdStart[1] = true;

			if(SteerCmd == STEER_HW_INFO_CMD_LEFT)
			{
				if(m_mccparam.bSteerFrontRightFlag == true)
				{
					ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,STEER FRONT RIGHT,End,%s,%06d,%06d,%06d,%d,%3.3lf,Next Node Dist,%6.1lf,Steer Front Right Time,%d,Steer Front Right Hunting Count,%d,OHT Detect Output Status,%d,OBS Output Status,%d,Steer Front Left Off Time,%d,Steer Front Right On Time,%d,Steer Front Trq0 On Time,%d,Steer Front Trq0 Off Time,%d,Steer Front DIR On Time,%d,Max UBG Level,%d,Min UBG Level,%d,Max OBS Level,%d,Min OBS Level,%d",
							m_defualtparam->VHLName,m_mccparam.cCarrierType,
							m_mccparam.uSourceNode,
							m_mccparam.uTargetNode,
							m_pExecuteInfo->ExecutePositionInfo.CurrNode,
							m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
							dSpeedOfNow,
							pPathInfo->dLength - m_pOHTMainStatus->StatusCommon.CurNodeOffset,
							OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwSteerFrontTime),
							m_mccparam.nSteerFrontHauntingCount,
							m_pOHTDetect->GetUbgAreaStatus(),
							m_pObstacle->GetObsAreaStatus(),
							m_mccparam.dwSteerFLeftOffTime,
							m_mccparam.dwSteerFRightOnTime,
							m_mccparam.dwSteerFTRQ0OnTime,
							m_mccparam.dwSteerFTRQ0OffTime,
							m_mccparam.dwSteerFDIROnTime,
							m_mccparam.nUBGMaxOnSteering,
							m_mccparam.nUBGMinOnSteering,
							m_mccparam.nOBSMaxOnSteering,
							m_mccparam.nOBSMinOnSteering);

//					AUTO_RECOV_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,STEER FRONT RIGHT,End,%s,%06d,%06d,%06d,%d,%3.3lf,Next Node Dist,%6.1lf,Steer Front Right Time,%d,Steer Front Right Hunting Count,%d,OHT Detect Output Status,%d,OBS Output Status,%d,Steer Front Left Off Time,%d,Steer Front Right On Time,%d,Steer Front Trq0 On Time,%d,Steer Front Trq0 Off Time,%d,Steer Front DIR On Time,%d,Max UBG Level,%d,Min UBG Level,%d,Max OBS Level,%d,Min OBS Level,%d,Right Front Recovery Time,%d,Right Steer Retry Count,%d",
//							m_defualtparam->VHLName,m_mccparam.cCarrierType,
//							m_mccparam.uSourceNode,
//							m_mccparam.uTargetNode,
//							m_pExecuteInfo->ExecutePositionInfo.CurrNode,
//							m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
//							dSpeedOfNow,
//							pPathInfo->dLength - m_pOHTMainStatus->StatusCommon.CurNodeOffset,
//							OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwSteerFrontTime),
//							m_mccparam.nSteerFrontHauntingCount,
//							m_pOHTDetect->GetUbgAreaStatus(),
//							m_pObstacle->GetObsAreaStatus(),
//							m_mccparam.dwSteerFLeftOffTime,
//							m_mccparam.dwSteerFRightOnTime,
//							m_mccparam.dwSteerFTRQ0OnTime,
//							m_mccparam.dwSteerFTRQ0OffTime,
//							m_mccparam.dwSteerFDIROnTime,
//							m_mccparam.nUBGMaxOnSteering,
//							m_mccparam.nUBGMinOnSteering,
//							m_mccparam.nOBSMaxOnSteering,
//							m_mccparam.nOBSMinOnSteering,
//							OHTUTILITY::PreventOverflowGetTimeMs(m_nRFrontSteerRecovery_Time),
//							m_nRightSteerRecovery_Cnt);
					ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,STEER REAR RIGHT,End,%s,%06d,%06d,%06d,%d,%3.3lf,Next Node Dist,%6.1lf,Steer Rear Right Time,%d,Steer Rear Right Hunting Count,%d,OHT Detect Output Status,%d,OBS Output Status,%d,Steer Rear Left Off Time,%d,Steer Rear Right On Time,%d,Steer Rear Trq0 On Time,%d,Steer Rear Trq0 Off Time,%d,Steer Rear DIR On Time,%d,Max UBG Level,%d,Min UBG Level,%d,Max OBS Level,%d,Min OBS Level,%d",
							m_defualtparam->VHLName,m_mccparam.cCarrierType,
							m_mccparam.uSourceNode,
							m_mccparam.uTargetNode,
							m_pExecuteInfo->ExecutePositionInfo.CurrNode,
							m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
							dSpeedOfNow,
							pPathInfo->dLength - m_pOHTMainStatus->StatusCommon.CurNodeOffset,
							OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwSteerRearTime),
							m_mccparam.nSteerRearHauntingCount,
							m_pOHTDetect->GetUbgAreaStatus(),
							m_pObstacle->GetObsAreaStatus(),
							m_mccparam.dwSteerRLeftOffTime,
							m_mccparam.dwSteerRRightOnTime,
							m_mccparam.dwSteerRTRQ0OnTime,
							m_mccparam.dwSteerRTRQ0OffTime,
							m_mccparam.dwSteerRDIROnTime,
							m_mccparam.nUBGMaxOnSteering,
							m_mccparam.nUBGMinOnSteering,
							m_mccparam.nOBSMaxOnSteering,
							m_mccparam.nOBSMinOnSteering);

//					AUTO_RECOV_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,STEER REAR RIGHT,End,%s,%06d,%06d,%06d,%d,%3.3lf,Next Node Dist,%6.1lf,Steer Rear Right Time,%d,Steer Rear Right Hunting Count,%d,OHT Detect Output Status,%d,OBS Output Status,%d,Steer Rear Left Off Time,%d,Steer Rear Right On Time,%d,Steer Rear Trq0 On Time,%d,Steer Rear Trq0 Off Time,%d,Steer Rear DIR On Time,%d,Max UBG Level,%d,Min UBG Level,%d,Max OBS Level,%d,Min OBS Level,%d,Right Rear Recovery Time,%d,Right Steer Retry Count,%d",
//							m_defualtparam->VHLName,m_mccparam.cCarrierType,
//							m_mccparam.uSourceNode,
//							m_mccparam.uTargetNode,
//							m_pExecuteInfo->ExecutePositionInfo.CurrNode,
//							m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
//							dSpeedOfNow,
//							pPathInfo->dLength - m_pOHTMainStatus->StatusCommon.CurNodeOffset,
//							OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwSteerRearTime),
//							m_mccparam.nSteerRearHauntingCount,
//							m_pOHTDetect->GetUbgAreaStatus(),
//							m_pObstacle->GetObsAreaStatus(),
//							m_mccparam.dwSteerRLeftOffTime,
//							m_mccparam.dwSteerRRightOnTime,
//							m_mccparam.dwSteerRTRQ0OnTime,
//							m_mccparam.dwSteerRTRQ0OffTime,
//							m_mccparam.dwSteerRDIROnTime,
//							m_mccparam.nUBGMaxOnSteering,
//							m_mccparam.nUBGMinOnSteering,
//							m_mccparam.nOBSMaxOnSteering,
//							m_mccparam.nOBSMinOnSteering,
//							OHTUTILITY::PreventOverflowGetTimeMs(m_nRRearSteerRecovery_Time),
//							m_nRightSteerRecovery_Cnt);

					m_mccparam.dwSteerFrontTime = 0;
					m_mccparam.bSteerFrontRightFlag = false;
					m_mccparam.nSteerFrontHauntingCount = 0;

					m_mccparam.dwSteerRearTime = 0;
					m_mccparam.bSteerRearLeftFlag = false;
					m_mccparam.nSteerRearHauntingCount = 0;
				}
				if(m_mccparam.bSteerFrontLeftFlag == false)
				{
					ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,STEER FRONT LEFT,Start,%s,%06d,%06d,%06d,%d,%3.3lf,Next Node Dist,%6.1lf,OHT Detect Output Status,%d,OBS Output Status,%d",
							m_defualtparam->VHLName,m_mccparam.cCarrierType,
								m_mccparam.uSourceNode,
								m_mccparam.uTargetNode,
								m_pExecuteInfo->ExecutePositionInfo.CurrNode,
								m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
								dSpeedOfNow,
								pPathInfo->dLength - m_pOHTMainStatus->StatusCommon.CurNodeOffset,
								m_pOHTDetect->GetUbgAreaStatus(),
								m_pObstacle->GetObsAreaStatus());
//					AUTO_RECOV_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,STEER FRONT LEFT,Start,%s,%06d,%06d,%06d,%d,%3.3lf,Next Node Dist,%6.1lf,OHT Detect Output Status,%d,OBS Output Status,%d",
//								m_defualtparam->VHLName,m_mccparam.cCarrierType,
//								m_mccparam.uSourceNode,
//								m_mccparam.uTargetNode,
//								m_pExecuteInfo->ExecutePositionInfo.CurrNode,
//								m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
//								dSpeedOfNow,
//								pPathInfo->dLength - m_pOHTMainStatus->StatusCommon.CurNodeOffset,
//								m_pOHTDetect->GetUbgAreaStatus(),
//								m_pObstacle->GetObsAreaStatus());

					ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,STEER REAR LEFT,Start,%s,%06d,%06d,%06d,%d,%3.3lf,Next Node Dist,%6.1lf,OHT Detect Output Status,%d,OBS Output Status,%d",
							m_defualtparam->VHLName,m_mccparam.cCarrierType,
								m_mccparam.uSourceNode,
								m_mccparam.uTargetNode,
								m_pExecuteInfo->ExecutePositionInfo.CurrNode,
								m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
								dSpeedOfNow,
								pPathInfo->dLength - m_pOHTMainStatus->StatusCommon.CurNodeOffset,
								m_pOHTDetect->GetUbgAreaStatus(),
								m_pObstacle->GetObsAreaStatus());
//					AUTO_RECOV_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,STEER REAR LEFT,Start,%s,%06d,%06d,%06d,%d,%3.3lf,Next Node Dist,%6.1lf,OHT Detect Output Status,%d,OBS Output Status,%d",
//								m_defualtparam->VHLName,m_mccparam.cCarrierType,
//								m_mccparam.uSourceNode,
//								m_mccparam.uTargetNode,
//								m_pExecuteInfo->ExecutePositionInfo.CurrNode,
//								m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
//								dSpeedOfNow,
//								pPathInfo->dLength - m_pOHTMainStatus->StatusCommon.CurNodeOffset,
//								m_pOHTDetect->GetUbgAreaStatus(),
//								m_pObstacle->GetObsAreaStatus());
					if(m_mccparam.dwSteerFrontTime == 0)
					{
						m_mccparam.dwSteerFrontTime = timeGetTime();
						m_mccparam.dwSteerRearTime = timeGetTime();
					}
					m_mccparam.bSteerFrontLeftFlag = true;
					m_mccparam.bSteerRearLeftFlag = true;

					Check_Node = m_pExecuteInfo->ExecutePositionInfo.CurrNode;
					Check_AutoRecovery_PreCheck = nPreCheckCount;
				}
			}
			else if(SteerCmd == STEER_HW_INFO_CMD_RIGHT)
			{
				if(m_mccparam.bSteerFrontLeftFlag == true)
				{
					ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,STEER FRONT LEFT,End,%s,%06d,%06d,%06d,%d,%3.3lf,Next Node Dist,%6.1lf,Steer Front Left Time,%d,Steer Front Left Hunting Count,%d,OHT Detect Output Status,%d,OBS Output Status,%d,Steer Front Right Off Time,%d,Steer Front Left On Time,%d,Steer Front Trq0 On Time,%d,Steer Front Trq0 Off Time,%d,Steer Front DIR Off Time,%d,Max UBG Level,%d,Min UBG Level,%d,Max OBS Level,%d,Min OBS Level,%d",
							m_defualtparam->VHLName,m_mccparam.cCarrierType,
							m_mccparam.uSourceNode,
							m_mccparam.uTargetNode,
							m_pExecuteInfo->ExecutePositionInfo.CurrNode,
							m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
							dSpeedOfNow,
							pPathInfo->dLength - m_pOHTMainStatus->StatusCommon.CurNodeOffset,
							OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwSteerFrontTime),
							m_mccparam.nSteerFrontHauntingCount,
							m_pOHTDetect->GetUbgAreaStatus(),
							m_pObstacle->GetObsAreaStatus(),
							m_mccparam.dwSteerFRightOffTime,
							m_mccparam.dwSteerFLeftOnTime,
							m_mccparam.dwSteerFTRQ0OnTime,
							m_mccparam.dwSteerFTRQ0OffTime,
							m_mccparam.dwSteerFTDIROffTime,
							m_mccparam.nUBGMaxOnSteering,
							m_mccparam.nUBGMinOnSteering,
							m_mccparam.nOBSMaxOnSteering,
							m_mccparam.nOBSMinOnSteering);

//					AUTO_RECOV_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,STEER FRONT LEFT,End,%s,%06d,%06d,%06d,%d,%3.3lf,Next Node Dist,%6.1lf,Steer Front Left Time,%d,Steer Front Left Hunting Count,%d,OHT Detect Output Status,%d,OBS Output Status,%d,Steer Front Right Off Time,%d,Steer Front Left On Time,%d,Steer Front Trq0 On Time,%d,Steer Front Trq0 Off Time,%d,Steer Front DIR Off Time,%d,Max UBG Level,%d,Min UBG Level,%d,Max OBS Level,%d,Min OBS Level,%d,Left Front Recovery Time,%d,Left Steer Retry Count,%d",
//							m_defualtparam->VHLName,m_mccparam.cCarrierType,
//							m_mccparam.uSourceNode,
//							m_mccparam.uTargetNode,
//							m_pExecuteInfo->ExecutePositionInfo.CurrNode,
//							m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
//							dSpeedOfNow,
//							pPathInfo->dLength - m_pOHTMainStatus->StatusCommon.CurNodeOffset,
//							OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwSteerFrontTime),
//							m_mccparam.nSteerFrontHauntingCount,
//							m_pOHTDetect->GetUbgAreaStatus(),
//							m_pObstacle->GetObsAreaStatus(),
//							m_mccparam.dwSteerFRightOffTime,
//							m_mccparam.dwSteerFLeftOnTime,
//							m_mccparam.dwSteerFTRQ0OnTime,
//							m_mccparam.dwSteerFTRQ0OffTime,
//							m_mccparam.dwSteerFTDIROffTime,
//							m_mccparam.nUBGMaxOnSteering,
//							m_mccparam.nUBGMinOnSteering,
//							m_mccparam.nOBSMaxOnSteering,
//							m_mccparam.nOBSMinOnSteering,
//							OHTUTILITY::PreventOverflowGetTimeMs(m_nLFrontSteerRecovery_Time),
//							m_nLeftSteerRecovery_Cnt);

					ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,STEER REAR LEFT,End,%s,%06d,%06d,%06d,%d,%3.3lf,Next Node Dist,%6.1lf,Steer Rear Left Time,%d,Steer Rear Left Hunting Count,%d,OHT Detect Output Status,%d,OBS Output Status,%d,Steer Rear Right Off Time,%d,Steer Rear Left On Time,%d,Steer Rear Trq0 On Time,%d,Steer Rear Trq0 Off Time,%d,Steer Rear DIR Off Time,%d,Max UBG Level,%d,Min UBG Level,%d,Max OBS Level,%d,Min OBS Level,%d",
							m_defualtparam->VHLName,m_mccparam.cCarrierType,
							m_mccparam.uSourceNode,
							m_mccparam.uTargetNode,
							m_pExecuteInfo->ExecutePositionInfo.CurrNode,
							m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
							dSpeedOfNow,
							pPathInfo->dLength - m_pOHTMainStatus->StatusCommon.CurNodeOffset,
							OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwSteerRearTime),
							m_mccparam.nSteerRearHauntingCount,
							m_pOHTDetect->GetUbgAreaStatus(),
							m_pObstacle->GetObsAreaStatus(),
							m_mccparam.dwSteerRRightOffTime,
							m_mccparam.dwSteerRLeftOnTime,
							m_mccparam.dwSteerRTRQ0OnTime,
							m_mccparam.dwSteerRTRQ0OffTime,
							m_mccparam.dwSteerRDIROffTime,
							m_mccparam.nUBGMaxOnSteering,
							m_mccparam.nUBGMinOnSteering,
							m_mccparam.nOBSMaxOnSteering,
							m_mccparam.nOBSMinOnSteering);

//					AUTO_RECOV_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,STEER REAR LEFT,End,%s,%06d,%06d,%06d,%d,%3.3lf,Next Node Dist,%6.1lf,Steer Rear Left Time,%d,Steer Rear Left Hunting Count,%d,OHT Detect Output Status,%d,OBS Output Status,%d,Steer Rear Right Off Time,%d,Steer Rear Left On Time,%d,Steer Rear Trq0 On Time,%d,Steer Rear Trq0 Off Time,%d,Steer Rear DIR Off Time,%d,Max UBG Level,%d,Min UBG Level,%d,Max OBS Level,%d,Min OBS Level,%d,Left Rear Recovery Time,%d,Left Steer Retry Count,%d",
//							m_defualtparam->VHLName,m_mccparam.cCarrierType,
//							m_mccparam.uSourceNode,
//							m_mccparam.uTargetNode,
//							m_pExecuteInfo->ExecutePositionInfo.CurrNode,
//							m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
//							dSpeedOfNow,
//							pPathInfo->dLength - m_pOHTMainStatus->StatusCommon.CurNodeOffset,
//							OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwSteerRearTime),
//							m_mccparam.nSteerRearHauntingCount,
//							m_pOHTDetect->GetUbgAreaStatus(),
//							m_pObstacle->GetObsAreaStatus(),
//							m_mccparam.dwSteerRRightOffTime,
//							m_mccparam.dwSteerRLeftOnTime,
//							m_mccparam.dwSteerRTRQ0OnTime,
//							m_mccparam.dwSteerRTRQ0OffTime,
//							m_mccparam.dwSteerRDIROffTime,
//							m_mccparam.nUBGMaxOnSteering,
//							m_mccparam.nUBGMinOnSteering,
//							m_mccparam.nOBSMaxOnSteering,
//							m_mccparam.nOBSMinOnSteering,
//							OHTUTILITY::PreventOverflowGetTimeMs(m_nLRearSteerRecovery_Time),
//							m_nLeftSteerRecovery_Cnt);
					m_mccparam.dwSteerFrontTime = 0;
					m_mccparam.bSteerFrontLeftFlag = false;
					m_mccparam.nSteerFrontHauntingCount = 0;

					m_mccparam.dwSteerRearTime = 0;
					m_mccparam.bSteerRearLeftFlag = false;
					m_mccparam.nSteerRearHauntingCount = 0;
				}

				if(m_mccparam.bSteerFrontRightFlag == false)
				{
					ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,STEER FRONT RIGHT,Start,%s,%06d,%06d,%06d,%d,%3.3lf,Next Node Dist,%6.1lf,OHT Detect Output Status,%d,OBS Output Status,%d",
								m_defualtparam->VHLName,m_mccparam.cCarrierType,
								m_mccparam.uSourceNode,
								m_mccparam.uTargetNode,
								m_pExecuteInfo->ExecutePositionInfo.CurrNode,
								m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
								dSpeedOfNow,
								pPathInfo->dLength - m_pOHTMainStatus->StatusCommon.CurNodeOffset,
								m_pOHTDetect->GetUbgAreaStatus(),
								m_pObstacle->GetObsAreaStatus());
//					AUTO_RECOV_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,STEER FRONT RIGHT,Start,%s,%06d,%06d,%06d,%d,%3.3lf,Next Node Dist,%6.1lf,OHT Detect Output Status,%d,OBS Output Status,%d",
//								m_defualtparam->VHLName,m_mccparam.cCarrierType,
//								m_mccparam.uSourceNode,
//								m_mccparam.uTargetNode,
//								m_pExecuteInfo->ExecutePositionInfo.CurrNode,
//								m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
//								dSpeedOfNow,
//								pPathInfo->dLength - m_pOHTMainStatus->StatusCommon.CurNodeOffset,
//								m_pOHTDetect->GetUbgAreaStatus(),
//								m_pObstacle->GetObsAreaStatus());
					ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,STEER REAR RIGHT,Start,%s,%06d,%06d,%06d,%d,%3.3lf,Next Node Dist,%6.1lf,OHT Detect Output Status,%d,OBS Output Status,%d",
								m_defualtparam->VHLName,m_mccparam.cCarrierType,
								m_mccparam.uSourceNode,
								m_mccparam.uTargetNode,
								m_pExecuteInfo->ExecutePositionInfo.CurrNode,
								m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
								dSpeedOfNow,
								pPathInfo->dLength - m_pOHTMainStatus->StatusCommon.CurNodeOffset,
								m_pOHTDetect->GetUbgAreaStatus(),
								m_pObstacle->GetObsAreaStatus());
//					AUTO_RECOV_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,STEER REAR RIGHT,Start,%s,%06d,%06d,%06d,%d,%3.3lf,Next Node Dist,%6.1lf,OHT Detect Output Status,%d,OBS Output Status,%d",
//								m_defualtparam->VHLName,m_mccparam.cCarrierType,
//								m_mccparam.uSourceNode,
//								m_mccparam.uTargetNode,
//								m_pExecuteInfo->ExecutePositionInfo.CurrNode,
//								m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
//								dSpeedOfNow,
//								pPathInfo->dLength - m_pOHTMainStatus->StatusCommon.CurNodeOffset,
//								m_pOHTDetect->GetUbgAreaStatus(),
//								m_pObstacle->GetObsAreaStatus());
					if(m_mccparam.dwSteerFrontTime == 0)
					{
						m_mccparam.dwSteerFrontTime = timeGetTime();
						m_mccparam.dwSteerRearTime = timeGetTime();
					}
					m_mccparam.bSteerFrontRightFlag = true;
					m_mccparam.bSteerRearRightFlag = true;

					Check_Node = m_pExecuteInfo->ExecutePositionInfo.CurrNode;
					Check_AutoRecovery_PreCheck = nPreCheckCount;
				}
            }
		}
	}

	if(pInfoSet->Steer.FrontCmdDirection==STEER_HW_INFO_CMD_LEFT)
	{
		if(pInfoSet->HwInfo.IO.SteerFrontLeftInOn==true)
		{
			bCmdArrived[0] = true;
			pHWSet->m_pCID->CID_Steerring_N_Branch_Select_Off();
		}
		if(pInfoSet->HwInfo.IO.SteerRearLeftInOn==true)     bCmdArrived[1] = true;
	}
	if(pInfoSet->Steer.FrontCmdDirection==STEER_HW_INFO_CMD_RIGHT)
	{
		if(pInfoSet->HwInfo.IO.SteerFrontRightInOn==true)
		{
			bCmdArrived[0] = true;
			pHWSet->m_pCID->CID_Steerring_N_Branch_Select_Off();
		}
		if(pInfoSet->HwInfo.IO.SteerRearRightInOn==true)    bCmdArrived[1] = true;
	}

	if((bCmdExist==false) || ((pInfoSet->HwInfo.IO.SteerFrontDirCmd==pInfoSet->Steer.FrontCmdDirection) && (pInfoSet->HwInfo.IO.SteerRearDirCmd==pInfoSet->Steer.RearCmdDirection)))
	{
		if(     (pInfoSet->Time.Steer.FrontSteeringDeparted.bFlag==true)
			&&  (OHTUTILITY::PreventOverflowGetTimeMs(pInfoSet->Time.Steer.FrontSteeringDeparted.dwTime)>m_pParamSet->Steer.dwMovingTorqueTime)
			&&  (pInfoSet->HwInfo.IO.SteerFrontTorque!=HW_STEER_TORQUE_STOP)
		)
		{
			bTorqueDown[0] = true;
		}
		if(     (pInfoSet->Time.Steer.RearSteeringDeparted.bFlag==true)
			&&  (OHTUTILITY::PreventOverflowGetTimeMs(pInfoSet->Time.Steer.RearSteeringDeparted.dwTime)>m_pParamSet->Steer.dwMovingTorqueTime)
			&&  (pInfoSet->HwInfo.IO.SteerRearTorque!=HW_STEER_TORQUE_STOP)
		)
		{
			bTorqueDown[1] = true;

		}
	}
//	 ADD_LOG("D_136/%d/%d/%d", bCmdExist,pInfoSet->Steer.FrontCmdDirection,pInfoSet->Steer.RearCmdDirection);
	if( (bCmdExist==false) || ((pInfoSet->HwInfo.IO.SteerFrontDirCmd==pInfoSet->Steer.FrontCmdDirection) && (pInfoSet->HwInfo.IO.SteerRearDirCmd==pInfoSet->Steer.RearCmdDirection)))
	{
		if(     (pInfoSet->Time.Steer.FrontSteeringArrived.bFlag==true)
			&&  (OHTUTILITY::PreventOverflowGetTimeMs(pInfoSet->Time.Steer.FrontSteeringArrived.dwTime)>m_pParamSet->Steer.dwCompleteCheckTime)
			&&  (pInfoSet->HwInfo.IO.DetectStatus != DETECT_AND_STOP)
			&&  (pInfoSet->Steer.FrontMoving==true)
		)
		{
			pInfoSet->Steer.FrontMoving = false;
			bTorqueTractionStart[0] = false;
			bCmdFinish[0] = true;
//			m_pSteer->CalculateMaxFrontMovingTime();//doori.shin Front Steering 이동시간 계산

			if(pInfoSet->HwInfo.IO.SteerFrontTorque!=1) bTorqueDown[0] = true;

			if(pInfoSet->HwInfo.IO.SteerFrontLeftInOn==true)
			{
				ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,STEER FRONT LEFT,End,%s,%06d,%06d,%06d,%d,%3.3lf,Next Node Dist,%6.1lf,Steer Front Left Time,%d,Steer Front Left Hunting Count,%d,OHT Detect Output Status,%d,OBS Output Status,%d,Steer Front Right Off Time,%d,Steer Front Left On Time,%d,Steer Front Trq0 On Time,%d,Steer Front Trq0 Off Time,%d,Steer Front DIR Off Time,%d,Max UBG Level,%d,Min UBG Level,%d,Max OBS Level,%d,Min OBS Level,%d",
							m_defualtparam->VHLName,m_mccparam.cCarrierType,
							m_mccparam.uSourceNode,
							m_mccparam.uTargetNode,
							m_pExecuteInfo->ExecutePositionInfo.CurrNode,
							m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
							dSpeedOfNow,
							pPathInfo->dLength - m_pOHTMainStatus->StatusCommon.CurNodeOffset,
							OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwSteerFrontTime),
							m_mccparam.nSteerFrontHauntingCount,
							m_pOHTDetect->GetUbgAreaStatus(),
							m_pObstacle->GetObsAreaStatus(),
							m_mccparam.dwSteerFRightOffTime,
							m_mccparam.dwSteerFLeftOnTime,
							m_mccparam.dwSteerFTRQ0OnTime,
							m_mccparam.dwSteerFTRQ0OffTime,
							m_mccparam.dwSteerFTDIROffTime,
							m_mccparam.nUBGMaxOnSteering,
							m_mccparam.nUBGMinOnSteering,
							m_mccparam.nOBSMaxOnSteering,
							m_mccparam.nOBSMinOnSteering);

//				AUTO_RECOV_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,STEER FRONT LEFT,End,%s,%06d,%06d,%06d,%d,%3.3lf,Next Node Dist,%6.1lf,Steer Front Left Time,%d,Steer Front Left Hunting Count,%d,OHT Detect Output Status,%d,OBS Output Status,%d,Steer Front Right Off Time,%d,Steer Front Left On Time,%d,Steer Front Trq0 On Time,%d,Steer Front Trq0 Off Time,%d,Steer Front DIR Off Time,%d,Max UBG Level,%d,Min UBG Level,%d,Max OBS Level,%d,Min OBS Level,%d,Left Front Recovery Time,%d,Left Steer Retry Count,%d",
//							m_defualtparam->VHLName,m_mccparam.cCarrierType,
//							m_mccparam.uSourceNode,
//							m_mccparam.uTargetNode,
//							m_pExecuteInfo->ExecutePositionInfo.CurrNode,
//							m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
//							dSpeedOfNow,
//							pPathInfo->dLength - m_pOHTMainStatus->StatusCommon.CurNodeOffset,
//							OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwSteerFrontTime),
//							m_mccparam.nSteerFrontHauntingCount,
//							m_pOHTDetect->GetUbgAreaStatus(),
//							m_pObstacle->GetObsAreaStatus(),
//							m_mccparam.dwSteerFRightOffTime,
//							m_mccparam.dwSteerFLeftOnTime,
//							m_mccparam.dwSteerFTRQ0OnTime,
//							m_mccparam.dwSteerFTRQ0OffTime,
//							m_mccparam.dwSteerFTDIROffTime,
//							m_mccparam.nUBGMaxOnSteering,
//							m_mccparam.nUBGMinOnSteering,
//							m_mccparam.nOBSMaxOnSteering,
//							m_mccparam.nOBSMinOnSteering,
//							OHTUTILITY::PreventOverflowGetTimeMs(m_nLFrontSteerRecovery_Time),
//							m_nLeftSteerRecovery_Cnt);
				m_mccparam.dwSteerFrontTime = 0;
				m_mccparam.bSteerFrontLeftFlag = false;
				m_mccparam.nSteerFrontHauntingCount = 0;
			}
			if(pInfoSet->HwInfo.IO.SteerFrontRightInOn==true)
			{
				ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,STEER FRONT RIGHT,End,%s,%06d,%06d,%06d,%d,%3.3lf,Next Node Dist,%6.1lf,Steer Front Right Time,%d,Steer Front Right Hunting Count,%d,OHT Detect Output Status,%d,OBS Output Status,%d,Steer Front Left Off Time,%d,Steer Front Right On Time,%d,Steer Front Trq0 On Time,%d,Steer Front Trq0 Off Time,%d,Steer Front DIR On Time,%d,Max UBG Level,%d,Min UBG Level,%d,Max OBS Level,%d,Min OBS Level,%d",
							m_defualtparam->VHLName,m_mccparam.cCarrierType,
							m_mccparam.uSourceNode,
							m_mccparam.uTargetNode,
							m_pExecuteInfo->ExecutePositionInfo.CurrNode,
							m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
							dSpeedOfNow,
							pPathInfo->dLength - m_pOHTMainStatus->StatusCommon.CurNodeOffset,
							OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwSteerFrontTime),
							m_mccparam.nSteerFrontHauntingCount,
							m_pOHTDetect->GetUbgAreaStatus(),
							m_pObstacle->GetObsAreaStatus(),
							m_mccparam.dwSteerFLeftOffTime,
							m_mccparam.dwSteerFRightOnTime,
							m_mccparam.dwSteerFTRQ0OnTime,
							m_mccparam.dwSteerFTRQ0OffTime,
							m_mccparam.dwSteerFDIROnTime,
							m_mccparam.nUBGMaxOnSteering,
							m_mccparam.nUBGMinOnSteering,
							m_mccparam.nOBSMaxOnSteering,
							m_mccparam.nOBSMinOnSteering);
//				AUTO_RECOV_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,STEER FRONT RIGHT,End,%s,%06d,%06d,%06d,%d,%3.3lf,Next Node Dist,%6.1lf,Steer Front Right Time,%d,Steer Front Right Hunting Count,%d,OHT Detect Output Status,%d,OBS Output Status,%d,Steer Front Left Off Time,%d,Steer Front Right On Time,%d,Steer Front Trq0 On Time,%d,Steer Front Trq0 Off Time,%d,Steer Front DIR On Time,%d,Max UBG Level,%d,Min UBG Level,%d,Max OBS Level,%d,Min OBS Level,%d,Right Front Recovery Time,%d,Right Steer Retry Count,%d",
//							m_defualtparam->VHLName,m_mccparam.cCarrierType,
//							m_mccparam.uSourceNode,
//							m_mccparam.uTargetNode,
//							m_pExecuteInfo->ExecutePositionInfo.CurrNode,
//							m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
//							dSpeedOfNow,
//							pPathInfo->dLength - m_pOHTMainStatus->StatusCommon.CurNodeOffset,
//							OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwSteerFrontTime),
//							m_mccparam.nSteerFrontHauntingCount,
//							m_pOHTDetect->GetUbgAreaStatus(),
//							m_pObstacle->GetObsAreaStatus(),
//							m_mccparam.dwSteerFLeftOffTime,
//							m_mccparam.dwSteerFRightOnTime,
//							m_mccparam.dwSteerFTRQ0OnTime,
//							m_mccparam.dwSteerFTRQ0OffTime,
//							m_mccparam.dwSteerFDIROnTime,
//							m_mccparam.nUBGMaxOnSteering,
//							m_mccparam.nUBGMinOnSteering,
//							m_mccparam.nOBSMaxOnSteering,
//							m_mccparam.nOBSMinOnSteering,
//							OHTUTILITY::PreventOverflowGetTimeMs(m_nRFrontSteerRecovery_Time),
//							m_nRightSteerRecovery_Cnt);

				m_mccparam.dwSteerFrontTime = 0;
				m_mccparam.bSteerFrontRightFlag = false;
				m_mccparam.nSteerFrontHauntingCount = 0;
			}
		}
		if(     (pInfoSet->Time.Steer.RearSteeringArrived.bFlag==true)
			&&  (OHTUTILITY::PreventOverflowGetTimeMs(pInfoSet->Time.Steer.RearSteeringArrived.dwTime)>m_pParamSet->Steer.dwCompleteCheckTime)
			&&  (pInfoSet->HwInfo.IO.DetectStatus != DETECT_AND_STOP)
			&&  (pInfoSet->Steer.RearMoving==true)
		)
		{
			pInfoSet->Steer.RearMoving = false;
			bTorqueTractionStart[1] = false;
			bCmdFinish[1] = true;
//			m_pSteer->CalculateMaxRearMovingTime(); //doori.shin Rear Steering 이동시간 계산

			if(pInfoSet->HwInfo.IO.SteerRearTorque!=1)  bTorqueDown[1] = true;

			if(pInfoSet->HwInfo.IO.SteerRearLeftInOn==true)
			{
				ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,STEER REAR LEFT,End,%s,%06d,%06d,%06d,%d,%3.3lf,Next Node Dist,%6.1lf,Steer Rear Left Time,%d,Steer Rear Left Hunting Count,%d,OHT Detect Output Status,%d,OBS Output Status,%d,Steer Rear Right Off Time,%d,Steer Rear Left On Time,%d,Steer Rear Trq0 On Time,%d,Steer Rear Trq0 Off Time,%d,Steer Rear DIR Off Time,%d,Max UBG Level,%d,Min UBG Level,%d,Max OBS Level,%d,Min OBS Level,%d",
							m_defualtparam->VHLName,m_mccparam.cCarrierType,
							m_mccparam.uSourceNode,
							m_mccparam.uTargetNode,
							m_pExecuteInfo->ExecutePositionInfo.CurrNode,
							m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
							dSpeedOfNow,
							pPathInfo->dLength - m_pOHTMainStatus->StatusCommon.CurNodeOffset,
							OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwSteerRearTime),
							m_mccparam.nSteerRearHauntingCount,
							m_pOHTDetect->GetUbgAreaStatus(),
							m_pObstacle->GetObsAreaStatus(),
							m_mccparam.dwSteerRRightOffTime,
							m_mccparam.dwSteerRLeftOnTime,
							m_mccparam.dwSteerRTRQ0OnTime,
							m_mccparam.dwSteerRTRQ0OffTime,
							m_mccparam.dwSteerRDIROffTime,
							m_mccparam.nUBGMaxOnSteering,
							m_mccparam.nUBGMinOnSteering,
							m_mccparam.nOBSMaxOnSteering,
							m_mccparam.nOBSMinOnSteering);

//				AUTO_RECOV_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,STEER REAR LEFT,End,%s,%06d,%06d,%06d,%d,%3.3lf,Next Node Dist,%6.1lf,Steer Rear Left Time,%d,Steer Rear Left Hunting Count,%d,OHT Detect Output Status,%d,OBS Output Status,%d,Steer Rear Right Off Time,%d,Steer Rear Left On Time,%d,Steer Rear Trq0 On Time,%d,Steer Rear Trq0 Off Time,%d,Steer Rear DIR Off Time,%d,Max UBG Level,%d,Min UBG Level,%d,Max OBS Level,%d,Min OBS Level,%d,Left Rear Recovery Time,%d,Left Steer Retry Count,%d",
//							m_defualtparam->VHLName,m_mccparam.cCarrierType,
//							m_mccparam.uSourceNode,
//							m_mccparam.uTargetNode,
//							m_pExecuteInfo->ExecutePositionInfo.CurrNode,
//							m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
//							dSpeedOfNow,
//							pPathInfo->dLength - m_pOHTMainStatus->StatusCommon.CurNodeOffset,
//							OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwSteerRearTime),
//							m_mccparam.nSteerRearHauntingCount,
//							m_pOHTDetect->GetUbgAreaStatus(),
//							m_pObstacle->GetObsAreaStatus(),
//							m_mccparam.dwSteerRRightOffTime,
//							m_mccparam.dwSteerRLeftOnTime,
//							m_mccparam.dwSteerRTRQ0OnTime,
//							m_mccparam.dwSteerRTRQ0OffTime,
//							m_mccparam.dwSteerRDIROffTime,
//							m_mccparam.nUBGMaxOnSteering,
//							m_mccparam.nUBGMinOnSteering,
//							m_mccparam.nOBSMaxOnSteering,
//							m_mccparam.nOBSMinOnSteering,
//							OHTUTILITY::PreventOverflowGetTimeMs(m_nLRearSteerRecovery_Time),
//							m_nLeftSteerRecovery_Cnt);
				m_mccparam.dwSteerRearTime = 0;
				m_mccparam.bSteerRearLeftFlag = false;
				m_mccparam.nSteerRearHauntingCount = 0;
			}
			if(pInfoSet->HwInfo.IO.SteerRearRightInOn==true)
			{
				ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,STEER REAR RIGHT,End,%s,%06d,%06d,%06d,%d,%3.3lf,Next Node Dist,%6.1lf,Steer Rear Right Time,%d,Steer Rear Right Hunting Count,%d,OHT Detect Output Status,%d,OBS Output Status,%d,Steer Rear Left Off Time,%d,Steer Rear Right On Time,%d,Steer Rear Trq0 On Time,%d,Steer Rear Trq0 Off Time,%d,Steer Rear DIR On Time,%d,Max UBG Level,%d,Min UBG Level,%d,Max OBS Level,%d,Min OBS Level,%d",
							m_defualtparam->VHLName,m_mccparam.cCarrierType,
							m_mccparam.uSourceNode,
							m_mccparam.uTargetNode,
							m_pExecuteInfo->ExecutePositionInfo.CurrNode,
							m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
							dSpeedOfNow,
							pPathInfo->dLength - m_pOHTMainStatus->StatusCommon.CurNodeOffset,
							OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwSteerRearTime),
							m_mccparam.nSteerRearHauntingCount,
							m_pOHTDetect->GetUbgAreaStatus(),
							m_pObstacle->GetObsAreaStatus(),
							m_mccparam.dwSteerRLeftOffTime,
							m_mccparam.dwSteerRRightOnTime,
							m_mccparam.dwSteerRTRQ0OnTime,
							m_mccparam.dwSteerRTRQ0OffTime,
							m_mccparam.dwSteerRDIROnTime,
							m_mccparam.nUBGMaxOnSteering,
							m_mccparam.nUBGMinOnSteering,
							m_mccparam.nOBSMaxOnSteering,
							m_mccparam.nOBSMinOnSteering);
//				AUTO_RECOV_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,STEER REAR RIGHT,End,%s,%06d,%06d,%06d,%d,%3.3lf,Next Node Dist,%6.1lf,Steer Rear Right Time,%d,Steer Rear Right Hunting Count,%d,OHT Detect Output Status,%d,OBS Output Status,%d,Steer Rear Left Off Time,%d,Steer Rear Right On Time,%d,Steer Rear Trq0 On Time,%d,Steer Rear Trq0 Off Time,%d,Steer Rear DIR On Time,%d,Max UBG Level,%d,Min UBG Level,%d,Max OBS Level,%d,Min OBS Level,%d,Right Rear Recovery Time,%d,Right Steer Retry Count,%d",
//							m_defualtparam->VHLName,m_mccparam.cCarrierType,
//							m_mccparam.uSourceNode,
//							m_mccparam.uTargetNode,
//							m_pExecuteInfo->ExecutePositionInfo.CurrNode,
//							m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
//							dSpeedOfNow,
//							pPathInfo->dLength - m_pOHTMainStatus->StatusCommon.CurNodeOffset,
//							OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwSteerRearTime),
//							m_mccparam.nSteerRearHauntingCount,
//							m_pOHTDetect->GetUbgAreaStatus(),
//							m_pObstacle->GetObsAreaStatus(),
//							m_mccparam.dwSteerRLeftOffTime,
//							m_mccparam.dwSteerRRightOnTime,
//							m_mccparam.dwSteerRTRQ0OnTime,
//							m_mccparam.dwSteerRTRQ0OffTime,
//							m_mccparam.dwSteerRDIROnTime,
//							m_mccparam.nUBGMaxOnSteering,
//							m_mccparam.nUBGMinOnSteering,
//							m_mccparam.nOBSMaxOnSteering,
//							m_mccparam.nOBSMinOnSteering,
//							OHTUTILITY::PreventOverflowGetTimeMs(m_nRRearSteerRecovery_Time),
//							m_nRightSteerRecovery_Cnt);

				m_mccparam.dwSteerRearTime = 0;
				m_mccparam.bSteerRearLeftFlag = false;
				m_mccparam.nSteerRearHauntingCount = 0;
			}
		}

		if( (pInfoSet->Steer.FrontMoving==false) && (pInfoSet->Steer.RearMoving==false) )
		{
			bCmdCompleted = true;
			if(pInfoSet->EventAndState.State.SteerAllCompleted==false)
			{
				ADD_LOG("D_137/%d", bCmdCompleted);

//				m_pSteer->IncreaseSteerMovingCount();//doori.shin Steering 이동시간 증가
			}
		}
	}


	//1 Time 확인
	//--------------------------------------------------------------------------------------//
	if((bCmdStart[0]==true) || (bCmdStart[1]==true))
	{
		pInfoSet->Time.Steer.SteeringChangeCmded.bFlag = true;
		pInfoSet->Time.Steer.SteeringChangeCmded.dwTime = dwCurrTime;
	}
	else if(bCmdCompleted==true)
	{
		pInfoSet->Time.Steer.SteeringChangeCmded.bFlag = false;
	}

	if(pInfoSet->Time.Steer.SteeringChangeCmded.bFlag == true)
	{
#if(UBG_SENSOR_ENABLE==ON)
		if( (pInfoSet->HwInfo.IO.DetectStatus == DETECT_AND_STOP)
		||  (pInfoSet->HwInfo.IO.ObsStatus == DETECT_AND_STOP)
		||  (pHWSet->GetAMCPauseStatus() == STATUS_OHT_PAUSED)
		)
#else
		if(pInfoSet->HwInfo.IO.ObsStatus==DETECT_AND_STOP)
#endif
		{
			pInfoSet->Time.Steer.SteeringChangeCmded.dwTime = dwCurrTime;

			nObsDetectCntForSteer++;

			if( !bTorqueObstacleStart[0]
				&& (pInfoSet->Time.Steer.FrontSteeringDeparted.bFlag == false)
				&& pInfoSet->Steer.FrontMoving
				&& !bCmdArrived[0]
				&& pInfoSet->Time.Steer.SteeringChangeCmded.bFlag
				&& (nObsDetectCntForSteer > OBS_DETECT_COUNT_LIMIT_FOR_STEER)
			)
			{
				if(!bCmdStart[0])
				{
					bTorqueObstacle[0] = true;
					bTorqueObstacleStart[0] = true;

					ADD_LOG("D-67");
				}
				else
				{
					nObsDetectCntForSteer = 0;
				}
			}

			if( !bTorqueObstacleStart[1]
				&& (pInfoSet->Time.Steer.RearSteeringDeparted.bFlag == false)
				&& pInfoSet->Steer.RearMoving
				&& !bCmdArrived[1]
				&& pInfoSet->Time.Steer.SteeringChangeCmded.bFlag
				&& (nObsDetectCntForSteer > OBS_DETECT_COUNT_LIMIT_FOR_STEER)
			)
			{
				if(!bCmdStart[1])
				{
					bTorqueObstacle[1] = true;
					bTorqueObstacleStart[1] = true;

					ADD_LOG("D-68");
				}
				else
				{
					nObsDetectCntForSteer = 0;
				}
			}
		}
		else
		{
			if(bTorqueObstacleStart[0] == true)
			{
				bTorqueObstacleStart[0] = false;

				if(!bCmdStart[0])
				{
					bTorqueObstacleEnd[0] = true;
					ADD_LOG("D-69");
				}
			}

			if(bTorqueObstacleStart[1] == true)
			{
				bTorqueObstacleStart[1] = false;

				if(!bCmdStart[1])
				{
					bTorqueObstacleEnd[1] = true;
					ADD_LOG("D-70");
				}
			}

			nObsDetectCntForSteer = 0;
		}
	}

	//--------------------------------------------------------------------------------------//
    if(bCmdArrived[0]==true)
    {
        if(pInfoSet->Time.Steer.FrontSteeringArrived.bFlag==false)
        {
            pInfoSet->Time.Steer.FrontSteeringArrived.bFlag = true;
            pInfoSet->Time.Steer.FrontSteeringArrived.dwTime = dwCurrTime;
        }
    }
    else
    {
        pInfoSet->Time.Steer.FrontSteeringArrived.bFlag = false;
    }
    //--------------------------------------------------------------------------------------//
    if(bCmdArrived[1]==true)
    {
        if(pInfoSet->Time.Steer.RearSteeringArrived.bFlag==false)
        {
            pInfoSet->Time.Steer.RearSteeringArrived.bFlag = true;
            pInfoSet->Time.Steer.RearSteeringArrived.dwTime = dwCurrTime;
        }
    }
    else
    {
        pInfoSet->Time.Steer.RearSteeringArrived.bFlag = false;
    }
    //--------------------------------------------------------------------------------------//
    if(     (pInfoSet->Steer.FrontMoving==true)
        &&  (pInfoSet->HwInfo.IO.SteerFrontLeftInOn==false)
        &&  (pInfoSet->HwInfo.IO.SteerFrontRightInOn==false)
    )
    {
        if(pInfoSet->Time.Steer.FrontSteeringDeparted.bFlag==false)
        {
            pInfoSet->Time.Steer.FrontSteeringDeparted.bFlag = true;
            pInfoSet->Time.Steer.FrontSteeringDeparted.dwTime = dwCurrTime;
        }
    }
    else if(bCmdStart[0]==true)
    {
        pInfoSet->Time.Steer.FrontSteeringDeparted.bFlag = false;
    }

    //--------------------------------------------------------------------------------------//
    if(     (pInfoSet->Steer.RearMoving==true)
        &&  (pInfoSet->HwInfo.IO.SteerRearLeftInOn==false)
        &&  (pInfoSet->HwInfo.IO.SteerRearRightInOn==false)
    )
    {
        if(pInfoSet->Time.Steer.RearSteeringDeparted.bFlag==false)
        {
            pInfoSet->Time.Steer.RearSteeringDeparted.bFlag = true;
            pInfoSet->Time.Steer.RearSteeringDeparted.dwTime = dwCurrTime;
        }
    }
    else if(bCmdStart[1]==true)
    {
        pInfoSet->Time.Steer.RearSteeringDeparted.bFlag = false;
    }
    //--------------------------------------------------------------------------------------//

    // by zzang9un 2014.03.21 : 아래 중간 비교문 주석 처리(Steering이 달라질 때 에러 발생을 위해 수정)
	if(     (bSteerChangeAreaByGuide==false && pInfoSet->Steer.FrontMoving==false && pInfoSet->Steer.RearMoving==false)
        // &&  ((pInfoSet->HwInfo.IO.SteerFrontDirCmd!=pInfoSet->Steer.FrontCmdDirection) || (pInfoSet->HwInfo.IO.SteerRearDirCmd!=pInfoSet->Steer.RearCmdDirection))
        &&  ((bCmdArrived[0]==false)||(bCmdArrived[1]==false))
	)
	{
		if(pInfoSet->Time.Steer.SteeringNotMatch.bFlag==false)
		{
			pInfoSet->Time.Steer.SteeringNotMatch.bFlag = true;
            pInfoSet->Time.Steer.SteeringNotMatch.dwTime = dwCurrTime;

			ADD_LOG("D_138/%d/%d/%d/%d/%d/%d/%d/%d/%d/%d"
            , dwCurrTime
			, bSteerChangeAreaByGuide
            , pInfoSet->Steer.FrontMoving
			, pInfoSet->Steer.RearMoving
            , pInfoSet->HwInfo.IO.SteerFrontDirCmd
            , pInfoSet->Steer.FrontCmdDirection
			, pInfoSet->HwInfo.IO.SteerRearDirCmd
			, pInfoSet->Steer.RearCmdDirection
            , bCmdArrived[0]
            , bCmdArrived[1]
			);

		}

	}
	else
    {
        pInfoSet->Time.Steer.SteeringNotMatch.bFlag = false;
    }
    //--------------------------------------------------------------------------------------//

    //1 Events & States
    // Event
    pInfoSet->EventAndState.Event.FrontSteerMoved = bTorqueDown[0];
    pInfoSet->EventAndState.Event.RearSteerMoved = bTorqueDown[1];
    pInfoSet->EventAndState.Event.FrontSteerCompleted = bCmdFinish[0];
    pInfoSet->EventAndState.Event.SteerAllCompleted = bCmdCompleted&(bCmdFinish[0]|bCmdFinish[1]);
    pInfoSet->EventAndState.Event.PushedByGuide = (bSteerChangeAreaByGuide==true)?bCmdExist:false;

    //State
    pInfoSet->EventAndState.State.SteerMoving = pInfoSet->Steer.FrontMoving|pInfoSet->Steer.RearMoving;
    pInfoSet->EventAndState.State.SteerFrontCompleted = !pInfoSet->Steer.FrontMoving;
    pInfoSet->EventAndState.State.SteerAllCompleted = bCmdCompleted;
    pInfoSet->EventAndState.State.SteerChangeAreaByGuide = bSteerChangeAreaByGuide;

    //1 명령 인가 / Back Up
	if(bCmdStart[0]==true)
    {
        SteerCtrl.FrontCmdOn = true;
		SteerCtrl.FrontDirection = SteerCmd;
		if(bSteerChangeAreaByGuide == true)
		{
			SteerCtrl.FrontTorque = HW_STEER_TORQUE_STOP;

			pHWSet->m_pCID->CID_Steerring_N_Branch();

        }
        else
		{
			SteerCtrl.FrontTorque = HW_STEER_TORQUE_MOVING;
		}
    }

    if(bCmdStart[1]==true)
    {
        SteerCtrl.RearCmdOn = true;
        SteerCtrl.RearDirection = SteerCmd;
		if(bSteerChangeAreaByGuide == true)
        {
			SteerCtrl.RearTorque = HW_STEER_TORQUE_STOP;
		}
        else
        {
            SteerCtrl.RearTorque = HW_STEER_TORQUE_MOVING;
        }
	}

    if(bTorqueDown[0]==true)
    {
        SteerCtrl.FrontCmdOn = true;
        SteerCtrl.FrontDirection = pInfoSet->HwInfo.IO.SteerRearDirCmd;
        SteerCtrl.FrontTorque = HW_STEER_TORQUE_STOP;
    }
    if(bTorqueDown[1]==true)
    {
        SteerCtrl.RearCmdOn = true;
        SteerCtrl.RearDirection = pInfoSet->HwInfo.IO.SteerRearDirCmd;
        SteerCtrl.RearTorque = HW_STEER_TORQUE_STOP;
    }

    // -------------------------------------------
    // [BEGIN] by zzang9un 2014.02.12 : Steering Retry

    // 명령 수행 후 Retry를 위한 시간 체크
    // Left
    if(!bTorqueTractionStart[0] &&
        pInfoSet->Steer.FrontMoving && !bCmdArrived[0] &&
        pInfoSet->Time.Steer.SteeringChangeCmded.bFlag &&
		(OHTUTILITY::PreventOverflowGetTimeMs(pInfoSet->Time.Steer.SteeringChangeCmded.dwTime) > TIME_STEERING_RETRY)
    )
    {
	    if(!bCmdStart[0])
    	{
	        bTorqueTraction[0] = true;
    	    bTorqueTractionStart[0] = true;
    	}
    }

    // Right
    if(!bTorqueTractionStart[1] &&
        pInfoSet->Steer.RearMoving && !bCmdArrived[1] &&
        pInfoSet->Time.Steer.SteeringChangeCmded.bFlag &&
		(OHTUTILITY::PreventOverflowGetTimeMs(pInfoSet->Time.Steer.SteeringChangeCmded.dwTime) > TIME_STEERING_RETRY)
    )
    {
	    if(!bCmdStart[1])
    	{
	        bTorqueTraction[1] = true;
    	    bTorqueTractionStart[1] = true;
    	}
    }

    // Left
    if(bTorqueTraction[0])
    {
        SteerCtrl.FrontCmdOn = true;
   	    SteerCtrl.FrontDirection = pInfoSet->HwInfo.IO.SteerFrontDirCmd;
       	SteerCtrl.FrontTorque = HW_STEER_TORQUE_TRACTION;
    }

    // Right
    if(bTorqueTraction[1])
    {
        SteerCtrl.RearCmdOn = true;
        SteerCtrl.RearDirection = pInfoSet->HwInfo.IO.SteerRearDirCmd;
        SteerCtrl.RearTorque = HW_STEER_TORQUE_TRACTION;
    }

    // Left
    if(bTorqueObstacle[0])
    {
        SteerCtrl.FrontCmdOn = true;

		SteerCtrl.FrontDirection = pInfoSet->HwInfo.IO.SteerFrontDirCmd;
        SteerCtrl.FrontTorque = HW_STEER_TORQUE_STOP;
		SteerTorque4Obstacle[0] = pInfoSet->HwInfo.IO.SteerFrontTorque;
    }

    // Right
    if(bTorqueObstacle[1])
    {
		SteerCtrl.RearCmdOn = true;

		SteerCtrl.RearDirection = pInfoSet->HwInfo.IO.SteerRearDirCmd;
        SteerCtrl.RearTorque = HW_STEER_TORQUE_STOP;
		SteerTorque4Obstacle[1] = pInfoSet->HwInfo.IO.SteerRearTorque;
    }

    if(bTorqueObstacleEnd[0])
    {
        SteerCtrl.FrontCmdOn = true;
   	    SteerCtrl.FrontDirection = pInfoSet->HwInfo.IO.SteerFrontDirCmd;
       	SteerCtrl.FrontTorque = SteerTorque4Obstacle[0];
    }

    if(bTorqueObstacleEnd[1])
    {
        SteerCtrl.RearCmdOn = true;
   	    SteerCtrl.RearDirection = pInfoSet->HwInfo.IO.SteerRearDirCmd;
       	SteerCtrl.RearTorque = SteerTorque4Obstacle[1];
    }

    // [END] by zzang9un 2014.02.12 : Steering Retry 시 견인 토크 인가
    // -------------------------------------------

    if((bCmdStart[0]==true)||(bTorqueDown[0]==true)||(bCmdStart[1]==true)||(bTorqueDown[1]==true) ||
        bTorqueTraction[0] || bTorqueTraction[1] ||
        bTorqueObstacle[0] || bTorqueObstacle[1] ||
		bTorqueObstacleEnd[0] || bTorqueObstacleEnd[1]
	)
	{
		*pSteerCtrl = SteerCtrl;
		ADD_LOG("D_139/%d/%d/%d/%d/%d/%d/%d/%d/%d/%d/%d/%d/%d/%d/%d/%d/%4X/%d/%d/%d"
			,bCmdStart[0], bTorqueObstacle[0], bTorqueObstacleEnd[0], bTorqueTraction[0], bTorqueDown[0]
			,bCmdStart[1], bTorqueObstacle[1], bTorqueObstacleEnd[1], bTorqueTraction[1], bTorqueDown[1]
            ,SteerCtrl.FrontCmdOn,SteerCtrl.FrontDirection,SteerCtrl.FrontTorque
            ,SteerCtrl.RearCmdOn,SteerCtrl.RearDirection,SteerCtrl.RearTorque
			,pInfoSet->Steer
            ,pInfoSet->HwInfo.Node.nPreCheckCount
			,pInfoSet->HwInfo.Node.nNodeCount
			,nPreCheckCount);
    }

	if((m_mccparam.bSteerFrontLeftFlag == true) || (m_mccparam.bSteerFrontRightFlag == true) || (m_mccparam.bSteerRearLeftFlag == true) || (m_mccparam.bSteerRearRightFlag == true))
	{
		if(m_mccparam.bSteerTimeCheckFlag == true)
		{
			if((m_mccparam.bPreSteerFTRQ0 == 0) && (pHWSet->m_pSteer->IsFTorque0On() == 1))
			{
				m_mccparam.dwSteerFTRQ0OnTime = dwCurrTime;
			}
			if((m_mccparam.bPreSteerFTRQ0 == 1) && (pHWSet->m_pSteer->IsFTorque0On() == 0))
			{
				m_mccparam.dwSteerFTRQ0OffTime = dwCurrTime;
			}
			if((m_mccparam.bPreSteerRTRQ0 == 0) && (pHWSet->m_pSteer->IsRTorque0On() == 1))
			{
				m_mccparam.dwSteerRTRQ0OnTime = dwCurrTime;
			}
			if((m_mccparam.bPreSteerRTRQ0 == 1) && (pHWSet->m_pSteer->IsRTorque0On() == 0))
			{
				m_mccparam.dwSteerRTRQ0OffTime = dwCurrTime;
			}
			if((m_mccparam.bPreSteerFDIR == 0) && (pHWSet->m_pSteer->IsFDirOn() == 1))
			{
				m_mccparam.dwSteerFDIROnTime = dwCurrTime;
			}
			if((m_mccparam.bPreSteerFDIR == 1) && (pHWSet->m_pSteer->IsFDirOn() == 0))
			{
				m_mccparam.dwSteerFTDIROffTime = dwCurrTime;
			}
			if((m_mccparam.bPreSteerRDIR == 0) && (pHWSet->m_pSteer->IsRDirOn() == 1))
			{
				m_mccparam.dwSteerRDIROnTime = dwCurrTime;
			}
			if((m_mccparam.bPreSteerRDIR == 1) && (pHWSet->m_pSteer->IsRDirOn() == 0))
			{
				m_mccparam.dwSteerRDIROffTime = dwCurrTime;
			}
			if((m_mccparam.bPreSteerFrontLeft == 0) && (pHWSet->m_pSteer->IsFrontLeftOn() == 1))
			{
				m_mccparam.dwSteerFLeftOnTime = dwCurrTime;
			}
			if((m_mccparam.bPreSteerFrontLeft == 1) && (pHWSet->m_pSteer->IsFrontLeftOn() == 0))
			{
				m_mccparam.dwSteerFLeftOffTime = dwCurrTime;
			}
			if((m_mccparam.bPreSteerRearLeft == 0) && (pHWSet->m_pSteer->IsRearLeftOn() == 1))
			{
				m_mccparam.dwSteerRLeftOnTime = dwCurrTime;
			}
			if((m_mccparam.bPreSteerRearLeft == 1) && (pHWSet->m_pSteer->IsRearLeftOn() == 0))
			{
				m_mccparam.dwSteerRLeftOffTime = dwCurrTime;
			}
			if((m_mccparam.bPreSteerFrontRight == 0) && (pHWSet->m_pSteer->IsFrontRightOn() == 1))
			{
				m_mccparam.dwSteerFRightOnTime = dwCurrTime;
			}
			if((m_mccparam.bPreSteerFrontRight == 1) && (pHWSet->m_pSteer->IsFrontRightOn() == 0))
			{
				m_mccparam.dwSteerFRightOffTime = dwCurrTime;
			}
			if((m_mccparam.bPreSteerRearRight == 0) && (pHWSet->m_pSteer->IsRearRightOn() == 1))
			{
				m_mccparam.dwSteerRRightOnTime = dwCurrTime;
			}
			if((m_mccparam.bPreSteerRearRight == 1) && (pHWSet->m_pSteer->IsRearRightOn() == 0))
			{
				m_mccparam.dwSteerRRightOffTime = dwCurrTime;
			}

			if(pHWSet->m_pSteer->IsFDirOn() == 0)
			{
				if((m_mccparam.bPreSteerFrontLeft == 1) && (pHWSet->m_pSteer->IsFrontLeftOn() == 0))
				{
					m_mccparam.nSteerFrontHauntingCount++;
				}
				if((m_mccparam.bPreSteerRearLeft == 1) && (pHWSet->m_pSteer->IsRearLeftOn() == 0))
				{
					m_mccparam.nSteerRearHauntingCount++;
                }
			}

			if(pHWSet->m_pSteer->IsFDirOn() == 1)
			{
				if((m_mccparam.bPreSteerFrontRight == 1) && (pHWSet->m_pSteer->IsFrontRightOn() == 0))
				{
					m_mccparam.nSteerFrontHauntingCount++;
				}
				if((m_mccparam.bPreSteerRearRight == 1) && (pHWSet->m_pSteer->IsRearRightOn() == 0))
				{
					m_mccparam.nSteerRearHauntingCount++;
                }
			}
		}

		m_mccparam.bSteerTimeCheckFlag = true;

		m_mccparam.bPreSteerFTRQ0 = pHWSet->m_pSteer->IsFTorque0On();
		m_mccparam.bPreSteerRTRQ0 = pHWSet->m_pSteer->IsRTorque0On();
		m_mccparam.bPreSteerFDIR = pHWSet->m_pSteer->IsFDirOn();
		m_mccparam.bPreSteerRDIR = pHWSet->m_pSteer->IsRDirOn();
		m_mccparam.bPreSteerFrontLeft = pHWSet->m_pSteer->IsFrontLeftOn();
		m_mccparam.bPreSteerRearLeft = pHWSet->m_pSteer->IsRearLeftOn();
		m_mccparam.bPreSteerFrontRight = pHWSet->m_pSteer->IsFrontRightOn();
		m_mccparam.bPreSteerRearRight = pHWSet->m_pSteer->IsRearRightOn();

		int tmpUBG = pHWSet->m_pOHTDetect->GetSensorLevel_MCC();
		int tmpOBS = pHWSet->m_pObstacle->GetSensorLevel_MCC();

		if(tmpUBG > m_mccparam.nUBGMaxOnSteering)
			m_mccparam.nUBGMaxOnSteering = tmpUBG;
		if(tmpUBG < m_mccparam.nUBGMinOnSteering)
			m_mccparam.nUBGMinOnSteering = tmpUBG;

		if(tmpOBS > m_mccparam.nOBSMaxOnSteering)
			m_mccparam.nOBSMaxOnSteering = tmpOBS;
		if(tmpOBS < m_mccparam.nOBSMinOnSteering)
			m_mccparam.nOBSMinOnSteering = tmpOBS;
	}
	else if (m_mccparam.bSteerTimeCheckFlag == true)
	{
		m_mccparam.bSteerTimeCheckFlag = false;
		m_mccparam.dwSteerFTRQ0OnTime = 0;
		m_mccparam.dwSteerFTRQ0OffTime = 0;
		m_mccparam.dwSteerRTRQ0OnTime = 0;
		m_mccparam.dwSteerRTRQ0OffTime = 0;
		m_mccparam.dwSteerFDIROnTime = 0;
		m_mccparam.dwSteerFTDIROffTime = 0;
		m_mccparam.dwSteerRDIROnTime = 0;
		m_mccparam.dwSteerRDIROffTime = 0;
		m_mccparam.dwSteerFLeftOnTime = 0;
		m_mccparam.dwSteerFLeftOffTime = 0;
		m_mccparam.dwSteerFRightOnTime = 0;
		m_mccparam.dwSteerFRightOffTime = 0;
		m_mccparam.dwSteerRLeftOnTime = 0;
		m_mccparam.dwSteerRLeftOffTime = 0;
		m_mccparam.dwSteerRRightOnTime = 0;
		m_mccparam.dwSteerRRightOffTime = 0;

		m_mccparam.nOBSMaxOnSteering = 0;
		m_mccparam.nOBSMinOnSteering = 8;
		m_mccparam.nUBGMaxOnSteering = 0;
		m_mccparam.nUBGMinOnSteering = 8;
	}



    return nTmpError;

}


/**
@brief    조향 상태 설정 및 명령 생성
@author  임태웅
@date    2013.08.06
@param pInfoSet 입력/변경되는 상태 정보
@param pSteerCtrl 조향 명령 정보
@return 에러 없으면 0반환, 있으면 에러 코드 반환
*/
UINT DrivingControl::checkBackSteer(DRIVING_INFO_SET *pInfoSet)
{
	UINT nTmpError = NO_ERR;

	DWORD dwCurrTime = timeGetTime();

	CTRL_INFO_OF_STEER SteerCtrl;
	memset(&SteerCtrl, 0, sizeof(CTRL_INFO_OF_STEER));

	CTRL_INFO_OF_STEER* pSteerCtrl = &(pInfoSet->Control.Steer);

	int nPreCheckCount = pInfoSet->HwInfo.Node.nNodeCount; //기존 정상주행시 Precheck

	DRIVING_CMD_INFO_OF_PATH* pPathInfo = getPathInfo(pInfoSet->HwInfo.Node.nNodeCount);

	//2 처음 시작할 때 PreCheck가 Node 를 넘어가있는 경우:
	//2 PreCheck 가 감지 되지 않아 무언 정지가 생길 수 있다.  이 경우 PreCheckCount 를 강제로 1로 만들어 준다
	if( (nPreCheckCount==0)
	&&  (pInfoSet->Position.bPreCheckIsOverFirstNode==true)
	)
	{
		nPreCheckCount=1;
	}

//	bool bSteerChangeAreaByGuide = isSteerChangeAreaByGuide();  // N분기 가이드 레일에 의해 조향이 변경되는 구간

	bool bCmdExist          = false;    // 조향 명령이 있을 경우
	bool bCmdStart[2]       = {false,}; // 조향 명령을 실시한 경우
	bool bTorqueDown[2] = {false,}; // 토크 변경을 실시한 경우
	bool bCmdArrived[2] = {false,}; // 조향이 명령 위치에 도달한 경우
	bool bCmdFinish[2]      = {false,}; // 전후 각각 조향 명령이 완료한 경우 ( 채터링 포함)
	bool bCmdCompleted      = false;    // 조향 명령 완료한 경우 ( 채터링 포함)

	bool bTorqueTraction[2] = {false,}; // Traction 토크로 변경 인가 여부
	static bool bTorqueTractionStart[2] = {false,}; // Traction 토크로 변경 명령 실행 flag

	bool bTorqueObstacle[2] = {false,}; 			// Obstacle 토크로 변경 인가 여부
	bool bTorqueObstacleEnd[2] = {false,}; 			// Obstacle 토크 종료
	static bool bTorqueObstacleStart[2] = {false,}; // Obstacle 토크로 변경 명령 실행 flag
	static HW_STEER_TORQUE SteerTorque4Obstacle[2] = {HW_STEER_TORQUE_STOP, HW_STEER_TORQUE_STOP};
	static int nObsDetectCntForSteer = 0;

	STEER_HW_INFO_CMD SteerCmd = STEER_HW_INFO_CMD_LEFT;

	//1  명령 생성 가능성 확인

	bCmdExist = getSteerCmd(nPreCheckCount,&SteerCmd);  // EndNode Count 사용

	//1 상태 반영
	pInfoSet->Steer.PathSteer = (pPathInfo!=NULL)?pPathInfo->Steering:STEERING_NONE;
//	pInfoSet->Steer.PathDirection = (pPathInfo!=NULL)?pPathInfo->Direction:PATH_DIRECTION_NO_USE;
	pInfoSet->Steer.FrontPosition = getSteerPosition(pInfoSet->HwInfo.IO.SteerFrontLeftInOn, pInfoSet->HwInfo.IO.SteerFrontRightInOn);
	pInfoSet->Steer.RearPosition = getSteerPosition(pInfoSet->HwInfo.IO.SteerRearLeftInOn, pInfoSet->HwInfo.IO.SteerRearRightInOn);

	if(bCmdExist==true)
	{
		if(SteerCmd!=pInfoSet->HwInfo.IO.SteerFrontDirCmd)//pInfoSet->Steer.FrontCmdDirection)
		{
			pInfoSet->Steer.FrontCmdDirection = SteerCmd;
			pInfoSet->Steer.FrontMoving = true;
			bCmdStart[0] = true;
		}

		if(SteerCmd!=pInfoSet->HwInfo.IO.SteerRearDirCmd)//pInfoSet->Steer.RearCmdDirection)
		{
			pInfoSet->Steer.RearCmdDirection = SteerCmd;
			pInfoSet->Steer.RearMoving = true;
			bCmdStart[1] = true;
		}
	}

	if(pInfoSet->Steer.FrontCmdDirection==STEER_HW_INFO_CMD_LEFT)
	{
		if(pInfoSet->HwInfo.IO.SteerFrontLeftInOn==true)
		{
			bCmdArrived[0] = true;
			pHWSet->m_pCID->CID_Steerring_N_Branch_Select_Off();
		}
		if(pInfoSet->HwInfo.IO.SteerRearLeftInOn==true)     bCmdArrived[1] = true;
	}
	if(pInfoSet->Steer.FrontCmdDirection==STEER_HW_INFO_CMD_RIGHT)
	{
		if(pInfoSet->HwInfo.IO.SteerFrontRightInOn==true)
		{
			bCmdArrived[0] = true;
			pHWSet->m_pCID->CID_Steerring_N_Branch_Select_Off();
		}
		if(pInfoSet->HwInfo.IO.SteerRearRightInOn==true)    bCmdArrived[1] = true;
	}

	if((bCmdExist==false) || ((pInfoSet->HwInfo.IO.SteerFrontDirCmd==pInfoSet->Steer.FrontCmdDirection) && (pInfoSet->HwInfo.IO.SteerRearDirCmd==pInfoSet->Steer.RearCmdDirection)))
	{
		if(     (pInfoSet->Time.Steer.FrontSteeringDeparted.bFlag==true)
			&&  (OHTUTILITY::PreventOverflowGetTimeMs(pInfoSet->Time.Steer.FrontSteeringDeparted.dwTime)>m_pParamSet->Steer.dwMovingTorqueTime)
			&&  (pInfoSet->HwInfo.IO.SteerFrontTorque!=HW_STEER_TORQUE_STOP)
		)
		{
			bTorqueDown[0] = true;
		}
		if(     (pInfoSet->Time.Steer.RearSteeringDeparted.bFlag==true)
			&&  (OHTUTILITY::PreventOverflowGetTimeMs(pInfoSet->Time.Steer.RearSteeringDeparted.dwTime)>m_pParamSet->Steer.dwMovingTorqueTime)
			&&  (pInfoSet->HwInfo.IO.SteerRearTorque!=HW_STEER_TORQUE_STOP)
		)
		{
			bTorqueDown[1] = true;

		}
	}

	if( (bCmdExist==false) || ((pInfoSet->HwInfo.IO.SteerFrontDirCmd==pInfoSet->Steer.FrontCmdDirection) && (pInfoSet->HwInfo.IO.SteerRearDirCmd==pInfoSet->Steer.RearCmdDirection)))
	{
		if(     (pInfoSet->Time.Steer.FrontSteeringArrived.bFlag==true)
			&&  (OHTUTILITY::PreventOverflowGetTimeMs(pInfoSet->Time.Steer.FrontSteeringArrived.dwTime)>m_pParamSet->Steer.dwCompleteCheckTime)
			&&  (pInfoSet->Steer.FrontMoving==true)
		)
		{
			pInfoSet->Steer.FrontMoving = false;
			bTorqueTractionStart[0] = false;
			bCmdFinish[0] = true;

//			m_pSteer->CalculateMaxFrontMovingTime();//doori.shin Front Steering 이동시간 계산

			if(pInfoSet->HwInfo.IO.SteerFrontTorque!=1) bTorqueDown[0] = true;
		}
		if(     (pInfoSet->Time.Steer.RearSteeringArrived.bFlag==true)
			&&  (OHTUTILITY::PreventOverflowGetTimeMs(pInfoSet->Time.Steer.RearSteeringArrived.dwTime)>m_pParamSet->Steer.dwCompleteCheckTime)
			&&  (pInfoSet->Steer.RearMoving==true)
		)
		{
			pInfoSet->Steer.RearMoving = false;
			bTorqueTractionStart[1] = false;
			bCmdFinish[1] = true;

//			m_pSteer->CalculateMaxRearMovingTime(); //doori.shin Rear Steering 이동시간 계산

			if(pInfoSet->HwInfo.IO.SteerRearTorque!=1)  bTorqueDown[1] = true;
		}

		if( (pInfoSet->Steer.FrontMoving==false) && (pInfoSet->Steer.RearMoving==false) )
		{
			bCmdCompleted = true;
			if(pInfoSet->EventAndState.State.SteerAllCompleted==false)
			{
				ADD_LOG("D_140/%d", bCmdCompleted);

//				m_pSteer->IncreaseSteerMovingCount();//doori.shin Steering 이동시간 증가
			}
		}
	}


	//1 Time 확인
	//--------------------------------------------------------------------------------------//
	if((bCmdStart[0]==true) || (bCmdStart[1]==true))
	{
		pInfoSet->Time.Steer.SteeringChangeCmded.bFlag = true;
		pInfoSet->Time.Steer.SteeringChangeCmded.dwTime = dwCurrTime;
	}
	else if(bCmdCompleted==true)
	{
		pInfoSet->Time.Steer.SteeringChangeCmded.bFlag = false;
	}

	if(pInfoSet->Time.Steer.SteeringChangeCmded.bFlag == true)
	{
#if(UBG_SENSOR_ENABLE==ON)
		if( (pInfoSet->HwInfo.IO.DetectStatus == DETECT_AND_STOP)
		||  (pInfoSet->HwInfo.IO.ObsStatus == DETECT_AND_STOP)
		||  (pHWSet->GetAMCPauseStatus() == STATUS_OHT_PAUSED)
		)
#else
		if(pInfoSet->HwInfo.IO.ObsStatus==DETECT_AND_STOP)
#endif
		{
			pInfoSet->Time.Steer.SteeringChangeCmded.dwTime = dwCurrTime;

			nObsDetectCntForSteer++;

			if( !bTorqueObstacleStart[0]
				&& (pInfoSet->Time.Steer.FrontSteeringDeparted.bFlag == false)
				&& pInfoSet->Steer.FrontMoving
				&& !bCmdArrived[0]
				&& pInfoSet->Time.Steer.SteeringChangeCmded.bFlag
				&& (nObsDetectCntForSteer > OBS_DETECT_COUNT_LIMIT_FOR_STEER)
			)
			{
				if(!bCmdStart[0])
				{
					bTorqueObstacle[0] = true;
					bTorqueObstacleStart[0] = true;

					ADD_LOG("D-71");
				}
				else
				{
					nObsDetectCntForSteer = 0;
				}
			}

			if( !bTorqueObstacleStart[1]
				&& (pInfoSet->Time.Steer.RearSteeringDeparted.bFlag == false)
				&& pInfoSet->Steer.RearMoving
				&& !bCmdArrived[1]
				&& pInfoSet->Time.Steer.SteeringChangeCmded.bFlag
				&& (nObsDetectCntForSteer > OBS_DETECT_COUNT_LIMIT_FOR_STEER)
			)
			{
				if(!bCmdStart[1])
				{
					bTorqueObstacle[1] = true;
					bTorqueObstacleStart[1] = true;

					ADD_LOG("D-72");
				}
				else
				{
					nObsDetectCntForSteer = 0;
				}
			}
		}
		else
		{

			pInfoSet->Time.Steer.SteeringChangeCmded.dwTime = dwCurrTime;

			if(bTorqueObstacleStart[0] == true)
			{
				bTorqueObstacleStart[0] = false;

				if(!bCmdStart[0])
				{
					bTorqueObstacleEnd[0] = true;
					ADD_LOG("D-73");
				}
			}

			if(bTorqueObstacleStart[1] == true)
			{
				bTorqueObstacleStart[1] = false;

				if(!bCmdStart[1])
				{
					bTorqueObstacleEnd[1] = true;
					ADD_LOG("D-74");
				}
			}

			nObsDetectCntForSteer = 0;
		}
	}

	//--------------------------------------------------------------------------------------//
    if(bCmdArrived[0]==true)
    {
        if(pInfoSet->Time.Steer.FrontSteeringArrived.bFlag==false)
        {
            pInfoSet->Time.Steer.FrontSteeringArrived.bFlag = true;
            pInfoSet->Time.Steer.FrontSteeringArrived.dwTime = dwCurrTime;
        }
    }
    else
    {
        pInfoSet->Time.Steer.FrontSteeringArrived.bFlag = false;
    }
    //--------------------------------------------------------------------------------------//
    if(bCmdArrived[1]==true)
    {
        if(pInfoSet->Time.Steer.RearSteeringArrived.bFlag==false)
        {
            pInfoSet->Time.Steer.RearSteeringArrived.bFlag = true;
            pInfoSet->Time.Steer.RearSteeringArrived.dwTime = dwCurrTime;
        }
    }
    else
    {
        pInfoSet->Time.Steer.RearSteeringArrived.bFlag = false;
    }
    //--------------------------------------------------------------------------------------//
    if(     (pInfoSet->Steer.FrontMoving==true)
        &&  (pInfoSet->HwInfo.IO.SteerFrontLeftInOn==false)
        &&  (pInfoSet->HwInfo.IO.SteerFrontRightInOn==false)
    )
    {
        if(pInfoSet->Time.Steer.FrontSteeringDeparted.bFlag==false)
        {
            pInfoSet->Time.Steer.FrontSteeringDeparted.bFlag = true;
            pInfoSet->Time.Steer.FrontSteeringDeparted.dwTime = dwCurrTime;
        }
    }
    else if(bCmdStart[0]==true)
    {
        pInfoSet->Time.Steer.FrontSteeringDeparted.bFlag = false;
    }

    //--------------------------------------------------------------------------------------//
    if(     (pInfoSet->Steer.RearMoving==true)
        &&  (pInfoSet->HwInfo.IO.SteerRearLeftInOn==false)
        &&  (pInfoSet->HwInfo.IO.SteerRearRightInOn==false)
    )
    {
        if(pInfoSet->Time.Steer.RearSteeringDeparted.bFlag==false)
        {
            pInfoSet->Time.Steer.RearSteeringDeparted.bFlag = true;
            pInfoSet->Time.Steer.RearSteeringDeparted.dwTime = dwCurrTime;
        }
    }
    else if(bCmdStart[1]==true)
    {
        pInfoSet->Time.Steer.RearSteeringDeparted.bFlag = false;
    }
    //--------------------------------------------------------------------------------------//

    // by zzang9un 2014.03.21 : 아래 중간 비교문 주석 처리(Steering이 달라질 때 에러 발생을 위해 수정)
	if((pInfoSet->Steer.FrontMoving==false && pInfoSet->Steer.RearMoving==false)
        // &&  ((pInfoSet->HwInfo.IO.SteerFrontDirCmd!=pInfoSet->Steer.FrontCmdDirection) || (pInfoSet->HwInfo.IO.SteerRearDirCmd!=pInfoSet->Steer.RearCmdDirection))
        &&  ((bCmdArrived[0]==false)||(bCmdArrived[1]==false))
	)
	{
		if(pInfoSet->Time.Steer.SteeringNotMatch.bFlag==false)
		{
			pInfoSet->Time.Steer.SteeringNotMatch.bFlag = true;
            pInfoSet->Time.Steer.SteeringNotMatch.dwTime = dwCurrTime;

			ADD_LOG("D_141/%d/%d/%d/%d/%d/%d/%d/%d/%d"
            , dwCurrTime
            , pInfoSet->Steer.FrontMoving
			, pInfoSet->Steer.RearMoving
            , pInfoSet->HwInfo.IO.SteerFrontDirCmd
            , pInfoSet->Steer.FrontCmdDirection
            , pInfoSet->HwInfo.IO.SteerRearDirCmd
			, pInfoSet->Steer.RearCmdDirection
            , bCmdArrived[0]
            , bCmdArrived[1]
			);

		}

	}
	else
    {
        pInfoSet->Time.Steer.SteeringNotMatch.bFlag = false;
    }
    //--------------------------------------------------------------------------------------//

    //1 Events & States
    // Event
    pInfoSet->EventAndState.Event.FrontSteerMoved = bTorqueDown[0];
    pInfoSet->EventAndState.Event.RearSteerMoved = bTorqueDown[1];
    pInfoSet->EventAndState.Event.FrontSteerCompleted = bCmdFinish[0];
    pInfoSet->EventAndState.Event.SteerAllCompleted = bCmdCompleted&(bCmdFinish[0]|bCmdFinish[1]);
    pInfoSet->EventAndState.Event.PushedByGuide = false;

    //State
    pInfoSet->EventAndState.State.SteerMoving = pInfoSet->Steer.FrontMoving|pInfoSet->Steer.RearMoving;
    pInfoSet->EventAndState.State.SteerFrontCompleted = !pInfoSet->Steer.FrontMoving;
    pInfoSet->EventAndState.State.SteerAllCompleted = bCmdCompleted;
    pInfoSet->EventAndState.State.SteerChangeAreaByGuide = false;

    //1 명령 인가 / Back Up
    if(bCmdStart[0]==true)
    {
        SteerCtrl.FrontCmdOn = true;
        SteerCtrl.FrontDirection = SteerCmd;

		SteerCtrl.FrontTorque = HW_STEER_TORQUE_MOVING;

    }

    if(bCmdStart[1]==true)
    {
        SteerCtrl.RearCmdOn = true;
        SteerCtrl.RearDirection = SteerCmd;

		SteerCtrl.RearTorque = HW_STEER_TORQUE_MOVING;

	}

    if(bTorqueDown[0]==true)
    {
        SteerCtrl.FrontCmdOn = true;
        SteerCtrl.FrontDirection = pInfoSet->HwInfo.IO.SteerRearDirCmd;
        SteerCtrl.FrontTorque = HW_STEER_TORQUE_STOP;
    }
    if(bTorqueDown[1]==true)
    {
        SteerCtrl.RearCmdOn = true;
        SteerCtrl.RearDirection = pInfoSet->HwInfo.IO.SteerRearDirCmd;
        SteerCtrl.RearTorque = HW_STEER_TORQUE_STOP;
    }

    // -------------------------------------------
    // [BEGIN] by zzang9un 2014.02.12 : Steering Retry

    // 명령 수행 후 Retry를 위한 시간 체크
    // Left
    if(!bTorqueTractionStart[0] &&
        pInfoSet->Steer.FrontMoving && !bCmdArrived[0] &&
        pInfoSet->Time.Steer.SteeringChangeCmded.bFlag &&
		(OHTUTILITY::PreventOverflowGetTimeMs(pInfoSet->Time.Steer.SteeringChangeCmded.dwTime) > TIME_STEERING_RETRY)
    )
    {
	    if(!bCmdStart[0])
    	{
	        bTorqueTraction[0] = true;
    	    bTorqueTractionStart[0] = true;
    	}
    }

    // Right
    if(!bTorqueTractionStart[1] &&
        pInfoSet->Steer.RearMoving && !bCmdArrived[1] &&
        pInfoSet->Time.Steer.SteeringChangeCmded.bFlag &&
        (OHTUTILITY::PreventOverflowGetTimeMs(pInfoSet->Time.Steer.SteeringChangeCmded.dwTime) > TIME_STEERING_RETRY)
    )
    {
	    if(!bCmdStart[1])
    	{
	        bTorqueTraction[1] = true;
    	    bTorqueTractionStart[1] = true;
    	}
    }

    // Left
    if(bTorqueTraction[0])
    {
        SteerCtrl.FrontCmdOn = true;
   	    SteerCtrl.FrontDirection = pInfoSet->HwInfo.IO.SteerFrontDirCmd;
       	SteerCtrl.FrontTorque = HW_STEER_TORQUE_TRACTION;
    }

    // Right
    if(bTorqueTraction[1])
    {
        SteerCtrl.RearCmdOn = true;
        SteerCtrl.RearDirection = pInfoSet->HwInfo.IO.SteerRearDirCmd;
        SteerCtrl.RearTorque = HW_STEER_TORQUE_TRACTION;
    }

    // Left
    if(bTorqueObstacle[0])
    {
        SteerCtrl.FrontCmdOn = true;

		SteerCtrl.FrontDirection = pInfoSet->HwInfo.IO.SteerFrontDirCmd;
        SteerCtrl.FrontTorque = HW_STEER_TORQUE_STOP;
		SteerTorque4Obstacle[0] = pInfoSet->HwInfo.IO.SteerFrontTorque;
    }

    // Right
    if(bTorqueObstacle[1])
    {
		SteerCtrl.RearCmdOn = true;

		SteerCtrl.RearDirection = pInfoSet->HwInfo.IO.SteerRearDirCmd;
        SteerCtrl.RearTorque = HW_STEER_TORQUE_STOP;
		SteerTorque4Obstacle[1] = pInfoSet->HwInfo.IO.SteerRearTorque;
    }

    if(bTorqueObstacleEnd[0])
    {
        SteerCtrl.FrontCmdOn = true;
   	    SteerCtrl.FrontDirection = pInfoSet->HwInfo.IO.SteerFrontDirCmd;
       	SteerCtrl.FrontTorque = SteerTorque4Obstacle[0];
    }

    if(bTorqueObstacleEnd[1])
    {
        SteerCtrl.RearCmdOn = true;
   	    SteerCtrl.RearDirection = pInfoSet->HwInfo.IO.SteerRearDirCmd;
       	SteerCtrl.RearTorque = SteerTorque4Obstacle[1];
    }

    // [END] by zzang9un 2014.02.12 : Steering Retry 시 견인 토크 인가
    // -------------------------------------------

    if((bCmdStart[0]==true)||(bTorqueDown[0]==true)||(bCmdStart[1]==true)||(bTorqueDown[1]==true) ||
        bTorqueTraction[0] || bTorqueTraction[1] ||
        bTorqueObstacle[0] || bTorqueObstacle[1] ||
		bTorqueObstacleEnd[0] || bTorqueObstacleEnd[1]
	)
	{
		*pSteerCtrl = SteerCtrl;
		ADD_LOG("D_142/%d/%d/%d/%d/%d/%d/%d/%d/%d/%d/%d/%d/%d/%d/%d/%d/%4X/%d/%d/%d"
			,bCmdStart[0], bTorqueObstacle[0], bTorqueObstacleEnd[0], bTorqueTraction[0], bTorqueDown[0]
			,bCmdStart[1], bTorqueObstacle[1], bTorqueObstacleEnd[1], bTorqueTraction[1], bTorqueDown[1]
            ,SteerCtrl.FrontCmdOn,SteerCtrl.FrontDirection,SteerCtrl.FrontTorque
            ,SteerCtrl.RearCmdOn,SteerCtrl.RearDirection,SteerCtrl.RearTorque
			,pInfoSet->Steer
            ,pInfoSet->HwInfo.Node.nPreCheckCount
			,pInfoSet->HwInfo.Node.nNodeCount
			,nPreCheckCount);
    }

    return nTmpError;

}


//void DrivingControl::CID_N_BRANCH_SELECT_OFF()
//{
//	pHWSet->m_pCID->CID_Steerring_N_Branch_Select_Off();
//}

/*
@brief    작업변경  확인 부분
@author  박태욱
@date    2016.11.06
@return 에러 없으면 0반환, 있으면 에러 코드 반환
*/
UINT DrivingControl::checkJobChange(DRIVING_INFO_SET *pInfoSet)
{
	int nError = NO_ERR;
	DWORD dwCurrTime = timeGetTime();

	DRIVING_CMD_INFO_OF_NODE* pNodeInfo = NULL;
	double dSpeedResult =0.0;


	try{
		//1 경로변경/삭제 처리 명령 처리
		if(m_pExecuteInfo->FlagPathChange.bPathChange == true)
		{
			bool bCheckChange = false; //주행부 삭제할 데이터 유무 확인 용
			CLASSIFIED_DRIVING_CHANGE	TempDrivnigInfo;

			memset(&TempDrivnigInfo, 0x00, sizeof(CLASSIFIED_DRIVING_CHANGE));
			bCheckChange = checkCmdInfoNodeList(&(m_ClassifiedCmd.NodeList), (int)m_pExecuteInfo->FlagPathChange.nChageNodeID, &TempDrivnigInfo);  ///< List 정보로부터 Node위치 확인

			if(bCheckChange ==true)
			{

				bCheckChange = clearCmdInfoListsLessAfter(TempDrivnigInfo);

				if(bCheckChange == true)
				{
					m_pExecuteInfo->FlagPathChange.cResult = SUCCESS;


					pInfoSet->EventAndState.Event.TargetChanged  = true;
					//둘다 CheckNodeCount(변경되는 위치)보다 클경우,
					if((pInfoSet->Position.CmdRefInfo.nCount >= TempDrivnigInfo.nCheckNodeCount) &&
						(pInfoSet->Position.CmdRefInfo.nKeyCount >= TempDrivnigInfo.nCheckNodeCount))
					{
                    	//전체 초기화
						pInfoSet->Position.CmdRefInfo.dCmdSpeed =  0.0;
						pInfoSet->Position.CmdRefInfo.dRefSpeed =  0.0;
						pInfoSet->Position.CmdRefInfo.dCmdDecel =  0.0;
						pInfoSet->Position.CmdRefInfo.dDist = 0.0;
						pInfoSet->Position.CmdRefInfo.dSpeedDownPos = 0.0;

						pInfoSet->Position.CmdRefInfo.nCount =pInfoSet->HwInfo.Node.nNodeCount;
						pInfoSet->Position.CmdRefInfo.nKeyCount =pInfoSet->HwInfo.Node.nNodeCount;

						/*
						double	dCmdSpeed;		///< 명령 내려진 속도
						double	dRefSpeed;		///< 기준 속도 (Map)
						double	dCmdDecel;		///< 명령 내려진 가속도
						int		nKeyCount;		///< 명령 내려진 위치의 Node Count
						int		nCount;			///< 명령 내려진 위치의 Node Count
						double	dDist;			///< 명령 내려진 실 거리 (모터 값)
						double	dSpeedDownPos;	///< 감속 시작 실 위치 (모터 값)
						*/
						ADD_LOG("D-75");
					}
					else if(pInfoSet->Position.CmdRefInfo.nKeyCount == TempDrivnigInfo.nCheckNodeCount)
					{
						//전체 초기화
						pInfoSet->Position.CmdRefInfo.dCmdSpeed =  0.0;
						pInfoSet->Position.CmdRefInfo.dRefSpeed =  0.0;
						pInfoSet->Position.CmdRefInfo.dCmdDecel =  0.0;
						pInfoSet->Position.CmdRefInfo.dDist = 0.0;
						pInfoSet->Position.CmdRefInfo.dSpeedDownPos = 0.0;

						pInfoSet->Position.CmdRefInfo.nCount =pInfoSet->HwInfo.Node.nNodeCount;
						pInfoSet->Position.CmdRefInfo.nKeyCount =pInfoSet->HwInfo.Node.nNodeCount;

						/*
						double	dCmdSpeed;		///< 명령 내려진 속도
						double	dRefSpeed;		///< 기준 속도 (Map)
						double	dCmdDecel;		///< 명령 내려진 가속도
						int		nKeyCount;		///< 명령 내려진 위치의 Node Count
						int		nCount;			///< 명령 내려진 위치의 Node Count
						double	dDist;			///< 명령 내려진 실 거리 (모터 값)
						double	dSpeedDownPos;	///< 감속 시작 실 위치 (모터 값)
						*/
						ADD_LOG("D-76");
					}
					else if(pInfoSet->Position.CmdRefInfo.nCount >= TempDrivnigInfo.nCheckNodeCount)
					{

						//마지막 위치가 짧아지는 경우는 그위치까지 낼수있는 Max Speed를 확인한다.
						pNodeInfo = getNodeInfo(TempDrivnigInfo.nCheckNodeCount);
						dSpeedResult = getMaxSpeed(m_pParamSet->Axis.Default.dDefaultAccel
														,m_pParamSet->Axis.Default.dDefaultDecel
														,(getRealPos(pNodeInfo->dDistSum)-pInfoSet->HwInfo.Axis1.dCurrPos));

						//Data 일부 초기화
						if(dSpeedResult < pInfoSet->Position.CmdRefInfo.dCmdSpeed)
							pInfoSet->Position.CmdRefInfo.dCmdSpeed =  dSpeedResult;

						if(dSpeedResult  < pInfoSet->Position.CmdRefInfo.dRefSpeed)
							pInfoSet->Position.CmdRefInfo.dRefSpeed =  dSpeedResult;

						pInfoSet->Position.CmdRefInfo.dDist = pInfoSet->HwInfo.Axis1.dCurrPos;

						pInfoSet->Position.CmdRefInfo.nCount = TempDrivnigInfo.nCheckNodeCount;
					}

					ADD_LOG("D_143/%d/%d/%d/%f/%d/%f"
					,pInfoSet->HwInfo.Node.nNodeCount
					,pInfoSet->Position.CmdRefInfo.nCount
					,pInfoSet->Position.CmdRefInfo.nKeyCount
					,pInfoSet->HwInfo.Axis1.dSpeed
					,TempDrivnigInfo.nCheckNodeCount,dSpeedResult);




				}
				else
				{
					m_pExecuteInfo->FlagPathChange.cResult = FAIL;
					ADD_LOG("D-77");
				}

			}
			else
			{
				m_pExecuteInfo->FlagPathChange.cResult = FAIL;
				ADD_LOG("D-78");
			}

			m_pExecuteInfo->FlagPathChange.bPathChange =false;

		}
	}catch(...)
		ADD_LOG("D-79");


	return  nError;


}

/**
@brief   근접 제어 무시 설정 가능 여부 판단
@see     AMOHTV80F-1606
@return  근접 제어 무시 설정 가능 여부
*/
bool DrivingControl::CanIgnoreVHLDetect()
{
	return (
		// 대차 무시 해제 상태 (정상적으로 센서 감지후 정지함) 인 경우
		(pHWSet->GetAMCVHLDetectStatus() == 1) &&
		// 전방 감지 센서에서 정지 레벨이 감지되지 아닌 경우
		(pHWSet->m_pOHTDetect->GetStatus() != DETECT_AND_STOP) &&
		(pHWSet->m_pObstacle->GetStatus() != DETECT_AND_STOP)
	);
}

/*
@brief    MTL 빼냄 확인 부분
@author   puting
@date    2016.11.06
@brief	 현재 PIO가 8점 지원안됨.
@return 에러 없으면 0반환, 있으면 에러 코드 반환
*/
UINT DrivingControl::checMTLTakeOut(DRIVING_HW_INFO_SET HwInfo)
{

	int nError = NO_ERR;

	//---------------------------------------------------------
	NODE_INFO_STD_PATHDATA Pathdata;
  	int tmpCurrenrtNodeID = 0;
	int tmpCurrentStationID = 0;
	bool bCheckTakeoutStart = false;

	tmpCurrenrtNodeID = (int)m_PositionInfo.CurrNode;
	tmpCurrentStationID = (int)m_PositionInfo.CurrStation;

//배출
	 //타이머 체크
    DWORD dwCurrTime = timeGetTime();
	static  DWORD   dwMTLTakeOutTime = timeGetTime();

	 if((m_nMTLTakeOutPIOStep != MTL_TakeOut_CTRL_STEP_NONE) && (m_nMTLTakeOutPIOStep != MTL_TakeOut_CTRL_STEP_COMPLETE))
	 {

		if(OHTUTILITY::PreventOverflowGetTimeMs(dwMTLTakeOutTime) > (4*60000))
		{
		  	return ERR_MTL_TAKEOUT_TIME_OUT;
     	}
	 }

 //PIO 세팅 김태균
	if(m_pExecuteInfo->FlagMTLInfo.bTakeoutCycle == true)
	{
			if(tmpCurrentStationID != 0 )
			{
				nError = OHTMainForm->GetPathDataManager_STD()->GetPathData(OHTMainForm->GetPathData_STD(),&Pathdata, tmpCurrentStationID);

				if((nError == NO_ERR) && (Pathdata.LayoutType == 0x01))
				{
					if((Pathdata.LeftNodeIDIn == tmpCurrentStationID) || (Pathdata.RightNodeIDIn == tmpCurrentStationID))
						bCheckTakeoutStart = true;
				}

//				ADD_LOG("D_144/%d/%d/%d/%d/%d/%d/%d",
//				tmpCurrentStationID,m_pExecuteInfo->FlagMTLInfo.nTakeOut,Pathdata.LeftNodeIDIn,Pathdata.RightNodeIDIn
//				,nError,bCheckTakeoutStart,Pathdata.LayoutType);

			   if ((bCheckTakeoutStart == true)&&(pHWSet->m_pDrivingAxis->IsRunning() == false)
				&&((m_pExecuteInfo->FlagMTLInfo.nTakeOut == INIT) || (m_pExecuteInfo->FlagMTLInfo.nTakeOut == COMPLETE))
				&&(m_nMTLTakeOutPIOStep == MTL_TakeOut_CTRL_STEP_NONE)
				&&(m_nMTLTakeInPIOStep == MTL_TakeIn_CTRL_STEP_NONE))
			   {

					nError = pHWSet->m_pLeftEQPIO->Set_RFPIO_Data_RS232_Hybrid(EQ_PIO_IR,0,0,0, m_defualtparam->VHLName);
					m_pMTLPIO->PIOEnable();
					m_nMTLTakeOutPIOStep = MTL_TakeOut_CTRL_STEP_INIT;
					ADD_LOG("D-80");

					dwMTLTakeOutTime = timeGetTime();
			   }
		   }else
		   {
				//주회주행
			   if(m_nMTLTakeOutPIOStep == MTL_TakeOut_CTRL_NG_COMPLETE)
					m_nMTLTakeOutPIOStep = MTL_TakeOut_CTRL_STEP_NONE;
		   }
	 }else
	 {
	 	//주회주행
       	if(m_nMTLTakeOutPIOStep == MTL_TakeOut_CTRL_NG_COMPLETE)
			m_nMTLTakeOutPIOStep = MTL_TakeOut_CTRL_STEP_NONE;
	 }


	switch(m_nMTLTakeOutPIOStep)
	{
		case MTL_TakeOut_CTRL_STEP_INIT:
		{

			if (m_pMTLPIO->IsGoSignalOn()== true)
			{
			   m_pMTLPIO->OHTInpositionOnOff_TR(ON);
			   ADD_LOG("D-81");
			   dwMTLTakeOutTime = timeGetTime();
			   m_nMTLTakeOutPIOStep++;
			}else
			{
             	m_pMTLPIO->PIOEnable();
            }
		}
		break;
		case MTL_TakeOut_CTRL_STEP_OCSReport_CHECK:
		  {

		  	dwMTLTakeOutTime = timeGetTime();
			m_nMTLTakeOutPIOStep++;
		  }
		  break;

		case MTL_TakeOut_CTRL_STEP_TakeOutREQ_ON:
		{
			if (m_pMTLPIO->IsGoSignalOn()== true)
			{
				m_pMTLPIO->TakeoutReqOnOff_CS1(ON);
				ADD_LOG("D-82");
				dwMTLTakeOutTime = timeGetTime();
				m_nMTLTakeOutPIOStep++;
			}
		}
		break;

		case MTL_TakeOut_CTRL_STEP_TakeOutOk_SIGNAL_CHECK:
		{
		  if (m_pMTLPIO->IsGoSignalOn()== true)
		  {
			if(m_pMTLPIO->IsTakeOutOkOn_LR() == true)
			{
				EnterCriticalSection(&OHTMainForm->m_CS);
				m_pExecuteInfo->FlagMTLInfo.nTakeOut = REPORT;
				m_pExecuteInfo->FlagMTLInfo.bTakeoutReport = true;    //빼냄보고 Flag On
				LeaveCriticalSection(&OHTMainForm->m_CS);

				ADD_LOG("D-83");
				dwMTLTakeOutTime = timeGetTime();
				m_nMTLTakeOutPIOStep++;
			}
			else if (m_pMTLPIO->IsTakeOutNGOn_UR() == true)
			 {
				EnterCriticalSection(&OHTMainForm->m_CS);
				m_pExecuteInfo->FlagMTLInfo.nTakeOut = FAIL;
				LeaveCriticalSection(&OHTMainForm->m_CS);
				m_nMTLTakeOutPIOStep = MTL_TakeOut_CTRL_NG_COMPLETE;

				ADD_LOG("D-84");
			 }
		  }

		}
		break;

		case MTL_TakeOut_CTRL_STEP_TakeOutREQ_OFF:
		{
			if (m_pMTLPIO->IsGoSignalOn()== true)
			{
				m_pMTLPIO->TakeoutReqOnOff_CS1(OFF);
				ADD_LOG("D-85");
				dwMTLTakeOutTime = timeGetTime();
				m_nMTLTakeOutPIOStep++;
			}
		}
		break;

		case MTL_TakeOut_CTRL_STEP_FrontMoveOK_SIGNAL_CHECK:
		{
			if (m_pMTLPIO->IsGoSignalOn()== true)
			{
				if ((m_pMTLPIO->IsMoveOKOn_RD() == true)&&(m_pMTLPIO->IsFrontMoveOn_HA() == true))
				{
					EnterCriticalSection(&OHTMainForm->m_CS);
					m_pExecuteInfo->FlagMTLInfo.nTakeOut = SUCCESS;
					LeaveCriticalSection(&OHTMainForm->m_CS);
					ADD_LOG("D-86");
					dwMTLTakeOutTime = timeGetTime();
					m_nMTLTakeOutPIOStep++;
				}
			}
		}
		break;

		case MTL_TakeOut_CTRL_STEP_OHT_MTL_Insert_Start:
		{
			//이동시작
		   	m_pMTLPIO->AllPIOOff();
			if(OHTUTILITY::PreventOverflowGetTimeMs(dwMTLTakeOutTime) > 4000)
			{
                ADD_LOG("D-87");
				dwMTLTakeOutTime = timeGetTime();
				m_nMTLTakeOutPIOStep++;
			}
		}
		break;

		case MTL_TakeOut_CTRL_STEP_OHT_MTL_Insert_End:
		{
			if(tmpCurrentStationID != 0 )
			{
				nError = OHTMainForm->GetPathDataManager_STD()->GetPathData(OHTMainForm->GetPathData_STD(),&Pathdata, tmpCurrentStationID);

				if((nError == NO_ERR) && (Pathdata.LayoutType == 0x01))
				{
					if((Pathdata.LeftNodeIDMiddle == tmpCurrentStationID) || (Pathdata.RightNodeIDMiddle == tmpCurrentStationID))
					  bCheckTakeoutStart = true;
				}
			}

			if ((bCheckTakeoutStart == true)&&(pHWSet->m_pDrivingAxis->IsRunning() == false))
			{
					ADD_LOG("D-88");
					dwMTLTakeOutTime = timeGetTime();
					m_nMTLTakeOutPIOStep++;
			}
		}
		break;

		case MTL_TakeOut_CTRL_STEP_OHT_Inposition_CHECK:
		{
			if (m_pMTLPIO->IsGoSignalOn()== true)
			{
				if(OHTUTILITY::PreventOverflowGetTimeMs(dwMTLTakeOutTime) > 4000)
				{
					m_pMTLPIO->OHTInpositionOnOff_TR(ON);
					ADD_LOG("D-89");
					dwMTLTakeOutTime = timeGetTime();
					m_nMTLTakeOutPIOStep++;
				}
			}else
			{
				m_pMTLPIO->PIOEnable();
			}
		}
		break;

		case MTL_TakeOut_CTRL_STEP_TakeOutCompt_CHECK:
		{
			if (m_pMTLPIO->IsGoSignalOn()== true)
			{
			   if (m_pMTLPIO->IsTakeOutNGOn_UR() == true)
			   {
				m_pMTLPIO->AllPIOOff();
				ADD_LOG("D-90");
				dwMTLTakeOutTime = timeGetTime();
				m_nMTLTakeOutPIOStep++;
			   }
			}
		}
		break;

		case MTL_TakeOut_CTRL_STEP_COMPLETE:
		{
		  if (m_pMTLPIO->IsGoSignalOn() == true)
			{
				m_pMTLPIO->AllPIOOff();

				ADD_LOG("D-91");
			}
		}
		break;

		case MTL_TakeOut_CTRL_NG_COMPLETE:
		{
			ADD_LOG("D-92");
			m_pMTLPIO->AllPIOOff();
//			m_nMTLTakeOutPIOStep = MTL_TakeOut_CTRL_STEP_NONE;
        }
	}




    //----------------------------------------------------
	return nError;

}



/*
@brief    투입 확인 부분
@author  puting
@date    2016.11.06
@brief	 현재 PIO가 8점 지원안됨.
@return 에러 없으면 0반환, 있으면 에러 코드 반환
*/
UINT DrivingControl::checMTLTakeIn(DRIVING_HW_INFO_SET HwInfo)
{
	int nError = NO_ERR;

	//---------------------------------------------------------
	int tmpCurrenrtNodeID = 0;
	int tmpCurrentStationID = 0;

	NODE_INFO_STD_PATHDATA Pathdata;

	tmpCurrenrtNodeID = (int)m_PositionInfo.CurrNode;
	tmpCurrentStationID = (int)m_PositionInfo.CurrStation;

	bool bCheckTakeInStart = false;
	//투입   김태균

	//타이머 체크
	DWORD dwCurrTime = timeGetTime();
	static  DWORD   dwMTLTakeInTime = timeGetTime();

	 if(m_nMTLTakeInPIOStep != MTL_TakeIn_CTRL_STEP_NONE)
	 {

		if(OHTUTILITY::PreventOverflowGetTimeMs(dwMTLTakeInTime) > (4*60000))
		{
		  return ERR_MTL_TAKEIN_TIME_OUT;
		}
	 }


	if((m_pExecuteInfo->ExecuteMode == EXECUTE_MODE_AUTO)
	 && (pHWSet->m_pDrivingAxis->IsRunning() == false)
	 && (m_nMTLTakeOutPIOStep == MTL_TakeOut_CTRL_STEP_NONE)
	 && (m_nMTLTakeInPIOStep == MTL_TakeIn_CTRL_STEP_NONE))
	 {

			if(tmpCurrentStationID != 0 )
			{
				nError = OHTMainForm->GetPathDataManager_STD()->GetPathData(OHTMainForm->GetPathData_STD(),&Pathdata, tmpCurrentStationID);

			   if((nError == NO_ERR) && (Pathdata.LayoutType == 0x01))
			   {
					if((Pathdata.LeftNodeIDMiddle == tmpCurrentStationID) || (Pathdata.RightNodeIDMiddle == tmpCurrentStationID))
						bCheckTakeInStart = true;
			   }

			   if (bCheckTakeInStart == true)
			   {

					//PIO로 투입 상태 확인
					if (m_pMTLPIO->IsGoSignalOn()== false)
					{
						pHWSet->m_pLeftEQPIO->Set_RFPIO_Data_RS232_Hybrid(EQ_PIO_IR,0,0,0,m_defualtparam->VHLName);

					}
					else
					{
						m_pMTLPIO->OHTInpositionOnOff_TR(ON); //투입전 정위치 신호

						if (m_pMTLPIO->IsTakeOutOkOn_LR() == true) //MTL로부터 투입 시작신호가 올경우 시작.
						{

							m_nMTLTakeInPIOStep = MTL_TakeIn_CTRL_STEP_INIT;
							dwMTLTakeInTime = timeGetTime();
							ADD_LOG("D-93");
						}
					}
			   }
		   }

	}


   switch(m_nMTLTakeInPIOStep)
   {
	   case MTL_TakeIn_CTRL_STEP_INIT:
	   {

			EnterCriticalSection(&OHTMainForm->m_CS);
			m_pExecuteInfo->FlagMTLInfo.nTakeIn = REQ_INSERT;
			m_pExecuteInfo->FlagMTLInfo.nRailNum = 0x01;
			m_pExecuteInfo->FlagMTLInfo.bTakeInCycle = true;
			LeaveCriticalSection(&OHTMainForm->m_CS);

			ADD_LOG("D-94");
			dwMTLTakeInTime = timeGetTime();
			m_nMTLTakeInPIOStep++;

	   }
	   break;

	   case MTL_TakeIn_CTRL_STEP_OHTTakeIn_OK_CHECK:
	   {
		 if (m_pMTLPIO->IsGoSignalOn()== true)
		 {
			if (m_pExecuteInfo->FlagMTLInfo.nTakeInOrder == SUCCESS)
			{
				m_pMTLPIO->TakeInOKOnOff_VA(ON);
				ADD_LOG("D-95");

				dwMTLTakeInTime = timeGetTime();
				m_nMTLTakeInPIOStep++;
			}
			else if (m_pExecuteInfo->FlagMTLInfo.nTakeInOrder == FAIL)
			{
				m_nMTLTakeInPIOStep = MTL_TakeIn_CTRL_STEP_OCSReport_Error;
			  	ADD_LOG("D-96");
			}
		 }else
		 {
             m_pMTLPIO->PIOEnable();
         }
	   }
	   break;

	   case MTL_TakeIn_CTRL_STEP_TakeIn_SIGNAL_CHECK:
	   {
			if (m_pMTLPIO->IsGoSignalOn()== true)
			{
				if ((m_pMTLPIO->IsMoveOKOn_RD() == true)&&(m_pMTLPIO->IsFrontMoveOn_HA() == true))
				{
					ADD_LOG("D-97");
					dwMTLTakeInTime = timeGetTime();
					m_nMTLTakeInPIOStep++;
				}
//				ADD_LOG("D_145/%d/%d",m_pMTLPIO->IsMoveOKOn_RD(),m_pMTLPIO->IsFrontMoveOn_HA());
			}
	   }
	   break;

	  case MTL_TakeIn_CTRL_STEP_OHT_MTL_TakeIn_Start:
	  {
			//이동시작
			m_pMTLPIO->AllPIOOff();
			if(OHTUTILITY::PreventOverflowGetTimeMs(dwMTLTakeInTime) > 4000)
			{
				ADD_LOG("D-98");
				dwMTLTakeInTime = timeGetTime();
				m_nMTLTakeInPIOStep++;
			}
	  }
	  break;

	  case MTL_TakeIn_CTRL_STEP_OHT_MTL_TakeIn_End:
	  {
			if(tmpCurrentStationID != 0 )
			{
			   nError = OHTMainForm->GetPathDataManager_STD()->GetPathData(OHTMainForm->GetPathData_STD(),&Pathdata, tmpCurrentStationID);
			   if((nError == NO_ERR) && (Pathdata.LayoutType == 0x01))
			   {
					if(((Pathdata.LeftDriveDirection == 0) &&(Pathdata.LeftNodeIDOut == tmpCurrentStationID))||
					   ((Pathdata.RightDriveDirection == 0) &&(Pathdata.RightNodeIDOut == tmpCurrentStationID)) ||
					   ((Pathdata.LeftDriveDirection == 1) &&(Pathdata.LeftNodeIDIn == tmpCurrentStationID)) ||
					   ((Pathdata.RightDriveDirection == 1) &&(Pathdata.RightNodeIDIn == tmpCurrentStationID))
					   )
						bCheckTakeInStart = true;
			   }
			}
			if ((bCheckTakeInStart == true)&&(pHWSet->m_pDrivingAxis->IsRunning() == false))
			{
				ADD_LOG("D-99");
				dwMTLTakeInTime = timeGetTime();
				m_nMTLTakeInPIOStep++;
			}
	  }
	  break;

	  case MTL_TakeIn_CTRL_STEP_OHT_Inposition_CHECK:
		{
			if (m_pMTLPIO->IsGoSignalOn()== true)
			{
				if(OHTUTILITY::PreventOverflowGetTimeMs(dwMTLTakeInTime) > 4000)
				{
					m_pMTLPIO->OHTInpositionOnOff_TR(ON);
					ADD_LOG("D-100");
					dwMTLTakeInTime = timeGetTime();
					m_nMTLTakeInPIOStep++;
				}
			}else
			{
                m_pMTLPIO->PIOEnable();
            }
		}
		break;

	  case MTL_TakeIn_CTRL_STEP_TakeInCompt_CHECK:
		{
			if (m_pMTLPIO->IsGoSignalOn()== true)
			{
			   if (m_pMTLPIO->IsMoveOKOn_RD() == true)
			   {
				m_pMTLPIO->AllPIOOff();
				ADD_LOG("D-101");
				dwMTLTakeInTime = timeGetTime();
				m_nMTLTakeInPIOStep++;
			   }
			}
		}
		break;

		case MTL_TakeIn_CTRL_STEP_COMPLETE:
		{
		  if (m_pMTLPIO->IsGoSignalOn() == true)
			{
				m_pMTLPIO->PIODisable(true);
				pHWSet->m_pLeftEQPIO->Init_SequenceForRFPIOConnection();
				ADD_LOG("D-102");

				EnterCriticalSection(&OHTMainForm->m_CS);
				m_pExecuteInfo->FlagMTLInfo.bTakeInCycle = false;
				m_pExecuteInfo->FlagMTLInfo.nTakeInOrder = INIT;
				LeaveCriticalSection(&OHTMainForm->m_CS);
				m_nMTLTakeInPIOStep = MTL_TakeIn_CTRL_STEP_NONE;
			}
		}
		break;

		case MTL_TakeIn_CTRL_STEP_OCSReport_Error:
		{
		  m_pMTLPIO->AllPIOOff();
		  ADD_LOG("D-103");
		  //return OCS 투입불가 Error 처리
		  EnterCriticalSection(&OHTMainForm->m_CS);
		  m_pExecuteInfo->FlagMTLInfo.bTakeInCycle = false;
		  m_pExecuteInfo->FlagMTLInfo.nTakeInOrder = INIT;
		  LeaveCriticalSection(&OHTMainForm->m_CS);
		  m_nMTLTakeInPIOStep = MTL_TakeIn_CTRL_STEP_NONE;
		}
		break;


   }




    //----------------------------------------------------
	return nError;

}


/*
@brief    MTL 빼냄 확인 부분
@author   puting
@date    2016.11.06
@brief	 현재 PIO가 8점 지원안됨.
@return 에러 없으면 0반환, 있으면 에러 코드 반환
*/
//UINT DrivingControl::checMTLTakeOut_PIO8(DRIVING_HW_INFO_SET HwInfo)
//{
//
//	int nError = NO_ERR;
//	//---------------------------------------------------------
//	NODE_INFO_STD_PATHDATA Pathdata;
//  	int tmpCurrenrtNodeID = 0;
//	int tmpCurrentStationID = 0;
//	bool bCheckTakeoutStart = false;
//
//	static bool bIsBack = false;
//
//	tmpCurrenrtNodeID = (int)m_PositionInfo.CurrNode;
//	tmpCurrentStationID = (int)m_PositionInfo.CurrStation;
//
////배출
//	 //타이머 체크
//    DWORD dwCurrTime = timeGetTime();
//	static  DWORD   dwMTLTakeOutTime = timeGetTime();
//
//	 if((m_nMTLTakeOutPIOStep != MTL_TakeOut_CTRL_STEP_NONE) && (m_nMTLTakeOutPIOStep != MTL_TakeOut_CTRL_STEP_COMPLETE))
//	 {
//
//		if(OHTUTILITY::PreventOverflowGetTimeMs(dwMTLTakeOutTime) > (4*60000))
//		{
//		  	return ERR_MTL_TAKEOUT_TIME_OUT;
//     	}
//	 }
//
// //PIO 세팅 김태균
//	if(m_pExecuteInfo->FlagMTLInfo.bTakeoutCycle == true)
//	{
//			if(tmpCurrentStationID != 0 )
//			{
//				nError = OHTMainForm->GetPathDataManager_STD()->GetPathData(OHTMainForm->GetPathData_STD(),&Pathdata, tmpCurrentStationID);
//
//				if((nError == NO_ERR) && (Pathdata.LayoutType == 0x01))
//				{
//					if((Pathdata.LeftNodeIDIn == tmpCurrentStationID) || (Pathdata.RightNodeIDIn == tmpCurrentStationID))
//					{
//						if(Pathdata.LeftNodeIDIn == tmpCurrentStationID)
//							bIsBack  = Pathdata.LeftDriveDirection;
//						else
//							bIsBack  = Pathdata.RightDriveDirection;
//
//						bCheckTakeoutStart = true;
//					}
//				}
//
////				ADD_LOG("D_146/%d/%d/%d/%d/%d/%d/%d",
////				tmpCurrentStationID,m_pExecuteInfo->FlagMTLInfo.nTakeOut,Pathdata.LeftNodeIDIn,Pathdata.RightNodeIDIn
////				,nError,bCheckTakeoutStart,Pathdata.LayoutType);
//
//			   if ((bCheckTakeoutStart == true)&&(pHWSet->m_pDrivingAxis->IsRunning() == false)
//				&&((m_pExecuteInfo->FlagMTLInfo.nTakeOut == INIT) || (m_pExecuteInfo->FlagMTLInfo.nTakeOut == COMPLETE))
//				&&(m_nMTLTakeOutPIOStep == MTL_TakeOut_CTRL_STEP_NONE)
//				&&(m_nMTLTakeInPIOStep == MTL_TakeIn_CTRL_STEP_NONE))
//			   {
//
//					nError = pHWSet->m_pLeftEQPIO->Set_RFPIO_Data_RS232_Hybrid(EQ_PIO_IR,0,0,0, m_defualtparam->VHLName);
//					m_pMTLPIO->PIOEnable();
//					m_nMTLTakeOutPIOStep = MTL_TakeOut_CTRL_STEP_INIT;
//					ADD_LOG("D-104");
//
//					dwMTLTakeOutTime = timeGetTime();
//			   }
//		   }else
//		   {
//				//주회주행
//			   if(m_nMTLTakeOutPIOStep == MTL_TakeOut_CTRL_NG_COMPLETE)
//					m_nMTLTakeOutPIOStep = MTL_TakeOut_CTRL_STEP_NONE;
//		   }
//	 }else
//	 {
//	 	//주회주행
//       	if(m_nMTLTakeOutPIOStep == MTL_TakeOut_CTRL_NG_COMPLETE)
//			m_nMTLTakeOutPIOStep = MTL_TakeOut_CTRL_STEP_NONE;
//	 }
//
//
//	switch(m_nMTLTakeOutPIOStep)
//	{
//		case MTL_TakeOut_CTRL_STEP_INIT:
//		{
//
//			if (m_pMTLPIO->IsGoSignalOn()== true)
//			{
//			   m_pMTLPIO->OHTInpositionOnOff_TR(ON);
//			   ADD_LOG("D-105");
//			   dwMTLTakeOutTime = timeGetTime();
//			   m_nMTLTakeOutPIOStep++;
//			}else
//			{
//             	m_pMTLPIO->PIOEnable();
//            }
//		}
//		break;
//		case MTL_TakeOut_CTRL_STEP_OCSReport_CHECK:
//		  {
//
//		  	dwMTLTakeOutTime = timeGetTime();
//			m_nMTLTakeOutPIOStep++;
//		  }
//		  break;
//
//		case MTL_TakeOut_CTRL_STEP_TakeOutREQ_ON:
//		{
//			if (m_pMTLPIO->IsGoSignalOn()== true)
//			{
//				m_pMTLPIO->TakeoutReqOnOff_CS1(ON);
//				ADD_LOG("D-106");
//				dwMTLTakeOutTime = timeGetTime();
//				m_nMTLTakeOutPIOStep++;
//			}
//		}
//		break;
//
//		case MTL_TakeOut_CTRL_STEP_TakeOutOk_SIGNAL_CHECK:
//		{
//		  if (m_pMTLPIO->IsGoSignalOn()== true)
//		  {
//			if(m_pMTLPIO->IsTakeOutOK_PIO8() == true)
//			{
//				ADD_LOG("D-107");
//				dwMTLTakeOutTime = timeGetTime();
//				m_nMTLTakeOutPIOStep++;
//			}
//			else if (m_pMTLPIO->IsTakeOutNG_PIO8() == true)
//			 {
//				EnterCriticalSection(&OHTMainForm->m_CS);
//				m_pExecuteInfo->FlagMTLInfo.nTakeOut = FAIL;
//				LeaveCriticalSection(&OHTMainForm->m_CS);
//				m_nMTLTakeOutPIOStep = MTL_TakeOut_CTRL_NG_COMPLETE;
//
//				ADD_LOG("D-108");
//			 }
//		  }
//
//		}
//		break;
//
//		case MTL_TakeOut_CTRL_STEP_TakeOutREQ_OFF:
//		{
//			if (m_pMTLPIO->IsGoSignalOn()== true)
//			{
//				m_pMTLPIO->TakeoutReqOnOff_CS1(OFF);
//				ADD_LOG("D-109");
//				dwMTLTakeOutTime = timeGetTime();
//				m_nMTLTakeOutPIOStep++;
//			}
//		}
//		break;
//
//		case MTL_TakeOut_CTRL_STEP_FrontMoveOK_SIGNAL_CHECK:
//		{
//			if (m_pMTLPIO->IsGoSignalOn()== true)
//			{
//				if(bIsBack ==false)
//				{
//					if ((m_pMTLPIO->IsMoveOK_PIO8() == true)&&(m_pMTLPIO->IsMove_Front_PIO8() == true))
//					{
//						EnterCriticalSection(&OHTMainForm->m_CS);
//						m_pExecuteInfo->FlagMTLInfo.nTakeOut = SUCCESS;
//						LeaveCriticalSection(&OHTMainForm->m_CS);
//						ADD_LOG("D-110");
//						dwMTLTakeOutTime = timeGetTime();
//						m_nMTLTakeOutPIOStep++;
//					}
//				}else
//				{
//					if ((m_pMTLPIO->IsMoveOK_PIO8() == true)&&(m_pMTLPIO->IsMove_Back_PIO8() == true))
//					{
//						EnterCriticalSection(&OHTMainForm->m_CS);
//						m_pExecuteInfo->FlagMTLInfo.nTakeOut = SUCCESS;
//						LeaveCriticalSection(&OHTMainForm->m_CS);
//						ADD_LOG("D-111");
//						dwMTLTakeOutTime = timeGetTime();
//						m_nMTLTakeOutPIOStep++;
//					}
//				}
//			}
//		}
//		break;
//
//		case MTL_TakeOut_CTRL_STEP_OHT_MTL_Insert_Start:
//		{
//			//이동시작
//			m_pMTLPIO->AllPIOOff();
//			if(OHTUTILITY::PreventOverflowGetTimeMs(dwMTLTakeOutTime) > 4000)
//			{
//                ADD_LOG("D-112");
//				dwMTLTakeOutTime = timeGetTime();
//				m_nMTLTakeOutPIOStep++;
//			}
//		}
//		break;
//
//		case MTL_TakeOut_CTRL_STEP_OHT_MTL_Insert_End:
//		{
//			nError = OHTMainForm->GetPathDataManager_STD()->GetPathData(OHTMainForm->GetPathData_STD(),&Pathdata, tmpCurrentStationID);
//
//			if((nError == NO_ERR) && (Pathdata.LayoutType == 0x01))
//			{
//				if((Pathdata.LeftNodeIDMiddle == tmpCurrentStationID) || (Pathdata.RightNodeIDMiddle == tmpCurrentStationID))
//				  bCheckTakeoutStart = true;
//			}
//
//			if ((bCheckTakeoutStart == true)&&(pHWSet->m_pDrivingAxis->IsRunning() == false))
//			{
//				ADD_LOG("D-113");
//
//					dwMTLTakeOutTime = timeGetTime();
//					m_nMTLTakeOutPIOStep++;
//			}
//		}
//		break;
//
//		case MTL_TakeOut_CTRL_STEP_OHT_Inposition_CHECK:
//		{
//			if (m_pMTLPIO->IsGoSignalOn()== true)
//			{
//				if(OHTUTILITY::PreventOverflowGetTimeMs(dwMTLTakeOutTime) > 4000)
//				{
//					m_pMTLPIO->OHTInpositionOnOff_TR(ON);
//					ADD_LOG("D-114");
//					dwMTLTakeOutTime = timeGetTime();
//					m_nMTLTakeOutPIOStep++;
//				}
//			}else
//			{
//                m_pMTLPIO->PIOEnable();
//            }
//		}
//		break;
//
//		case MTL_TakeOut_CTRL_STEP_TakeOutCompt_CHECK:
//		{
//			if (m_pMTLPIO->IsGoSignalOn()== true)
//			{
//			   if (m_pMTLPIO->IsTakeOutComplete_PIO8() == true)
//			   {
//				m_pMTLPIO->AllPIOOff();
//				ADD_LOG("D-115");
//				dwMTLTakeOutTime = timeGetTime();
//				m_nMTLTakeOutPIOStep++;
//			   }
//			}
//		}
//		break;
//
//		case MTL_TakeOut_CTRL_STEP_COMPLETE:
//		{
//		  if (m_pMTLPIO->IsGoSignalOn() == true)
//			{
//				m_pMTLPIO->AllPIOOff();
//
//				ADD_LOG("D-116");
//			}
//		}
//		break;
//
//		case MTL_TakeOut_CTRL_NG_COMPLETE:
//		{
//			ADD_LOG("D-117");
//			m_pMTLPIO->AllPIOOff();
////			m_nMTLTakeOutPIOStep = MTL_TakeOut_CTRL_STEP_NONE;
//        }
//	}
//
//
//
//
//    //----------------------------------------------------
//	return nError;
//
//}




/*
@brief    투입 확인 부분 (투입은 후진 X)
@author  puting
@date    2016.11.06
@brief	 현재 PIO가 8점 지원안됨.
@return 에러 없으면 0반환, 있으면 에러 코드 반환
*/
//UINT DrivingControl::checMTLTakeIn_PIO8(DRIVING_HW_INFO_SET HwInfo)
//{
//	int nError = NO_ERR;
//
//	static int nCheckCount = 0;
//	//---------------------------------------------------------
//	int tmpCurrenrtNodeID = 0;
//	int tmpCurrentStationID = 0;
//
//	NODE_INFO_STD_PATHDATA Pathdata;
//
//	tmpCurrenrtNodeID = (int)m_PositionInfo.CurrNode;
//	tmpCurrentStationID = (int)m_PositionInfo.CurrStation;
//
//	bool bCheckTakeInStart = false;
//	//투입   김태균
//
//	//타이머 체크
//	DWORD dwCurrTime = timeGetTime();
//	static  DWORD   dwMTLTakeInTime = timeGetTime();
//
//	 if(m_nMTLTakeInPIOStep != MTL_TakeIn_CTRL_STEP_NONE)
//	 {
//
//		if(OHTUTILITY::PreventOverflowGetTimeMs(dwMTLTakeInTime) > (4*60000))
//		{
//		  return ERR_MTL_TAKEIN_TIME_OUT;
//		}
//	 }
//
//
//	if((m_pExecuteInfo->ExecuteMode == EXECUTE_MODE_AUTO)
//	 && (pHWSet->m_pDrivingAxis->IsRunning() == false)
//	 && (m_nMTLTakeOutPIOStep == MTL_TakeOut_CTRL_STEP_NONE)
//	 && (m_nMTLTakeInPIOStep == MTL_TakeIn_CTRL_STEP_NONE))
//	 {
//
//			if(tmpCurrentStationID != 0 )
//			{
//				nError = OHTMainForm->GetPathDataManager_STD()->GetPathData(OHTMainForm->GetPathData_STD(),&Pathdata, tmpCurrentStationID);
//
//			   if((nError == NO_ERR) && (Pathdata.LayoutType == 0x01))
//			   {
//					if((Pathdata.LeftNodeIDMiddle == tmpCurrentStationID) || (Pathdata.RightNodeIDMiddle == tmpCurrentStationID))
//						bCheckTakeInStart = true;
//			   }
//
//			   if (bCheckTakeInStart == true)
//			   {
//					nError = pHWSet->m_pLeftEQPIO->Set_RFPIO_Data_RS232_Hybrid(EQ_PIO_IR,0,0,0,m_defualtparam->VHLName);
//
//					//PIO로 투입 상태 확인
//					if (m_pMTLPIO->IsGoSignalOn()== false)
//					{
//						m_pMTLPIO->PIOEnable();
//					}
//					else
//					{
//						m_pMTLPIO->OHTInpositionOnOff_TR(ON); //투입전 정위치 신호
//
//						if (m_pMTLPIO->IsTakeInReq_Rail_1_PIO8() == true) //MTL로부터 투입 시작신호가 올경우 시작.
//						{
//							m_nMTLTakeInPIOStep = MTL_TakeIn_CTRL_STEP_INIT;
//							dwMTLTakeInTime = timeGetTime();
//							ADD_LOG("D-118");
//						}
//					}
//			   }
//		   }
//
//	}
//
//
//   switch(m_nMTLTakeInPIOStep)
//   {
//	   case MTL_TakeIn_CTRL_STEP_INIT:
//	   {
//
//			EnterCriticalSection(&OHTMainForm->m_CS);
//			m_pExecuteInfo->FlagMTLInfo.nTakeIn = REQ_INSERT;
//			m_pExecuteInfo->FlagMTLInfo.nRailNum = 0x01;
//			m_pExecuteInfo->FlagMTLInfo.bTakeInCycle = true;
//			LeaveCriticalSection(&OHTMainForm->m_CS);
//
//			ADD_LOG("D-119");
//			dwMTLTakeInTime = timeGetTime();
//			m_nMTLTakeInPIOStep++;
//
//	   }
//	   break;
//
//	   case MTL_TakeIn_CTRL_STEP_OHTTakeIn_OK_CHECK:
//	   {
//		 if (m_pMTLPIO->IsGoSignalOn()== true)
//		 {
//			if (m_pExecuteInfo->FlagMTLInfo.nTakeInOrder == SUCCESS)
//			{
//				m_pMTLPIO->TakeInOKOnOff_VA(ON);
//				ADD_LOG("D-120");
//
//				dwMTLTakeInTime = timeGetTime();
//				m_nMTLTakeInPIOStep++;
//			}
//			else if (m_pExecuteInfo->FlagMTLInfo.nTakeInOrder == FAIL)
//			{
//				m_nMTLTakeInPIOStep = MTL_TakeIn_CTRL_STEP_OCSReport_Error;
//			  	ADD_LOG("D-121");
//			}
//		 }else
//		 {
//             m_pMTLPIO->PIOEnable();
//         }
//	   }
//	   break;
//
//	   case MTL_TakeIn_CTRL_STEP_TakeIn_SIGNAL_CHECK:
//	   {
//			if (m_pMTLPIO->IsGoSignalOn()== true)
//			{
//				if ((m_pMTLPIO->IsMoveOK_PIO8() == true)&&(m_pMTLPIO->IsMove_Front_PIO8() == true))
//				{
//					ADD_LOG("D-122");
//					dwMTLTakeInTime = timeGetTime();
//					m_nMTLTakeInPIOStep++;
//				}
////				ADD_LOG("D_147/%d/%d",m_pMTLPIO->IsMoveOKOn_RD(),m_pMTLPIO->IsFrontMoveOn_HA());
//			}
//	   }
//	   break;
//
//	  case MTL_TakeIn_CTRL_STEP_OHT_MTL_TakeIn_Start:
//	  {
//			//이동시작
//			m_pMTLPIO->AllPIOOff();
//			if(OHTUTILITY::PreventOverflowGetTimeMs(dwMTLTakeInTime) > 4000)
//			{
//				ADD_LOG("D-123");
//				dwMTLTakeInTime = timeGetTime();
//				m_nMTLTakeInPIOStep++;
//			}
//	  }
//	  break;
//
//	  case MTL_TakeIn_CTRL_STEP_OHT_MTL_TakeIn_End:
//	  {
//	  	   nError = OHTMainForm->GetPathDataManager_STD()->GetPathData(OHTMainForm->GetPathData_STD(),&Pathdata, tmpCurrentStationID);
//		   if((nError == NO_ERR) && (Pathdata.LayoutType == 0x01))
//		   {
//				if(((Pathdata.LeftDriveDirection == 0) &&(Pathdata.LeftNodeIDOut == tmpCurrentStationID))||
//				   ((Pathdata.RightDriveDirection == 0) &&(Pathdata.RightNodeIDOut == tmpCurrentStationID)) ||
//				   ((Pathdata.LeftDriveDirection == 1) &&(Pathdata.LeftNodeIDIn == tmpCurrentStationID)) ||
//				   ((Pathdata.RightDriveDirection == 1) &&(Pathdata.RightNodeIDIn == tmpCurrentStationID))
//				   )
//					bCheckTakeInStart = true;
//		   }
//
//			if ((bCheckTakeInStart == true)&&(pHWSet->m_pDrivingAxis->IsRunning() == false))
//			{
//				ADD_LOG("D-124");
//				dwMTLTakeInTime = timeGetTime();
//				m_nMTLTakeInPIOStep++;
//			}
//	  }
//	  break;
//
//	  case MTL_TakeIn_CTRL_STEP_OHT_Inposition_CHECK:
//		{
//			if (m_pMTLPIO->IsGoSignalOn()== true)
//			{
//				if(OHTUTILITY::PreventOverflowGetTimeMs(dwMTLTakeInTime) > 4000)
//				{
//					m_pMTLPIO->OHTInpositionOnOff_TR(ON);
//					ADD_LOG("D-125");
//					dwMTLTakeInTime = timeGetTime();
//					m_nMTLTakeInPIOStep++;
//				}
//			}else
//			{
//                m_pMTLPIO->PIOEnable();
//            }
//		}
//		break;
//
//	  case MTL_TakeIn_CTRL_STEP_TakeInCompt_CHECK:
//		{
//			if (m_pMTLPIO->IsGoSignalOn()== true)
//			{
//			   if (m_pMTLPIO->IsTakeInComplete_PIO8() == true)
//			   {
//				m_pMTLPIO->AllPIOOff();
//				ADD_LOG("D-126");
//				dwMTLTakeInTime = timeGetTime();
//				m_nMTLTakeInPIOStep++;
//			   }
//			}
//		}
//		break;
//
//		case MTL_TakeIn_CTRL_STEP_COMPLETE:
//		{
//		  if (m_pMTLPIO->IsGoSignalOn() == true)
//			{
//				m_pMTLPIO->AllPIOOff();
//				ADD_LOG("D-127");
//
//				EnterCriticalSection(&OHTMainForm->m_CS);
//				m_pExecuteInfo->FlagMTLInfo.bTakeInCycle = false;
//				m_pExecuteInfo->FlagMTLInfo.nTakeInOrder = INIT;
//				LeaveCriticalSection(&OHTMainForm->m_CS);
//				m_nMTLTakeInPIOStep = MTL_TakeIn_CTRL_STEP_NONE;
//			}
//		}
//		break;
//
//		case MTL_TakeIn_CTRL_STEP_OCSReport_Error:
//		{
//		  m_pMTLPIO->AllPIOOff();
//		  ADD_LOG("D-128");
//		  //return OCS 투입불가 Error 처리
//		  EnterCriticalSection(&OHTMainForm->m_CS);
//		  m_pExecuteInfo->FlagMTLInfo.bTakeInCycle = false;
//		  m_pExecuteInfo->FlagMTLInfo.nTakeInOrder = INIT;
//		  LeaveCriticalSection(&OHTMainForm->m_CS);
//		  m_nMTLTakeInPIOStep = MTL_TakeIn_CTRL_STEP_NONE;
//		}
//		break;
//
//
//   }
//
//    //----------------------------------------------------
//	return nError;
//
//}


/*
@brief    Servo 내부제한토크  상태 설정 및 명령 생성
@author  박태욱
@date    2016.08.06
@param pInfoSet 입력/변경되는 상태 정보
@param pDetectCtrl 전방 감지 명령 정보
@return 에러 없으면 0반환, 있으면 에러 코드 반환
*/
UINT DrivingControl::checkServoTorqueFlag(DRIVING_INFO_SET *pInfoSet)
{
	int nError = NO_ERR;
	DWORD dwCurrTime = timeGetTime();
	static int nCheckCount = 0;
	static int nCheckCount_Torqur90=0;
	static int nCheckCount_Torqur800=0;

	DRIVING_CMD_INFO_OF_NODE* pNodeInfo = getNodeInfo(pInfoSet->HwInfo.Node.nNodeCount);

	//경사로 유무 판단하는 부분
	if(pNodeInfo->NodeType ==SLOPE_NTYPE)
	{
		if(pNodeInfo->NodeType != m_cSlopeNodeInfo)
		{
			ADD_LOG("D-129");
			m_pDrivingAxis->SetSlopeTime();
		}

	}
	else
	{
		if((m_cSlopeNodeInfo ==SLOPE_NTYPE) || (m_cSlopeNodeInfo ==INIT_NTYPE))
		{
			ADD_LOG("D-130");
			m_pDrivingAxis->SetSlopeTimeRelease();
		}
	}

	m_cSlopeNodeInfo = pNodeInfo->NodeType;


	if(pNodeInfo==NULL)
    {
		ADD_LOG("D_149/%d/%d"
			, pInfoSet->HwInfo.Node.nNodeCount
			, m_ClassifiedCmd.NodeList.getCount());
		ADD_FDC_LOG("ERR/%d/3/5/%06d/%06d/%d/%d/%06d",
					ERR_NOTFIND_NODE,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pExecuteInfo->ExecutePositionInfo.NextNode,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					m_pOHTMainStatus->StatusCommon.ExistFoup,
					m_pOHTMainStatus->StatusCommon.StopStationID);
		return ERR_NOTFIND_NODE;// 에러 처리 : 명령에 없는 노드 Count 실시
	}

#if((OHT_NAME == OHT_NAME_STD_V82)|| (OHT_NAME == OHT_NAME_STD_V85S)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
	if(m_cSlopeNodeInfo ==SLOPE_NTYPE)
	{

		if(pHWSet->GetAMCTorqueStatus()==SETSLOPE)
		{
			nCheckCount++;
			if(nCheckCount==5)
			{
				m_pDrivingAxis->SetTorqueLimit();
				nCheckCount =0;
			}
		}
		else if(pHWSet->GetAMCTorqueStatus()==RELSLOPE)
		{
			nCheckCount++;
			if(nCheckCount ==5)
			{
				m_pDrivingAxis->SetTorqueLimitRelease();
				nCheckCount =0;
			}
		}
		else
		{

			nCheckCount = 0;
		}

	}

#else
	if(m_defualtparam->bUseRSA==true)
	{
		if(m_cSlopeNodeInfo ==SLOPE_NTYPE)
		{
			// 설정 토크제한 설정
			//AOHC-583 E633 대응 개선으로 Slope 대차 감지 시, Pause 먼저 진행하도록 로직 변경
			if(pHWSet->GetAMCTorqueStatus()==SETSLOPE)
			{
				ERR_LOG("[SETSLOPE] GetAMCTorqueStatus() : %d, GetAMCPauseStatus():%d, IsSetInnerLimitTorque_90():%d, IsSetInnerLimitTorque_800():%d, ",pHWSet->GetAMCTorqueStatus(),pHWSet->GetAMCPauseStatus(),m_pServoControl->IsSetInnerLimitTorque_90(),m_pServoControl->IsSetInnerLimitTorque_800() );

				nCheckCount++;
				if(nCheckCount == 5)
				{
					nCheckCount++;
					if(nCheckCount == 5)
					{
						m_pDrivingAxis->SetTorqueLimit();

						if(m_pRSAControl->IsSetInnerLimitTorque_90() == false)
						 nCheckCount_Torqur90++;
						 if(nCheckCount_Torqur90> 10)    //5*10*16
						 {
							nError = ERR_SERVO_DRIVING_ALARM;
							ERR_LOG("[checkServoTorqueFlag1] Fail SetInnerLimitTorque_90");
							nCheckCount_Torqur90 =0;
						 }
					}
					else
						nCheckCount_Torqur90 =0;

					nCheckCount =0;
					ADD_LOG("D_151/%d",m_pServoControl->IsSetInnerLimitTorque_90());
					ERR_LOG("SETSLOPE 완료");
				}

			}
			// 설정 토크제한 해지
			else if(pHWSet->GetAMCTorqueStatus()==RELSLOPE)
			{
				ERR_LOG("[RELSLOPE] GetAMCTorqueStatus() : %d, GetAMCPauseStatus():%d, IsSetInnerLimitTorque_90():%d, IsSetInnerLimitTorque_800():%d",pHWSet->GetAMCTorqueStatus(),pHWSet->GetAMCPauseStatus(),m_pServoControl->IsSetInnerLimitTorque_90(),m_pServoControl->IsSetInnerLimitTorque_800() );
				nCheckCount++;
				if(nCheckCount ==5)
				{
					if(m_pRSAControl->IsSetInnerLimitTorque_300() == false)
					   m_pRSAControl->SetInnerLimitTorque_300();

					if(m_pRSAControl->IsSetInnerLimitTorque_300()== true)
					{
						m_pDrivingAxis->SetTorqueLimitRelease();
						nCheckCount_Torqur800=0;
					}
					else
					{
						nCheckCount_Torqur800++;
						if(nCheckCount_Torqur800>10)
						{
							nError = ERR_SERVO_DRIVING_ALARM;
							ERR_LOG("[checkServoTorqueFlag1] RSA Fail SetInnerLimitTorque_800");
							nCheckCount_Torqur800=0;
						}
					}
					nCheckCount=0;
					ERR_LOG("RELSLOPE 완료");
				}
			}
			else
			{
				nCheckCount = 0;
				nCheckCount_Torqur90 = 0;
				nCheckCount_Torqur800=0;
			}

        }
		else
		{
			if(m_pRSAControl->IsSetInnerLimitTorque_300() == false)
				m_pRSAControl->SetInnerLimitTorque_300();
		}

	}
	else
	{
		if(m_cSlopeNodeInfo ==SLOPE_NTYPE)
		{
			// 설정 토크제한 설정
			//AOHC-583 E633 대응 개선으로 Slope 대차 감지 시, Pause 먼저 진행하도록 로직 변경
			if(pHWSet->GetAMCTorqueStatus()==SETSLOPE)
			{
				nCheckCount++;
				if(nCheckCount == 5)
				{
					m_pDrivingAxis->SetTorqueLimit();   //

					if(m_pServoControl->IsSetInnerLimitTorque_90() ==false)
					{
						m_pServoControl->SetInnerLimitTorque_90();

						 nCheckCount_Torqur90++;
						 if(nCheckCount_Torqur90> 10)    //5*10*16
						 {
							nError = ERR_SERVO_DRIVING_ALARM;
							ERR_LOG("[checkServoTorqueFlag1] YASKAWA Fail SetInnerLimitTorque_90");
							nCheckCount_Torqur90 =0;
						 }
					}
					else
						nCheckCount_Torqur90 =0;

					nCheckCount =0;
					ADD_LOG("D_151/%d",m_pServoControl->IsSetInnerLimitTorque_90());
				}
			}
			  // 설정 토크제한 해지
			else if(pHWSet->GetAMCTorqueStatus()==RELSLOPE)
			{
				nCheckCount++;
				if(nCheckCount ==5)
				{
					if(m_pServoControl->IsSetInnerLimitTorque_800() ==false)
						m_pServoControl->SetInnerLimitTorque_800();


					if(m_pServoControl->IsSetInnerLimitTorque_800() ==true)
					{
						m_pDrivingAxis->SetTorqueLimitRelease();
						nCheckCount_Torqur800=0;
					}
					else
					{
						nCheckCount_Torqur800++;
						if(nCheckCount_Torqur800>10)
						{
							nError = ERR_SERVO_DRIVING_ALARM;
							ERR_LOG("[checkServoTorqueFlag1] YASKAWA Fail SetInnerLimitTorque_800");
							nCheckCount_Torqur800=0;
						}
					}
					nCheckCount=0;
				}
			}
			else
			{
				nCheckCount = 0;
				nCheckCount_Torqur90 = 0;
				nCheckCount_Torqur800=0;
			}
		}
		else
		{
			if(m_pServoControl->IsSetInnerLimitTorque_800() ==false)
				m_pServoControl->SetInnerLimitTorque_800();
		}
	}
#endif

	return nError;

}
/*
@brief    전방 감지 상태 설정 및 명령 생성
@author  임태웅
@date    2013.08.06
@param pInfoSet 입력/변경되는 상태 정보
@param pDetectCtrl 전방 감지 명령 정보
@return 에러 없으면 0반환, 있으면 에러 코드 반환
*/
UINT DrivingControl::checkFrontObservation(DRIVING_INFO_SET *pInfoSet)
{
    UINT nTmpError = NO_ERR;
	static int nDistNotMatch = 0;
	static int nUBGNotMatch = 0;

    DWORD dwCurrTime = timeGetTime();
    bool bStopWithNoReason = false;
	USER_DETECT_INFO DetectInfo;

	double  dSpeedOfNow = pInfoSet->HwInfo.Axis1.dSpeed;

	static int nDiagUD = 0;
	static int nDiagUC = 0;
	static int nDiagUF = 0;

//	memset(&DetectInfo, 0, sizeof(CTRL_INFO_OF_FRONT_DETECT));
	memset(&DetectInfo, 0, sizeof(USER_DETECT_INFO));
    // Control 정보
	CTRL_INFO_OF_FRONT_DETECT* pDetectCtrl = &(pInfoSet->Control.FrontObservation);

    //2 Time
#if(UBG_SENSOR_ENABLE == ON)
	if(pInfoSet->HwInfo.IO.DetectStatus==DETECT_UNIT_FAIL)
	{
		if(pInfoSet->Time.FrontObserve.OHTDetectFail.bFlag==false)
		{
			pInfoSet->Time.FrontObserve.OHTDetectFail.bFlag = true;
			pInfoSet->Time.FrontObserve.OHTDetectFail.dwTime = dwCurrTime;
		}
	}
	else
	{
		pInfoSet->Time.FrontObserve.OHTDetectFail.bFlag = false;
	}
#endif

	if(pInfoSet->HwInfo.IO.ObsStatus==DETECT_UNIT_FAIL)
    {
        if(pInfoSet->Time.FrontObserve.OBSDetectFail.bFlag==false)
        {
            pInfoSet->Time.FrontObserve.OBSDetectFail.bFlag = true;
			pInfoSet->Time.FrontObserve.OBSDetectFail.dwTime = dwCurrTime;
		}
    }
	else
    {
		pInfoSet->Time.FrontObserve.OBSDetectFail.bFlag = false;
    }


#if(UBG_SENSOR_ENABLE == ON)
	if(     (pInfoSet->HwInfo.IO.ObsStatus==DETECT_AND_STOP)
        &&  (pInfoSet->HwInfo.IO.DetectStatus==DETECT_NONE)
        &&  (pHWSet->GetAMCPauseStatus() != STATUS_OHT_PAUSED)
        )
#else
	if(pInfoSet->HwInfo.IO.ObsStatus==DETECT_AND_STOP)
#endif
    {
        if(pInfoSet->Time.FrontObserve.OBSDetect.bFlag==false)
        {
            pInfoSet->Time.FrontObserve.OBSDetect.bFlag = true;
            pInfoSet->Time.FrontObserve.OBSDetect.dwTime = dwCurrTime;
        }
    }
    else
    {
        pInfoSet->Time.FrontObserve.OBSDetect.bFlag = false;
    }

#if(UBG_SENSOR_ENABLE == ON)
	if(     (pInfoSet->HwInfo.IO.DetectStatus==DETECT_AND_STOP)
		&&  (dSpeedOfNow != 0.0)
		&&  (m_mccparam.dUBGDetectStopPoint != 0.0))
	{
		m_mccparam.dUBGDetectStopPoint = pInfoSet->HwInfo.Axis1.dCurrPos;
	}
	else if(pInfoSet->HwInfo.IO.DetectStatus!=DETECT_AND_STOP)
	{
		m_mccparam.dUBGDetectStopPoint = 0;
	}
#endif

#if(UBG_SENSOR_ENABLE == ON)
	if(     ((pInfoSet->HwInfo.IO.ObsStatus == DETECT_AND_STOP)
		||  (pInfoSet->HwInfo.IO.DetectStatus == DETECT_AND_STOP))
		&&	(dSpeedOfNow == 0.0))
#else
	if((pInfoSet->HwInfo.IO.ObsStatus == DETECT_AND_STOP) && (dSpeedOfNow == 0.0))
#endif
	{
		if((m_mccparam.bDetectStatus == false) && (m_bIsAMCVHLDetectIgnore == false))
		{
			m_mccparam.dUBGDetectStopDistance = pInfoSet->HwInfo.Axis1.dCurrPos - m_mccparam.dUBGDetectStopPoint;
			ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,OHT DETECT AND STOP,Start,%s,%06d,%06d,%06d,%d,%3.3lf,OHT Detect Status,%d,OBS Detect Status,%d,OHT Detect Level,%d,OBS Detect Level,%d,OHT Detect Move Dist,%.2f",
								m_defualtparam->VHLName,m_mccparam.cCarrierType,
								m_mccparam.uSourceNode,
								m_mccparam.uTargetNode,
								m_pExecuteInfo->ExecutePositionInfo.CurrNode,
								m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
								dSpeedOfNow,
								pInfoSet->HwInfo.IO.DetectStatus,
								pInfoSet->HwInfo.IO.ObsStatus,
								pHWSet->m_pOHTDetect->GetSensorLevel_MCC(),
								pHWSet->m_pObstacle->GetSensorLevel_MCC(),
								m_mccparam.dUBGDetectStopDistance);
			m_mccparam.bDetectStatus = true;
			m_mccparam.dUBGDetectStopPoint = 0;
			m_mccparam.dUBGDetectStopDistance = 0;
		}

		if((pInfoSet->HwInfo.IO.ObsStatus == DETECT_AND_STOP) && (m_mccparam.dwOBSDetectTime == 0))
		{
			m_mccparam.dwOBSDetectTime = dwCurrTime;
		}
#if(UBG_SENSOR_ENABLE == ON)
		if((pInfoSet->HwInfo.IO.DetectStatus == DETECT_AND_STOP) && (m_mccparam.dwUBGDetectTime == 0))
		{
			m_mccparam.dwUBGDetectTime = dwCurrTime;
		}
#endif
	}


#if(UBG_SENSOR_ENABLE == ON)
	if((m_mccparam.bDetectStatus == true) && (dSpeedOfNow != 0.0) &&
		((pInfoSet->HwInfo.IO.ObsStatus != DETECT_AND_STOP)
		&&  (pInfoSet->HwInfo.IO.DetectStatus != DETECT_AND_STOP)))
#else
	if((m_mccparam.bDetectStatus == true) && (dSpeedOfNow != 0.0) &&
		(pInfoSet->HwInfo.IO.ObsStatus != DETECT_AND_STOP))
#endif
	{
		if(m_mccparam.dwUBGDetectTime != 0)
		{
			m_mccparam.dwUBGDetectTime = OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwUBGDetectTime);
		}

		if(m_mccparam.dwOBSDetectTime != 0)
		{
			m_mccparam.dwOBSDetectTime = OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwOBSDetectTime);
		}
		ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,OHT DETECT AND STOP,End,%s,%06d,%06d,%06d,%d,%3.3lf,OHT Detect Stop Time,%d,OBS Detect Stop Time,%d,OHT Detect Level,%d,OBS Detect Level,%d",
							m_defualtparam->VHLName,m_mccparam.cCarrierType,
							m_mccparam.uSourceNode,
							m_mccparam.uTargetNode,
							m_pExecuteInfo->ExecutePositionInfo.CurrNode,
							m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
							dSpeedOfNow,
							m_mccparam.dwUBGDetectTime,
							m_mccparam.dwOBSDetectTime,
							pHWSet->m_pOHTDetect->GetSensorLevel_MCC(),
							pHWSet->m_pObstacle->GetSensorLevel_MCC());
		m_mccparam.bDetectStatus = false;
		m_mccparam.dwOBSDetectTime = 0;
		m_mccparam.dwUBGDetectTime = 0;
		m_mccparam.bMarkingOHTDetectStop = true;
	}

	if(m_DiagManager->GetPreviosValue(PREVIOS_DIAG_UF) != nDiagUF)
	{
		nDiagUF = m_DiagManager->GetPreviosValue(PREVIOS_DIAG_UF);

		if(nDiagUF != 0)
		{
			ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,OHT DETECT FAIL,-,%s,%06d,%06d,%06d,%d,%3.3lf,OHT Detect Level,%d,OBS Detect Level,%d",
								m_defualtparam->VHLName,m_mccparam.cCarrierType,
								m_mccparam.uSourceNode,
								m_mccparam.uTargetNode,
								m_pExecuteInfo->ExecutePositionInfo.CurrNode,
								m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
								dSpeedOfNow,
								pHWSet->m_pOHTDetect->GetSensorLevel_MCC(),
								pHWSet->m_pObstacle->GetSensorLevel_MCC());
		}
	}

	if(m_DiagManager->GetPreviosValue(PREVIOS_DIAG_UD) != nDiagUD)
	{
		nDiagUD = m_DiagManager->GetPreviosValue(PREVIOS_DIAG_UD);

		if(nDiagUD != 0)
		{
			ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,OHT DETECT DIRECT CHECK,-,%s,%06d,%06d,%06d,%d,%3.3lf,OHT Detect Level,%d,OBS Detect Level,%d",
							m_defualtparam->VHLName,m_mccparam.cCarrierType,
							m_mccparam.uSourceNode,
							m_mccparam.uTargetNode,
							m_pExecuteInfo->ExecutePositionInfo.CurrNode,
							m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
							dSpeedOfNow,
							pHWSet->m_pOHTDetect->GetSensorLevel_MCC(),
							pHWSet->m_pObstacle->GetSensorLevel_MCC());
		}
	}

	if(m_DiagManager->GetPreviosValue(PREVIOS_DIAG_UC) != nDiagUC)
	{
		nDiagUC = m_DiagManager->GetPreviosValue(PREVIOS_DIAG_UC);

		if(nDiagUC != 0)
		{
			//prevUBG_Lv Key value 추가 필요
//			ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,OHT DETECT SEQ CHECK,-,%s,%06d,%06d,%06d,%d,%3.3lf,Pre OHT Detect Status,%d,OHT Detect Level,%d,OBS Detect Level,%d",
			ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,OHT DETECT SEQ CHECK,-,%s,%06d,%06d,%06d,%d,%3.3lf,OHT Detect Level,%d,OBS Detect Level,%d",
							m_defualtparam->VHLName,m_mccparam.cCarrierType,
							m_mccparam.uSourceNode,
							m_mccparam.uTargetNode,
							m_pExecuteInfo->ExecutePositionInfo.CurrNode,
							m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
							dSpeedOfNow,
							pHWSet->m_pOHTDetect->GetSensorLevel_MCC(),
							pHWSet->m_pObstacle->GetSensorLevel_MCC());
		}
	}

    pInfoSet->EventAndState.Event.StopWithNoReason = false; //1 임시 초기화

#if(UBG_SENSOR_ENABLE == ON)
	if(     (pInfoSet->HwInfo.IO.Axis1Running!=true)
		&&  (pInfoSet->HwInfo.IO.ObsStatus!=DETECT_AND_STOP)
		&&  (pInfoSet->HwInfo.IO.DetectStatus!=DETECT_AND_STOP)
		&&	(pHWSet->GetAMCPauseStatus() != STATUS_OHT_PAUSED)
		)
#else
	if(     (pInfoSet->HwInfo.IO.Axis1Running!=true)
		&&  (pInfoSet->HwInfo.IO.ObsStatus!=DETECT_AND_STOP)
		)
#endif
	{
        // 전방 감지 상태가 Stop이 아닌데 OHT가 움직이지 않는 경우
        if(pInfoSet->Time.Stop.OnAbnormalStop.bFlag==false)
        {
            // OnAbnormalStop.bFlag만 True로 변경함
            pInfoSet->Time.Stop.OnAbnormalStop.bFlag = true;
            pInfoSet->Time.Stop.OnAbnormalStop.dwTime = dwCurrTime;
            bStopWithNoReason = true;
			ADD_LOG("D_152/%d/%d/%d/%d/%6.1lf/%6.1lf/%3d/%d/%6.1lf/%3d/%d/%6.1lf/%d/%6.1lf/%d"
				, pInfoSet->HwInfo.IO.Axis1Running
                , pInfoSet->HwInfo.IO.ObsStatus
                , pInfoSet->HwInfo.IO.DetectStatus
                , pInfoSet->Time.Stop.OnAbnormalStop.dwTime

                , pInfoSet->HwInfo.Axis1.dCurrPos

				, pInfoSet->HwInfo.Node.dPreCheckPosition
                , pInfoSet->HwInfo.Node.nPreCheckCount
                , pInfoSet->HwInfo.IO.NodePreCheckOn

                , pInfoSet->HwInfo.Node.dNodePosition
                , pInfoSet->HwInfo.Node.nNodeCount
                , pInfoSet->HwInfo.IO.NodeOn

                , pInfoSet->HwInfo.TagStaion.dFrontPosition
                , pInfoSet->HwInfo.IO.TagStationFrontOn
                , pInfoSet->HwInfo.TagStaion.dRearPosition
                , pInfoSet->HwInfo.IO.TagStationRearOn
                );
        }

        if(pInfoSet->Time.Stop.OnAbnormalRetry.bFlag==false)//1 긴급 작업
        {
            pInfoSet->Time.Stop.OnAbnormalRetry.bFlag = true;
            pInfoSet->Time.Stop.OnAbnormalRetry.dwTime = dwCurrTime;
        }
        else if(OHTUTILITY::PreventOverflowGetTimeMs(pInfoSet->Time.Stop.OnAbnormalRetry.dwTime)>500)
		{
            if(fabs(pInfoSet->HwInfo.Axis1.dFinalPos-pInfoSet->HwInfo.Axis1.dCurrPos)>ACCEPTABLE_DRIVING_POSITION_ERROR)
            {
				pInfoSet->Time.Stop.OnAbnormalRetry.bFlag = false;
                pInfoSet->EventAndState.Event.StopWithNoReason = true;
            }
        }
    }
    else
    {
        pInfoSet->Time.Stop.OnAbnormalStop.bFlag = false;
		pInfoSet->Time.Stop.OnAbnormalRetry.bFlag = false;
    }

    //2 Events & States
    // Event
    pInfoSet->EventAndState.Event.StopWithNoReason = bStopWithNoReason;
    if(fabs(pInfoSet->HwInfo.Axis1.dFinalPos-pInfoSet->Control.Axis.Dynamic.dDist)>ACCEPTABLE_DRIVING_POSITION_ERROR)
    {
        nDistNotMatch++;
    }
    else
    {
        nDistNotMatch = 0;
    }
    pInfoSet->EventAndState.Event.DistNotMatch = (nDistNotMatch>5)?true:false;
    if(nDistNotMatch>5)
    {
        nDistNotMatch = 0;
    }

    if(pInfoSet->EventAndState.Event.DistNotMatch==true && m_StatusSet.uStep==DRIVING_CTRL_STEP_GO_RUN)
	{

		if((m_bOnBackMove ==false)
		&& (pInfoSet->Control.Axis.Dynamic.dDist !=0.0)
		&& (pInfoSet->HwInfo.Axis1.dSpeed < -0.1)
		&& (pInfoSet->HwInfo.Axis1.dCurrPos > pInfoSet->Control.Axis.Dynamic.dDist))
		{
			//후진 방지 기능 1차 적용  E1069
			ADD_LOG("D_153/%f",pInfoSet->HwInfo.Axis1.dSpeed);
			m_pDrivingAxis->MoveStop(DEFAULT_EMERGENCY_DECEL);
        }

        ADD_LOG("D_154/%7.1lf/%7.1lf/%7.1lf/%7.1lf"
            , (pInfoSet->HwInfo.Axis1.dFinalPos-pInfoSet->Control.Axis.Dynamic.dDist)
			, pInfoSet->HwInfo.Axis1.dFinalPos
			, pInfoSet->Control.Axis.Dynamic.dDist
            , ACCEPTABLE_DRIVING_POSITION_ERROR);
    }

    //State
#if(UBG_SENSOR_ENABLE == ON)
	pInfoSet->EventAndState.State.StopByFrontDetect = ((pInfoSet->HwInfo.IO.Axis1Running!=true)
													&&((pInfoSet->HwInfo.IO.ObsStatus==DETECT_AND_STOP)||(pInfoSet->HwInfo.IO.DetectStatus==DETECT_AND_STOP)))
                                                    ?true:false;
    pInfoSet->EventAndState.State.SpeedDownByFrontDetect = ((pInfoSet->HwInfo.IO.Axis1Running==true)
                                                    &&((pInfoSet->HwInfo.IO.ObsStatus==DETECT_AND_MOVE)||(pInfoSet->HwInfo.IO.DetectStatus==DETECT_AND_MOVE)))
                                                    ?true:false;
#else
	pInfoSet->EventAndState.State.StopByFrontDetect = ((pInfoSet->HwInfo.IO.Axis1Running!=true)
													&&(pInfoSet->HwInfo.IO.ObsStatus==DETECT_AND_STOP))
													?true:false;
	pInfoSet->EventAndState.State.SpeedDownByFrontDetect = ((pInfoSet->HwInfo.IO.Axis1Running==true)
													&&(pInfoSet->HwInfo.IO.ObsStatus==DETECT_AND_MOVE))
													?true:false;
#endif



	//1  명령 작성 및 BackUp

	if(((m_pOHTDetect->CheckSensorOff() == true) || (pHWSet->GetAMCVHLDetectStatus() ==0))&& (m_StatusSet.uStep==DRIVING_CTRL_STEP_GO_RUN))
	{
		if(getFrontObservation(pInfoSet->HwInfo.Node.nNodeCount, &DetectInfo)==true)
		{

			if((DetectInfo.UseFollowControlFlag != pDetectCtrl->Info.UseFollowControlFlag)
#if(USE_CHANGENODE == 1)
			|| (DetectInfo.OHTDetectType != pDetectCtrl->Info.OHTDetectType)
			|| (DetectInfo.OBSDetectType!= pDetectCtrl->Info.OBSDetectType)
			|| (DetectInfo.OHTDetectTypeOpt != pDetectCtrl->Info.OHTDetectTypeOpt)
			|| (DetectInfo.OBSDetectTypeOpt != pDetectCtrl->Info.OBSDetectTypeOpt)
#else
			|| (DetectInfo.Type != pDetectCtrl->Info.Type)
#endif
			|| (DetectInfo.NodeCount != pDetectCtrl->Info.NodeCount)
			|| (DetectInfo.DistSumOfStraightPath != pDetectCtrl->Info.DistSumOfStraightPath)
			|| (DetectInfo.FollowCommandType != pDetectCtrl->Info.FollowCommandType)
			|| (DetectInfo.PBSIgnoreFlag != pDetectCtrl->Info.PBSIgnoreFlag)
			|| (pHWSet->GetAMCVHLDetectStatus() ==0)
			)
			{

				nUBGNotMatch++;
				if((nUBGNotMatch >5) && (pHWSet->GetAMCVHLDetectStatus() ==0))
				{
	               nTmpError = ERR_DETECT_SENSOR_FAIL;
				   ADD_FDC_LOG("ERR/%d/1/5/%06d/%06d/%d/%d/%06d",
							ERR_DETECT_SENSOR_FAIL,
							m_pOHTMainStatus->StatusCommon.CurNodeID,
							m_pExecuteInfo->ExecutePositionInfo.NextNode,
							m_pOHTMainStatus->StatusCommon.CurNodeOffset,
							m_pOHTMainStatus->StatusCommon.ExistFoup,
							m_pOHTMainStatus->StatusCommon.StopStationID);
				}

				pDetectCtrl->bCmdOn = true;
				pDetectCtrl->Info = DetectInfo;
			}
		}
    }
	else
	{
		nUBGNotMatch = 0;
		if( (getFrontObservation(pInfoSet->HwInfo.Node.nPreCheckCount, &DetectInfo)==true)
		||  (pInfoSet->EventAndState.MarkState.FollowCtrlOffArea==true) )
		{
			//2 근접 제어 센서를 Off 시키는 조건
			if(pInfoSet->EventAndState.MarkState.FollowCtrlOffArea==true) // 아래 임시로 사용
			{
				memset(&DetectInfo,0,sizeof(USER_DETECT_INFO));
			}

			if((DetectInfo.UseFollowControlFlag != pDetectCtrl->Info.UseFollowControlFlag)
#if(USE_CHANGENODE == 1)
			|| (DetectInfo.OHTDetectType != pDetectCtrl->Info.OHTDetectType)
			|| (DetectInfo.OBSDetectType!= pDetectCtrl->Info.OBSDetectType)
			|| (DetectInfo.OHTDetectTypeOpt != pDetectCtrl->Info.OHTDetectTypeOpt)
			|| (DetectInfo.OBSDetectTypeOpt != pDetectCtrl->Info.OBSDetectTypeOpt)
#else
			|| (DetectInfo.Type != pDetectCtrl->Info.Type)
#endif
			|| (DetectInfo.NodeCount != pDetectCtrl->Info.NodeCount)
			|| (DetectInfo.DistSumOfStraightPath != pDetectCtrl->Info.DistSumOfStraightPath)
			|| (DetectInfo.FollowCommandType != pDetectCtrl->Info.FollowCommandType)
			|| (DetectInfo.PBSIgnoreFlag != pDetectCtrl->Info.PBSIgnoreFlag)
			)
			{
	//			ADD_LOG("D_155/%d/%06X", pInfoSet->HwInfo.Node.nPreCheckCount, pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.uNode);
	//
	//			ADD_LOG("D_156/%d/%d/%d/%.4f/%d/%d", DetectInfo.UseFollowControlFlag, DetectInfo.Type, DetectInfo.NodeCount,
	//			DetectInfo.DistSumOfStraightPath, DetectInfo.FollowCommandType, DetectInfo.PBSIgnoreFlag);
	//
	//			ADD_LOG("D_157/%d/%d/%d/%.4f/%d/%d", pDetectCtrl->Info.UseFollowControlFlag, pDetectCtrl->Info.Type, pDetectCtrl->Info.NodeCount,
	//			pDetectCtrl->Info.DistSumOfStraightPath, pDetectCtrl->Info.FollowCommandType, pDetectCtrl->Info.PBSIgnoreFlag);

				pDetectCtrl->bCmdOn = true;
				pDetectCtrl->Info = DetectInfo;
			}
		}
	}

	return nTmpError;
}

/*
@brief	장애물 감지 설정
@author 김경수
@date	2015.04.30
@param	pInfoSet 입력/변경되는 상태 정보
@param
@return 에러 없으면 0반환, 있으면 에러 코드 반환
*/
UINT DrivingControl::checkOBSAreaforNoFollowControl(DRIVING_INFO_SET* pInfoSet)
{
	UINT nTmpError = NO_ERR;

	int nOBSAreaSelect = SICK_OBS_AREA_0;
	int nNowOBSAreaSelect = 0;

	double dRealDistSumToTarget = getRealPos(m_ClassifiedCmd.TargetInfo.dDistSumToNode+m_ClassifiedCmd.TargetInfo.dOffset);
	double dRestDistance = dRealDistSumToTarget - m_InfoSet.HwInfo.Axis1.dCurrPos;

    if(dRestDistance <= OBS_REST_DISTANCE_800mm)
	{
		nOBSAreaSelect = SICK_OBS_AREA_6;
	}else
	{
		return nTmpError;
	}

#if(USE_CHANGENODE == 1)
	if((m_pExecuteInfo->ExecuteMode != EXECUTE_MODE_MANUAL) && (pInfoSet->Control.FrontObservation.Info.OHTDetectType == OHT_DETECT_CMD_PATH_DIRECTION_NORMAL))
#else
	if((m_pExecuteInfo->ExecuteMode != EXECUTE_MODE_MANUAL) && (pInfoSet->Control.FrontObservation.Info.Type == OHT_DETECT_CMD_PATH_DIRECTION_NORMAL))
#endif
	{
		nNowOBSAreaSelect = m_pObstacle->GetObsAreaStatus();

		if(nOBSAreaSelect != nNowOBSAreaSelect)
		{

			if(nOBSAreaSelect == SICK_OBS_AREA_6)
			{
				m_pObstacle->AreaSelect(nOBSAreaSelect);

				ADD_LOG("D_158/%7.1lf/%7.1lf/%7.1lf/%d/%d",
					dRestDistance,
					dRealDistSumToTarget,
					m_InfoSet.HwInfo.Axis1.dCurrPos,
					nOBSAreaSelect,
					nNowOBSAreaSelect
				);
			}
		}
	}

	return nTmpError;
}



UINT DrivingControl::checkAxisFirstNode(DRIVING_INFO_SET* pInfoSet)
{
    int nTmpError = NO_ERR;

	DWORD   dwCurrTime = timeGetTime();
	static DWORD dwTimeOfFirstNode = timeGetTime();
	static int nNodeCountClearCheck = 0;

    CTRL_INFO_OF_SYNC_AXIS_MOVE AxisCtrlInfo;
    CTRL_INFO_OF_SYNC_AXIS_MOVE *pAxisCtrl = &(pInfoSet->Control.Axis);
    CTRL_INFO_OF_ID_READER_CMD_TYPE *pIdReaderCmdType   = pInfoSet->Control.IdReader;   // ID Reader 배열의 첫번째 주소를 가지고 옮: Node
    DRIVING_HW_INFO_SET HwInfo = pInfoSet->HwInfo;

    int nStartID = pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.uNode;
    bool* bFirstNIDIsCorrect = &(pInfoSet->Position.bFirstNIDIsCorrect);
    bool bIsRunning = HwInfo.IO.Axis1Running;
    double dCurrPos = HwInfo.Axis1.dCurrPos;
    double dAxisTarget = HwInfo.Axis1.dFinalPos;    // 0 이 아님
    double dTarget = m_pParamSet->Mark[0].Dist.dLengthOfSecond;


	m_bFirstNodeStep = true; //위치값 갱신시 초기 무시처리를 위해 사용함. puting
    // ( 30-0.5 ) mm 이동 후에도 노드가 나타나지 않을 경우 정지 시 에러 발생
    if( (bIsRunning==false )
    &&  (dCurrPos>(DIST_TO_CHECK_FIRST_NODE_MARGIN-ACCEPTABLE_DRIVING_FRISTNODE_POSITION_ERROR))
    )
    {
        ERR_LOG("[checkAxisFirstNode] ERR_NOTMATCH_TAGLENGTH Pos:%6.1lf", dCurrPos);
//        nTmpError = ERR_NOTMATCH_TAGLENGTH; //에러처리는 하지 않고 다음단계로 넘어가는 시퀀스로 진행.

		*bFirstNIDIsCorrect=true;
		return nTmpError;
    }

    if( (bIsRunning==false )
    &&  (dCurrPos<(dTarget-ACCEPTABLE_DRIVING_FRISTNODE_POSITION_ERROR))
    )
    {
        *bFirstNIDIsCorrect=false;
        *pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;

		dwTimeOfFirstNode = timeGetTime();
        nNodeCountClearCheck = 0;
        memset(&(pAxisCtrl->Dynamic.AdditionalInfo),0,sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
        pAxisCtrl->Dynamic.dAccel   = m_pParamSet->Axis.Default.dDefaultAccel;
        pAxisCtrl->Dynamic.dDecel   = m_pParamSet->Axis.Default.dDefaultDecel;
        pAxisCtrl->Dynamic.dSpeed   = 0.1;  // 이값은 0.3보다 작아야 함 (50mm 갈 때의 최대 속도)
        pAxisCtrl->Dynamic.dDist = DIST_TO_CHECK_FIRST_NODE_MARGIN;
        pAxisCtrl->byType = AXIS_CTRL_CMD_MOVE_DS;
        ADD_LOG("D_159/%6.1lf/%6.1lf/%6.1lf/%6.1lf"
        , pAxisCtrl->Dynamic.dAccel
        , pAxisCtrl->Dynamic.dDecel
        , pAxisCtrl->Dynamic.dSpeed
        , pAxisCtrl->Dynamic.dDist
        );
    }
    else
    {
        // Node Count를 계속 Reset 한다.
        memset(&(pAxisCtrl->Static), 0x00, sizeof(STATIC_SYNC_AXIS_CTRL_INFO));
        if(bIsRunning==true)
        {
			pAxisCtrl->Static.NodeCountReset = true;
			pAxisCtrl->byType = AXIS_CTRL_CMD_STATIC;
			nNodeCountClearCheck++;
		}

		if(OHTUTILITY::PreventOverflowGetTimeMs(dwTimeOfFirstNode) > 200)
		{
			*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
             dwTimeOfFirstNode = timeGetTime();
		}

		if(HwInfo.Node.nBcrId!=0)
		{
			if(HwInfo.Node.nBcrId==nStartID)
			{
#if((OHT_NAME == OHT_NAME_STD_V82)|| (OHT_NAME == OHT_NAME_STD_V85S)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
//				if(( dCurrPos > DIST_TO_CHECK_FIRST_NODE_POSITION) ||
//				((HwInfo.IO.NodeOn ==true)&& (nNodeCountClearCheck >1)))     //V8.2 E305 발생, first node 마진 확보로 DIST_TO_CHECK_FIRST_NODE_POSITION 삭제
				if((HwInfo.IO.NodeOn ==true)&& (nNodeCountClearCheck >1))
#else
				if(( dCurrPos > DIST_TO_CHECK_FIRST_NODE_POSITION) ||
				((HwInfo.IO.NodeOn ==true)&& (nNodeCountClearCheck >1)))
#endif
				{
					*bFirstNIDIsCorrect = true;
				}
				ADD_LOG("D_160/%6X/%6X/%6.11f/%d", HwInfo.Node.nBcrId, nStartID,dCurrPos,HwInfo.IO.NodeOn);

			}
            else
            {
                nTmpError = ERR_NOTFIND_NODE;
				ADD_FDC_LOG("ERR/%d/4/5/%06d/%06d/%d/%d/%06d",
							ERR_NOTFIND_NODE,
							m_pOHTMainStatus->StatusCommon.CurNodeID,
							m_pExecuteInfo->ExecutePositionInfo.NextNode,
							m_pOHTMainStatus->StatusCommon.CurNodeOffset,
							m_pOHTMainStatus->StatusCommon.ExistFoup,
							m_pOHTMainStatus->StatusCommon.StopStationID);
                ERR_LOG("[checkAxisFirstNode] ID Result!=StartID (%6X!=%6X)", HwInfo.Node.nBcrId, nStartID);
            }
        }
    }

    return nTmpError;

}





UINT DrivingControl::checkAxisRun(DRIVING_INFO_SET* pInfoSet)
{
	int nTmpError = NO_ERR;

//  double  dSpeed= 0.0;
//  int     nStopNodeCount = 0;
    bool    bCmdExist = false;

    CTRL_INFO_OF_SYNC_AXIS_MOVE AxisCtrlInfo;
    CTRL_INFO_OF_SYNC_AXIS_MOVE *pAxisCtrl = &(pInfoSet->Control.Axis);

//  DRIVING_HW_INFO_SET HwInfo = pInfoSet->HwInfo;
//  double  dRealDistSumToTarget = 0.0;
	//int     nTargetID = 0;


    if( ((pInfoSet->EventAndState.Event.CmdAdded==true)
	||  (pInfoSet->EventAndState.Event.TargetChanged==true)
	||  (pInfoSet->EventAndState.Event.PreCheck==true)
	||  (pInfoSet->EventAndState.Event.Check==true)
	||  (pInfoSet->EventAndState.Event.SpeedDownPassed==true)
    ||  (pInfoSet->EventAndState.Event.FrontSteerCompleted==true)
	||  (pInfoSet->EventAndState.Event.SteerAllCompleted==true)
	||  (pInfoSet->EventAndState.Event.StopWithNoReason==true)
	||  ((pInfoSet->EventAndState.Event.DistNotMatch==true) && (pHWSet->GetAMCPauseStatus() == STATUS_NORMAL))
	||  (pInfoSet->EventAndState.Event.MarkCmd==true)))
	{
		if(pInfoSet->EventAndState.Event.TargetChanged == true)
		{
			ADD_LOG("D_161/%d/%d/%d/%d/%d/%d/%d/%d/%d/%d",
			pHWSet->m_pOHTDetect->GetStatus(),
			pHWSet->GetAMCPauseStatus(),
			pInfoSet->EventAndState.Event.CmdAdded,
			pInfoSet->EventAndState.Event.StopWithNoReason,
			pInfoSet->EventAndState.Event.MarkCmd,
			pInfoSet->EventAndState.Event.PreCheck,
			pInfoSet->EventAndState.Event.Check,
			pInfoSet->EventAndState.Event.FrontSteerCompleted,
			pInfoSet->EventAndState.Event.SteerAllCompleted,
			pInfoSet->EventAndState.Event.DistNotMatch);
		}

		 try{
		if(m_bOnBackMove == false)
			bCmdExist = getAxisCmdInfo(pInfoSet, &AxisCtrlInfo);
		else
			bCmdExist = getAxisCmdInfoBack(pInfoSet, &AxisCtrlInfo);
		}
		catch(...)
		{
			 ADD_LOG("D-131");
		}
		if(bCmdExist==true)
		{
			pAxisCtrl->byType = AXIS_CTRL_CMD_MOVE_DS;
			*pAxisCtrl = AxisCtrlInfo;
		}
		else if(    (pInfoSet->EventAndState.Event.DistNotMatch==true)
//              ||  (pInfoSet->EventAndState.Event.StopWithNoReason==true)
				)
		{
			//pAxisCtrl->byType = AXIS_CTRL_CMD_MOVE_DS;
			ADD_LOG("D_162/%06d/%3d/%3d/%6.1lf/%6.4lf/%6.4lf/%3.1lf/%6.1lf/%6.1lf/%6.1lf/%4X/%6.1lf"
				, pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.uNode
				, pInfoSet->HwInfo.Node.nNodeCount
				, pInfoSet->HwInfo.Node.nPreCheckCount
				, pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset
				, pAxisCtrl->Dynamic.dAccel, pAxisCtrl->Dynamic.dDecel
				, pAxisCtrl->Dynamic.dSpeed, pAxisCtrl->Dynamic.dDist
				, pInfoSet->HwInfo.Axis1.dCurrPos
				, pInfoSet->Position.Compensation.dLinkDistError
				, pInfoSet->EventAndState.Event
				, pInfoSet->Position.CmdRefInfo.dSpeedDownPos
				);

		}
    }

	getPostionInfoOnRunning(*pInfoSet, &m_PositionInfo);

    return nTmpError;

}


UINT DrivingControl::checkAxisMark(DRIVING_INFO_SET* pInfoSet)
{
   int nTmpError = NO_ERR;

    DRIVING_HW_INFO_SET HwInfo      = pInfoSet->HwInfo;
	double  dRealDistSumToTarget    = getRealPos(m_ClassifiedCmd.TargetInfo.dDistSumToNode+m_ClassifiedCmd.TargetInfo.dOffset);
	double  dSpeedLimit         = getMarkSpeedLimitOnGoing(HwInfo.Node.nNodeCount);
	int     nTargetID               = (m_ClassifiedCmd.TargetInfo.Type==MARK_TYPE_NODE)
									?m_ClassifiedCmd.TargetInfo.Node:m_ClassifiedCmd.TargetInfo.Station;
	int nPhysicalID = m_ClassifiedCmd.TargetInfo.PhysicalStation;
	int     nNodeCount          = m_ClassifiedCmd.TargetInfo.nCount;
	DRIVING_MARK_STATE*                 pMarkState          = &(pInfoSet->EventAndState.MarkState);
	CTRL_INFO_OF_SYNC_AXIS_MOVE*        pAxisCtrl           = &(pInfoSet->Control.Axis);
	CTRL_INFO_OF_ID_READER_CMD_TYPE*    pIdReaderCmdType    = NULL;
	int     nID = 0;

	double dSTBOffset = m_ClassifiedCmd.TargetInfo.dSTBOffset;

	static  DWORD   dwShutterTrigerTime  = timeGetTime();
	DWORD       dwCurrTime  = timeGetTime();
	bool bOverrunIngn = m_ClassifiedCmd.TargetInfo.bIgnolOverRun;

    DRIVING_CMD_INFO_OF_NODE* pNodeInfo=NULL;


	//1 마크 처리
	switch(m_ClassifiedCmd.TargetInfo.Type)
	{
	case MARK_TYPE_NODE:
		pIdReaderCmdType = (pInfoSet->Control.IdReader);
		nTmpError = markOnNode(HwInfo, dRealDistSumToTarget, dSpeedLimit, nTargetID, nNodeCount, pMarkState, pAxisCtrl, pIdReaderCmdType, &nID);
		break;
	case MARK_TYPE_TAG_STATION:
		pIdReaderCmdType = ((pInfoSet->Control.IdReader)+1);
		nTmpError = markOnTagStation(HwInfo, dRealDistSumToTarget, dSpeedLimit, nTargetID, pMarkState, pAxisCtrl, pIdReaderCmdType, &nID,bOverrunIngn);
		break;
	case MARK_TYPE_QR_STATION_LEFT:
	case MARK_TYPE_QR_LEFT_TOP:
	case MARK_TYPE_QR_LEFT_BOTTOM:
	case MARK_TYPE_QR_LEFT_BOTTOM_S:
	case MARK_TYPE_QR_PSTB_LEFT:
		pIdReaderCmdType = ((pInfoSet->Control.IdReader)+2);
		if(m_pParamSet->Mark[2].MakerType ==MAKER_TYPE_KEYENCE)
			nTmpError = markOnQRStation(true, HwInfo, dRealDistSumToTarget, dSpeedLimit, nTargetID, pMarkState, pAxisCtrl, pIdReaderCmdType, &nID);
		else if(m_pParamSet->Mark[2].MakerType ==MAKER_TYPE_OMRON)
			nTmpError = markOnQRStationDiffType(true, HwInfo, dRealDistSumToTarget, dSpeedLimit, nTargetID, pMarkState, pAxisCtrl, pIdReaderCmdType, &nID);
		else   //DM50 코그닉스
			nTmpError = markOnQRStationDiffType2(true, HwInfo, dRealDistSumToTarget, dSpeedLimit, nTargetID, pMarkState, pAxisCtrl, pIdReaderCmdType, &nID,bOverrunIngn,dSTBOffset, nPhysicalID);
        break;
    case MARK_TYPE_QR_STATION_RIGHT:
	case MARK_TYPE_QR_RIGHT_TOP:
	case MARK_TYPE_QR_RIGHT_BOTTOM:
	case MARK_TYPE_QR_RIGHT_BOTTOM_S:
	case MARK_TYPE_QR_PSTB_RIGHT:
		pIdReaderCmdType = ((pInfoSet->Control.IdReader)+3);
		if(m_pParamSet->Mark[3].MakerType ==MAKER_TYPE_KEYENCE)
			nTmpError = markOnQRStation(false, HwInfo, dRealDistSumToTarget, dSpeedLimit, nTargetID, pMarkState, pAxisCtrl, pIdReaderCmdType, &nID);
		else if(m_pParamSet->Mark[3].MakerType ==MAKER_TYPE_OMRON)
			nTmpError = markOnQRStationDiffType(false, HwInfo, dRealDistSumToTarget, dSpeedLimit, nTargetID, pMarkState, pAxisCtrl, pIdReaderCmdType, &nID);
		else  //DM50 코그닉스
			nTmpError = markOnQRStationDiffType2(false, HwInfo, dRealDistSumToTarget, dSpeedLimit, nTargetID, pMarkState, pAxisCtrl, pIdReaderCmdType, &nID,bOverrunIngn,dSTBOffset, nPhysicalID);
		break;


	//후진 기능 적용
	case MARK_TYPE_TAG_STATION_BACK:
		pIdReaderCmdType = ((pInfoSet->Control.IdReader)+1);
		nTmpError = markOnTagStationBack(HwInfo, dRealDistSumToTarget, dSpeedLimit, nTargetID, pMarkState, pAxisCtrl, pIdReaderCmdType, &nID);
		break;

	}


	if((m_ClassifiedCmd.TargetInfo.Type == MARK_TYPE_TAG_STATION)
	|| (m_ClassifiedCmd.TargetInfo.Type == MARK_TYPE_QR_STATION_LEFT)
	|| (m_ClassifiedCmd.TargetInfo.Type == MARK_TYPE_QR_LEFT_TOP)
	|| (m_ClassifiedCmd.TargetInfo.Type == MARK_TYPE_QR_LEFT_BOTTOM)
	|| (m_ClassifiedCmd.TargetInfo.Type == MARK_TYPE_QR_LEFT_BOTTOM_S)
	|| (m_ClassifiedCmd.TargetInfo.Type == MARK_TYPE_QR_STATION_RIGHT)
	|| (m_ClassifiedCmd.TargetInfo.Type == MARK_TYPE_QR_RIGHT_TOP)
	|| (m_ClassifiedCmd.TargetInfo.Type == MARK_TYPE_QR_RIGHT_BOTTOM)
	|| (m_ClassifiedCmd.TargetInfo.Type == MARK_TYPE_QR_RIGHT_BOTTOM_S)
	|| (m_ClassifiedCmd.TargetInfo.Type == MARK_TYPE_QR_PSTB_LEFT)
	|| (m_ClassifiedCmd.TargetInfo.Type == MARK_TYPE_QR_PSTB_RIGHT))
	{

		   //1.사전 Shutter 동작 작업 실시.
		   //1.1내림 싸이클시 실시. (Load)
		if(nTmpError == NO_ERR)
		{
//		   ADD_LOG("D_163/%d/%d",m_pExecuteInfo->FlagPreTrans.bPreShutter,m_pExecuteInfo->FlagPreTrans.bPrePIO);
		   if((m_defualtparam->PreShutter) &&
			  (dRealDistSumToTarget > 300.0))
		   {
			   if(m_pExecuteInfo->FlagPreTrans.bPreShutter == true)
			   {
					if(m_ClassifiedCmd.TargetInfo.Station == m_pExecuteInfo->FlagPreTrans.nTargetID)
					{
                    	//대차 유무에 따라 분류
						if(((pHWSet->m_pOHTDetect->GetCheckStatus() == true) ||
						   (pHWSet->m_pObstacle->GetStatus() == DETECT_AND_STOP)) && (pHWSet->GetAMCVHLDetectStatus() ==1))
						{
							if(pMarkState->Arrived ==true)
							{
								if(m_bShutterCloseFlag == false)
								{
									ExeCmdShutterOpen(HwInfo.Axis1.dSpeed);
								}
							}else
								dwShutterTrigerTime  = timeGetTime();
						}
						else if((pHWSet->m_pOHTDetect->GetStatus() == DETECT_AND_MOVE) && (pHWSet->GetAMCVHLDetectStatus() ==1))   //Long경우만 해당.
						{
							if(pMarkState->SecondMet ==true)    //대차 유무에 따라 분류 필요.
							{
								//사전작업 실시필요시 동작.
								if(OHTUTILITY::PreventOverflowGetTimeMs(dwShutterTrigerTime) > 100)
								{
									if(m_bShutterCloseFlag == false)
									{
										ExeCmdShutterOpen(HwInfo.Axis1.dSpeed);
									}
								}

							}else
								dwShutterTrigerTime  = timeGetTime();
						}
						else
						{
							if((m_pExecuteInfo->FlagPreTrans.cPortType != PORT_TYPE_STB_L)
							&&(m_pExecuteInfo->FlagPreTrans.cPortType != PORT_TYPE_STB_R)
							&&(m_pExecuteInfo->FlagPreTrans.cPortType != PORT_TYPE_UTB)
							&&(m_pExecuteInfo->FlagPreTrans.cPortType != PORT_TYPE_N2STB_L)
							&&(m_pExecuteInfo->FlagPreTrans.cPortType != PORT_TYPE_N2STB_R)
							&&(m_pExecuteInfo->FlagPreTrans.cPortType != PORT_TYPE_STB_L_T)
							&&(m_pExecuteInfo->FlagPreTrans.cPortType != PORT_TYPE_STB_L_B)
							&&(m_pExecuteInfo->FlagPreTrans.cPortType != PORT_TYPE_STB_R_T)
							&&(m_pExecuteInfo->FlagPreTrans.cPortType != PORT_TYPE_STB_R_B)
							&&(m_pExecuteInfo->FlagPreTrans.cPortType != PORT_TYPE_STB_L_B_S)
							&&(m_pExecuteInfo->FlagPreTrans.cPortType != PORT_TYPE_STB_R_B_S))
							{
								if((pMarkState->FirstMet ==true) || (pMarkState->SecondMet ==true))    //대차 유무에 따라 분류 필요.
								{
									if(OHTUTILITY::PreventOverflowGetTimeMs(dwShutterTrigerTime) > 100)
									{
										//사전작업 실시필요시 동작.
										if(m_bShutterCloseFlag == false)
										{
											ExeCmdShutterOpen(HwInfo.Axis1.dSpeed);
										}
									}
								}else
									dwShutterTrigerTime  = timeGetTime();
							}else
							{
								if(pMarkState->OnRoutineIn ==true)    //대차 유무에 따라 분류 필요.
								{
									//사전작업 실시필요시 동작.
									if(m_bShutterCloseFlag == false)
									{
										ExeCmdShutterOpen(HwInfo.Axis1.dSpeed);
									}
								}
                            }

						}
					}

			   }
		   }


		   //2. 사전 EQ PIO 동작 실시.  (내림/올림싸이클 모두)
		   if((m_defualtparam->PreEQPIO)
		   && (m_pExecuteInfo->FlagMTLInfo.bTakeoutCycle == false)
		   && (m_pExecuteInfo->FlagMTLInfo.bTakeInCycle == false))
		   {
			   if(m_pExecuteInfo->FlagPreTrans.bPrePIO == true)
			   {
					if(m_ClassifiedCmd.TargetInfo.Station ==  m_pExecuteInfo->FlagPreTrans.nTargetID)
					{
					   if((m_pExecuteInfo->FlagPreTrans.cPortType != PORT_TYPE_STB_L)
						&&(m_pExecuteInfo->FlagPreTrans.cPortType != PORT_TYPE_STB_R)
						&&(m_pExecuteInfo->FlagPreTrans.cPortType != PORT_TYPE_UTB)
						&&(m_pExecuteInfo->FlagPreTrans.cPortType != PORT_TYPE_N2STB_L)
						&&(m_pExecuteInfo->FlagPreTrans.cPortType != PORT_TYPE_N2STB_R)
						&&(m_pExecuteInfo->FlagPreTrans.cPortType != PORT_TYPE_STB_L_B_S)
						&&(m_pExecuteInfo->FlagPreTrans.cPortType != PORT_TYPE_STB_R_B_S))
						{
							if(m_pExecuteInfo->FlagPreTrans.nPIOID ==0)   // PIO ID가 0인 경우 IR 처리됨.
								nTmpError = ExeCmdEQPIOOpen(EQ_PIO_IR, m_pExecuteInfo->FlagPreTrans.nPIOID, m_pExecuteInfo->FlagPreTrans.nPIOChannel, 0);
							else
							{
							   if(m_pExecuteInfo->FlagPreTrans.nPIOType == EQ_PIO_IR)  //혹시 모를 예외 처리(기존 로직 유지)
							   {
									nTmpError = ExeCmdEQPIOOpen(EQ_PIO_HYBRID, m_pExecuteInfo->FlagPreTrans.nPIOID, m_pExecuteInfo->FlagPreTrans.nPIOChannel, m_pExecuteInfo->FlagPreTrans.nPIOCS);
							   }
							   else
							   {
                               		nTmpError = ExeCmdEQPIOOpen(m_pExecuteInfo->FlagPreTrans.nPIOType, m_pExecuteInfo->FlagPreTrans.nPIOID, m_pExecuteInfo->FlagPreTrans.nPIOChannel, m_pExecuteInfo->FlagPreTrans.nPIOCS);
							   }

							}
						}

						if((pHWSet->m_pLeftEQPIO->GetRFPIOConnectStep()==8) && (m_pExecuteInfo->FlagPreTrans.cPortType == PORT_TYPE_STB_L_T || m_pExecuteInfo->FlagPreTrans.cPortType == PORT_TYPE_STB_L_B || m_pExecuteInfo->FlagPreTrans.cPortType == PORT_TYPE_STB_R_T || m_pExecuteInfo->FlagPreTrans.cPortType == PORT_TYPE_STB_R_B))
						{
							if(IsInnerFoup()) // load
							{
								nTmpError = ExeCmdEQPIOForDualStageStbLoad();
							}
							else // unload
							{
								nTmpError = ExeCmdEQPIOForDualStageStbUnload();
							}
						}
					}
				}
			}
		}

	}



    if(pAxisCtrl->byType==AXIS_CTRL_CMD_MOVE_DS)
    {
        ADD_LOG("D_164/%06d/%7.4lf/%7.4lf/%7.4lf/%3.1lf/%7.1lf/%7.1lf/%5.1lf/%5.1lf/%d/%5.1lf/%d"
            , pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.uNode
            , pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset
            , pAxisCtrl->Dynamic.dAccel, pAxisCtrl->Dynamic.dDecel
            , pAxisCtrl->Dynamic.dSpeed, pAxisCtrl->Dynamic.dDist
            , HwInfo.Axis1.dCurrPos
            , pAxisCtrl->Dynamic.AdditionalInfo.dSmallDistance
            , HwInfo.TagStaion.dFrontPosition
            , HwInfo.IO.TagStationFrontOn
            , HwInfo.TagStaion.dRearPosition
            , HwInfo.IO.TagStationRearOn
            );
    }
     //오버런은 별도로 또 정리할것..
    //1 결과 정리
    if(pMarkState->Arrived)
    {
		pNodeInfo = getNodeInfo(HwInfo.Node.nNodeCount);

        //2  현재 위치 정리
        pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.bMarked = true;
        if(m_ClassifiedCmd.TargetInfo.Type==MARK_TYPE_NODE)
        {
            pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.uNode=nID;
            pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.uNextNode=0;
            pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.uRealArrivedNode=nID;
            pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.uStation=0;
        }
        else
        {
            pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info = pInfoSet->Position.CurrentAndTarget.TargetPosition;
//          pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.uRealArrivedNode
//              = (pNodeInfo!=NULL)
//              ?(pNodeInfo->ID):(pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.uNode);
            pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.uStation=nID;
        }
        pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.MarkType =  m_ClassifiedCmd.TargetInfo.Type;

        //2 마크 정보로 정리
        pInfoSet->Position.Mark.dFrontPosition  = HwInfo.Axis1.dCurrPos;
        pInfoSet->Position.Mark.dRearPosition   = HwInfo.Axis2.dCurrPos;
        pInfoSet->Position.Mark.PositionStatus  = pInfoSet->Position.CurrentAndTarget.CurrPositionStatus;


        //2 마크 정보를 멤버변수로 저장
        setPreviousArrivalInfo(pInfoSet->Position.Mark.PositionStatus);
        ADD_LOG("D_165/%d/%5.1lf/%06d/%06d/%d/%5.1lf/%06d/%06d"
            , pInfoSet->Position.Mark.PositionStatus.Info.MarkType
            , pInfoSet->Position.Mark.PositionStatus.Info.dOffset
            , pInfoSet->Position.Mark.PositionStatus.Info.uNode
            , pInfoSet->Position.Mark.PositionStatus.Info.uNextNode
            , m_PreviousArrivalInfo.Info.MarkType
            , m_PreviousArrivalInfo.Info.dOffset
            , m_PreviousArrivalInfo.Info.uNode
            , m_PreviousArrivalInfo.Info.uNextNode
            );

        	getPostionInfoOnRunning(*pInfoSet, &m_PositionInfo);
			getPostionInfoOnMarked(*pInfoSet, &m_PositionInfo);
	}
	else if(nTmpError !=NO_ERR)
	{
		if(m_ClassifiedCmd.TargetInfo.Type==MARK_TYPE_NODE)
		{
            pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.uNode=nID;
            pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.uNextNode=0;
            pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.uRealArrivedNode=nID;
            pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.uStation=0;
        }
        else
        {
            pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info = pInfoSet->Position.CurrentAndTarget.TargetPosition;
            pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.uStation=nID;
		}

		if(((nTmpError == ERR_BCR_READTIMEOUT) || (nTmpError == ERR_QRR_READTIMEOUT))//오버런시 현재위치가 offset 0.0mm offset인 경우만
		  && (m_ClassifiedCmd.TargetInfo.Type!=MARK_TYPE_NODE)
		  && (pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset == 0.0))
		{
			getPostionInfoOnRunning(*pInfoSet, &m_PositionInfo);
			getPostionInfoOnMarked(*pInfoSet, &m_PositionInfo);
        }

	}else
	{
		getPostionInfoOnRunning(*pInfoSet, &m_PositionInfo);
	}

	return nTmpError;

}



void DrivingControl::measureDist(DRIVING_INFO_SET InfoSet, List<EXECUTE_RESPONSE_MAPMAKING_INFO*> *pListOfTmpStationData, List<EXECUTE_RESPONSE_MAPMAKING_INFO*> *pListOfMapData)
{
    bool bInit = false;
    bool bNodeUpdated = false;
    double  dCurrNodeMarkPosition = 0.0;
	UINT uCurrNID = 0;
	static UINT uLastEndNID = 0;

    EXECUTE_RESPONSE_MAPMAKING_INFO *pNodeInfo;    //저장할 Map 구조체
    EXECUTE_RESPONSE_MAPMAKING_INFO *pStationInfo; //저장할 Map 구조체

	//1 Node
	pNodeInfo=NULL;
	pNodeInfo=measureNodeDist(InfoSet, &uCurrNID, &dCurrNodeMarkPosition, &bInit);
	if(pNodeInfo!=NULL)
	{
		bNodeUpdated = true;
		pListOfMapData->insertBack(pNodeInfo);

		if(uLastEndNID == 0)
		{
			uLastEndNID = InfoSet.Position.CurrentAndTarget.TargetPosition.uNode;
			ADD_LOG("[MapMake] Set Last End Node ID: %d", uLastEndNID);
		}
	}

	// AMOHTV80F-1726 'Station 작업 임시 List' 초기화 필요 시 수행
	if (bInit && uLastEndNID != 0)
	{
		if ((pListOfTmpStationData->getCount() > 0) &&
			(uLastEndNID != InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode)
		) {
			pListOfTmpStationData->clear();
			ADD_LOG("[MapMake] Clear TmpStationData");
		}
		uLastEndNID = 0;
	}

	//1 Tag Station
	if(m_bMapMakeType.MapMake_StopTag ==ON)
	{
		pStationInfo=NULL;
		pStationInfo=measureTagStatationDist(InfoSet, uCurrNID, dCurrNodeMarkPosition, bInit);
		if(pStationInfo!=NULL)
		{
			pListOfTmpStationData->insertBack(pStationInfo);
		}
	}

	//1 QR Left Station
	if(m_bMapMakeType.MapMake_QR_Left_Tag ==ON)
	{
		pStationInfo=NULL;
		pStationInfo=measureQRStatationDist(true, InfoSet, uCurrNID, dCurrNodeMarkPosition, bInit);
		if(pStationInfo!=NULL)
		{
			pListOfTmpStationData->insertBack(pStationInfo);
		}
	}

	//1 QR Right Station
	if(m_bMapMakeType.MapMake_QR_Right_Tag ==ON)
	{
		pStationInfo=NULL;
		pStationInfo=measureQRStatationDist(false, InfoSet, uCurrNID, dCurrNodeMarkPosition, bInit);
		if(pStationInfo!=NULL)
		{
			pListOfTmpStationData->insertBack(pStationInfo);
		}
	}

    //1 Station Info 정리
    if((bNodeUpdated==true) && (pNodeInfo!=NULL))
    {
		insertStationInfo(*pNodeInfo, pListOfTmpStationData, pListOfMapData);
    }

}


EXECUTE_RESPONSE_MAPMAKING_INFO* DrivingControl::measureNodeDist(DRIVING_INFO_SET InfoSet, UINT *puCurrNID, double *pdCurrNodeMarkPosition, bool *pbInit)
{
    EXECUTE_RESPONSE_MAPMAKING_INFO *pMapMakeInfo=NULL; //저장할 Map 구조체

    static int nNodeCount = -1; // Node Count

    static  UINT    uPreNID = 0;    // 이전 Node의 ID
    static  UINT    uCurrNID = 0;   // 현재 Node의 ID
    static  double  dPreNodeMarkPosition = 0.0; // 이전 Node 의 Mark 위치
    static  double  dCurrNodeMarkPosition = 0.0;    // 현재 Node 의 Mark 위치

    double dNodeDistOffset = (InfoSet.HwInfo.Node.nNodeCount==0)?(-1*m_pParamSet->Mark[0].Dist.dAddDistAfterSecondMet):0;   // Mark 위치를 구하기 위한 Offset

    UINT uTmpNID = InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode;         // 현재 Node의 ID
    int nTmpNodeCount = InfoSet.HwInfo.Node.nNodeCount;                                     // 현재 Node Count
    double dTmpCurrNodeMarkPosition = InfoSet.HwInfo.Node.dNodePosition+dNodeDistOffset;    // 현재까지 만난 Node의 중심 위치
	double dTmpCurrPosition = InfoSet.HwInfo.Axis1.dCurrPos;                                // 현재 위치

	UINT uTmpBCRNodeID = InfoSet.HwInfo.Node.nBcrId;
	static UINT uCurrentBCRID = 0;
	static  UINT    uBCRCheckCount = 0;   // 현재 Node의 ID

    bool bMarked = InfoSet.Position.CurrentAndTarget.CurrPositionStatus.bMarked;
    bool bTmpMarkPositionPassed = false;

	UINT uPathIndex = 0;
	UINT uPreDis = 0;
	bool bSkipDis = false;

	//AOHC-369 STB 확장형 적용을 위한 Map Make 기능 개선
	DRIVING_CMD_INFO_OF_PATH* pPathInfo = getPathInfo(nTmpNodeCount);
	static bool bUseVirtualNode = false;	//VirtualNode 사용구간 여부
	double dCurrNodeOffset = dTmpCurrPosition - InfoSet.HwInfo.Node.dNodePosition;	//현재 NodeOffset
	static bool bIsUpdateVirtualNode = false;	//VirtualNode 갱신을 해야하는지(설정 영역에서 장애물 감지되면 true)
	static int nVirtualNodeDetectCounter = 0;	//장애물 감지횟수Count 함(채터링 용)
	static int dModOptdtistance = 0;
	double m_dOptDistCha = 0.0;
	UINT nNodeOffset = 0;

	if(nTmpNodeCount==0 &&
	 ((nNodeCount!=0) || (uCurrentBCRID != uTmpNID) || (dCurrNodeMarkPosition !=0.0)))
	{
		nNodeCount = 0;
		uPreNID = uTmpNID;
		uCurrNID = uTmpNID;
		uCurrentBCRID = uTmpNID;
		uBCRCheckCount = 0;
//      dPreNodeMarkPosition = 0.0;
        dPreNodeMarkPosition = -1*m_pParamSet->Mark[0].Dist.dAddDistAfterSecondMet;
        dCurrNodeMarkPosition = 0.0;
		*pbInit = true;
		ADD_LOG("D-132");
    }
    else
    {
//      dPreNodeMarkPosition = 0.0;
        *pbInit = false;
    }
	if((uTmpBCRNodeID !=  uCurrentBCRID) && (uTmpBCRNodeID !=0))
	{
		uCurrentBCRID = uTmpBCRNodeID;
		ADD_LOG("D_166/%d",uCurrentBCRID);

	}

//AOHC-369
		if(pPathInfo != NULL)
		{
#if(USE_CHANGENODE == 1)
			if(bUseVirtualNode == false)
			{
			if(pPathInfo->NodeType == OPT_TAG
			|| pPathInfo->NodeType == OPT_DISTANCE
			|| pPathInfo->NodeType == OPT_COMBO)
			{
				bUseVirtualNode = true;
			}

			}


			//Virtual Node 사용 구간이면 체크
			if(bUseVirtualNode == true)
			{
			//장애물센서 체크 거리 확인
			int nMargin = 500; //임시로 500mm를 넣음, 최적화 필요
			if(((int)dCurrNodeOffset > pPathInfo->OptDistance - nMargin) || ((int)dCurrNodeOffset < pPathInfo->OptDistance + nMargin))
			{
				//장애물센서 감지(Long, Middle) 되면 값 보정
			if((m_pObstacle->GetStatus() == DETECT_AND_MOVE) ||(m_pObstacle->GetStatus() == DETECT_AND_STOP))      //DETECT_AND_STOP 추가
			{
				nVirtualNodeDetectCounter++;

				//Detect Count가 5회 이상이면 실제 장애물 감지로 판단
				//카운트 횟수도 최적화가 필요
				int nCounter = 5;

				if((nVirtualNodeDetectCounter > nCounter)
				&& (bIsUpdateVirtualNode == false))
				{
					bIsUpdateVirtualNode = true;
					dModOptdtistance = (int)dCurrNodeOffset;

				}
			}
			}
			}
#endif
		}
		 else
		 {
				bUseVirtualNode = false;
			  //	bIsUpdateVirtualNode = false;

		 }


	//1 2. 다음 Node 만났을 때의 처리
	if(dTmpCurrPosition>=dTmpCurrNodeMarkPosition)
	{
		bTmpMarkPositionPassed = true;
	}
	else if(bMarked==true)
	{
		bTmpMarkPositionPassed = true;
		ADD_LOG("D-133");
	}

	if( (nTmpNodeCount!=nNodeCount)
	&&  (bTmpMarkPositionPassed==true)
	)
	{
		//노드 변경시 초기화
		bUseVirtualNode = false; //AOHC-369

		//2 1) 정보 획득
		if(uCurrentBCRID  == uTmpNID)  //BCR이 Read실패할 경우 에러처리.
		{
			nNodeCount = nTmpNodeCount;
			dCurrNodeMarkPosition = dTmpCurrNodeMarkPosition;
			uCurrNID = uTmpNID;

			//2 Map 데이터에서 거리값 불러오기
			uPathIndex = OHTMainForm->GetMap()->GetPathIndex(uPreNID, uCurrNID);
			uPreDis = OHTMainForm->GetMap()->m_PathArray[uPathIndex].Distance;

			//2 2) 구조체 작성
			pMapMakeInfo = new EXECUTE_RESPONSE_MAPMAKING_INFO;
			memset(pMapMakeInfo, 0, sizeof(EXECUTE_RESPONSE_MAPMAKING_INFO));
			if(m_bMapMakeType.MapMake_DrivingTag ==ON)
			{
				ADD_LOG("D-134");
				// Map Make 진행한 거리값이 OFFSET 값만큼 클 경우 업데이트 진행
				if(fabs((int)(dCurrNodeMarkPosition - dPreNodeMarkPosition)-uPreDis) > PATH_DIS_OFFSET)
				{
					pMapMakeInfo->NodeOffsetInfo[0].Dist        = (int)(dCurrNodeMarkPosition - dPreNodeMarkPosition);
					bSkipDis = false;
				}
				else
				{
					pMapMakeInfo->NodeOffsetInfo[0].Dist        = uPreDis;
					bSkipDis = true;
				}
			}
			else
			{
					ADD_LOG("D-135");
					//주행업데이트 플레그가 off일 경우 기존꺼 사용.
					pMapMakeInfo->NodeOffsetInfo[0].Dist        = uPreDis;
					bSkipDis = true;
			}

			pMapMakeInfo->NodeOffsetInfo[0].StartNodeID = uPreNID;
			pMapMakeInfo->NodeOffsetInfo[0].EndNodeID   = uCurrNID;
			pMapMakeInfo->StationID = 0;
			pMapMakeInfo->StationType   = MARK_TYPE_NODE;


			//2 3) 주행 노드 좌표 변경
	//		Set_Node_XorY(pMapMakeInfo, uPreNID, uCurrNID,pMapMakeInfo->NodeOffsetInfo[0].Dist, bSkipDis);
			pMapMakeInfo->NodeDataInfo.NID = 0;

			//AOHC-369 STB 확장형 적용을 위한 Map Make 기능 개선
			//VirtualNode Update
			if(bIsUpdateVirtualNode == true && pMapMakeInfo->bUseVirtualNode == false)
			{  	//MapMakeInfo에 정보를 업데이트 함
				pMapMakeInfo->bUseVirtualNode = true;

				//감지 위치로부터 200mm(임시) 전의 offset값으로 변경
				// optional offset 음수인 경우, 워닝 처리(로그 추가), optional offset  0 적용
				if((dModOptdtistance - 200 ) > 0 )
				{
				   m_nOptDistChange = dModOptdtistance - 200;//200은 최적화가 필요
				  //pMapMakeInfo->nOptionalDistance = dModOptdtistance - 200;//200은 최적화가 필요
				}
				else
				{
				   m_nOptDistChange = pMapMakeInfo->NodeOffsetInfo[0].Dist;
				  // pMapMakeInfo->nOptionalDistance = pMapMakeInfo->NodeOffsetInfo[0].Dist; //  dModOptdtistance - 200 < 0 이면 전체를 특수패턴으로 사용해야하므로 기존 링크 Distance 값 적용
				}


				nNodeOffset =  pMapMakeInfo->NodeOffsetInfo[0].Dist;
				m_dOptDistCha = (double)m_nOptDistChange / (double)nNodeOffset;
				pMapMakeInfo->nOptionalDistance =  OHTMainForm->GetMap()-> calReOptRatio(m_dOptDistCha);          // mapdata의 optional로 변경하기 위해서
				 ADD_LOG("m_dOptDistCha : %f, m_nOptDistChange:%d, pMapMakeInfo->NodeOffsetInfo[0].Dist :%d",m_dOptDistCha, m_nOptDistChange, pMapMakeInfo->NodeOffsetInfo[0].Dist );


				dModOptdtistance = 0;
				//변수 초기화
				bIsUpdateVirtualNode = false;
				nVirtualNodeDetectCounter = 0;

			}


			//2 4) 로그 작성
			ADD_LOG("D_167/%d/%6d/%6d/%4d/%6.1lf/%6.1lf/%6.1lf/%d/%d/%d"
				, pMapMakeInfo->StationType
				, pMapMakeInfo->NodeOffsetInfo[0].StartNodeID
				, pMapMakeInfo->NodeOffsetInfo[0].EndNodeID
				, pMapMakeInfo->NodeOffsetInfo[0].Dist
				, (dCurrNodeMarkPosition - dPreNodeMarkPosition)
				, dCurrNodeMarkPosition
				, dPreNodeMarkPosition
				, bSkipDis
				, PATH_DIS_OFFSET
				,uBCRCheckCount);

				//AOHC-369 STB 확장형 적용을 위한 Map Make 기능 개선 - test 로그 삭제 필
				ADD_LOG("Optional Distance[%d] : %4d",pMapMakeInfo->bUseVirtualNode, pMapMakeInfo->nOptionalDistance);

			//2 4) 정보 정리(다음 Node를 위해)
			dPreNodeMarkPosition = dCurrNodeMarkPosition;
			uPreNID = uCurrNID;
			uBCRCheckCount = 0;
			if(bMarked==true)
			{
				nNodeCount = -1;
			}


		}
		else
		{
			uBCRCheckCount++;
			//Node는 만났으나, BCR이 위치에 맞는 값으로 갱신안되는 경우 Check
			if(uBCRCheckCount > m_pParamSet->MapMakerCount_Driving)
			{
                m_StatusSet.uError = ERR_BCR_READ;    //에러 코드 분류 필요.
				return pMapMakeInfo;
            }
		}
	}

	*puCurrNID = uCurrNID;
    *pdCurrNodeMarkPosition = dCurrNodeMarkPosition;

    return pMapMakeInfo;
}



EXECUTE_RESPONSE_MAPMAKING_INFO* DrivingControl::measureTagStatationDist(DRIVING_INFO_SET InfoSet, UINT uCurrNID, double dCurrNodeMarkPosition, bool bInit)
{
    EXECUTE_RESPONSE_MAPMAKING_INFO *pStationInfo=NULL; //저장할 Map 구조체

    static UINT uPreStationID = 0;  // 사용하지 않는 값
	static double dPreStationPosition = 0.0; // 사용하지 않는 값

	static int nCheckCountBCRRead = 0; //BCR Read 횟수 확인

    double dStationDistOffset = 0.0;//(InfoSet.HwInfo.Node.nNodeCount==0)?m_pParamSet->Mark[1].Dist.dAddDistAfterSecondMet:0;   // Mark 위치를 구하기 위한 Offset

	static UINT uTmpStationID = 0;//InfoSet.HwInfo.TagStaion.nBcrId;

	bool bFrontOn = InfoSet.HwInfo.IO.TagStationFrontOn;
	bool bRearOn = InfoSet.HwInfo.IO.TagStationRearOn;

	double dTmpStationPosition = InfoSet.HwInfo.TagStaion.dRearPosition;
	double dTmpStationFrontPosion = InfoSet.HwInfo.TagStaion.dFrontPosition;

	double dTmpCurrPosition = InfoSet.HwInfo.Axis1.dCurrPos;    // 현재 위치

	static double dPreStationCheckPosition = 0.0; // 사용하지 않는 값

	//1 1. 초기화
    if(bInit==true)
	{
		uTmpStationID = 0;
        uPreStationID = 0;
		dPreStationPosition = 0.0;
		nCheckCountBCRRead = 0;
		 ADD_LOG("D-136");
    }
    else
    {

	}

	if(uTmpStationID==0)
	{
		if(InfoSet.HwInfo.TagStaion.nBcrId !=0)
		{
			dPreStationCheckPosition = dTmpCurrPosition;  //BCR 인식된 위치 저장
			uTmpStationID = InfoSet.HwInfo.TagStaion.nBcrId;
		}
	}
	else
	{
		//반사판 미인식 될경우 이전데이터 무시처리
		if((dTmpCurrPosition - dPreStationCheckPosition) > 250.0) //반사판 미인식 될경우 다음 Station 정상인식을 위한 초기화처리
		{
			if(dTmpStationPosition!=dPreStationPosition)
			{
				ADD_LOG("D_168/%d",uTmpStationID);
				dPreStationPosition =  dTmpStationPosition;//dTmpStationPosition로 변경이 필요하지 않은지?? puting
			}
			uTmpStationID = 0;
		}
	}


	//1 2. Station 만났을 때의 처리
	if(uTmpStationID!=0 && uTmpStationID!=uPreStationID)
	{

		 if((dTmpStationPosition!=0.0)&& (bRearOn == true)/* && (uPreStationID != 0)*/)
		 {
			if((bFrontOn == true)&&(dTmpStationFrontPosion !=0.0)&&((dTmpCurrPosition - dTmpStationFrontPosion)<STATION_FRONT_REAR_DIST-5.0)) // Front, Rear 거리보다 5mm 작게
			{   //채터링 넣을지는 확인 필요
				ADD_LOG("1-ST.%d, TmpStationPosition : %f, bFrontOn : %d,bRearOn: %d,CurPos - FrontDetectPos : %f ",uTmpStationID,dTmpStationPosition,bFrontOn, bRearOn,(dTmpCurrPosition - dTmpStationFrontPosion));
				m_nCurrStation = uTmpStationID;
				m_StatusSet.uError = ERR_MARK_RSTOPSEN_OFF;
				return pStationInfo;
			}
		 }

		if(((bRearOn==true)
		&& (dTmpStationPosition==0.0))
		|| (((dTmpStationPosition!=0.0) && (dTmpStationPosition!=dPreStationPosition)
		&& (fabs(dTmpStationPosition-dTmpCurrPosition)<(m_pParamSet->Mark[1].Dist.dDistFromFirstToSecond+10))))
		)
		{
            //2 1) 정보 획득
			if((dTmpStationFrontPosion >250.0)  && (dTmpStationPosition!=0.0) &&
			((nCheckCountBCRRead <  m_pParamSet->MapMakerCount_Trans)||
			((dTmpStationPosition - dTmpStationFrontPosion) < m_pParamSet->ScatteredReflection)))
			{
				ADD_LOG("D_169/%d/%f/%f",nCheckCountBCRRead,dTmpStationFrontPosion,dTmpStationPosition);
				m_StatusSet.uError = ERR_BCR_READ_TRANS;
				return pStationInfo;
			}

			//2 2) 구조체 작성
			pStationInfo = new EXECUTE_RESPONSE_MAPMAKING_INFO;
			memset(pStationInfo, 0, sizeof(EXECUTE_RESPONSE_MAPMAKING_INFO));
			if(dTmpStationPosition!=0.0)
			{
				if((dTmpStationPosition - dCurrNodeMarkPosition + dStationDistOffset) > 0.0)
				{
					pStationInfo->NodeOffsetInfo[0].Dist        = (int)(dTmpStationPosition - dCurrNodeMarkPosition + dStationDistOffset);
				}
				else
				{
					//Station값이 갱신되기 전에 다음노드로 넘어간 경우 처리됨.
					ADD_LOG("D_170/%d/%f/%f",uTmpStationID,dCurrNodeMarkPosition,dTmpStationPosition);
					pStationInfo->NodeOffsetInfo[0].Dist        = 0;
				}
			}
			else
			{
				//Rear On과 StationRear 위치값 갱신차이가 발생할 경우 처리됨.
				ADD_LOG("D_171/%d/%f/%f",uTmpStationID,dCurrNodeMarkPosition,dTmpStationPosition);
				pStationInfo->NodeOffsetInfo[0].Dist        = (int)(dTmpCurrPosition - dCurrNodeMarkPosition + dStationDistOffset);
			}

			pStationInfo->NodeOffsetInfo[0].StartNodeID = uCurrNID;
            pStationInfo->NodeOffsetInfo[0].EndNodeID   = 0;    // 우선 비워둔다
            pStationInfo->StationID                     = uTmpStationID;
			pStationInfo->StationType                   = MARK_TYPE_TAG_STATION;

            //2 3) 로그 작성
            ADD_LOG("D_172/%d/%6d/%6d/%6d/%4d/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%d"
                , pStationInfo->StationType
                , pStationInfo->NodeOffsetInfo[0].StartNodeID,  pStationInfo->NodeOffsetInfo[0].EndNodeID
                , pStationInfo->StationID
                , pStationInfo->NodeOffsetInfo[0].Dist
				, (dTmpStationPosition - dCurrNodeMarkPosition)
                , dTmpStationPosition, dCurrNodeMarkPosition, dTmpCurrPosition, dTmpStationFrontPosion,nCheckCountBCRRead);

			//2 4) 정보 정리(다음 Node를 위해)
			dPreStationPosition =  dTmpStationPosition;//dTmpStationPosition로 변경이 필요하지 않은지?? puting
			uPreStationID = uTmpStationID;
			nCheckCountBCRRead = 0;
			uTmpStationID = 0;

		}else
		{
			//동일한 Tag 인식 횟수 확인
//        	 ADD_LOG("D_173/%d",nCheckCountBCRRead);
			if(InfoSet.HwInfo.TagStaion.nBcrId !=0)
			{
				if(uTmpStationID ==InfoSet.HwInfo.TagStaion.nBcrId)
					nCheckCountBCRRead++;
			}
		}
	}

    return pStationInfo;

}

EXECUTE_RESPONSE_MAPMAKING_INFO* DrivingControl::measureQRStatationDist(bool bIsLeft, DRIVING_INFO_SET InfoSet, UINT uCurrNID, double dCurrNodeMarkPosition, bool bInit)
{

    EXECUTE_RESPONSE_MAPMAKING_INFO *pStationInfo=NULL; //저장할 Map 구조체

	static UINT uPreStationID = 0;  // 사용하지 않는 값
	static UINT uPreStationID_Right = 0;  // 사용하지 않는 값

    UINT uTmpStationID = 0;
    double dStationDistOffset = 0.0;//(InfoSet.HwInfo.Node.nNodeCount==0)?m_pParamSet->Mark[1].Dist.dAddDistAfterSecondMet:0;   // Mark 위치를 구하기 위한 Offset
//  double dStationDistOffset = 0.0;    // Mark 위치를 구하기 위한 Offset

    double dTmpCurrPosition = InfoSet.HwInfo.Axis1.dCurrPos;    // 현재 위치

    if(bIsLeft==true)
    {
        uTmpStationID = InfoSet.HwInfo.QrStaionLeft.nQrId;
        dStationDistOffset += InfoSet.HwInfo.QrStaionLeft.dQrOffset;
    }
    else
    {
        uTmpStationID = InfoSet.HwInfo.QrStaionRight.nQrId;
        dStationDistOffset += InfoSet.HwInfo.QrStaionRight.dQrOffset;
    }

    //1 1. 초기화
    if(bInit==true)
    {
		uPreStationID = 0;
		uPreStationID_Right = 0;
    }

    //1 2. Station 만났을 때의 처리
	if((uTmpStationID!=0) &&
		(((bIsLeft == true) && (uTmpStationID!=uPreStationID)) ||
		((bIsLeft == false) && (uTmpStationID!=uPreStationID_Right))))
	{
		//2 1) 정보 획득


        //2 2) 구조체 작성
        pStationInfo = new EXECUTE_RESPONSE_MAPMAKING_INFO;
		memset(pStationInfo, 0, sizeof(EXECUTE_RESPONSE_MAPMAKING_INFO));

		if((dTmpCurrPosition - dCurrNodeMarkPosition + dStationDistOffset) > 0.0)
		{
			pStationInfo->NodeOffsetInfo[0].Dist        = (int)(dTmpCurrPosition - dCurrNodeMarkPosition + dStationDistOffset);
		}
		else
		{
			//Station값이 갱신되기 전에 다음노드로 넘어간 경우 처리됨.
			pStationInfo->NodeOffsetInfo[0].Dist        = 0;
		}

        pStationInfo->NodeOffsetInfo[0].StartNodeID = uCurrNID;
        pStationInfo->NodeOffsetInfo[0].EndNodeID   = 0;    // 우선 비워둔다
        pStationInfo->StationID                     = uTmpStationID;
        pStationInfo->StationType                   = (bIsLeft==true)?MARK_TYPE_QR_STATION_LEFT:MARK_TYPE_QR_STATION_RIGHT;

        //2 3) 로그 작성
        ADD_LOG("D_174/%d/%6d/%6d/%6d/%4d/%6.1lf/%6.1lf/%6.1lf/%6.1lf"
            , pStationInfo->StationType
            , pStationInfo->NodeOffsetInfo[0].StartNodeID,  pStationInfo->NodeOffsetInfo[0].EndNodeID
            , pStationInfo->StationID
            , pStationInfo->NodeOffsetInfo[0].Dist, (dTmpCurrPosition - dCurrNodeMarkPosition + dStationDistOffset)
            , dTmpCurrPosition, dCurrNodeMarkPosition, dStationDistOffset);

		//2 4) 정보 정리(다음 Node를 위해)
		if(bIsLeft ==true)
			uPreStationID = uTmpStationID;
		else
          	uPreStationID_Right = uTmpStationID;
    }

    return pStationInfo;

}



void DrivingControl::insertStationInfo(EXECUTE_RESPONSE_MAPMAKING_INFO NodeInfo, List<EXECUTE_RESPONSE_MAPMAKING_INFO*> *pListOfTmpStationData, List<EXECUTE_RESPONSE_MAPMAKING_INFO*> *pListOfMapData)
{
    EXECUTE_RESPONSE_MAPMAKING_INFO *pStationInfo=NULL; //저장할 Map 구조체
    int nCountOfList = pListOfTmpStationData->getCount();

    for(int n=0; n<nCountOfList; n++)
	{

		pStationInfo = pListOfTmpStationData->popFront();

		if( (pStationInfo->NodeOffsetInfo[0].Dist <=(NodeInfo.NodeOffsetInfo[0].Dist-m_pParamSet->MapMakerMargin_Gap))
		||  (NodeInfo.NodeOffsetInfo[0].EndNodeID == m_InfoSet.Position.CurrentAndTarget.TargetPosition.uNode)
		 )
		{
			if(pStationInfo->NodeOffsetInfo[0].Dist <=(NodeInfo.NodeOffsetInfo[0].Dist-m_pParamSet->MapMakerMargin_Gap))
			{
				pStationInfo->NodeOffsetInfo[0].EndNodeID = NodeInfo.NodeOffsetInfo[0].EndNodeID;
				pListOfMapData->insertBack(pStationInfo);
				//ADD_LOG("D_175/%d/%d", pStationInfo->NodeOffsetInfo[0].StartNodeID,pStationInfo->NodeOffsetInfo[0].Dist);

			}
			else
			{
				// 어떻게 처리할지 고민할것.
				pStationInfo->NodeOffsetInfo[0].StartNodeID = NodeInfo.NodeOffsetInfo[0].EndNodeID;
				pStationInfo->NodeOffsetInfo[0].Dist        = 0.0;//MAX(NodeInfo.NodeOffsetInfo[0].Dist,0.0);
				pStationInfo->NodeOffsetInfo[0].EndNodeID   = 0;
				pListOfMapData->insertBack(pStationInfo);
				//ADD_LOG("D_176/%d/%d", pStationInfo->NodeOffsetInfo[0].StartNodeID,pStationInfo->NodeOffsetInfo[0].Dist)
				//delete pStationInfo;
//				pStationInfo->NodeOffsetInfo[0].StartNodeID = NodeInfo.NodeOffsetInfo[0].EndNodeID;
//				pStationInfo->NodeOffsetInfo[0].Dist        = 0.0;//MAX(NodeInfo.NodeOffsetInfo[0].Dist,0.0);
//				pStationInfo->NodeOffsetInfo[0].EndNodeID   = 0;
				//추후에 쓸경우 변경해줄것. 현재 Station Editor 컨셉으로는 불가함. puting
			}
		}
		else
        {
//          pStationInfo->NodeOffsetInfo[1] = pStationInfo->NodeOffsetInfo[0];
//          pStationInfo->NodeOffsetInfo[1].EndNodeID = NodeInfo.NodeOffsetInfo[0].EndNodeID;
            pStationInfo->NodeOffsetInfo[0].StartNodeID = NodeInfo.NodeOffsetInfo[0].EndNodeID;
            pStationInfo->NodeOffsetInfo[0].Dist        = 0.0;//MAX(NodeInfo.NodeOffsetInfo[0].Dist,0.0);
            pStationInfo->NodeOffsetInfo[0].EndNodeID   = 0;

            pListOfTmpStationData->insertBack(pStationInfo);

			//ADD_LOG("D_177/%d/%d", pStationInfo->NodeOffsetInfo[0].StartNodeID,pStationInfo->NodeOffsetInfo[0].Dist);

        }

	}


}



/**
@brief  Passbox control
@author 김경수
@date   2014.12.16
@param  puStep 주행의 Step 변수
@return 에러 없으면 0반환, 있으면 에러 코드 반환
*/
UINT DrivingControl::executeOpenPassBox(DRIVING_HW_INFO_SET HwInfo, DRIVING_INFO_SET *pInfoSet, UINT *puStep)
{
	UINT nError = NO_ERR;
    static DWORD dwPassBoxPIOWaitTime = 0;

    if((nError == NO_ERR) && (m_nPassBoxPIOStep >= PASSBOX_CTRL_STEP_OHT_STATUS_ON) && (m_nPassBoxPIOStep < PASSBOX_CTRL_STEP_COMPLETE))
	{
		if(m_pPassBoxPIO->Check_GoOffTime(PASSBOX_PIO_CHECK_GO_SIGNAL_CHECK_TIME) == RTN_FAIL)
		{
			nError = ERR_PASSBOX_PIO_GO_SIGNAL_CHECK_ABNORMAL_OFF;
			ADD_LOG("D_178/%d/%d", m_nPassBoxPIOStep, nError);
			ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d/%d",
									ERR_PASSBOX_PIO_GO_SIGNAL_CHECK_ABNORMAL_OFF,
									m_pOHTMainStatus->StatusCommon.CurNodeID,
									m_pExecuteInfo->ExecutePositionInfo.NextNode,
									m_pOHTMainStatus->StatusCommon.CurNodeOffset,
									m_pOHTMainStatus->StatusCommon.ExistFoup,
									m_pOHTMainStatus->StatusCommon.StopStationID,
									m_nPassBoxPIOStep);
		}
   	}

    if((nError == NO_ERR) && (m_nPassBoxPIOStep >= PASSBOX_CTRL_STEP_OHT_STATUS_ON) && (m_nPassBoxPIOStep < PASSBOX_CTRL_STEP_COMPLETE))
	{
		if(m_pPassBoxPIO->Check_ESOffTime(PASSBOX_PIO_CHECK_ES_SIGNAL_CHECK_TIME) == RTN_FAIL)
		{
			nError = ERR_PASSBOX_PIO_ES_SIGNAL_CHECK_ABNORMAL_OFF;
			ADD_LOG("D_179/%d/%d", m_nPassBoxPIOStep, nError);
			ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d/%d",
									ERR_PASSBOX_PIO_ES_SIGNAL_CHECK_ABNORMAL_OFF,
									m_pOHTMainStatus->StatusCommon.CurNodeID,
									m_pExecuteInfo->ExecutePositionInfo.NextNode,
									m_pOHTMainStatus->StatusCommon.CurNodeOffset,
									m_pOHTMainStatus->StatusCommon.ExistFoup,
									m_pOHTMainStatus->StatusCommon.StopStationID,
									m_nPassBoxPIOStep);
		}
   	}

    if((nError == NO_ERR) && (m_nPassBoxPIOStep >= PASSBOX_CTRL_STEP_OHT_STATUS_ON) && (m_nPassBoxPIOStep < PASSBOX_CTRL_STEP_COMPLETE))
	{
		if(m_pPassBoxPIO->Check_PB_AVBL_OffTime(PASSBOX_PIO_CHECK_PB_AVBL_SIGNAL_CHECK_TIME) == RTN_FAIL)
		{
			nError = ERR_PASSBOX_PIO_PB_AVBL_SIGNAL_CHECK_ABNORMAL_OFF;
			ADD_LOG("D_180/%d/%d", m_nPassBoxPIOStep, nError);
        	ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d/%d",
									ERR_PASSBOX_PIO_PB_AVBL_SIGNAL_CHECK_ABNORMAL_OFF,
									m_pOHTMainStatus->StatusCommon.CurNodeID,
									m_pExecuteInfo->ExecutePositionInfo.NextNode,
									m_pOHTMainStatus->StatusCommon.CurNodeOffset,
									m_pOHTMainStatus->StatusCommon.ExistFoup,
									m_pOHTMainStatus->StatusCommon.StopStationID,
									m_nPassBoxPIOStep);
		}
   	}

	// PassBox Open을 위한 PIO 통신
	switch (m_nPassBoxPIOStep)
	{
		case PASSBOX_CTRL_STEP_INIT :
			if(nError == NO_ERR)
			{
				nError = m_pPassBoxPIO->PIOEnable();
				dwPassBoxPIOWaitTime = timeGetTime();
				m_nPassBoxPIOStep++;
			}
			break;

		case PASSBOX_CTRL_STEP_GO_SIGNAL_CHECK :
			if((nError==NO_ERR) && (m_pPassBoxPIO->IsGoSignalOn() == true))
			{
				m_nPassBoxPIOStep++;
				ADD_LOG("D_181/%d", m_nPassBoxPIOStep);
			}
			else
			{
				if(OHTUTILITY::PreventOverflowGetTimeMs(dwPassBoxPIOWaitTime) > PASSBOX_PIO_CHECK_GO_SIGNAL_WAIT_TIME)
				{
					nError = ERR_PASSBOX_PIO_GO_SIGNAL_ABNORMAL_OFF;
					ADD_LOG("D_182/%d/%d/%d", m_nPassBoxPIOStep, nError, OHTUTILITY::PreventOverflowGetTimeMs(dwPassBoxPIOWaitTime));
					dwPassBoxPIOWaitTime = 0;
					ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d/%d",
									ERR_PASSBOX_PIO_GO_SIGNAL_ABNORMAL_OFF,
									m_pOHTMainStatus->StatusCommon.CurNodeID,
									m_pExecuteInfo->ExecutePositionInfo.NextNode,
									m_pOHTMainStatus->StatusCommon.CurNodeOffset,
									m_pOHTMainStatus->StatusCommon.ExistFoup,
									m_pOHTMainStatus->StatusCommon.StopStationID,
									m_nPassBoxPIOStep);
				}
			}
			break;

		case PASSBOX_CTRL_STEP_SIGNAL_OFF :
			if(nError==NO_ERR)
			{
				m_pPassBoxPIO->AllPIOOff();
				dwPassBoxPIOWaitTime = timeGetTime();
				m_nPassBoxPIOStep++;
				ADD_LOG("D_183/%d", m_nPassBoxPIOStep);
			}
			break;

		case PASSBOX_CTRL_STEP_ES_SIGNAL_CHECK :
			if((nError==NO_ERR) && (m_pPassBoxPIO->IsESOn()	== true))
			{
				dwPassBoxPIOWaitTime = timeGetTime();
				m_nPassBoxPIOStep++;
				ADD_LOG("D_184/%d", m_nPassBoxPIOStep);
			}
			else
			{
				if(OHTUTILITY::PreventOverflowGetTimeMs(dwPassBoxPIOWaitTime) > PASSBOX_PIO_CHECK_ES_SIGNAL_WAIT_TIME)
				{
					nError = ERR_PASSBOX_PIO_ES_SIGNAL_ABNORMAL_OFF;
					ADD_LOG("D_185/%d/%d/%d", m_nPassBoxPIOStep, nError, OHTUTILITY::PreventOverflowGetTimeMs(dwPassBoxPIOWaitTime));
					dwPassBoxPIOWaitTime = 0;
					ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d/%d",
									ERR_PASSBOX_PIO_ES_SIGNAL_ABNORMAL_OFF,
									m_pOHTMainStatus->StatusCommon.CurNodeID,
									m_pExecuteInfo->ExecutePositionInfo.NextNode,
									m_pOHTMainStatus->StatusCommon.CurNodeOffset,
									m_pOHTMainStatus->StatusCommon.ExistFoup,
									m_pOHTMainStatus->StatusCommon.StopStationID,
									m_nPassBoxPIOStep);
				}
			}
			break;

		case PASSBOX_CTRL_STEP_PB_AVBL_SIGNAL_CHECK :
			if((nError==NO_ERR) && (m_pPassBoxPIO->IsPBAVBLOn() == true))
			{
				m_nPassBoxPIOStep++;
				dwPassBoxPIOWaitTime = timeGetTime();
				ADD_LOG("D_186/%d", m_nPassBoxPIOStep);
			}
			else
			{
				if(OHTUTILITY::PreventOverflowGetTimeMs(dwPassBoxPIOWaitTime) > PASSBOX_PIO_CHECK_PB_AVBL_SIGNAL_WAIT_TIME)
				{
					nError = ERR_PASSBOX_PIO_PB_AVBL_SIGNAL_ABNORMAL_OFF;
					ADD_LOG("D_187/%d/%d/%d", m_nPassBoxPIOStep, nError, OHTUTILITY::PreventOverflowGetTimeMs(dwPassBoxPIOWaitTime));
					dwPassBoxPIOWaitTime = 0;
					ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d/%d",
									ERR_PASSBOX_PIO_PB_AVBL_SIGNAL_ABNORMAL_OFF,
									m_pOHTMainStatus->StatusCommon.CurNodeID,
									m_pExecuteInfo->ExecutePositionInfo.NextNode,
									m_pOHTMainStatus->StatusCommon.CurNodeOffset,
									m_pOHTMainStatus->StatusCommon.ExistFoup,
									m_pOHTMainStatus->StatusCommon.StopStationID,
									m_nPassBoxPIOStep);
				}
			}
			break;

		case PASSBOX_CTRL_STEP_ABNORMAL_SIGNAL_CHECK :
			if((nError==NO_ERR)
				&& (m_pPassBoxPIO->IsCloseOn() == false)
				&& (m_pPassBoxPIO->IsBusyOn() == false)
				&& (m_pPassBoxPIO->IsOpenOn() == false)
			)
			{
				m_nPassBoxPIOStep++;
				ADD_LOG("D_188/%d", m_nPassBoxPIOStep);
			}
			else
			{
				if(OHTUTILITY::PreventOverflowGetTimeMs(dwPassBoxPIOWaitTime) > PASSBOX_PIO_CHECK_ABNORMAL_SIGNAL_WAIT_TIME)
				{
					if(m_pPassBoxPIO->IsCloseOn() == true)
					{
						nError = ERR_PASSBOX_PIO_CLOSE_SIGNAL_INIT_ABNORMAL_ON;
						ADD_LOG("D_189/%d/%d/%d", m_nPassBoxPIOStep, nError, OHTUTILITY::PreventOverflowGetTimeMs(dwPassBoxPIOWaitTime));
						ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d/%d",
									ERR_PASSBOX_PIO_CLOSE_SIGNAL_INIT_ABNORMAL_ON,
									m_pOHTMainStatus->StatusCommon.CurNodeID,
									m_pExecuteInfo->ExecutePositionInfo.NextNode,
									m_pOHTMainStatus->StatusCommon.CurNodeOffset,
									m_pOHTMainStatus->StatusCommon.ExistFoup,
									m_pOHTMainStatus->StatusCommon.StopStationID,
									m_nPassBoxPIOStep);
					}
					else if(m_pPassBoxPIO->IsBusyOn() == true)
					{
						nError = ERR_PASSBOX_PIO_BUSY_SIGNAL_INIT_ABNORMAL_ON;
						ADD_LOG("D_190/%d/%d/%d", m_nPassBoxPIOStep, nError, OHTUTILITY::PreventOverflowGetTimeMs(dwPassBoxPIOWaitTime));
						ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d/%d",
									ERR_PASSBOX_PIO_BUSY_SIGNAL_INIT_ABNORMAL_ON,
									m_pOHTMainStatus->StatusCommon.CurNodeID,
									m_pExecuteInfo->ExecutePositionInfo.NextNode,
									m_pOHTMainStatus->StatusCommon.CurNodeOffset,
									m_pOHTMainStatus->StatusCommon.ExistFoup,
									m_pOHTMainStatus->StatusCommon.StopStationID,
									m_nPassBoxPIOStep);
					}
					else
					{
						nError = ERR_PASSBOX_PIO_OPEN_SIGNAL_INIT_ABNORMAL_ON;
						ADD_LOG("D_191/%d/%d/%d", m_nPassBoxPIOStep, nError, OHTUTILITY::PreventOverflowGetTimeMs(dwPassBoxPIOWaitTime));
                    	ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d/%d",
									ERR_PASSBOX_PIO_OPEN_SIGNAL_INIT_ABNORMAL_ON,
									m_pOHTMainStatus->StatusCommon.CurNodeID,
									m_pExecuteInfo->ExecutePositionInfo.NextNode,
									m_pOHTMainStatus->StatusCommon.CurNodeOffset,
									m_pOHTMainStatus->StatusCommon.ExistFoup,
									m_pOHTMainStatus->StatusCommon.StopStationID,
									m_nPassBoxPIOStep);
					}
					dwPassBoxPIOWaitTime = 0;
				}
			}
			break;

		case PASSBOX_CTRL_STEP_OHT_STATUS_ON :
			if(nError==NO_ERR)
			{
				nError = m_pPassBoxPIO->OHTStatusOnOff(ON);
				dwPassBoxPIOWaitTime = timeGetTime();
				ADD_LOG("D_192/%d", m_nPassBoxPIOStep);
				m_nPassBoxPIOStep++;
			}
			break;

		case PASSBOX_CTRL_STEP_CLOSE_ON_CHECK :
			if((nError==NO_ERR) && (m_pPassBoxPIO->IsCloseOn() == true))
			{
				Sleep(100);		// TP1
				m_nPassBoxPIOStep++;
				ADD_LOG("D_193/%d", m_nPassBoxPIOStep);
			}
			else
			{
				if(OHTUTILITY::PreventOverflowGetTimeMs(dwPassBoxPIOWaitTime) > PASSBOX_PIO_CHECK_CLOSE_ON_SIGNAL_TA1)
				{
					nError = ERR_PASSBOX_PIO_CLOSE_SIGNAL_ABNORMAL_OFF;
					ADD_LOG("D_194/%d/%d/%d", m_nPassBoxPIOStep, nError, OHTUTILITY::PreventOverflowGetTimeMs(dwPassBoxPIOWaitTime));
					dwPassBoxPIOWaitTime = 0;
					ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d/%d",
									ERR_PASSBOX_PIO_CLOSE_SIGNAL_ABNORMAL_OFF,
									m_pOHTMainStatus->StatusCommon.CurNodeID,
									m_pExecuteInfo->ExecutePositionInfo.NextNode,
									m_pOHTMainStatus->StatusCommon.CurNodeOffset,
									m_pOHTMainStatus->StatusCommon.ExistFoup,
									m_pOHTMainStatus->StatusCommon.StopStationID,
									m_nPassBoxPIOStep);
				}
			}
			break;

		case PASSBOX_CTRL_STEP_DOOR_SELECT :
			if(nError==NO_ERR)
			{
				nError = m_pPassBoxPIO->DoorSelectOnOff(ON);
				ADD_LOG("D_195/%d", m_nPassBoxPIOStep);
				m_nPassBoxPIOStep++;
			}
			break;

		case PASSBOX_CTRL_STEP_OPEN_REQ :
			if(nError==NO_ERR)
			{
				nError = m_pPassBoxPIO->OpenReqOnOff(ON);
				dwPassBoxPIOWaitTime = timeGetTime();
				ADD_LOG("D_196/%d", m_nPassBoxPIOStep);
				m_nPassBoxPIOStep++;
			}
			break;

		case PASSBOX_CTRL_STEP_BUSY_ON_SIGNAL_CHECK :
			if((nError==NO_ERR) && (m_pPassBoxPIO->IsBusyOn() == true))
			{
				Sleep(100);		// TP2
				m_nPassBoxPIOStep++;
				ADD_LOG("D_197/%d", m_nPassBoxPIOStep);
			}
			else
			{
				if(OHTUTILITY::PreventOverflowGetTimeMs(dwPassBoxPIOWaitTime) > PASSBOX_PIO_CHECK_BUSY_ON_SIGNAL_TA2)
				{
					nError = ERR_PASSBOX_PIO_BUSY_SIGNAL_ABNORMAL_OFF;
					ADD_LOG("D_198/%d/%d/%d", m_nPassBoxPIOStep, nError, OHTUTILITY::PreventOverflowGetTimeMs(dwPassBoxPIOWaitTime));
					dwPassBoxPIOWaitTime = 0;
					ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d/%d",
									ERR_PASSBOX_PIO_BUSY_SIGNAL_ABNORMAL_OFF,
									m_pOHTMainStatus->StatusCommon.CurNodeID,
									m_pExecuteInfo->ExecutePositionInfo.NextNode,
									m_pOHTMainStatus->StatusCommon.CurNodeOffset,
									m_pOHTMainStatus->StatusCommon.ExistFoup,
									m_pOHTMainStatus->StatusCommon.StopStationID,
									m_nPassBoxPIOStep);
				}
			}
			break;

		case PASSBOX_CTRL_STEP_READY_ON :
			if(nError==NO_ERR)
			{
				nError = m_pPassBoxPIO->ReadyOnOff(ON);
				dwPassBoxPIOWaitTime = timeGetTime();
				ADD_LOG("D_199/%d", m_nPassBoxPIOStep);
				m_nPassBoxPIOStep++;
			}
			break;

		case PASSBOX_CTRL_STEP_CLOSE_OFF_CHECK :
			if((nError==NO_ERR) && (m_pPassBoxPIO->IsCloseOn() == false))
			{
				Sleep(100);		// TP3
				nError = m_pPassBoxPIO->OpenReqOnOff(OFF);
				dwPassBoxPIOWaitTime = timeGetTime();
				ADD_LOG("D_200/%d", m_nPassBoxPIOStep);
				m_nPassBoxPIOStep++;
			}
			else
			{
				if(OHTUTILITY::PreventOverflowGetTimeMs(dwPassBoxPIOWaitTime) > PASSBOX_PIO_CHECK_CLOSE_OFF_SIGNAL_TA3)
				{
					nError = ERR_PASSBOX_PIO_CLOSE_SIGNAL_ABNORMAL_ON;
					ADD_LOG("D_201/%d/%d/%d", m_nPassBoxPIOStep, nError, OHTUTILITY::PreventOverflowGetTimeMs(dwPassBoxPIOWaitTime));
					dwPassBoxPIOWaitTime = 0;
					ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d/%d",
									ERR_PASSBOX_PIO_CLOSE_SIGNAL_ABNORMAL_ON,
									m_pOHTMainStatus->StatusCommon.CurNodeID,
									m_pExecuteInfo->ExecutePositionInfo.NextNode,
									m_pOHTMainStatus->StatusCommon.CurNodeOffset,
									m_pOHTMainStatus->StatusCommon.ExistFoup,
									m_pOHTMainStatus->StatusCommon.StopStationID,
									m_nPassBoxPIOStep);
				}
			}
			break;

		case PASSBOX_CTRL_STEP_BUSY_OFF_CHECK :
			if((nError==NO_ERR) && (m_pPassBoxPIO->IsBusyOn() == false))
			{
				Sleep(100);		// TP4
				nError = m_pPassBoxPIO->ReadyOnOff(OFF);
				dwPassBoxPIOWaitTime = timeGetTime();
				ADD_LOG("D_202/%d", m_nPassBoxPIOStep);
				m_nPassBoxPIOStep++;
			}
			else
			{
				if(OHTUTILITY::PreventOverflowGetTimeMs(dwPassBoxPIOWaitTime) > PASSBOX_PIO_CHECK_BUSY_OFF_SIGNAL_TA4)
				{
					nError = ERR_PASSBOX_PIO_BUSY_SIGNAL_ABNORMAL_ON;
					ADD_LOG("D_203/%d/%d/%d", m_nPassBoxPIOStep, nError, OHTUTILITY::PreventOverflowGetTimeMs(dwPassBoxPIOWaitTime));
					dwPassBoxPIOWaitTime = 0;
					ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d/%d",
									ERR_PASSBOX_PIO_BUSY_SIGNAL_ABNORMAL_ON,
									m_pOHTMainStatus->StatusCommon.CurNodeID,
									m_pExecuteInfo->ExecutePositionInfo.NextNode,
									m_pOHTMainStatus->StatusCommon.CurNodeOffset,
									m_pOHTMainStatus->StatusCommon.ExistFoup,
									m_pOHTMainStatus->StatusCommon.StopStationID,
									m_nPassBoxPIOStep);
				}
			}
			break;

		case PASSBOX_CTRL_STEP_PASSBOX_DOOR_OPEN_CHECK :
			if((nError==NO_ERR) && (m_pPassBoxPIO->IsOpenOn() == true))
			{
				m_pPassBoxPIO->ReadyOnOff(OFF);
				Sleep(10);
				m_pPassBoxPIO->DoorSelectOnOff(OFF);
				Sleep(10);
				m_pPassBoxPIO->OHTStatusOnOff(OFF);
				Sleep(100);

				ADD_LOG("D_204/%d", m_nPassBoxPIOStep);
				m_nPassBoxPIOStep++;
			}
			else
			{
				if(OHTUTILITY::PreventOverflowGetTimeMs(dwPassBoxPIOWaitTime) > PASSBOX_PIO_CHECK_OPEN_ON_WAIT_TIME)
				{
					nError = ERR_PASSBOX_PIO_OPEN_SIGNAL_ABNORMAL_OFF;
					ADD_LOG("D_205/%d/%d/%d", m_nPassBoxPIOStep, nError, OHTUTILITY::PreventOverflowGetTimeMs(dwPassBoxPIOWaitTime));
					dwPassBoxPIOWaitTime = 0;
					ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d/%d",
									ERR_PASSBOX_PIO_OPEN_SIGNAL_ABNORMAL_OFF,
									m_pOHTMainStatus->StatusCommon.CurNodeID,
									m_pExecuteInfo->ExecutePositionInfo.NextNode,
									m_pOHTMainStatus->StatusCommon.CurNodeOffset,
									m_pOHTMainStatus->StatusCommon.ExistFoup,
									m_pOHTMainStatus->StatusCommon.StopStationID,
									m_nPassBoxPIOStep);
				}
			}
			break;

		case PASSBOX_CTRL_STEP_COMPLETE :
			ADD_LOG("D-137");
			m_pPassBoxPIO->PIODisable(true);
			*puStep = DRIVING_CTRL_STEP_GO_INIT;
			break;
	}

	return nError;
}

/*
   리프터를 미리 부르는 동작 제어
*/

UINT DrivingControl::executePreEvevetor(DEVICE_NODE_TYPE DirType)
{
	UINT nError = NO_ERR;
	int iReturn;

	AnsiString OHTNAME;
	int Priority;
	int Turn;
	unsigned char LightGuideID;
	bool LightGuideDirectionIsLeft;

	bool bCheckMTLType= false;

	if((DirType >=MTL_SEL_ON_LEFT) && (DirType <=MTL_STOP_RIGTH))
	{
       	bCheckMTLType = true;
	}

	static int iRetryCnt = 0;

	int nDeviceTimeout = m_pParamSet->LightGuide_TIME_OUT_MS_VHLLifter;

	OHTNAME = m_strOhtName;
	Priority = PRIORITY_LEVEL_9;
	if(m_defualtparam->VHLLifterPassEnable == 0)
	{
		Turn = PASS_DIRECTION_REQUEST_ALL;
        LightGuideID = LIGHT_GUIDE_ID_INPUT_ENTER;
		/*
	  if (m_nElevetorDirection == PASS_DIRECTION_REQUEST_RIGHT)	// 내가 하부에 진입하고, 상부로 가고 싶다
			LightGuideID = LIGHT_GUIDE_ID_INPUT_UP;
	  else
			LightGuideID = LIGHT_GUIDE_ID_INPUT_DOWN;
	  */

	}
	else // AOHC-217 VHLLifter 속도 개선 jhoun.lim 181107
	{
		Turn = m_nElevetorDirection; // jhoun.lim 181107
		LightGuideID = LIGHT_GUIDE_ID_NONE;	 // AOHC-217 VHLLifter 속도 개선 jhoun.lim 181107
	}

	if((DirType >=MTL_SEL_ON_LEFT) && (DirType <=MTL_STOP_RIGTH))
	{
	   LightGuideID = LIGHT_GUIDE_ID_INPUT_MTL;
	   nDeviceTimeout = m_pParamSet->LightGuide_TIME_OUT_MS_MTL;
	}

	if((DirType == LIFTPRE_NTYPE_LEFT) ||(DirType ==MTL_SEL_ON_LEFT) ||(DirType ==LIFTIN_NTYPE_LEFT) ||(DirType ==MTL_STOP_LEFT))
		LightGuideDirectionIsLeft = true;
	else
		LightGuideDirectionIsLeft = false;


	AnsiString strLogTmp;

	static int iDelayCnt = 0;
	// -----------------------------

	if(m_nElevetorRideStep >VHL_ELEVETOR_RIDE_CTRL_STEP_CID_INIT)
	{
		if(!(CID_Check_Mode_Lifter(LightGuideDirectionIsLeft)))
		{
			CID_IO_SETTING_LIFTER(LightGuideDirectionIsLeft);
			ADD_CID_LOG("[LIFTER] [Pre] Lifter_Checking");
		}
	}

	switch(m_nElevetorRideStep)
	{
		case VHL_ELEVETOR_RIDE_CTRL_STEP_CID_INIT:
		{
			//ADD_CID_LOG("\n------------------------------");


			CID_IO_SETTING_LIFTER(LightGuideDirectionIsLeft);
			m_iLifterPrePass = VHL_ELEVETOR_PREPASS_STEP_TOUCH;

			iRetryCnt = 0;
			m_nElevetorRideStep++;	// next step
			//AOHC-217 VHLLifter 속도 개선
		   // if (0 : off Pass), (1 : on Pass) jhoun.lim 19.10.15
			if(m_defualtparam->VHLLifterPassEnable == 0)
			{
				m_nElevetorDirection = PASS_DIRECTION_REQUEST_ALL;
			}
			else
			{
				m_nElevetorDirection = PASS_DIRECTION_REQUEST_BEFORECHECK;   // jhoun.lim 18.11.14
			}
			if(bCheckMTLType ==true)
				strLogTmp.sprintf("[MTL PRE(01)] CID_INIT:%d,%d", m_nElevetorDirection,DirType);
			else
				strLogTmp.sprintf("[LIFTER PRE(01)] CID_INIT:%d,%d", m_nElevetorDirection,DirType);
			ADD_CID_LOG(strLogTmp);
		}
		break;

// -------------------

		case VHL_ELEVETOR_RIDE_CTRL_STEP_SERIAL_INIT:
		{
			//ADD_CID_LOG("[LIFTER PRE (02)] - SERIAL_INIT");

		// Try Reset
			nError = VHL_OPC_RESET();

			if(nError == NO_ERR)
			{
				if(bCheckMTLType ==true)
					ADD_CID_LOG("[MTL PRE(02)] OPC RESET... Return Code is : NO_ERR");
				else
					ADD_CID_LOG("[LIFTER PRE(02)] OPC RESET... Return Code is : NO_ERR");
				iDelayCnt = 0;
				m_nElevetorRideStep++;
			}
			else
			{
				// Sleep(DELAY_SERIAL_RESET);
				iRetryCnt = iRetryCnt + DELAY_SERIAL_READ;
				if(bCheckMTLType ==true)
					strLogTmp.sprintf("[MTL PRE(02)]OPC B/D RESET... Return Code is : %d (ERROR Exist).. ErrTime(ms) : %d", nError, iRetryCnt);
				else
					strLogTmp.sprintf("[LIFTER PRE(02)]OPC B/D RESET... Return Code is : %d (ERROR Exist).. ErrTime(ms) : %d", nError, iRetryCnt);
				ADD_CID_LOG(strLogTmp);

			}

			if(iRetryCnt > nDeviceTimeout)
			{
				if(bCheckMTLType ==true)
					ADD_CID_LOG("[MTL PRE(02)] SERIAL_INIT retry over");
				else
					ADD_CID_LOG("[LIFTER PRE(02)] SERIAL_INIT retry over");

				if((DirType >=MTL_SEL_ON_LEFT) && (DirType <=MTL_STOP_RIGTH))
					return ERR_MTL_LG_OPC_RESET_CMD_SEND_FAIL;
				else
					return ERR_LIFTER_OPC_RESET_CMD_SEND_FAIL;
			}
		}
		break;

		case VHL_ELEVETOR_RIDE_CTRL_STEP_SERIAL_WAIT:
			if (iDelayCnt > (DELAY_SERIAL_RESET / 10))
			{
//				ADD_CID_LOG("[LIFTER PRE STEP(03)] - SERIAL_WAIT");
				// Sleep(DELAY_SERIAL_RESET);

			   //	ADD_CID_LOG("[LIFTER PRE]  VHL_OPC_RESET_RESPONSE() - BEFORE");
				iReturn = VHL_OPC_RESET_RESPONSE();

//				strLogTmp.sprintf("[LIFTER PRE] OPC B/D RESET Response. Return Code is (HEX) : %02X  (CHAR) : %c", iReturn, iReturn);
//				ADD_CID_LOG(strLogTmp);

				if(iReturn == TRANSPER_STATUS_DATA_RECEIVED_OK)
				{
					iRetryCnt = 0;
					m_nElevetorRideStep++;

					if(bCheckMTLType ==true)
						ADD_CID_LOG("[MTL PRE(03)] OPC B/D RESET Response - RECEIVED_OK");
					else
						ADD_CID_LOG("[LIFTER PRE(03)] OPC B/D RESET Response - RECEIVED_OK");
				}
				else if(iReturn == TRANSPER_STATUS_DATA_NOT_RECEIVED)
				{
					m_nElevetorRideStep = VHL_ELEVETOR_RIDE_CTRL_STEP_SERIAL_INIT;	// retry
					iRetryCnt = iRetryCnt + DELAY_SERIAL_READ;
					if(bCheckMTLType ==true)
						strLogTmp.sprintf("[MTL PRE(03)] OPC B/D RESET Response - DATA_NOT_RECEIVED ErrTime(ms) : %d ", iRetryCnt);
					else
						strLogTmp.sprintf("[LIFTER PRE(03)] OPC B/D RESET Response - DATA_NOT_RECEIVED ErrTime(ms) : %d ", iRetryCnt);
					ADD_CID_LOG(strLogTmp);
				}
				else
				{
					m_nElevetorRideStep = VHL_ELEVETOR_RIDE_CTRL_STEP_SERIAL_INIT;	// retry
					iRetryCnt = iRetryCnt + DELAY_SERIAL_READ;
					if(bCheckMTLType ==true)
						strLogTmp.sprintf("[MTL PRE](03) OPC B/D RESET Response - OTHER ERR	ErrTime(ms) : %d, Return: %02X ", iRetryCnt,iReturn);
					else
						strLogTmp.sprintf("[LIFTER PRE](03) OPC B/D RESET Response - OTHER ERR	ErrTime(ms) : %d, Return: %02X ", iRetryCnt,iReturn);
					ADD_CID_LOG(strLogTmp);
				}
/*
				if(iRetryCnt > LIFTER_PASS_TIME_OUT_MS)
				{
					ADD_CID_LOG("[LIFTER PRE] SERIAL_INIT retry over");
					return ERR_LIFTER_OPC_RESET_CMD_RESULT_FAIL;
				}
*/
			}
			else
			{
				iDelayCnt++;
			}
		break;


// -------------------
		case VHL_ELEVETOR_RIDE_CTRL_STEP_INPUT_REQUEST: 	// 투입허가 요청함
		{
//			ADD_CID_LOG("[LIFTER PRE (04)] - INPUT_REQUEST");



			nError = VHL_OPC_PASS_REQUEST(m_defualtparam->VHLName, Priority, Turn, LightGuideID);

			if(nError == NO_ERR)
			{
//				ADD_CID_LOG("[LIFTER PRE](04) INPUT_REQUEST STEP OK...,DirType:%d", DirType);
				iDelayCnt = 0;
				m_nElevetorRideStep++;
			}
			else
			{
				// Sleep(DELAY_SERIAL_READ);
				iRetryCnt = iRetryCnt + DELAY_SERIAL_READ;
//				strLogTmp.sprintf("[LIFTER PRE](04) VHL_OPC_PASS_REQUEST - Return : %d ErrTime(ms) : %d", nError, iRetryCnt);
//				ADD_CID_LOG(strLogTmp);
			}
            if(bCheckMTLType ==true)
				strLogTmp.sprintf("[MTL PRE(04)] Pass Request-OHTNAME:%s,Priority:%c,Turn:%c,LightGuideID:%c,Return:%d,ErrTime(ms):%d,DirType:%d", m_defualtparam->VHLName, Priority, Turn, LightGuideID,nError, iRetryCnt,DirType);
			else
				strLogTmp.sprintf("[LIFTER PRE(04)] Pass Request-OHTNAME:%s,Priority:%c,Turn:%c,LightGuideID:%c,Return:%d,ErrTime(ms):%d,DirType:%d", m_defualtparam->VHLName, Priority, Turn, LightGuideID,nError, iRetryCnt,DirType);

			ADD_CID_LOG(strLogTmp);

			if(iRetryCnt > nDeviceTimeout)
			{
				if(bCheckMTLType ==true)
					ADD_CID_LOG("[MTL PRE(04)] SERIAL_INIT retry over");
				else
					ADD_CID_LOG("[LIFTER PRE(04)] SERIAL_INIT retry over");


				if((DirType >=MTL_SEL_ON_LEFT) && (DirType <=MTL_STOP_RIGTH))
					return ERR_MTL_LG_REQUEST_CMD_SEND_FAIL;
				else
					return ERR_LIFTER_INPUT_REQUEST_CMD_SEND_FAIL;
			}
		}
		break;


		case VHL_ELEVETOR_RIDE_CTRL_STEP_INPUT_CONFIRM_WAIT:	// 투입허가 승인대기
			if (iDelayCnt > (DELAY_SERIAL_WAIT_N_REQUEST_RETRY / 10))
			{
//				ADD_CID_LOG("\n[LIFTER PRE (05)] - CONFIRM_WAIT");
				// Sleep(DELAY_SERIAL_WAIT_N_REQUEST_RETRY);

				iReturn = VHL_OPC_PASS_RESPONSE(LightGuideID);

				//AOHC-217 VHLLifter 속도 개선
				if(iReturn == VHL_LIFTER_TO_CID_R_ALL_PASS_OK || iReturn == VHL_LIFTER_TO_CID_R_ALL_PASS_OK_P) // jhoun.lim
				{
					if(bCheckMTLType ==true)
						strLogTmp.sprintf("[MTL PRE(05)] INPUT_CONFIRM_WAIT OK...%c", iReturn);
					else
						strLogTmp.sprintf("[LIFTER PRE(05)] INPUT_CONFIRM_WAIT OK...%c", iReturn);
					ADD_CID_LOG(strLogTmp);
					//ADD_CID_LOG("[LIFTER PRE] INPUT_CONFIRM OK...");
					iRetryCnt = 0;
					m_nElevetorRideStep++;
				}
				else
				{
					iRetryCnt = iRetryCnt + DELAY_SERIAL_WAIT_N_REQUEST_RETRY;
					if(bCheckMTLType ==true)
						strLogTmp.sprintf("[MTL PRE(05)]  CONFIRM_WAIT Err. Code : %c ErrTime(ms) : %d", iReturn, iRetryCnt);
					else
						strLogTmp.sprintf("[LIFTER PRE(05)]  CONFIRM_WAIT Err. Code : %c ErrTime(ms) : %d", iReturn, iRetryCnt);
					ADD_CID_LOG(strLogTmp);
					m_nElevetorRideStep = VHL_ELEVETOR_RIDE_CTRL_STEP_INPUT_REQUEST;
				}

				if(iRetryCnt > nDeviceTimeout)
				{
					if(bCheckMTLType ==true)
						ADD_CID_LOG("[MTL PRE(05)] SERIAL_INIT retry over");
					else
						ADD_CID_LOG("[LIFTER PRE(05)] SERIAL_INIT retry over");

					if((DirType >=MTL_SEL_ON_LEFT) && (DirType <=MTL_STOP_RIGTH))
						return ERR_MTL_LG_REQUEST_CONFIRM_TIME_OUT;
					else
						return ERR_LIFTER_INPUT_REQUEST_CONFIRM_TIME_OUT;
				}

			}
			else
			{
				iDelayCnt++;
			}
		break;

// -------------------

		case VHL_ELEVETOR_RIDE_CTRL_STEP_COMPLETE:		// 스테이트 머신 끝날땐 어떻게 처리해줘야 하나
		{
//			ADD_CID_LOG("[LIFTER PRE(06)");
			Sleep(20);

            //초기화
			VHL_OPC_RESET();
			Sleep(DELAY_SERIAL_RESET);
			VHL_OPC_RESET_RESPONSE();

			iReturn = CID_SELECT_ALL_OFF();		// CID의 Select를 모두 Off한다

			if(bCheckMTLType ==true)
				strLogTmp.sprintf("[MTL PRE](06) SELECT all off return : %d", iReturn);
			else
				strLogTmp.sprintf("[LIFTER PRE](06) SELECT all off return : %d", iReturn);
			ADD_CID_LOG(strLogTmp);
			Sleep(DELAY_CID_COMMAND);	// 장비사양상 최소 10ms딜레이 줘야 함

			m_iLifterPrePass = VHL_ELEVETOR_PREPASS_STEP_COMPLETE;	// Lifter In 노드까지 가기 전에 투입허가 요청을 받아낸 경우
//			ADD_CID_LOG("executePreEvevetor,VHL_ELEVETOR_PREPASS_STEP_COMPLETE");
			m_IsLifterCheck = false;
			m_IsMTLCheck = false;
			return NO_ERR;
		}
		break;
	}

	return NO_ERR;
}


/**
@brief  Elevetor 타기 동작 Control
@author 김승현
@date   2016.02.15
@param  puStep 주행의 Step 변수
@return 에러 없으면 0반환, 있으면 에러 코드 반환
*/


UINT DrivingControl::executeRideEvevetor(DRIVING_HW_INFO_SET HwInfo, DRIVING_INFO_SET *pInfoSet, UINT *puStep)
{
	UINT nError = NO_ERR;
	int iReturn;

	DRIVING_CMD_INFO_OF_NODE* pNodeInfo = getNodeInfo(0);

	if(pNodeInfo==NULL)
    {
        ADD_LOG("D_206/%d/%d/%d"
            , HwInfo.Node.nNodeCount
            , pInfoSet->HwInfo.Node.nNodeCount
			, m_ClassifiedCmd.NodeList.getCount());
		return nError;// 에러 처리 : 명령에 없는 노드 Count 실시
	}

    int nDeviceTimeout = m_pParamSet->LightGuide_TIME_OUT_MS_VHLLifter;

	bool bCheckMTLType= false;

	if((pNodeInfo->NodeType >=MTL_SEL_ON_LEFT) && (pNodeInfo->NodeType <=MTL_STOP_RIGTH))
	{
		bCheckMTLType = true;
	}

	// 임시 - 디버그용
	AnsiString OHTNAME;
	int Priority;
	int Turn;
	unsigned char LightGuideID;
	bool LightGuideDirectionIsLeft;

	static int iRetryCnt = 0;

	// OHTNAME = "OHT001";
	OHTNAME = m_strOhtName;
	Priority = PRIORITY_LEVEL_9;
	if(m_defualtparam->VHLLifterPassEnable == 0)
	{
		Turn = PASS_DIRECTION_REQUEST_ALL;
		LightGuideID = LIGHT_GUIDE_ID_INPUT_ENTER;
//		if (m_nElevetorDirection == PASS_DIRECTION_REQUEST_RIGHT)	// 내가 하부에 진입하고, 상부로 가고 싶다
//			LightGuideID = LIGHT_GUIDE_ID_INPUT_UP;
//		else
//			LightGuideID = LIGHT_GUIDE_ID_INPUT_DOWN;
	}

	else
	{
		Turn = m_nElevetorDirection; // jhoun.lim 181107
		LightGuideID = LIGHT_GUIDE_ID_NONE; // AOHC-217 VHLLifter 속도 개선 jhoun.lim 181107
	}

	if((pNodeInfo->NodeType >=MTL_SEL_ON_LEFT) && (pNodeInfo->NodeType <=MTL_STOP_RIGTH))
	{
		LightGuideID = LIGHT_GUIDE_ID_INPUT_MTL;
        nDeviceTimeout = m_pParamSet->LightGuide_TIME_OUT_MS_MTL;
	}

	if((pNodeInfo->NodeType >=AUTODOOR_LEFT) && (pNodeInfo->NodeType <=AUTODOOR_RIGHT))
	{
		Turn = PASS_DIRECTION_REQUEST_ALL;
		LightGuideID = LIGHT_GUIDE_ID_INPUT_AUTODOOR;
		nDeviceTimeout = m_pParamSet->LightGuide_TIME_OUT_MS_AutoDoor;
	}

	if((pNodeInfo->NodeType == LIFTPRE_NTYPE_LEFT) ||(pNodeInfo->NodeType == MTL_SEL_ON_LEFT)  ||(pNodeInfo->NodeType == LIFTIN_NTYPE_LEFT)  ||(pNodeInfo->NodeType == MTL_STOP_LEFT))
		LightGuideDirectionIsLeft = true;
	else
		LightGuideDirectionIsLeft = false;

		AnsiString strLogTmp;
	// -----------------------------

	if(m_nElevetorRideStep >VHL_ELEVETOR_RIDE_CTRL_STEP_CID_INIT)
	{
		if(!(CID_Check_Mode_Lifter(LightGuideDirectionIsLeft)))
		{
			CID_IO_SETTING_LIFTER(LightGuideDirectionIsLeft);
			ADD_CID_LOG("[LIFTER] Lifter_Checking");
		}
	}

	if(bReqLifterCounterReset == true)
	{
		bReqLifterCounterReset = false;
		iRetryCnt = 0;
	}

	switch(m_nElevetorRideStep)
	{
		case VHL_ELEVETOR_RIDE_CTRL_STEP_CID_INIT:
		{
//			ADD_CID_LOG("\n-------------------------------");
//			ADD_CID_LOG("[LIFTER] CID_INIT");
			// Steering Check
			// if(pTmpDrivingInfo.BasicInfo.Steering == STEERING_LEFT

			nError = CID_SELECT_ALL_OFF();		// CID의 Select를 모두 Off한다
			if(nError != NO_ERR)
			{
            	if(bCheckMTLType ==true)
					strLogTmp.sprintf("[MTL RIDE(01)] SELECT all off return : %d", nError);
				else
					strLogTmp.sprintf("[LIFTER RIDE(01)] SELECT all off return : %d", nError);
				ADD_CID_LOG(strLogTmp);
			}
			Sleep(DELAY_CID_COMMAND);	// 장비사양상 최소 10ms딜레이 줘야 함

			nError = CID_OPERATION_MODE_LIFTER();	// CID장치를 리프터 모드로 전환한다
			if(nError != NO_ERR)
			{
				if(bCheckMTLType ==true)
					strLogTmp.sprintf("[MTL RIDE(01)] OP MODE LIFTER : %d", nError);
				else
					strLogTmp.sprintf("[LIFTER RIDE(01)] OP MODE LIFTER : %d", nError);
				ADD_CID_LOG(strLogTmp);
			}
			Sleep(DELAY_CID_COMMAND);

			// 좌,우 방향을 선택한다
			if(LightGuideDirectionIsLeft == true)
			{
				nError = CID_SELECT_DIRECTION_LEFT();
//				strLogTmp.sprintf("[LIFTER RIDE](1) LEFT 선택 : %d", nError);
//				ADD_CID_LOG(strLogTmp);
				Sleep(DELAY_CID_COMMAND);
			}
			else
			{
				nError = CID_SELECT_DIRECTION_RIGHT();
//				strLogTmp.sprintf("[LIFTER RIDE](1) RIGHT 선택 : %d", nError);
//				ADD_CID_LOG(strLogTmp);
				Sleep(DELAY_CID_COMMAND);
			}

			iRetryCnt = 0;
			m_nElevetorRideStep++;	// next step

			//AOHC-217 VHLLifter 속도 개선
			// if (0 : off Pass), (1 : on Pass) jhoun.lim 19.10.15
			if(m_defualtparam->VHLLifterPassEnable == 0)
			{
				m_nElevetorDirection =  PASS_DIRECTION_REQUEST_ALL;
			}
			else
			{
				m_nElevetorDirection =  PASS_DIRECTION_REQUEST_BEFORECHECK; // jhoun.lim 18.11.14
			}

			if(bCheckMTLType ==true)
				strLogTmp.sprintf("[MTL RIDE(01)]CID_INIT_DIRECTION:%d,%d,Error:%d", LightGuideDirectionIsLeft,m_nElevetorDirection, nError);
			else
            	strLogTmp.sprintf("[LIFTER RIDE(01)]CID_INIT_DIRECTION:%d,%d,Error:%d", LightGuideDirectionIsLeft,m_nElevetorDirection, nError);
			ADD_CID_LOG(strLogTmp);

		}
		break;

// -------------------


		case VHL_ELEVETOR_RIDE_CTRL_STEP_SERIAL_INIT:
		{
//			ADD_CID_LOG("\n[LIFTER RIDE(02)] - SERIAL_INIT");

		// Try Reset
			nError = VHL_OPC_RESET();

			if(nError == NO_ERR)
			{
				if(bCheckMTLType ==true)
					ADD_CID_LOG("[MTL RIDE(02)] OPC RESET... Return Code is : NO_ERR");
				else
					ADD_CID_LOG("[LIFTER RIDE(02)] OPC RESET... Return Code is : NO_ERR");
				m_nElevetorRideStep++;
			}
			else
			{
				Sleep(DELAY_SERIAL_RESET);
				iRetryCnt = iRetryCnt + DELAY_SERIAL_READ;
				if(bCheckMTLType ==true)
					strLogTmp.sprintf("[MTL RIDE(02)] OPC B/D RESET... Return Code is : %d (ERROR Exist).. ErrTime(ms) : %d", nError, iRetryCnt);
				else
					strLogTmp.sprintf("[LIFTER RIDE(02)] OPC B/D RESET... Return Code is : %d (ERROR Exist).. ErrTime(ms) : %d", nError, iRetryCnt);
				ADD_CID_LOG(strLogTmp);

			}

			if(iRetryCnt > nDeviceTimeout)
			{
				if(bCheckMTLType ==true)
					ADD_CID_LOG("[MTL RIDE(02)] SERIAL_INIT retry over");
				else
					ADD_CID_LOG("[LIFTER RIDE(02)] SERIAL_INIT retry over");
				if((pNodeInfo->NodeType >=MTL_SEL_ON_LEFT) && (pNodeInfo->NodeType <=MTL_STOP_RIGTH))
					return ERR_MTL_LG_OPC_RESET_CMD_SEND_FAIL;
				else
					return ERR_LIFTER_OPC_RESET_CMD_SEND_FAIL;
			}
		}
		break;

		case VHL_ELEVETOR_RIDE_CTRL_STEP_SERIAL_WAIT:
		{
//			ADD_CID_LOG("\n[LIFTER RIDE (03)] - SERIAL_WAIT");
			Sleep(DELAY_SERIAL_RESET);

//			ADD_CID_LOG("[LIFTER]  VHL_OPC_RESET_RESPONSE() - BEFORE");
			iReturn = VHL_OPC_RESET_RESPONSE();

//			strLogTmp.sprintf("[LIFTER] OPC B/D RESET Response. Return Code is (HEX) : %02X  (CHAR) : %c", iReturn, iReturn);
//			ADD_CID_LOG(strLogTmp);

			if(iReturn == TRANSPER_STATUS_DATA_RECEIVED_OK)
			{
				iRetryCnt = 0;
				m_nElevetorRideStep++;

				if(bCheckMTLType ==true)
					ADD_CID_LOG("[MTL RIDE(03)] OPC B/D RESET Response - RECEIVED_OK");
				else
					ADD_CID_LOG("[LIFTER RIDE(03)] OPC B/D RESET Response - RECEIVED_OK");
			}
			else if(iReturn == TRANSPER_STATUS_DATA_NOT_RECEIVED)
			{
				m_nElevetorRideStep = VHL_ELEVETOR_RIDE_CTRL_STEP_SERIAL_INIT;	// retry
				iRetryCnt = iRetryCnt + DELAY_SERIAL_READ;
				if(bCheckMTLType ==true)
					strLogTmp.sprintf("[MTL RIDE(03)] OPC B/D RESET Response - DATA_NOT_RECEIVED ErrTime(ms) : %d ", iRetryCnt);
				else
					strLogTmp.sprintf("[LIFTER RIDE(03)] OPC B/D RESET Response - DATA_NOT_RECEIVED ErrTime(ms) : %d ", iRetryCnt);
				ADD_CID_LOG(strLogTmp);
			}
			else
			{
				m_nElevetorRideStep = VHL_ELEVETOR_RIDE_CTRL_STEP_SERIAL_INIT;	// retry
				iRetryCnt = iRetryCnt + DELAY_SERIAL_READ;
				if(bCheckMTLType ==true)
					strLogTmp.sprintf("[MTL RIDE(03)] OPC B/D RESET Response - OTHER ERR  ErrTime(ms) : %d,Return: %02X", iRetryCnt,iReturn);
				else
					strLogTmp.sprintf("[LIFTER RIDE(03)] OPC B/D RESET Response - OTHER ERR  ErrTime(ms) : %d,Return: %02X", iRetryCnt,iReturn);
				ADD_CID_LOG(strLogTmp);
			}

			if(iRetryCnt > nDeviceTimeout)
			{
				if(bCheckMTLType ==true)
					ADD_CID_LOG("[MTL RIDE(03)] SERIAL_INIT retry over");
				else
					ADD_CID_LOG("[LIFTER RIDE(03)] SERIAL_INIT retry over");

				if((pNodeInfo->NodeType >=MTL_SEL_ON_LEFT) && (pNodeInfo->NodeType <=MTL_STOP_RIGTH))
				 	return ERR_MTL_LG_OPC_RESET_CMD_RESULT_FAIL;
				else
					return ERR_LIFTER_OPC_RESET_CMD_RESULT_FAIL;
			}
		}
		break;


// -------------------
		case VHL_ELEVETOR_RIDE_CTRL_STEP_INPUT_REQUEST:		// 투입허가 요청함
		{
//			ADD_CID_LOG("[LIFTER RIDE (04)] - INPUT_REQUEST");
			/* strLogTmp.sprintf("[LIFTER] Pass Request - OHTNAME : %s Priority : %d Turn : %d LightGuideID : %d",
								OHTNAME, Priority, Turn, LightGuideID); */


			nError = VHL_OPC_PASS_REQUEST(m_defualtparam->VHLName, Priority, Turn, LightGuideID);

			if(nError == NO_ERR)
			{
//				ADD_CID_LOG("[LIFTER] INPUT_REQUEST STEP OK...");
				m_nElevetorRideStep++;
			}
			else
			{
				Sleep(DELAY_SERIAL_READ);
				iRetryCnt = iRetryCnt + DELAY_SERIAL_READ;
//				strLogTmp.sprintf("[LIFTER] VHL_OPC_PASS_REQUEST - Return : %d ErrTime(ms) : %d", nError, iRetryCnt);
//				ADD_CID_LOG(strLogTmp);
			}
			if(bCheckMTLType ==true)
				strLogTmp.sprintf("[MTL RIDE(04)]Pass Request-OHTNAME:%s,Priority:%c,Turn:%c,LightGuideID:%c,Return:%d,ErrTime(ms):%d,DirType:%d", m_defualtparam->VHLName, Priority, Turn, LightGuideID,nError, iRetryCnt,pNodeInfo->NodeType);
			else
				strLogTmp.sprintf("[LIFTER RIDE(04)]Pass Request-OHTNAME:%s,Priority:%c,Turn:%c,LightGuideID:%c,Return:%d,ErrTime(ms):%d,DirType:%d", m_defualtparam->VHLName, Priority, Turn, LightGuideID,nError, iRetryCnt,pNodeInfo->NodeType);
			ADD_CID_LOG(strLogTmp);

			if(iRetryCnt > nDeviceTimeout)
			{
				if(bCheckMTLType ==true)
					ADD_CID_LOG("[MTL RIDE(04)] SERIAL_INIT retry over");
				else
					ADD_CID_LOG("[LIFTER RIDE(04)] SERIAL_INIT retry over");
				if((pNodeInfo->NodeType >=MTL_SEL_ON_LEFT) && (pNodeInfo->NodeType <=MTL_STOP_RIGTH))
					return ERR_MTL_LG_REQUEST_CMD_SEND_FAIL;
				else
					return ERR_LIFTER_INPUT_REQUEST_CMD_SEND_FAIL;
			}
		}
		break;


		case VHL_ELEVETOR_RIDE_CTRL_STEP_INPUT_CONFIRM_WAIT:	// 투입허가 승인대기
		{
//			ADD_CID_LOG("\n[LIFTER RIDE (05)] - INPUT_CONFIRM_WAIT");
			Sleep(DELAY_SERIAL_WAIT_N_REQUEST_RETRY);

			iReturn = VHL_OPC_PASS_RESPONSE(LightGuideID);

			//AOHC-217 VHLLifter 속도 개선
			if(iReturn == VHL_LIFTER_TO_CID_R_ALL_PASS_OK || iReturn == VHL_LIFTER_TO_CID_R_ALL_PASS_OK_P) // jhoun.lim
			{

				if(bCheckMTLType ==true)
					strLogTmp.sprintf("[MTL RIDE(05)]INPUT_CONFIRM_WAIT OK...%c", iReturn);
				else
					strLogTmp.sprintf("[LIFTER RIDE(05)]INPUT_CONFIRM_WAIT OK...%c", iReturn);
				ADD_CID_LOG(strLogTmp);
				//ADD_CID_LOG("[LIFTER] INPUT_CONFIRM_WAIT OK...");
				iRetryCnt = 0;
				m_nElevetorRideStep++;
			}
			else
			{
				iRetryCnt = iRetryCnt + DELAY_SERIAL_WAIT_N_REQUEST_RETRY;
				if(bCheckMTLType ==true)
					strLogTmp.sprintf("[MTL RIDE(05)]INPUT_CONFIRM_WAIT Err. Code : %c ErrTime(ms) : %d", iReturn, iRetryCnt);
				else
					strLogTmp.sprintf("[LIFTER RIDE(05)]INPUT_CONFIRM_WAIT Err. Code : %c ErrTime(ms) : %d", iReturn, iRetryCnt);
				ADD_CID_LOG(strLogTmp);
				m_nElevetorRideStep = VHL_ELEVETOR_RIDE_CTRL_STEP_INPUT_REQUEST;
			}

			if(iRetryCnt > nDeviceTimeout)
			{
				if(bCheckMTLType ==true)
					ADD_CID_LOG("[MTL RIDE(05)] SERIAL_INIT retry over");
				else
					ADD_CID_LOG("[LIFTER RIDE(05)] SERIAL_INIT retry over");
				if((pNodeInfo->NodeType >=MTL_SEL_ON_LEFT) && (pNodeInfo->NodeType <=MTL_STOP_RIGTH))
						return ERR_MTL_LG_REQUEST_CONFIRM_TIME_OUT;
				else
						return ERR_LIFTER_INPUT_REQUEST_CONFIRM_TIME_OUT;
			}

		}
		break;

// -------------------

		case VHL_ELEVETOR_RIDE_CTRL_STEP_COMPLETE:		// 스테이트 머신 끝날땐 어떻게 처리해줘야 하나??
		{
//			ADD_CID_LOG("\n[LIFTER RIDE (06)");
			Sleep(20);

			//초기화
			VHL_OPC_RESET();
			Sleep(DELAY_SERIAL_RESET);
			VHL_OPC_RESET_RESPONSE();

			iReturn = CID_SELECT_ALL_OFF();		// CID의 Select를 모두 Off한다
			if(bCheckMTLType ==true)
				strLogTmp.sprintf("[MTL RIDE(6)] SELECT all off return : %d", iReturn);
			else
				strLogTmp.sprintf("[LIFTER RIDE(6)] SELECT all off return : %d", iReturn);
			ADD_CID_LOG(strLogTmp);
			Sleep(DELAY_CID_COMMAND);	// 장비사양상 최소 10ms딜레이 줘야 함

			*puStep = DRIVING_CTRL_STEP_GO_INIT;
			m_iLifterPrePass = VHL_ELEVETOR_PREPASS_STEP_COMPLETE;
//			ADD_CID_LOG("executeRideEvevetor,autodoor_1");
			m_IsLifterCheck = false;
			m_IsMTLCheck = false;
			m_IsAutoDoorCheck = false;
			return NO_ERR;
		}
		break;
	}

	return NO_ERR;
}


/**
@brief	Elevetor 내리는 동작 Control
@author 김승현
@date	2016.02.15
@param	puStep 주행의 Step 변수
@return 에러 없으면 0반환, 있으면 에러 코드 반환
*/


UINT DrivingControl::executeOffEvevetor(DRIVING_HW_INFO_SET HwInfo, DRIVING_INFO_SET *pInfoSet, UINT *puStep)
{
	int iReturn;
	static int iRetryCnt = 0;

	LList 						DRIVING_INFO_List;
	EXECUTE_DRIVING_INFO		*pEXECUTE_DRIVING_INFO	= NULL;	// List에 저장하는 구조체

	AnsiString OHTNAME;
	int Priority;
	int Turn;
	unsigned char LightGuideID;
	bool LightGuideDirectionIsLeft;

	OHTNAME = m_strOhtName;
	Priority = PRIORITY_LEVEL_9;
	Turn = m_nElevetorDirection;

	if (m_nElevetorDirection == PASS_DIRECTION_REQUEST_RIGHT)	// 내가 하부에 진입하고, 상부로 가고 싶다
		LightGuideID = LIGHT_GUIDE_ID_INPUT_UP;
	else
		LightGuideID = LIGHT_GUIDE_ID_INPUT_DOWN;


	LightGuideDirectionIsLeft = m_pParamSet->bVHLLifterDir;


	AnsiString strLogTmp;
	// -----------------------------

	if(m_nElevetorRideStep >VHL_ELEVETOR_RIDE_CTRL_STEP_CID_INIT)
	{
		if(!(CID_Check_Mode_Lifter(LightGuideDirectionIsLeft)))
		{
			CID_IO_SETTING_LIFTER(LightGuideDirectionIsLeft);
			ADD_CID_LOG("[LIFTER [off] Lifter_Checking");
		}
	}

	switch(m_nElevetorOffStep)
	{
		case VHL_ELEVETOR_OFF_CTRL_STEP_INIT:
		{
			ADD_CID_LOG("[LIFTER OUT (01)] - OFF_CTRL_STEP_INIT");

            CID_IO_SETTING_LIFTER(LightGuideDirectionIsLeft);

			m_iLifterPrePass = VHL_ELEVETOR_PREPASS_STEP_NONE;

			iRetryCnt = 0;
			m_nElevetorOffStep++;
		}
		break;

// -------------------

		case VHL_ELEVETOR_OFF_CTRL_STEP_OUTPUT_REQUEST_INIT:
		{
//			strLogTmp.sprintf("[LIFTER OUT (02)] OUTPUT_REQUEST Direction : %c", Turn);
//			ADD_CID_LOG(strLogTmp);

			iReturn = VHL_OPC_PASS_REQUEST(m_defualtparam->VHLName, Priority, Turn, LightGuideID);
//			strLogTmp.sprintf("[LIFTER OUT (02)] Out Init Return : %d, Direction : %c", iReturn, Turn);
			strLogTmp.sprintf("[LIFTER OUT(02)]Pass Request-OHTNAME:%s,Priority:%c,Turn:%c,LightGuideID:%c,Return:%d,ErrTime(ms):%d", m_defualtparam->VHLName, Priority, Turn, LightGuideID,iReturn, iRetryCnt);
			ADD_CID_LOG(strLogTmp);
			m_nElevetorOffStep++;
		}
		break;

		case VHL_ELEVETOR_OFF_CTRL_STEP_OUTPUT_RESPONSE:
		{
//			ADD_CID_LOG("[LIFTER OUT(03)] - OUTPUT_RESPONSE");
			Sleep(DELAY_SERIAL_WAIT_N_REQUEST_RETRY);
			// 이 함수의 리턴값은 응답으로 온 방향 지정값이 들어오며
			// 'R', 'L', 'r', 'l' 4가지가 유효하다
			iReturn = VHL_OPC_PASS_RESPONSE(LightGuideID);

			if(Turn == iReturn)
			{
				strLogTmp.sprintf("[LIFTER OUT(03)] OUTPUT_CONFIRM OK! Return = (DEC)%d  (HEX)%02x  (CHAR)%c", iReturn, iReturn, iReturn);
				ADD_CID_LOG(strLogTmp);
				m_nElevetorOffStep++;
			}
			else
			{
				iRetryCnt = iRetryCnt + DELAY_SERIAL_WAIT_N_REQUEST_RETRY;
				strLogTmp.sprintf("[LIFTER OUT(03)] CONFIRM Wait. Retry. Result = (DEC)%d  (HEX)%02x  (CHAR)%c  ErrTime(ms) : %d",
															iReturn, iReturn, iReturn, iRetryCnt);
				ADD_CID_LOG(strLogTmp);
				m_nElevetorOffStep = VHL_ELEVETOR_OFF_CTRL_STEP_OUTPUT_REQUEST_INIT;
			}

			if(iRetryCnt > m_pParamSet->LightGuide_TIME_OUT_MS_VHLLifter)
			{
				ADD_CID_LOG("[LIFTER OUT(03)] SERIAL_INIT retry over");
				return ERR_LIFTER_OUTPUT_REQUEST_CONFIRM_TIME_OUT;
			}
		}
		break;

// -------------------

		case VHL_ELEVETOR_OFF_CTRL_STEP_OUTPUT_COMPLETE:
		{
//			ADD_CID_LOG("[LIFTER OUT (04) : OUT END]");

			VHL_OPC_RESET();
			Sleep(DELAY_SERIAL_RESET);
			VHL_OPC_RESET_RESPONSE();

			iReturn = CID_SELECT_ALL_OFF();		// CID의 Select를 모두 Off한다
			strLogTmp.sprintf("[LIFTER OUT (04)] SELECT all off return : %d", iReturn);
			ADD_CID_LOG(strLogTmp);
			Sleep(DELAY_CID_COMMAND);	// 장비사양상 최소 10ms딜레이 줘야 함

			ADD_CID_LOG("------------------------------------------------------------");



		  	*puStep = DRIVING_CTRL_STEP_GO_INIT;
			//CID 관련 초기화---------------------------------------------------------------------------/

			m_bsecond = false;
			m_CID_Pause = false;
			m_CIDComptFlag = false;  // cid 완료 처리 Flag
			m_CIDComptTryFlag = false;  // cid 완료 처리 시도 Flag
			m_CID_COMMON_bit_off_need = false;
			m_CIDMonitoringFlag = false;
			m_CIDLinkFlag = false;
			m_CIDStatusFlag = false;
			m_CIDStatusPauseFlag = false;
			m_CIDPauseTime = 0;
			m_CID_Status_Pause = false;
			m_Igro_CIDStatusPuaseFlag = false;
			m_bLinkFail = false;
			m_bLinkDisconnected = false;
			m_bInitialLink = false;
			m_CIDDirection = CID_DIRECTION_NOT_LINK;
			m_bCIDNotUse = false;
			m_CIDOperationStarted = false;  // 2016. 12. 23 추가
			m_job_change_flag_no_cid_area = false; //0: not change 1 : change
			m_job_change_flag_exception_CommonTag = false;
			m_CurrCIDStartnode = 0;
			m_sCIDStatus[0]=0;
			m_sCIDStatus[1]=0;
			m_sCIDStatus[2]=0;

			bCountOfCID_Delay    = 0;
			bCountOfCIDLink    = 0; 	   //링크 연결 관련
			m_job_change_without_link_complete = false;
			bCountOfCIDDualOccup	= 0;  //동시진입 관련
			bCountOfCIDComptACK    = 0;  //완료처리 응답 관련

			bDirCIDChage = false;		// 방향전환 전에 완료처리를 함을 나타내는 변수
			tmpStopID = 0;
			memset(&Info, 0, sizeof(CID_CTRL_INFO));
			memset(&CID_4WAY_CONTROL_INFO, 0, sizeof(CID_4WAY_INFO));

			m_CIDNameReadFlag = false;
			m_tmpCurrentResetNode = 0;
			m_tmpCurrentStopNode = 0;
			m_nCIDTerminateCount = 0;

			m_Diag_CID_index = 0;
			memset(&m_Diag_CID_R_ID[0][0],'0',sizeof(m_Diag_CID_R_ID));
			memset(&m_Diag_ResetNode[0],0,sizeof(m_Diag_ResetNode));
			memset(&m_Diag_StopNode[0],0,sizeof(m_Diag_StopNode));

			m_nCidControlStep = CID_STEP_CONNECTING;

//  			ADD_LOG("C-104");
			//---------------------------------------------------------------------------/
			return NO_ERR;
		}
		break;
	}

	return NO_ERR;
}



/**
@brief   주행 초기화 확인
@author  임태웅
@date    2013.7.31
@param puStep 주행의 Step 변수
@return 에러 없으면 0반환, 있으면 에러 코드 반환
*/
UINT DrivingControl::executeGoInit(DRIVING_HW_INFO_SET HwInfo, DRIVING_INFO_SET *pInfoSet, UINT *puStep)
{
    UINT nTmpError = NO_ERR;


    //2 처음 시작할 때 PreCheck가 Node 를 넘어가있는 경우:
    //2 PreCheck 가 감지 되지 않아 무언 정지가 생길 수 있다.  이 경우 PreCheckCount 를 강제로 1로 만들어 준다
    DRIVING_CMD_INFO_OF_PATH* pPathInfo = getPathInfo(pInfoSet->HwInfo.Node.nNodeCount);
    DRIVING_CMD_INFO_OF_PATH* pNextPathInfo = getPathInfo(pInfoSet->HwInfo.Node.nNodeCount+1);

	//이전 노드카운트 위치값 초기화
	m_dPreNodecount = 0;
	m_dPreNodecountPosition = 0.0;
	m_dPreNodecountSpeed =0.0;
	m_dPrePrecheckNodecountPosition = 0.0;
	m_nPrePreCount = 0;
	m_dCheckPrecheckNodecountPosition = 0.0;
	m_bFirstNodeStep = false;
	m_bIsFirstNodeCountAdd = false;
	m_bIsAMCVHLDetectIgnore = false;

	m_bIsRecovery = false;
	m_isE1069Case1 = false;

	m_dCheckAMCDecelPosition = 0.0;
	m_dPreTargetPosition = 0.0;

  	memset(&m_InfoSet.EventAndState.MarkState, 0x00, sizeof(DRIVING_MARK_STATE));  //E1069 관련 Markstate 초기화

	double  dSpeedOfNow = HwInfo.Axis1.dSpeed;

    if( (pInfoSet->HwInfo.Node.nPreCheckCount==0)
    &&  (pNextPathInfo!=NULL)
    &&  (pInfoSet->HwInfo.Axis1.dCurrPos<ACCEPTABLE_DRIVING_POSITION_ERROR)
    )
    {
        if((pPathInfo->dLength-pInfoSet->Position.Compensation.dPreArriveOffset)<
            (m_pParamSet->Mark[0].Dist.dDistFromFirstToSecond+m_pParamSet->Mark[0].Dist.dLengthOfSecond*2))
        {
            pInfoSet->Position.bPreCheckIsOverFirstNode = true;
        }
    }

    *puStep = DRIVING_CTRL_STEP_GO_PREPARE;

	ADD_LOG("D-138");

	ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,DRIVING,Start,%s,%06d,%06d,%06d,%d,%3.3lf",
					m_defualtparam->VHLName,m_mccparam.cCarrierType,
					m_mccparam.uSourceNode,
					m_mccparam.uTargetNode,
					m_pExecuteInfo->ExecutePositionInfo.CurrNode,
					m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
					dSpeedOfNow);

	m_mccparam.nHandInpositionOffCount = 0;
	m_mccparam.nHandAlarmOffCount = 0;
	m_mccparam.nHandRightGripOffCount = 0;
	m_mccparam.nHandLeftGripOffCount = 0;
	m_mccparam.nHandCloseOffCount = 0;
	m_mccparam.nHandOpenOffCount = 0;
	m_mccparam.nHandPIOOffCount = 0;

	m_mccparam.uFromStation = m_pOHTMainStatus->StatusCommon.CurStationID;

	// Manual_CID()
	/*
		Manual Mode에서 사이클 명령을 보내는 경우, CID출력이 이미 나가고 있는 상태이므로
		스테이트 머신을 정상적으로 수행하지 못하는 문제를 수정함
	*/
	static int iPreMode = EXECUTE_MODE_MANUAL;	// 초기값은 manual이니까

	if ((m_pExecuteInfo->ExecuteMode == EXECUTE_MODE_MANUAL) && (iPreMode == EXECUTE_MODE_AUTO))
	{
		iPreMode = EXECUTE_MODE_MANUAL;
		pHWSet->m_pCID->CID_Output_Clear(3);
		pHWSet->m_pCID->CID_Out_Common_Tag(8, true);	// abnormal bit = on
		ADD_LOG("C-105");
	}
	else if((m_pExecuteInfo->ExecuteMode == EXECUTE_MODE_AUTO) && (iPreMode == EXECUTE_MODE_MANUAL))
	{
		ADD_LOG("C-106");
		iPreMode = EXECUTE_MODE_AUTO;

#if 0
		// step1
		ADD_LOG("C-107");
		pHWSet->m_pCID->CID_Out_Occup_Req(false);
		pHWSet->m_pCID->CID_Out_Manual(false);

		// step2
		Sleep(10);
		pHWSet->m_pCID->CID_Out_PASS_Compt(true);
#endif

	}

	CheckReadyToRunTime_ExcuteGo = timeGetTime();

    return nTmpError;
}



/**
@brief   주행의 대기 상태로 전환 및 확인
@author  임태웅
@date    2013.7.31
@param puStep 주행의 Step 변수
@return 에러檍ㅖ{"{檍ㅖ鸚?oSet, UINT *puStㅔtInfo.dOffset);
*/
UINT DrivingControl::executeGoPrepare(DRIVING_HW_INFO_SET HwInfo, DRIVING_INFO_SET *pInfoSet, UINT *puStep)
{
    UINT nTmpError = NO_ERR;
	double  dRealDistSumToTarget    = getRealPos(m_ClassifiedCmd.TargetInfo.dDistSumToNode+m_ClassifiedCmd.TargetInfo.dOffset);
    DRIVING_CTRL_INFO_SET *pCtrlInfo = &(pInfoSet->Control);

 	// Control 정보
	USER_DETECT_INFO DetectInfo;
//	memset(&DetectInfo, 0, sizeof(CTRL_INFO_OF_FRONT_DETECT));

	//작업변경 확인  puting
	if(m_bOnBackMove == false)	nTmpError = checkJobChange(pInfoSet);

	if((getFrontObservation(0, &DetectInfo)==true) && (nTmpError ==NO_ERR))
	{

		if(checkReadyToRun(HwInfo, DetectInfo, &(pCtrlInfo->Axis), &(pCtrlInfo->Steer), &(pCtrlInfo->FrontObservation))==true)
		{

            ADD_LOG("D_207/%d/%d/%6.1lf/%6.1lf/%f/%6.11f"
            , pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.MarkType, MARK_TYPE_NODE
			, pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset, OFFSET_TO_CHECK_FIRST_NODE
			, dRealDistSumToTarget,m_ClassifiedCmd.TargetInfo.dOffset
			);


		//1  명령 작성 puting
//		if(memcmp(&DetectInfo, &(pCtrlInfo->FrontObservation.Info), sizeof(USER_DETECT_INFO))!=0)
//		if((DetectInfo.UseFollowControlFlag != pCtrlInfo->FrontObservation.Info.UseFollowControlFlag) ||
//		   (DetectInfo.Type != pCtrlInfo->FrontObservation.Info.Type) ||
//		   (DetectInfo.NodeCount != pCtrlInfo->FrontObservation.Info.NodeCount)||
//		   (DetectInfo.FollowCommandType != pCtrlInfo->FrontObservation.Info.FollowCommandType) ||
//		   (DetectInfo.PBSIgnoreFlag !=pCtrlInfo->FrontObservation.Info.PBSIgnoreFlag) ||
//		   (DetectInfo.DistSumOfStraightPath != pCtrlInfo->FrontObservation.Info.DistSumOfStraightPath))
//		{
//		}

			//사후  동작 작업

			if(dRealDistSumToTarget < 800) //거리값확인해볼것
			{
				  if(m_defualtparam->PreShutter)
				  {
						if(IsInnerFoup() == true)
						{
							m_bShutterCloseFlag = true;
							nTmpError = pHWSet->m_pShutter->Close_Classifying_Material();

							if(nTmpError != NO_ERR)
							{
								nTmpError = NO_ERR;
								m_bShutterCloseMovingFlag = true;
							}
						}
				  }
			}
			else
			{
				if(m_defualtparam->PreShutter)
				{
					ExeCmdShutterClose(HwInfo.Axis1.dSpeed);
				}
			}

			//초기 패턴 값 확인
			getFrontObservationNodeCount(0);

			 //현재 위치가 슬로프일경우 초기화 처리함.
			if(m_cSlopeNodeInfo == SLOPE_NTYPE) m_cSlopeNodeInfo = INIT_NTYPE;

			if(m_bOnBackMove == false)
			{
				if(dRealDistSumToTarget<DIST_TO_CHECK_MARK_NODE_MARGIN)
				{
					*puStep = DRIVING_CTRL_STEP_GO_MARK;
					ADD_LOG("D-139");
				}
				else if(    (pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.MarkType!=MARK_TYPE_NODE)
						&&  (pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset<OFFSET_TO_CHECK_FIRST_NODE)
				)
				{
					*puStep = DRIVING_CTRL_STEP_GO_FIRST_NODE;
					ADD_LOG("D-140");
				}
				else
				{
					*puStep = DRIVING_CTRL_STEP_GO_RUN;
					ADD_LOG("D-141");
				}
			}else
			{

			   *puStep = DRIVING_CTRL_STEP_GO_RUN;
				ADD_LOG("D-142");

			}

			Sleep(100);

		}
		else
		{
#if((OHT_NAME == OHT_NAME_STD_V82)|| (OHT_NAME == OHT_NAME_STD_V85S)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
#else
			//AOHC-288
			if(OHTUTILITY::PreventOverflowGetTimeMs(CheckReadyToRunTime_ExcuteGo) > DRIVING_SETTING_TIME)
			{
				if(m_defualtparam->bUseRSA==true)
				{
					if(m_pRSAControl->IsSetInnerLimitTorque_300() == false)
					{
						nTmpError=ERR_SERVO_DRIVING_ALARM;
						CheckReadyToRunTime_ExcuteGo = timeGetTime();
						ADD_LOG("D-143");
					}
				}
				else
				{
					if(m_pServoControl->IsSetInnerLimitTorque_800() ==false)
					{
						nTmpError=ERR_SERVO_DRIVING_ALARM;
						CheckReadyToRunTime_ExcuteGo = timeGetTime();
						ADD_LOG("D-143");
					}
				}
			}

#endif
		}

    }

    return nTmpError;
}


/**
@brief   주행 처리
@author  임태웅
@date    2013.7.31
@param puStep 주행의 Step 변수
@return 에러 없으면 0반환, 있으면 에러 코드 반환
*/
UINT DrivingControl::executeGoFirstNode(DRIVING_HW_INFO_SET HwInfo, DRIVING_INFO_SET *pInfoSet, UINT *puStep)
{
    UINT nTmpError = NO_ERR;

//  DRIVING_CTRL_INFO_SET *pCtrlInfo = &(pInfoSet->Control);

	//작업변경 확인  puting
	if(m_bOnBackMove == false)	nTmpError = checkJobChange(pInfoSet);

    pInfoSet->HwInfo = HwInfo;


	if(nTmpError==NO_ERR)   nTmpError = checkSteer(pInfoSet);
	if(nTmpError==NO_ERR)   nTmpError = checkFrontObservation(pInfoSet);
	if(nTmpError==NO_ERR)   nTmpError = checkServoTorqueFlag(pInfoSet);
	if(nTmpError==NO_ERR)   nTmpError = checkAxisFirstNode(pInfoSet);
#if(OHT_NAME != OHT_NAME_P4_MASK)
	if(nTmpError==NO_ERR)   nTmpError = checkCID(HwInfo, pInfoSet);
#endif
    if(nTmpError==NO_ERR)
	{
		if((pInfoSet->Position.bFirstNIDIsCorrect==true)
		&&  ((HwInfo.Axis1.dCurrPos>POSITION_TO_CHECK_FIRST_NODE) ||(HwInfo.IO.NodeOn == true))
		)
		{
			*puStep = DRIVING_CTRL_STEP_GO_RUN;

		 	Sleep(10); // 컨테스트 스위칭 처리 부분
            ADD_LOG("D_208/%5.1lf/%5.1lf"
                , pInfoSet->HwInfo.Axis1.dCurrPos
				, compensate(pInfoSet->HwInfo.Axis1.dCurrPos));
        }
    }

    return nTmpError;
}



/**
@brief   주행 처리
@author  임태웅
@date    2013.7.31
@param puStep 주행의 Step 변수
@return 에러 없으면 0반환, 있으면 에러 코드 반환
*/
UINT DrivingControl::executeGoRun(DRIVING_HW_INFO_SET HwInfo, DRIVING_INFO_SET *pInfoSet, UINT *puStep)
{
    UINT nTmpError = NO_ERR;

//  DRIVING_CTRL_INFO_SET *pCtrlInfo = &(pInfoSet->Control);
   	if(m_bOnBackMove == false)
	{
		if(nTmpError==NO_ERR)   nTmpError = checkPosition(HwInfo, pInfoSet);
		if(nTmpError==NO_ERR)   nTmpError = checkSteer(pInfoSet);
		if(nTmpError==NO_ERR)   nTmpError = checkFrontObservation(pInfoSet);
		if(nTmpError==NO_ERR)   nTmpError = checkServoTorqueFlag(pInfoSet);
		if(nTmpError==NO_ERR)   nTmpError = checkAxisRun(pInfoSet);
#if(OHT_NAME != OHT_NAME_P4_MASK)
		if(nTmpError==NO_ERR)   nTmpError = checkCID(HwInfo, pInfoSet);
#endif
#if (FOLLOW_CONTROL != 1)
		if(nTmpError==NO_ERR)   nTmpError = checkOBSAreaforNoFollowControl(pInfoSet);
#endif
	}else
	{
		// 후진 puting
		if(nTmpError==NO_ERR)   nTmpError = checkBackPosition(HwInfo, pInfoSet);
		if(nTmpError==NO_ERR)   nTmpError = checkBackSteer(pInfoSet);
		if(nTmpError==NO_ERR)   nTmpError = checkServoTorqueFlag(pInfoSet);
		if(nTmpError==NO_ERR)   nTmpError = checkAxisRun(pInfoSet);
    }

    if(nTmpError==NO_ERR)
    {
        if(pInfoSet->EventAndState.State.MarkArea==true)
		{
			if(m_bOnBackMove == false)
			{
				if(!((HwInfo.IO.ObsStatus==DETECT_AND_STOP) || (HwInfo.IO.DetectStatus==DETECT_AND_STOP)))
				{
					*puStep = DRIVING_CTRL_STEP_GO_MARK;

					ADD_LOG("D_209/%5.1lf/%5.1lf"
						, pInfoSet->HwInfo.Axis1.dCurrPos
						, compensate(pInfoSet->HwInfo.Axis1.dCurrPos));
				}
			}else
			{
					*puStep = DRIVING_CTRL_STEP_GO_MARK;

					ADD_LOG("D_210/%5.1lf/%5.1lf"
						, pInfoSet->HwInfo.Axis1.dCurrPos
						, compensate(pInfoSet->HwInfo.Axis1.dCurrPos));
            }
        }

//		if(m_pExecuteInfo->ExecuteMode == EXECUTE_MODE_AUTO)
//		{
//			if(pInfoSet->EventAndState.State.DualStageStbArea==true)
//			{
//				if(pHWSet->m_pLeftEQPIO->GetRFPIOConnectStep()!=8)
//				{
//					nTmpError = ExeCmdEQPIOOpen(OHTMainForm->Get_EQPIO_Type(), m_pExecuteInfo->FlagPreTrans.nPIOID, m_pExecuteInfo->FlagPreTrans.nPIOChannel, m_pExecuteInfo->FlagPreTrans.nPIOCS);
//				}
//				else
//				{
//					if(IsInnerFoup()) // load
//					{
//						nTmpError = ExeCmdEQPIOForDualStageStbLoad();
//					}
//					else // unload
//					{
//						nTmpError = ExeCmdEQPIOForDualStageStbUnload();
//					}
//				}
//			}
//		}
    }

    return nTmpError;
}

/**
@brief   마크 처리 및 확인
@author  임태웅
@date    2013.7.31
@param puStep 주행의 Step 변수
@return 에러 없으면 0반환, 있으면 에러 코드 반환
*/
UINT DrivingControl::executeGoMark(DRIVING_HW_INFO_SET HwInfo, DRIVING_INFO_SET* pInfoSet, UINT *puStep)
{
	UINT nTmpError = NO_ERR;

	DRIVING_CMD_INFO_OF_NODE* pNodeInfo = getNodeInfo(HwInfo.Node.nNodeCount);
	double  dSpeedOfNow = HwInfo.Axis1.dSpeed;

	 if(m_bOnBackMove == false)
	{
		if(nTmpError==NO_ERR)   nTmpError = checkPosition(HwInfo, pInfoSet);
		if(nTmpError==NO_ERR)   nTmpError = checkSteer(pInfoSet);
		if(nTmpError==NO_ERR)   nTmpError = checkFrontObservation(pInfoSet);
		if(nTmpError==NO_ERR)   nTmpError = checkServoTorqueFlag(pInfoSet);
#if(OHT_NAME != OHT_NAME_P4_MASK)
		if(nTmpError==NO_ERR)   nTmpError = checkCID(HwInfo, pInfoSet);
#endif
		if(nTmpError==NO_ERR)   nTmpError = checkAxisMark(pInfoSet);
#if (FOLLOW_CONTROL != 1)
		if(nTmpError==NO_ERR)   nTmpError = checkOBSAreaforNoFollowControl(pInfoSet);
#endif
	}else
	{
		// 후진 puting
		if(nTmpError==NO_ERR)   nTmpError = checkBackPosition(HwInfo, pInfoSet);
		if(nTmpError==NO_ERR)   nTmpError = checkBackSteer(pInfoSet);
		if(nTmpError==NO_ERR)   nTmpError = checkServoTorqueFlag(pInfoSet);
		if(nTmpError==NO_ERR)   nTmpError = checkAxisMark(pInfoSet);
    }

    if(nTmpError==NO_ERR)
    {
		if(pInfoSet->EventAndState.MarkState.Arrived==true)
		{

			*puStep = DRIVING_CTRL_STEP_GO_CHECK_STOP;
			 CheckComplete_ExcuteGo=timeGetTime();
 			dwRearSensorChatteringDelayV82 = timeGetTime();

			ADD_LOG("[STEP] DRIVING_CTRL_STEP_GO_CHECK_STOP");
			//AOHC-357
		  // if( ( pInfoSet->Position.CurrentAndTarget.TargetPosition.MarkType!= MARK_TYPE_NODE ) && (pInfoSet->Position.CurrentAndTarget.TargetPosition.dOffset < 25) )
		   if( pInfoSet->Position.CurrentAndTarget.TargetPosition.MarkType!= MARK_TYPE_NODE )
		   {
				  m_bMarkOffsetCheck = true;    //offset 25mm 체크해서 이적재 마크하지 못하고 주행에서 작업변경 받음 Nack 위한 flag
		   }
			ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,DRIVING,End,%s,%06d,%06d,%06d,%d,%3.3lf,DistSum,%6.1lf,FOUP Cover Detect,%d,Inner FOUP Detect,%d,Inner FOUP Not Detect,%d,Shift Home Sensor Off,%d,Hoist Home Sensor Off,%d,Shutter Front Open Sensor Count,%d,Shutter Front Close Sensor Count,%d,Shutter Rear Open Sensor Count,%d,Shutter Rear Close Sensor Count,%d,Hand Abnormal Status,%d/%d/%d/%d/%d/%d/%d,SOSLAB Serial Fail Count,%d",
				m_defualtparam->VHLName,m_mccparam.cCarrierType,
						m_mccparam.uSourceNode,
						m_mccparam.uTargetNode,
						m_pExecuteInfo->ExecutePositionInfo.CurrNode,
						m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
				dSpeedOfNow,
				pNodeInfo->dDistSum,
						m_mccparam.nFoupCoverDetectCount,
						m_mccparam.nInnerFOUPDetectCount,
						m_mccparam.nInnerFOUPNotDetectCount,
						m_mccparam.nShiftHomeSenOffCount,
						m_mccparam.nHoistHomeSenOffCount,
						m_mccparam.nShutterFrontOpenCount,
						m_mccparam.nShutterFrontCloseCount,
						m_mccparam.nShutterRearOpenCount,
						m_mccparam.nShutterRearCloseCount,
						m_mccparam.nHandInpositionOffCount,
						m_mccparam.nHandAlarmOffCount,
						m_mccparam.nHandRightGripOffCount,
						m_mccparam.nHandLeftGripOffCount,
						m_mccparam.nHandCloseOffCount,
						m_mccparam.nHandOpenOffCount,
						m_mccparam.nHandPIOOffCount,
						pHWSet->m_pOHTDetect->GetRetryCountInfo());
			SEND_WARN("MCC/14/1/10/%06d/%06d/%d/%d/%06d/%d/%d/%d/%d/%d/%d/%d/%d/%d",
						m_pOHTMainStatus->StatusCommon.CurNodeID,
						m_pExecuteInfo->ExecutePositionInfo.NextNode,
						m_pOHTMainStatus->StatusCommon.CurNodeOffset,
						m_pOHTMainStatus->StatusCommon.ExistFoup,
						m_pOHTMainStatus->StatusCommon.StopStationID,
						m_mccparam.nFoupCoverDetectCount,
						m_mccparam.nInnerFOUPDetectCount,
						m_mccparam.nInnerFOUPNotDetectCount,
						m_mccparam.nShiftHomeSenOffCount,
						m_mccparam.nHoistHomeSenOffCount,
						m_mccparam.nShutterFrontOpenCount,
						m_mccparam.nShutterFrontCloseCount,
						m_mccparam.nShutterRearOpenCount,
						m_mccparam.nShutterRearCloseCount);
			m_mccparam.nFoupCoverDetectCount = 0;
			m_mccparam.nInnerFOUPDetectCount = 0;
			m_mccparam.nInnerFOUPNotDetectCount = 0;
			m_mccparam.nShiftHomeSenOffCount = 0;
			m_mccparam.nHoistHomeSenOffCount = 0;
			pHWSet->m_pOHTDetect->SetRetryCountInfo(false); // count Reset
		}
	}

	return nTmpError;
}

/**
@brief   주행의 완료 확인
@author  임태웅
@date    2013.7.31
@param puStep 주행의 Step 변수
@return 에러 없으면 0반환, 있으면 에러 코드 반환
*/
UINT DrivingControl::executeGoCheckStop(DRIVING_HW_INFO_SET HwInfo, DRIVING_INFO_SET *pInfoSet, UINT *puStep)
{
    UINT nTmpError = NO_ERR;
	DRIVING_CTRL_INFO_SET *pCtrlInfo = NULL;

   DWORD       dwCurrTime  = timeGetTime();
   static  DWORD   dwCIDTrigerTime  = timeGetTime();

	int TempNodeCount = 0;
   	PATH_DIVERGENCE_INFO NodeDivInfo = NULL;
	PATH_DIVERGENCE_INFO NextDivInfo = NULL;

	if(m_bOnBackMove == false)
	{
		if(nTmpError==NO_ERR)   nTmpError = checkPosition(HwInfo, pInfoSet);
		if(nTmpError==NO_ERR)   nTmpError = checkSteer(pInfoSet);
		if(nTmpError==NO_ERR)   nTmpError = checkFrontObservation(pInfoSet);
		if(nTmpError==NO_ERR)   nTmpError = checkServoTorqueFlag(pInfoSet);
#if(OHT_NAME != OHT_NAME_P4_MASK)
		if(nTmpError==NO_ERR)   nTmpError = checkCID(HwInfo, pInfoSet);
#endif
	}
	else
	{
		// 후진 puting
		if(nTmpError==NO_ERR)   nTmpError = checkBackPosition(HwInfo, pInfoSet);
		if(nTmpError==NO_ERR)   nTmpError = checkBackSteer(pInfoSet);
		if(nTmpError==NO_ERR)   nTmpError = checkServoTorqueFlag(pInfoSet);
	}
    if(nTmpError==NO_ERR)
    {
        pCtrlInfo = &(pInfoSet->Control);
		if(checkCompletion(pInfoSet->HwInfo, &(pCtrlInfo->Axis), &(pCtrlInfo->Steer), &(pCtrlInfo->FrontObservation))==true)
		{
			// m_CID_COMMON_bit_off_need : 공용 노드 완료 처리를 마무리 하기 위한 시간 지연 목적 : 2000ms
			// executeGoCheckStop step에서 m_CIDComptTryFlag == false여야 하나 잘못 된 경우 처리

			if ((m_CIDComptTryFlag == true) || (m_CID_COMMON_bit_off_need == true))
			{
				// 작업 변경 후 m_CIDComptTryFlag == true 되어 진입
				// 2초 기다리는 동안 executeGoCheckStop 처리 안됨
				// 강제로 disconnetcion 시키면서 CID로직 이상현상 발생
				ADD_LOG("C_128/%d/%d", m_CIDComptTryFlag, m_CID_COMMON_bit_off_need);
				if(OHTUTILITY::PreventOverflowGetTimeMs(dwCIDTrigerTime) > 2000)
				{
					ADD_LOG("C_129/%d/%d", m_CIDComptTryFlag, m_CID_COMMON_bit_off_need);
					if(m_CID_COMMON_bit_off_need == true)
					{
						pHWSet->m_pCID->CID_Out_Common_Tag(12,ON);
					}
					pHWSet->m_pCID->CID_Out_PASS_Compt(ON);
					Sleep(20);
					pHWSet->m_pCID->CID_Output_Clear(5);

					m_nCidControlStep = CID_STEP_CONNECTING;
					m_CIDComptTryFlag= false;
					m_CID_COMMON_bit_off_need = false;

					//m_nCidControlStep = CID_STEP_COMPLETION; 로 변경하여 CID_STEP_COMPLETION에서 처리 하도록 수정 필요
                }

				return nTmpError;
			}
			//작업변경에 의해 overrun 무시처리가 안될 경우, 정차 이후 반납 처리. //방어코드
			ADD_LOG("C_130/%d/%d/%d/%d", Info.Safety_Level, Info.tmpCurrentStationID, Info.CMD_StationID, pHWSet->m_pCID->IsOccupying());
			if(((Info.Safety_Level == 0x01)|| (Info.bIgnolOverRun == true)) && Info.tmpCurrentStationID == Info.CMD_StationID && pHWSet->m_pCID->IsOccupying() == true)
			{
				pHWSet->m_pCID->CID_Occup_return(44);
				m_nCidControlStep = CID_STEP_CHECKING_PATH;

				ADD_LOG("C-108");
				if(Info.bIgnolOverRun == true)
				{
					ERR_LOG("[Check]CID_IgnolOverRun");
				}
			}

			//방어코드
			if(((Info.Safety_Level == 0x01)|| (Info.bIgnolOverRun == true)) && (Info.tmpCurrentStationID == Info.CMD_StationID) && ((pHWSet->m_pCID->IsInterlock_ON() == true)|| (m_pExecuteInfo->FlagCIDReport.bCIDInterlock==true)) )
			{
				m_pExecuteInfo->FlagCIDReport.bCIDInterlock= false;

				ERR_LOG("[Check]CID_CIDInterlock");

          	}

		 if(m_ClassifiedCmd.TargetInfo.Type != MARK_TYPE_NODE)
		 {
		   try{
			//분기 방향 정보
				if(getDivergenceInfo(m_ClassifiedCmd.TargetInfo.nCount-1, &NodeDivInfo, &NextDivInfo,&TempNodeCount)==true)
				{
					m_pExecuteInfo->nCheckDivInfo  =   NodeDivInfo;  //분기 정보 갱신
				}

				ADD_LOG("D_211/%d/%d", m_ClassifiedCmd.TargetInfo.nCount, NodeDivInfo);
			}catch(...)
			{
				ADD_LOG("D-145");

			}
		 }

			*puStep = DRIVING_CTRL_STEP_GO_COMPLETE;

			EnterCriticalSection(&OHTMainForm->m_CS);
			m_pExecuteInfo->AccumulationData.dDrivingEncoder += pInfoSet->Position.CmdRefInfo.dDist;
			LeaveCriticalSection(&OHTMainForm->m_CS);
			ADD_LOG("D-146");


		}
		else
		{
		   dwCIDTrigerTime  = timeGetTime();


		   //Station Mark의 경우 CheckCompletion 500ms 대기하는 Case있음 //AOHC-288
		   if(OHTUTILITY::PreventOverflowGetTimeMs(CheckComplete_ExcuteGo) > DRIVING_SETTING_TIME)
		   {

				nTmpError = ERR_SERVO_DRIVING_ALARM;
				CheckComplete_ExcuteGo=  timeGetTime();
				ADD_LOG("D-147");
		   }
		}
	}

    return nTmpError;
}

/**
@brief   주행의 완료 확인
@author  임태웅
@date    2013.7.31
@param puStep 주행의 Step 변수
@return 에러 없으면 0반환, 있으면 에러 코드 반환
*/
UINT DrivingControl::executeGoComplete(DRIVING_HW_INFO_SET HwInfo, DRIVING_INFO_SET *pInfoSet,UINT *puStep)
{
	UINT nTmpError = NO_ERR;
//  DRIVING_CTRL_INFO_SET *pCtrlInfo = &(pInfoSet->Control);

    if(nTmpError==NO_ERR)
	{
		//진단모니터링 항목(엔코더값 차이 확인)
		double dFrontPos = pInfoSet->HwInfo.Axis1.dCurrPos;
		double dRearPos = pInfoSet->HwInfo.Axis2.dCurrPos;

		//차이값 계산
		int nEncoderDiff = (int)((fabs(dFrontPos - dRearPos) / dFrontPos) * 100);
	 //	ADD_LOG("D_212/%d", (DWORD)nEncoderDiff);
		m_DiagManager->IncreasePreviosDiagMax(PREVIOS_DIAG_MO_FRGAP, nEncoderDiff);

		//차이값이 일정 범위를 초과하면 Count up
		if(nEncoderDiff > m_DiagManager->GetDiagParam().nRefAbnormDifferenceEncoderLimit)
		{
			//Count가 일정 횟수 이상되면 Abnormal으로 판단
			if(m_DiagManager->GetAbnormalDrvDiffCount() > m_DiagManager->GetDiagParam().nRefAbnormDifferenceEncoderCount)
			{
				if(OHTUTILITY::PreventOverflowGetTimeMs(m_DiagManager->GetDiagEventFlag().dwReferenceAbnormalDifferenceEncoderCount) > 24*60*60*1000)
				{
					m_DiagManager->InsertAbnormalDiagData(DIAG_ABNORMAL_DATA_ID_DIFFERENCE_ENCODER);
					m_DiagManager->GetDiagEventFlag().dwReferenceAbnormalDifferenceEncoderCount = timeGetTime();
					m_DiagManager->ResetAbnormalDrvDiffCount();
				}

			}
			else
             	m_DiagManager->IncreaseAbnormalDrvDiffCount();
        }


		if(m_bOnMapMake==true)
		{
			m_bOnMapMake=false;
			memset(&m_bMapMakeType, 0x00, sizeof(MAP_MAKER_TYPE));
			ADD_LOG("D_213/%d", m_bOnMapMake);
		}

		if(m_bOnBackMove ==true)
		{
			m_bOnBackMove = false;
			ADD_LOG("D-148");
        }
		m_Dectect_Dir = PATH_DIRECTION_NO_USE;
		m_Dectect_OBS_Dir = PATH_DIRECTION_NO_USE;
		*puStep = DRIVING_CTRL_STEP_NONE;

		ADD_LOG("D_214/%f",dFrontPos);
	}

    return nTmpError;
}

/**
@brief   InfoLists 의 상태를 확인하고 모든 정보를 삭제
@author  ehoto
@date    2013.7.19
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
bool DrivingControl::clearCmdInfoLists()
{
    const int nCount = 6;
    bool abSuccess[nCount] ={false,};
    bool bSuccess = true;

    abSuccess[0] = clearList(&(m_ClassifiedCmd.NodeList));
    abSuccess[1] = clearList(&(m_ClassifiedCmd.SteerList));
	abSuccess[2] = clearList(&(m_ClassifiedCmd.DirectionList));
    abSuccess[3] = clearList(&(m_ClassifiedCmd.SpeedlList));
	abSuccess[4] = clearList(&(m_ClassifiedCmd.PathList));
	abSuccess[5] = clearList(&(m_ClassifiedCmd.DivList));

	memset(&m_ClassifiedCmd.TargetInfo, 0, sizeof(m_ClassifiedCmd.TargetInfo));

    for(int n=0; n<nCount; n++)
    {
		bSuccess = bSuccess & abSuccess[n];
	}

    return bSuccess;
}

/**
@brief   InfoLists 의 상태를 확인하고 nNodeCount 이전의 정보를 삭제
@author  임태웅
@date    2013.7.19
@param nNodeCount 노드 카운트
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
bool  DrivingControl::clearCmdInfoListsLessThan(int nNodeCount)
{
	const int nCount = 6;
	bool abSuccess[nCount] ={false,};
	bool bSuccess = true;

	abSuccess[0] = clearListLessThan(&(m_ClassifiedCmd.NodeList), nNodeCount);
	abSuccess[1] = clearListLessThan(&(m_ClassifiedCmd.SteerList), nNodeCount);
	abSuccess[2] = clearListLessThan(&(m_ClassifiedCmd.DirectionList), nNodeCount);
	abSuccess[3] = clearListLessThan(&(m_ClassifiedCmd.SpeedlList), nNodeCount);
	abSuccess[4] = clearListLessThan(&(m_ClassifiedCmd.PathList), nNodeCount);
	abSuccess[5] = clearListLessThan(&(m_ClassifiedCmd.DivList), nNodeCount);

    for(int n=0; n<nCount; n++)
    {
        bSuccess = bSuccess & abSuccess[n];
	}

    return bSuccess;
}

/**
@brief   InfoLists 의 상태를 확인하고 nNodeCount 이전의 정보를 삭제
@author  임태웅
@date    2013.7.19
@param nNodeCount 노드 카운트
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
bool  DrivingControl::clearCmdInfoListsLessAfter(CLASSIFIED_DRIVING_CHANGE TempDrivnigInfo)
{
    const int nCount = 6;
    bool abSuccess[nCount] ={false,};
    bool bSuccess = true;
//    TempDrivnigInfo.nCheckNodeCount
	abSuccess[0] = CancelList(&(m_ClassifiedCmd.NodeList), TempDrivnigInfo);
	abSuccess[1] = CancelList(&(m_ClassifiedCmd.SteerList), TempDrivnigInfo);
	abSuccess[2] = CancelList(&(m_ClassifiedCmd.DirectionList), TempDrivnigInfo);
	abSuccess[3] = CancelList(&(m_ClassifiedCmd.SpeedlList), TempDrivnigInfo);
	abSuccess[4] = CancelList(&(m_ClassifiedCmd.PathList), TempDrivnigInfo);
	abSuccess[5] = CancelList(&(m_ClassifiedCmd.DivList), TempDrivnigInfo);

    for(int n=0; n<nCount; n++)
    {
		bSuccess = bSuccess & abSuccess[n];
	}

	if(bSuccess == true)
	{
		m_ClassifiedCmd.TargetInfo = TempDrivnigInfo.TargetInfo;
    	//최종 타겟 변경
	}

    return bSuccess;
}
/**
@brief   m_InfoSet.Control의 명령 Flag를 초기화 함
@author  임태웅
@date    2013.08.10
@param nNodeCount 노드 카운트
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
bool DrivingControl::clearDrivingCtrlInfoSet()
{
    m_InfoSet.Control.Steer.FrontCmdOn = false;
    m_InfoSet.Control.Steer.RearCmdOn= false;
    m_InfoSet.Control.Axis.byType = AXIS_CTRL_CMD_NONE;
    m_InfoSet.Control.FrontObservation.bCmdOn = false;
    for(int n=0; n<14; n++)
    {
		m_InfoSet.Control.IdReader[n] = CTRL_INFO_OF_ID_READER_CMD_NONE;
    }

//	ADD_LOG("D-149");

    return true;
}

/**
@brief   DrivingControl HW정보 획득 함수
@author  임태웅
@date    2013.07.01
*/
DRIVING_HW_INFO_SET DrivingControl::getHWInfo()
{
    DRIVING_HW_INFO_SET TmpHwInfo;
    memset(&TmpHwInfo, 0, sizeof(DRIVING_HW_INFO_SET));

    //2 I/O 정보
    TmpHwInfo.IO.BrakeRelease       = m_pDrivingAxis->IsBrakeReleased();
    TmpHwInfo.IO.Axis1AmpOn         = m_pDrivingAxis->IsAMPEnable();
    TmpHwInfo.IO.Axis1Running       = m_pDrivingAxis->IsRunning();
    TmpHwInfo.IO.Axis1InPosition    = m_pDrivingAxis->IsInPosition();
    TmpHwInfo.IO.Axis1AxisDone      = m_pDrivingAxis->IsAxisDone();
    if(m_pDrivingAxis->IsSyncControl()==true)
    {
        TmpHwInfo.IO.Axis2AmpOn         = m_pDrivingAxis->m_pSlaveAxis->IsAMPEnable();
        TmpHwInfo.IO.Axis2Running       = m_pDrivingAxis->m_pSlaveAxis->IsRunning();
        TmpHwInfo.IO.Axis2InPosition    = m_pDrivingAxis->m_pSlaveAxis->IsInPosition();
        TmpHwInfo.IO.Axis2AxisDone      = m_pDrivingAxis->m_pSlaveAxis->IsAxisDone();
    }

    TmpHwInfo.IO.NodePreCheckOn     = m_pDrivingTag->IsPreCheckOn();
    TmpHwInfo.IO.NodeOn             = m_pDrivingTag->IsOn();
    TmpHwInfo.IO.TagStationFrontOn  = m_pTransStopTag->IsOnFrontSensor();
    TmpHwInfo.IO.TagStationRearOn   = m_pTransStopTag->IsOnRearSensor();
    TmpHwInfo.IO.ObsStatus          = m_pObstacle->GetStatus();
	TmpHwInfo.IO.DetectStatus       = m_pOHTDetect->GetStatus();

    TmpHwInfo.IO.SteerFrontLeftInOn     = m_pSteer->IsFrontLeftOn();
    TmpHwInfo.IO.SteerFrontRightInOn    = m_pSteer->IsFrontRightOn();
    TmpHwInfo.IO.SteerRearLeftInOn      = m_pSteer->IsRearLeftOn();
    TmpHwInfo.IO.SteerRearRightInOn     = m_pSteer->IsRearRightOn();
    TmpHwInfo.IO.SteerFrontTorque       = m_pSteer->GetFrontTorque();
    TmpHwInfo.IO.SteerFrontDirCmd       = (m_pSteer->GetFrontCmd()==HW_STEER_DIRECTION_LEFT)?0:1;   //< 조향 명령 ( 0:왼쪽 / 1:오른쪽 )
    TmpHwInfo.IO.SteerRearTorque        = m_pSteer->GetRearTorque();
    TmpHwInfo.IO.SteerRearDirCmd        = (m_pSteer->GetRearCmd()==HW_STEER_DIRECTION_LEFT)?0:1;


    //2  Axis 1 정보
    TmpHwInfo.Axis1.dCurrPos            = m_pDrivingAxis->GetCurrentPosition();
	TmpHwInfo.Axis1.dFinalPos           = m_pDrivingAxis->GetFinalPosition();
    TmpHwInfo.Axis1.dSpeed              = m_pDrivingAxis->GetCurrentVelocity();
    TmpHwInfo.Axis1.dFollowError        = m_pDrivingAxis->GetFollowingError();
    TmpHwInfo.Axis1.dSmallAddCheckPos   = m_pDrivingAxis->GetSmallAddCheckPosition();
    TmpHwInfo.Axis1.nError              = m_pDrivingAxis->GetError();

	//2  Axis 2 정보
    if(m_pDrivingAxis->IsSyncControl()==true)
    {
        TmpHwInfo.Axis2.dCurrPos            = m_pDrivingAxis->m_pSlaveAxis->GetCurrentPosition();
        TmpHwInfo.Axis2.dFinalPos           = m_pDrivingAxis->m_pSlaveAxis->GetFinalPosition();
        TmpHwInfo.Axis2.dSpeed              = m_pDrivingAxis->m_pSlaveAxis->GetCurrentVelocity();
		TmpHwInfo.Axis2.dFollowError        = m_pDrivingAxis->m_pSlaveAxis->GetFollowingError();
        TmpHwInfo.Axis2.dSmallAddCheckPos   = m_pDrivingAxis->m_pSlaveAxis->GetSmallAddCheckPosition();
        TmpHwInfo.Axis2.nError              = m_pDrivingAxis->m_pSlaveAxis->GetError();
    }

    //2 Node 정보
    USER_NODE_CHECK_DATA UserNodeCheckData;
    m_pDrivingAxis->GetNodeCountInfo(UserNodeCheckData);

	int nID = 0;

	if(m_pDrivingBCR->GetID(&nID) != NO_ERR)
	{
		nID = 0;
	}

    TmpHwInfo.Node.nNodeCount           = UserNodeCheckData.NodeCount;
    TmpHwInfo.Node.dNodePosition        = UserNodeCheckData.PositionOfDrivingTag;
    TmpHwInfo.Node.nPreCheckCount       = UserNodeCheckData.NodeCountOfPreCheck;
    TmpHwInfo.Node.dPreCheckPosition    = UserNodeCheckData.PositionOfDrivingTagPreCheck;
    TmpHwInfo.Node.nBcrId               = nID;

    //2 Tag Station 정보
	//AOHC-249 BCR Read Sequence 개선
	if(m_pTransBCR->GetID(&nID, &b_ReadBcr)!=NO_ERR)
	{
		nID = 0;
	}
    TmpHwInfo.TagStaion.dFrontPosition  = UserNodeCheckData.PositionOfTransTagFirst;
    TmpHwInfo.TagStaion.dRearPosition   = UserNodeCheckData.PositionOfTransTagFinal;
    TmpHwInfo.TagStaion.nBcrId          = nID;
//  if(nID!=0)
//  {
//      ADD_LOG("D_215/%X",nID);
//  }

    //2 QR Station 정보 (Left)
    double dOffset = 0.0;
    if(m_pLeftQRR->GetIDnOffset(&nID, &dOffset)!=NO_ERR)
    {
        nID = 0;
        dOffset = 0.0;
    }
    TmpHwInfo.QrStaionLeft.nQrId        = nID;
    TmpHwInfo.QrStaionLeft.dQrOffset    = dOffset;

    //2 QR Station 정보 (Right)
    dOffset = 0.0;
    if(m_pRightQRR->GetIDnOffset(&nID, &dOffset)!=NO_ERR)
    {
        nID = 0;
        dOffset = 0.0;
    }
    TmpHwInfo.QrStaionRight.nQrId       = nID;
    TmpHwInfo.QrStaionRight.dQrOffset   = dOffset;

    return TmpHwInfo;

}


/**
@brief   DrivingControl Axis Control 함수
@author  임태웅
@date    2013.07.01
*/
int DrivingControl::controlAll(DRIVING_CTRL_INFO_SET CtrlInfo)
{
    int nTmpError = NO_ERR;
	static MARK_TYPE MarkType[14] =
    {
		MARK_TYPE_NODE,
		MARK_TYPE_TAG_STATION,
		MARK_TYPE_QR_STATION_LEFT,
		MARK_TYPE_QR_STATION_RIGHT,
		MARK_TYPE_OFFSET,
		MARK_TYPE_QR_LEFT_TOP,
		MARK_TYPE_QR_LEFT_BOTTOM,
		MARK_TYPE_QR_RIGHT_TOP,
		MARK_TYPE_QR_RIGHT_BOTTOM,
		MARK_TYPE_QR_LEFT_BOTTOM_S,
		MARK_TYPE_QR_RIGHT_BOTTOM_S,
		MARK_TYPE_QR_PSTB_LEFT,
		MARK_TYPE_QR_PSTB_RIGHT,
		MARK_TYPE_TAG_STATION_BACK
	};

    //1 동작
    if(nTmpError==NO_ERR)   nTmpError = controlFrontObservation(CtrlInfo.FrontObservation);
	if(nTmpError==NO_ERR)   nTmpError = controlSteer(CtrlInfo.Steer);
    if(nTmpError==NO_ERR)   nTmpError = controlAxis(CtrlInfo.Axis);
	for(int n=0; n<14; n++)
    {
		if( (nTmpError==NO_ERR)
		 && (CtrlInfo.IdReader[n]!=CTRL_INFO_OF_ID_READER_CMD_NONE) )
        {
			nTmpError = controlIdReader(MarkType[n], CtrlInfo.IdReader[n]);
        }
    }
    return nTmpError;
}

/**
@brief   DrivingControl Axis Control 함수
@author  임태웅
@date    2013.07.01
*/
int DrivingControl::controlAxis(CTRL_INFO_OF_SYNC_AXIS_MOVE AxisInfo)
{
    int nTmpError = NO_ERR;
	double dAccel = 0.0, dDecel = 0.0, dSpeed = 0.0, dDist = 0.0;
	USER_MOVE_DS_ADDITIONAL_INFO AdditionalInfo;
	bool bAmpOn = false;
#if((OHT_NAME == OHT_NAME_STD_V82)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
	static int ResetWaitCount = 999999;
#endif
    dAccel  = AxisInfo.Dynamic.dAccel;
    dDecel  = AxisInfo.Dynamic.dDecel;
    dSpeed  = AxisInfo.Dynamic.dSpeed;
    dDist   = AxisInfo.Dynamic.dDist;
    AdditionalInfo  = AxisInfo.Dynamic.AdditionalInfo;

    switch(AxisInfo.byType)
    {
    case AXIS_CTRL_CMD_NONE:
        break;
	case AXIS_CTRL_CMD_STATIC:
        if(AxisInfo.Static.NodeCountReset==true)
        {
		  //  ADD_LOG("D-150");
            m_pDrivingAxis->ClearNodeCountInfo();
        }

        if(AxisInfo.Static.Axis1ResetCmdOn==true)
        {
            ADD_LOG("D-151");
            nTmpError = m_pDrivingAxis->Reset();
		}
#if((OHT_NAME == OHT_NAME_STD_V82)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
		if(AxisInfo.Static.Axis1SetHomeCmdOn==true && nTmpError==NO_ERR)
		{
		  //	ADD_LOG("controlAxis: Axis1 Home");
			if(ResetWaitCount > 100){   //CIS
				nTmpError = m_pDrivingAxis->SetHome();
				ResetWaitCount = 0;
			}
			else{
				 ResetWaitCount++;    //CIS
			}
		}
		else{
			ResetWaitCount = 101;   //CIS
		}
#else
        if(AxisInfo.Static.Axis1SetHomeCmdOn==true && nTmpError==NO_ERR)
        {
		  //	ADD_LOG("controlAxis: Axis1 Home");
			nTmpError = m_pDrivingAxis->SetHome();
        }
#endif
        if(AxisInfo.Static.Axis1AmpCmdOn==true && nTmpError==NO_ERR)
        {
            bAmpOn = AxisInfo.Static.Axis1AmpOn;
			//ADD_LOG("D_216/%d", bAmpOn);
            nTmpError = m_pDrivingAxis->SetAMPEnable(bAmpOn);
        }

        if(AxisInfo.Static.Axis2ResetCmdOn==true && nTmpError==NO_ERR)
        {
            ADD_LOG("D-153");
			nTmpError = m_pDrivingAxis->m_pSlaveAxis->Reset();
        }
		if(AxisInfo.Static.Axis2SetHomeCmdOn==true && nTmpError==NO_ERR)
        {
		  //  ADD_LOG("D-154");
#if((OHT_NAME == OHT_NAME_STD_V82)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
#else
			nTmpError = m_pDrivingAxis->m_pSlaveAxis->SetHome();
#endif
		}
		if(AxisInfo.Static.Axis2AmpCmdOn==true && nTmpError==NO_ERR)
        {
            bAmpOn = AxisInfo.Static.Axis2AmpOn;
			//ADD_LOG("D_217/%d", bAmpOn);
            nTmpError = m_pDrivingAxis->m_pSlaveAxis->SetAMPEnable(bAmpOn);
        }
        break;
	case AXIS_CTRL_CMD_MOVE_DS:
		if(m_pDrivingAxis->IsSlaveAMPEnable()  ==false)                  //673관련 코드 추가
			nTmpError = m_pDrivingAxis->SetSlaveAMPEnable(true);         //673관련 코드 추가
        if(nTmpError==NO_ERR)                                            //673관련 코드 추가
		nTmpError = m_pDrivingAxis->MoveDistance(dAccel, dDecel, dSpeed, dDist, AdditionalInfo);
//		ADD_LOG("D_218/%f", dDist);
        break;
    case AXIS_CTRL_CMD_MOVE_S:
		nTmpError = m_pDrivingAxis->MoveStop(dDecel);
		ADD_LOG("D_219/%f", dDecel);
        break;
    case AXIS_CTRL_CMD_MOVE_P:
        nTmpError = m_pDrivingAxis->MovePositive(dAccel, dSpeed);
        break;
    case AXIS_CTRL_CMD_MOVE_N:
        nTmpError = m_pDrivingAxis->MoveNegative(dAccel, dSpeed);
        break;
    }

    return nTmpError;
}

/**
@brief   DrivingControl 조향 Control 함수
@author  임태웅
@date    2013.07.01
*/
int DrivingControl::controlSteer(CTRL_INFO_OF_STEER SteerInfo)
{
	int nTmpError = NO_ERR;
	bool bCheckMoveSteer[2] = {0,};

	HW_STEER_DIRECTION_CMD SteerDirectionCmd;
    HW_STEER_TORQUE SteerTorque;

    // 명령 있을 경우 로그 작성
//    if(SteerInfo.FrontCmdOn==true || SteerInfo.RearCmdOn==true)
//	{
//		ADD_LOG("D_220/%d/%d/%d/%d/%d/%d"
//			,SteerInfo.FrontCmdOn, SteerInfo.FrontDirection, SteerInfo.FrontTorque
//            ,SteerInfo.RearCmdOn, SteerInfo.RearDirection, SteerInfo.RearTorque     );
//    }

    if(SteerInfo.FrontCmdOn==true)
    {
        if(SteerInfo.FrontDirection==0)         SteerDirectionCmd = HW_STEER_DIRECTION_CMD_LEFT;
        else if(SteerInfo.FrontDirection==1)    SteerDirectionCmd = HW_STEER_DIRECTION_CMD_RIGHT;
        switch(SteerInfo.FrontTorque)
        {
         case 0:
            SteerTorque = HW_STEER_TORQUE_FREE;
            break;
		 case 1:
            SteerTorque = HW_STEER_TORQUE_STOP;
            break;
		 case 2:
            SteerTorque = HW_STEER_TORQUE_MOVING;
            break;
         case 3:
            SteerTorque = HW_STEER_TORQUE_TRACTION;
            break;
        }

        nTmpError = m_pSteer->SetFrontTorque(SteerTorque);
        if( nTmpError== NO_ERR )
        {
			nTmpError = m_pSteer->SetFrontDirection(SteerDirectionCmd);
		}

		if(nTmpError == NO_ERR)
		{
			bCheckMoveSteer[0] = true;
		}

    }
    if(SteerInfo.RearCmdOn==true && nTmpError== NO_ERR)
    {
        if(SteerInfo.RearDirection==0)          SteerDirectionCmd = HW_STEER_DIRECTION_CMD_LEFT;
        else if(SteerInfo.RearDirection==1)     SteerDirectionCmd = HW_STEER_DIRECTION_CMD_RIGHT;
        switch(SteerInfo.RearTorque)
        {
         case 0:
            SteerTorque = HW_STEER_TORQUE_FREE;
            break;
         case 1:
            SteerTorque = HW_STEER_TORQUE_STOP;
            break;
         case 2:
            SteerTorque = HW_STEER_TORQUE_MOVING;
            break;
         case 3:
            SteerTorque = HW_STEER_TORQUE_TRACTION;
            break;
        }

        if( nTmpError== NO_ERR )
        {
            nTmpError = m_pSteer->SetRearTorque(SteerTorque);
        }
        if( nTmpError== NO_ERR )
        {
            nTmpError = m_pSteer->SetRearDirection(SteerDirectionCmd);

		}

		if(nTmpError == NO_ERR)
		{
			bCheckMoveSteer[1] = true;
		}
	}

	//진단모니터링 항목(Auto 인 경우 Steering 구동횟수 Count)
	if((bCheckMoveSteer[0] == true) && (bCheckMoveSteer[1] == true))
	{
		m_pSteer->IncreaseMovingCount();
	}

    return nTmpError;
}

/**
@brief   DrivingControl 전방 감시 Control 함수
@author  임태웅
@date    2013.07.01
*/
int DrivingControl::controlFrontObservation(CTRL_INFO_OF_FRONT_DETECT DirectionCmd)
{
    if(DirectionCmd.bCmdOn==true)
	{
#if(USE_CHANGENODE == 1)
		ADD_LOG("D_221/%d/%d/%d/%d/%d"
			, DirectionCmd.Info.NodeType
			, DirectionCmd.Info.OHTDetectTypeOpt, DirectionCmd.Info.OBSDetectTypeOpt
			, DirectionCmd.Info.DistON, DirectionCmd.Info.DistAfterON);
#endif

//			ADD_LOG("D-155");
		return m_pDrivingAxis->SetDetectInfo(DirectionCmd.Info);
    }
    else
    {
        return 0;
    }
}

/**
@brief   DrivingControl ID Reader Control 함수 (BCR/QR)
@author  임태웅
@date    2013.07.01
*/
int DrivingControl::controlIdReader(MARK_TYPE MarkType, CTRL_INFO_OF_ID_READER_CMD_TYPE CmdType)
{
    return controlIdReader(MarkType, CmdType, NULL, NULL);
}

/**
@brief   DrivingControl ID Reader Control 함수 (BCR/QR)
@author  임태웅
@date    2013.07.01
*/
int DrivingControl::controlIdReader(MARK_TYPE MarkType, CTRL_INFO_OF_ID_READER_CMD_TYPE CmdType, int* pnResultID)
{
    return controlIdReader(MarkType, CmdType, pnResultID, NULL);
}

/**
@brief   DrivingControl ID Reader Control 함수 (BCR/QR)
@author  임태웅
@date    2013.07.01
*/
int DrivingControl::controlIdReader(MARK_TYPE MarkType, CTRL_INFO_OF_ID_READER_CMD_TYPE CmdType, int* pnResultID, double* pdResultOffset)
{
	VirtualIdReader *pIdReader = NULL;

    // Return 을 위한 변수 추가 2016.05.01 by soo583
	int nTmpError = NO_ERR;


//    if(CmdType!=CTRL_INFO_OF_ID_READER_CMD_NONE)
//    {
//        ADD_LOG("D_222/%X/%X",MarkType, CmdType);
//    }

    // ID Reader Type 선택
    switch(MarkType)
    {
    case MARK_TYPE_NODE:
        pIdReader = m_pDrivingBCR;
        pIdReader->SetResultPointer(pnResultID);
        break;

	case MARK_TYPE_TAG_STATION:
	case MARK_TYPE_TAG_STATION_BACK:
        pIdReader = m_pTransBCR;
        pIdReader->SetResultPointer(pnResultID);
        break;

    case MARK_TYPE_QR_STATION_LEFT:
	case MARK_TYPE_QR_LEFT_TOP:
	case MARK_TYPE_QR_LEFT_BOTTOM:
	case MARK_TYPE_QR_LEFT_BOTTOM_S:
	case MARK_TYPE_QR_PSTB_LEFT:
        pIdReader = m_pLeftQRR;
        pIdReader->SetResultPointer(pnResultID, pdResultOffset);
        break;

    case MARK_TYPE_QR_STATION_RIGHT:
	case MARK_TYPE_QR_RIGHT_TOP:
	case MARK_TYPE_QR_RIGHT_BOTTOM:
	case MARK_TYPE_QR_RIGHT_BOTTOM_S:
	case MARK_TYPE_QR_PSTB_RIGHT:
        pIdReader = m_pRightQRR;
        pIdReader->SetResultPointer(pnResultID, pdResultOffset);
        break;
    }

    // 명령 수행
    switch(CmdType)
    {
	case CTRL_INFO_OF_ID_READER_CMD_NONE:
        break;

    case CTRL_INFO_OF_ID_READER_CMD_ENABLE:
		nTmpError = pIdReader->Enable();
        break;

    case CTRL_INFO_OF_ID_READER_CMD_DISABLE:
		pIdReader->Disable();
        break;

    case CTRL_INFO_OF_ID_READER_CMD_RESTART:
		nTmpError = pIdReader->ReStart();
        break;

    case CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON:
		nTmpError = pIdReader->SendTriggerOn();
        break;

    case CTRL_INFO_OF_ID_READER_CMD_READ_DATA:
		nTmpError = pIdReader->ReadBuffer();
        break;

	case CTRL_INFO_OF_ID_READER_CMD_TRIGGER_OFF:
		nTmpError = pIdReader->SendTriggerOff();
		break;

    case CTRL_INFO_OF_ID_READER_CMD_READ_SEQUENTIALLY:
        nTmpError = pIdReader->SendTriggerOn();
        Sleep(100); // 시간은 확인 할 것
        if(nTmpError == NO_ERR)    { nTmpError = pIdReader->ReadBuffer(); }
        if(nTmpError == NO_ERR)    { nTmpError = pIdReader->SendTriggerOff(); }
        break;

    }
     return nTmpError;
}

#define RecoveryLimitCountForMarkOnNode				2
#define RecoveryLimitCountForMarkOnTagStation		7

/**
@brief   DrivingControl Mark 구동 정보 획득 함수(Node)
@author  임태웅
@date    2013.07.01
*/
int DrivingControl::markOnNode(DRIVING_HW_INFO_SET HwInfo, double dRealDistSumToTarget, double dSpeedLimit, int nTargetID, int nNodeCount, DRIVING_MARK_STATE* pMarkState, CTRL_INFO_OF_SYNC_AXIS_MOVE* pCtrlInfo, CTRL_INFO_OF_ID_READER_CMD_TYPE *pIdReaderCmdType, int* pnID)
{
	int     nTmpID = 0;
    static int nReadedID = 0;
    static int nTmpTargetID =0;
    static bool bIdReaded = false;
	static DWORD dwCheckTime = 0;
	static DWORD dwTriggerTime = 0;
	double MarkInPosition_OnNode = 0.0;
	double FirstMetSpeed_OnNode = 0.0;
	static int nRecoveryLimitCount = 0;
	static bool IsManual = false;
	static DWORD dwMoveDSTriggerTime = timeGetTime();
	static DWORD dwMoveDSRetryTime = timeGetTime();

	static DWORD dwRecoveryTime = timeGetTime();

	DWORD   dwCurrTime = timeGetTime();

    int     nTmpError = NO_ERR;

    memset(pCtrlInfo, 0x00, sizeof(CTRL_INFO_OF_SYNC_AXIS_MOVE));
	*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_NONE;

    DRIVING_MARK_STATE PreMarkState = *pMarkState;

	DRIVING_MARK_PARAM MarkParam = m_pParamSet->Mark[0];

//	if(m_ClassifiedCmd.TargetInfo.PassBoxIn)
//	{
		// Passbox marking시 진입 속도 및 In-Position limit 변경 가능하도록 준비함
		// 우선 동일한 값 사용하도록 설정
	MarkInPosition_OnNode = MarkParam.Dist.dMarkInPosLimit;
	FirstMetSpeed_OnNode = MarkParam.Speed.dOfFirstMet;
//	}
//	else
//	{
//		MarkInPosition_OnNode = MarkParam.Dist.dMarkInPosLimit;
//		FirstMetSpeed_OnNode = MarkParam.Speed.dOfFirstMet;
//	}

    static bool bFirstMetTriggerWithFirstDetect = false;    // First Trigger On 되었을 때 FirstSensor 가 On 인 경우
    static double dRealPositionOfFirstMetTriggerOnWithFirstDetect = 0.0;
    static bool bFirstPassedState = false;  // Target이 dRealDistSumToTarget 근처에 있는 경우로 nTargetID 이 0이 아닐 경우 true로 설정
    bool bFirstMetMoveDist = false;

    double  dStartDistToSecond = 0.0;

    // --------------------------------------------------------------------------------------------------------------------------------------
    //1 0. 정보 획득
	// --------------------------------------------------------------------------------------------------------------------------------------
	nTmpID = HwInfo.Node.nBcrId;


	int     nFirstCount     = HwInfo.Node.nPreCheckCount;
    int     nSecondCount        = HwInfo.Node.nNodeCount;
	bool    bDetectFirst        = HwInfo.IO.NodePreCheckOn;
    bool    bDetectSecond       = HwInfo.IO.NodeOn;
	bool    bFirstPassed        = (nFirstCount>=nNodeCount)?true:false;
	bool    bSecondPassed       = (nSecondCount==nNodeCount)?true:false;
	static DWORD dwWaitHwBCRNodeTrgTime = 0; //BCR READ TRIGGER CHECK TIME
    bool    bRoutineInTrigger   = !(PreMarkState.OnRoutineIn);
	bool    bRoutineInWithFirstPassed = false;
	bool    bFirstMetTrigger    = (PreMarkState.FirstMet==false && bFirstPassed==true)?true:false;
    bool    bSecondMetTrigger   = (PreMarkState.SecondMet==false && bSecondPassed==true)?true:false;

    // 짧은 거리에서 Node 가 감지되는 경우
    if( (dRealDistSumToTarget<MAX(MarkParam.Dist.dLengthOfSecond*3, 110))//100mm 이상
    &&  (bSecondMetTrigger==false) && (bDetectSecond==true) )
    {
        bSecondMetTrigger = true;
    }

	static bool bPreOverRunTrigger = false;
    bool    bOverRunTrigger = false;

    bool    bAxis1InPosition            = HwInfo.IO.Axis1InPosition;
    bool    bAxis1Running               = HwInfo.IO.Axis1Running;
    static  TIME_CHECK  StopWithoutFrontDetect;
    bool    bStopWithoutFrontDetect = false;
#if(UBG_SENSOR_ENABLE == ON)
//	if(bAxis1Running==false && HwInfo.IO.ObsStatus!=DETECT_AND_STOP && HwInfo.IO.DetectStatus!=DETECT_AND_STOP)
	if((HwInfo.IO.Axis1Running==false)
	&& ((HwInfo.IO.DetectStatus!=DETECT_AND_STOP)||(pHWSet->GetAMCVHLDetectStatus() ==0)))
#else
	if(HwInfo.IO.Axis1Running==false
	&& ((HwInfo.IO.DetectStatus!=DETECT_AND_STOP) || (pHWSet->GetAMCVHLDetectStatus() ==0)))
#endif
	{
        if(StopWithoutFrontDetect.bFlag==false)
        {
			StopWithoutFrontDetect.dwTime = dwCurrTime;
            StopWithoutFrontDetect.bFlag = true;
        }
        else if(OHTUTILITY::PreventOverflowGetTimeMs(StopWithoutFrontDetect.dwTime)>200)
        {
            bStopWithoutFrontDetect = true;
        }
    }
    else
    {
        StopWithoutFrontDetect.bFlag = false;
        bStopWithoutFrontDetect = false;
    }


	double  dSpeedOfNow                 = HwInfo.Axis1.dSpeed;              //m_pDrivingAxis->GetCurrentPosition(); //미보정 현재 위치
    double  dRealPositionOfNow          = HwInfo.Axis1.dCurrPos;            //m_pDrivingAxis->GetCurrentPosition(); //미보정 현재 위치
    double  dRealPositionOfFirstDetect  = HwInfo.Node.dPreCheckPosition;    // First Sensor 감지 미보정 엔코더 값
    double  dRealPositionOfSecondDetect = HwInfo.Node.dNodePosition;        // Final Sensor 감지 미보정 엔코더 값
    double  dRealPositionOfSmallAddCheck = HwInfo.Axis1.dSmallAddCheckPos;  // SmallAddCheck 위치
    static  double  dRealPositionOfMostPositive = 0.0;                      // 최대로 멀리갔을 때의 거리
    static  double  dRealPositionOfIdReaded     = 0.0;                      // 최대로 멀리갔을 때의 거리
	static  double dRefSpeedOnSecondMeet = 0.2;

	bool bStartMarking = false;

//	 ADD_LOG("D_223/%d/%d/%d/%d/%d/%d",
//	 bFirstMetTrigger,
//	 PreMarkState.FirstMet,
//	 bFirstPassed,
//	 nFirstCount,
//	 nSecondCount,
//	 nNodeCount);
    //2 Manual 상태 에서 초근접하여 마크 하는 경우 (임시) : 초근접인 경우 넘어가서 다음 노드에 마크하고 이전 ID를 올림
    //2 직후 Node 에 마크 하도록 함
    if( (nTargetID==0) && (dRealPositionOfNow<MarkParam.Dist.dAddDistAfterSecondMet)
    &&  (bSecondMetTrigger==false) && (bDetectSecond==true)
    )
    {
        bSecondMetTrigger = true;
    }

	if(bDetectFirst == true)
	{
		if(m_mccparam.dMarkFirstDetectSpeed == 0.0)
	{
		m_mccparam.dMarkFirstDetectSpeed = dSpeedOfNow;
			m_mccparam.bPrePreCheckSensorDetect = false;
		}
		else if(m_mccparam.bPrePreCheckSensorDetect == true)
		{
			m_mccparam.nPreCheckSensorHauntingCount++;
			m_mccparam.bPrePreCheckSensorDetect = false;
	}
	}
	else
	{
		if(m_mccparam.dMarkFirstDetectSpeed != 0.0)
		{
			m_mccparam.bPrePreCheckSensorDetect = true;
		}
	}

	if(bDetectSecond == true)
	{
		if(m_mccparam.dMarkSecondDetectSpeed == 0.0)
	{
		m_mccparam.dMarkSecondDetectSpeed = dSpeedOfNow;
			m_mccparam.bPreStopSensorDetect = false;
		}
		else if(m_mccparam.bPreStopSensorDetect == true)
		{
			m_mccparam.nStopSensorHauntingCount++;
			m_mccparam.bPreStopSensorDetect = false;
		}
	}
	else
	{
		if(m_mccparam.dMarkSecondDetectSpeed != 0.0)
		{
			m_mccparam.bPreStopSensorDetect = true;
		}
	}

    if(PreMarkState.OnRoutineIn==false)
	{
        StopWithoutFrontDetect.bFlag = false;
        StopWithoutFrontDetect.dwTime = dwCurrTime;
		dwCheckTime = dwCurrTime;
		dwTriggerTime = dwCurrTime;
        nReadedID = 0;
		nTmpTargetID = nTargetID;

		if(nTargetID ==0)
			IsManual = true;
		else
			IsManual = false;

        bFirstPassedState = false;
        bIdReaded = false;
        dRealPositionOfMostPositive = dRealPositionOfNow;
        dRealPositionOfIdReaded     = 0.0;
        bFirstMetTriggerWithFirstDetect = false;
        dRealPositionOfFirstMetTriggerOnWithFirstDetect = 0.0;
        dRefSpeedOnSecondMeet = sqrt(2*MarkParam.Accel.dOfFirstMet*MarkParam.Dist.dAddDistAfterSecondMet);  // v = sqrt( 2 * a * S) : 감속 거리의 최대 진입 속도
        dRefSpeedOnSecondMeet = MAX(MarkParam.Speed.dOfSecondMet, dRefSpeedOnSecondMeet);

        bPreOverRunTrigger = false;
		nRecoveryLimitCount = 0;

		ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,NODE MARK,Start,%s,%06d,%06d,%06d,%d,%3.3lf,Mark Type,%d",
					m_defualtparam->VHLName,m_mccparam.cCarrierType,
					m_mccparam.uSourceNode,
					m_mccparam.uTargetNode,
					m_pExecuteInfo->ExecutePositionInfo.CurrNode,
					m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
					dSpeedOfNow,
					m_InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType);
		m_mccparam.bMarkStartFlag = true;
		m_mccparam.dMarkStartSpeed = dSpeedOfNow;
		m_mccparam.dMarkStartDist = dRealPositionOfNow;
		m_mccparam.nBCRTriggerCount = 0;
		m_mccparam.nPreCheckSensorHauntingCount = 0;
		m_mccparam.nStopSensorHauntingCount = 0;
		m_mccparam.bMarkingOHTDetectStop = false;
    }
    else
    {
		dRealPositionOfMostPositive = (dRealPositionOfNow>dRealPositionOfMostPositive)?dRealPositionOfNow:dRealPositionOfMostPositive;

		if((IsManual == true) && ((nTmpID!=0) || (nTmpTargetID !=0)))
		{
			nFirstCount = 1;
			bFirstPassed = true;
			bFirstMetTrigger    = (PreMarkState.FirstMet==false)?true:false;
		}

		if((IsManual == true) && (bDetectSecond == true))
		{
			nSecondCount = 1;
			bSecondPassed = true;

			bSecondMetTrigger   = (PreMarkState.SecondMet==false)?true:false;
		}
	}

	if(IsManual==true && nTmpID!=0)
    {
        nTmpTargetID = nTmpID;
        ADD_LOG("D_224/%d/%d/%6.1lf/%6.1lf/%6.1lf/%6.1lf", nTmpID, nTmpTargetID
            , dRealPositionOfNow, dRealPositionOfFirstDetect, dRealPositionOfSecondDetect, dRealPositionOfSmallAddCheck);
    }

	if(nTmpID!=0 &&nTmpTargetID!=0)
	{
		if(nTmpID==nTmpTargetID)
		{
        	bIdReaded = true;
			dRealPositionOfIdReaded = dRealPositionOfNow;
		}

		if(nReadedID != nTmpID)
		{
			ADD_LOG("D_225/%d/%d/%6.1lf/%d/%d/%6.1lf/%6.1lf/%6.1lf/%6.1lf", nTmpID, bIdReaded, dRealPositionOfIdReaded, nReadedID, nTmpID
				, dRealPositionOfNow, dRealPositionOfFirstDetect, dRealPositionOfSecondDetect, dRealPositionOfSmallAddCheck);
		}
		nReadedID = nTmpID;
	}
	else if(((dRealPositionOfNow - dRealPositionOfIdReaded) > MarkParam.Dist.dDistFromFirstToSecond) && (bIdReaded ==true))
	{
		ADD_LOG("D_226/%d/%d/%6.1lf/%d/%6.1lf/%6.1lf/%6.1lf/%6.1lf",nTmpID, bIdReaded, dRealPositionOfIdReaded, nReadedID
			, dRealPositionOfNow, dRealPositionOfFirstDetect, dRealPositionOfSecondDetect, dRealPositionOfSmallAddCheck);

		bIdReaded = false;
		nReadedID = 0;

		if(IsManual == true)
        	nTmpTargetID = 0;

	}
	//AOHC-288
	if( (bFirstMetTrigger==true)
	&&  (bFirstPassedState==false)
	&&  (nTmpTargetID!=0)
	&&  (((dRealPositionOfFirstDetect + MarkParam.Dist.dAddDistAfetrFirstMet + MarkParam.Dist.dLengthOfSecond) - dRealPositionOfNow) > SENSOR_CHECK_DISTANCE)
    &&  (dRealDistSumToTarget>MarkParam.Dist.dAddDistAfetrFirstMet)
	)
	{
		bFirstPassedState = true;
		bFirstMetMoveDist = true;
        dStartDistToSecond  = dRealPositionOfFirstDetect
                                + MarkParam.Dist.dAddDistAfetrFirstMet
                                + MarkParam.Dist.dLengthOfSecond;   // Falling Edge
        ADD_LOG("D_227/%6.1lf/%6.1lf/%6.1lf/%6.1lf"
			, dRealPositionOfNow, dRealPositionOfFirstDetect, dRealPositionOfSecondDetect, dRealPositionOfSmallAddCheck);
    }

	if(bFirstMetTrigger)
    {

		 // 로그 중복 방지 코드 3000ms
		 static DWORD dwPrevTick = 0;
		 if(OHTUTILITY::PreventOverflowGetTimeMs(dwPrevTick) > 3000)       //20191104 KDS
		 {
			ADD_LOG("D_228/%d/%d/%d", nFirstCount, nSecondCount, nNodeCount);
			dwPrevTick = timeGetTime();
		 }


	}
    if(bSecondMetTrigger)
    {
        ADD_LOG("D_229/%d/%d/%d", nFirstCount, nSecondCount, nNodeCount);
    }

    //2 First 만나고 일정 거리 경과 및 감속 후, 두번째 Small Add(저속) 지연해서 실시 하기 위해
    if(bFirstMetTrigger==true && bDetectFirst==true && bFirstMetTriggerWithFirstDetect==false)
    {
        bFirstMetTriggerWithFirstDetect = true;
        dRealPositionOfFirstMetTriggerOnWithFirstDetect = dRealPositionOfNow;
        ADD_LOG("D_230/%d/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%6.1lf", bFirstMetTriggerWithFirstDetect, dRealPositionOfFirstMetTriggerOnWithFirstDetect
            , dRealPositionOfNow, dRealPositionOfFirstDetect, dRealPositionOfSecondDetect, dRealPositionOfSmallAddCheck);
    }
	if(bFirstMetTrigger==true && bFirstMetTriggerWithFirstDetect == true)
    {
        if(((dRealPositionOfNow-dRealPositionOfFirstMetTriggerOnWithFirstDetect)<(MarkParam.Dist.dAddDistAfetrFirstMet/2))||
            (dSpeedOfNow>(dRefSpeedOnSecondMeet+2.0)))  //2.0 은 안전율 ( 1.0m/s2 감속 시 0.2초동안 감속되는 속도 )
        {
			if(bStopWithoutFrontDetect==true)
			{
				if(OHTUTILITY::PreventOverflowGetTimeMs(dwMoveDSRetryTime) > 500)
				{
					pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfFirstMet;	//dOfSecondMet;
					pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfFirstMet;	//dOfSecondMet;
					pCtrlInfo->Dynamic.dSpeed   = FirstMetSpeed_OnNode;			//dOfSecondMet;
					if(bCheckPulse == true)
					{
						pCtrlInfo->Dynamic.dDist    = dRealPositionOfFirstDetect
														+ MarkParam.Dist.dAddDistAfetrFirstMet
														+ MarkParam.Dist.dLengthOfSecond
														+ 1;   // Falling Edge
						bCheckPulse = false;
					}
					else
					{
                    	pCtrlInfo->Dynamic.dDist    = dRealPositionOfFirstDetect
														+ MarkParam.Dist.dAddDistAfetrFirstMet
														+ MarkParam.Dist.dLengthOfSecond;   // Falling Edge
						bCheckPulse = true;
					}
					memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
					pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;

					ADD_LOG("D_255/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%6.1lf"
							, dRealPositionOfNow, dRealPositionOfFirstMetTriggerOnWithFirstDetect, dSpeedOfNow, dRefSpeedOnSecondMeet,0.00);

					dwMoveDSRetryTime = timeGetTime();
				}
				bFirstMetTrigger=false;
			}
			else
			{
				bFirstMetTrigger=false;
			}
        }
        else
        {
            ADD_LOG("D_231/%d/%6.1lf/%6.1lf/%6.1lf/%d/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%6.1lf",
                ((dRealPositionOfNow-dRealPositionOfFirstMetTriggerOnWithFirstDetect)<(MarkParam.Dist.dAddDistAfetrFirstMet/2)),
                dRealPositionOfNow, dRealPositionOfFirstMetTriggerOnWithFirstDetect, MarkParam.Dist.dAddDistAfetrFirstMet,
                (dSpeedOfNow>(dRefSpeedOnSecondMeet+2.0)),
                dSpeedOfNow, dRefSpeedOnSecondMeet
                , dRealPositionOfNow, dRealPositionOfFirstDetect, dRealPositionOfSecondDetect, dRealPositionOfSmallAddCheck);
        }
    }

    //2 근접 제어 센서를 Off 시키는 조건
//	if(pMarkState->FollowCtrlOffArea==false)
	if(CanIgnoreVHLDetect())
	{
//      if( (bFirstMetTrigger==true)
//      ||  (bSecondMetTrigger==true)
//      ||  (dRealDistSumToTarget-dRealPositionOfNow<100)
//      ||  (pMarkState->FirstMet==true)
//      ||  (pMarkState->SecondMet==true)
//      ||  (pMarkState->IdCheck==true)
//      ||  (pMarkState->Arrived==true)
//      ||  (pMarkState->OverRun==true)
//      ||  (pMarkState->Recovery==true)
//      ||  (pMarkState->OnMoveCmd==true)
//      )

		if( (bSecondMetTrigger==true)
		||  (bIdReaded==true)
		||  (pMarkState->SecondMet==true)
		||  (pMarkState->IdCheck==true)
		||  (pMarkState->Arrived==true)
		||  (pMarkState->OverRun==true)
		||  (pMarkState->Recovery==true)
		)
//		if(pMarkState->Arrived==true)
		{

			m_pDrivingAxis->SetVHLDetectIgnor();
			m_bIsAMCVHLDetectIgnore = true;
//			pMarkState->FollowCtrlOffArea=true;
			ADD_LOG("D_232/%6.1lf/%6.1lf", dRealDistSumToTarget, dRealPositionOfNow);
		}
		else if(bFirstPassed==true || dRealDistSumToTarget<MarkParam.Dist.dDistFromFirstToSecond)
		{
			// PreCheck를 만났거나(bFirstPassed==true),
            // Target이 PreCheck와 StopSensor 사이인 경우(dRealDistSumToTarget<MarkParam.Dist.dDistFromFirstToSecond)
			// 도착 100mm 전에 장애물을 off한다.
			// Precheck 센서 만나고나서 일정거리 이후로 조건 변경
			if((dRealPositionOfFirstDetect + MarkParam.Dist.dDistFromFirstToSecond) - dRealPositionOfNow  < 50)
//			if(dRealDistSumToTarget-dRealPositionOfNow<50)
			{

				m_pDrivingAxis->SetVHLDetectIgnor();
				m_bIsAMCVHLDetectIgnore = true;

//				pMarkState->FollowCtrlOffArea=true;
				ADD_LOG("D_233/%6.1lf/%6.1lf/%6.1lf", dRealPositionOfFirstDetect,dRealDistSumToTarget, dRealPositionOfNow);
			}
		}

		if(bIdReaded == false)
		{
			if(OHTUTILITY::PreventOverflowGetTimeMs( dwWaitHwBCRNodeTrgTime) > 200)    //20191104 KDS
			{
				*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON; //DrivingControl::markOnTagStation
				dwWaitHwBCRNodeTrgTime = timeGetTime();
                m_mccparam.nBCRTriggerCount++;
			}
		}
	}
	else
	{
		if(OHTUTILITY::PreventOverflowGetTimeMs( dwWaitHwBCRNodeTrgTime) > 200)    //20191104 KDS
		{
			*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
			dwWaitHwBCRNodeTrgTime = timeGetTime();
			m_mccparam.nBCRTriggerCount ++;
		}

	}

	if(pMarkState->FollowCtrlOffArea==false)
	{
		if(pMarkState->Arrived==true)
		{
			pMarkState->FollowCtrlOffArea=true;
			ADD_LOG("D_234/%6.1lf/%6.1lf", dRealDistSumToTarget, dRealPositionOfNow);
		}
	}


    // --------------------------------------------------------------------------------------------------------------------------------------
    //1 0. 에러 처리
    // --------------------------------------------------------------------------------------------------------------------------------------
    if(dRealPositionOfNow>(dRealDistSumToTarget+MarkParam.Dist.dForwardMoveDistLimit))
    {
        pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
        pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
		nTmpError = ERR_NOTMATCH_TAGLENGTH_FINALNODE_MET_LATE;

        ADD_LOG("D_235/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%6.1lf"
            , dRealPositionOfNow, dRealDistSumToTarget, MarkParam.Dist.dForwardMoveDistLimit
            , dRealPositionOfNow, dRealPositionOfFirstDetect, dRealPositionOfSecondDetect, dRealPositionOfSmallAddCheck);
		ADD_FDC_LOG("ERR/%d/2/6/%06d/%06d/%d/%d/%06d/%6.1lf",
					ERR_NOTMATCH_TAGLENGTH_FINALNODE_MET_LATE,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pExecuteInfo->ExecutePositionInfo.NextNode,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					m_pOHTMainStatus->StatusCommon.ExistFoup,
					m_pOHTMainStatus->StatusCommon.StopStationID,
					dRealPositionOfNow - (dRealDistSumToTarget+MarkParam.Dist.dForwardMoveDistLimit));
        return nTmpError;
    }
    else if(dRealPositionOfNow<(dRealPositionOfMostPositive-MarkParam.Dist.dBackMoveDistLimit))
	{
        pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
        pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
        nTmpError = ERR_NOTMATCH_TAGLENGTH_FINALNODE_MOVE_BACK_LIMIT;
        ADD_LOG("D_236/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%6.1lf"
            , dRealPositionOfNow, dRealPositionOfMostPositive, MarkParam.Dist.dBackMoveDistLimit
            , dRealPositionOfNow, dRealPositionOfFirstDetect, dRealPositionOfSecondDetect, dRealPositionOfSmallAddCheck);
		ADD_FDC_LOG("ERR/%d/1/8/%06d/%06d/%d/%d/%06d/%f/%f/%f",
					ERR_NOTMATCH_TAGLENGTH_FINALNODE_MOVE_BACK_LIMIT,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pExecuteInfo->ExecutePositionInfo.NextNode,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					m_pOHTMainStatus->StatusCommon.ExistFoup,
					m_pOHTMainStatus->StatusCommon.StopStationID,
					dRealPositionOfNow,
					dRealPositionOfMostPositive,
					MarkParam.Dist.dBackMoveDistLimit);
        return nTmpError;
    }

    // --------------------------------------------------------------------------------------------------------------------------------------
    //1 1. Status 처리
    // --------------------------------------------------------------------------------------------------------------------------------------
    //2 0) 이상 처리
    if(PreMarkState.OverRun==false)
    {
        if(nSecondCount>nNodeCount)
        {
            // by zzang9un 2013.11.27 : 검증을 위한 로그 생성
            ADD_LOG("D-156");
			bPreOverRunTrigger = true;
        }

        if(bFirstPassed==true && bSecondPassed==true && bDetectFirst==false && bDetectSecond==false &&
		nNodeCount>0 && dRealPositionOfNow>(dRealPositionOfSecondDetect+MarkParam.Dist.dAddDistAfterSecondMet))
        {
            // by zzang9un 2013.11.27 : 검증을 위한 로그 생성
			ADD_LOG("D-157");
			bPreOverRunTrigger = true;
			bOverrunReverse = true;
        }
    }
    //2 1) First, Second 모두 미감지: 처리 사항 특별히 없음

    //2 2) First 감지 상태로 시작 : FirstMet 하지 않고 RoutineIn하도록 함 --> 다음 주기에 FisrtMet처리함
	if(PreMarkState.OnRoutineIn==false && bDetectFirst==true && bFirstMetTrigger==true)
    {
        bFirstMetTrigger=false;
    }
    //2 3) First와 Second 사이 Node 존재: 이전 Status에는 First/SecondMet이 전부 Off였으나 동시에 ON된 경우 OverRun 처리
    if(bFirstMetTrigger==true && bSecondMetTrigger==true)
    {
        // by zzang9un 2013.11.27 : 검증을 위한 로그 생성
        ADD_LOG("D-158");
        bPreOverRunTrigger = true;
    }
    //2 4) Second 감지 상태로 시작 : OverRun 처리
    if(PreMarkState.OnRoutineIn==false && bDetectSecond==true && bSecondMetTrigger==true)
    {
        // by zzang9un 2013.11.27 : 검증을 위한 로그 생성
        ADD_LOG("D-159");
		bStartMarking = true;
        bPreOverRunTrigger = true;
    }

    // by zzang9un 2013.11.25 : 3), 4) 결과에 따라 OverRun 처리
    // OverRun을 10mm 여유를 두고 판단하도록 수정(E2303 관련 에러 수정 조치)
    if(bPreOverRunTrigger == true && ((dRealPositionOfNow>dRealPositionOfSecondDetect+20) || bStartMarking))
    {
        ADD_LOG("D_237/%f/%f",
                dRealPositionOfNow,
                dRealPositionOfSecondDetect);
        bOverRunTrigger = true;
    }

    //2 5) RoutineIn 전에 거리 리밋이 First~Second 센서 감지 거리 보다 적을 경우
    if( PreMarkState.OnRoutineIn==false && bDetectFirst==false && bDetectSecond==false
    &&  ((dRealDistSumToTarget-dRealPositionOfNow)<MarkParam.Dist.dDistFromFirstToSecond)
    )
    {
        bFirstMetTrigger = true;
	}

    //2 6) RoutineIn 전에 거리 리밋이 First~Second 센서 감지 거리 보다 적을 경우
	if( PreMarkState.OnRoutineIn==false && bDetectFirst==false && nTargetID!=0
    &&  ((dRealDistSumToTarget-dRealPositionOfNow)<MarkParam.Dist.dDistFromFirstToSecond)
    &&  ((dRealDistSumToTarget-dRealPositionOfNow)>MAX(MarkParam.Dist.dLengthOfSecond*3, 110))
    )
    {
        bFirstMetTrigger = true;
    }
    //2 7) FirstMet 한 경우 Node 만난 위치 값이 사용 가능한 경우
    if( (bFirstMetMoveDist==true)
    &&  (bFirstMetTrigger==true)
    &&  (nFirstCount>0)
    )
	{
        bFirstMetTrigger=false;
    }

    // --------------------------------------------------------------------------------------------------------------------------------------
    //1 2. 명령 처리
    // --------------------------------------------------------------------------------------------------------------------------------------
    //2 0) ID 확인: 마크 루틴 완료 후 id를 확인하는 절차
    if(PreMarkState.IdCheck==true)
    {
        //1 ID 확인 하는 부분 처리

        if(pnID==NULL)
		{
			*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_NONE;
            pMarkState->Arrived = true;
        }
        else
        {
            if(bIdReaded==true)
            {
				*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_NONE;
                ADD_LOG("D_238/%6.1lf/%6.1lf/%6.1lf/%6.1lf"
                    , dRealPositionOfNow, dRealPositionOfFirstDetect, dRealPositionOfSecondDetect, dRealPositionOfSmallAddCheck);
                pMarkState->Arrived = true;
                *pnID = nReadedID;
            }
			else if(OHTUTILITY::PreventOverflowGetTimeMs(dwTriggerTime) > 200)
            {
				if(OHTUTILITY::PreventOverflowGetTimeMs(dwCheckTime) > 2000)
				{
					if(m_pExecuteInfo->nFinishOfNode == nTmpTargetID)
					{
						m_pExecuteInfo->FlagOverRunInfo.OverrunType = 0x01; //주행
						m_pExecuteInfo->ExecutePositionInfo.CurrNode = nTmpTargetID;
						m_pExecuteInfo->FlagOverRunInfo.nFinalNode = nTmpTargetID;    //주행은 주행, 이적재는 이적재
						m_PositionInfo.CurrNode = nTmpTargetID;
						m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode = nTmpTargetID;
					}

					if(OHTUTILITY::PreventOverflowGetTimeMs(dwCheckTime) > 3500)
					{
						*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_NONE;
						pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
						pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;

						if(m_pExecuteInfo->nFinishOfNode == nTmpTargetID)
						{
							m_DiagManager->IncreasePreviosDiagCount(PREVIOS_DIAG_DBT);
							ADD_MD_LOG("DBT Cur Node 2 : %d",m_pExecuteInfo->nFinishOfNode);
							nTmpError = ERR_BCR_READTIMEOUT;
							m_mccparam.bBCRReadFail = true;
							ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d/1",
										ERR_BCR_READTIMEOUT,
										m_pOHTMainStatus->StatusCommon.CurNodeID,
										m_pExecuteInfo->ExecutePositionInfo.NextNode,
										m_pOHTMainStatus->StatusCommon.CurNodeOffset,
										m_pOHTMainStatus->StatusCommon.ExistFoup,
										m_pOHTMainStatus->StatusCommon.StopStationID);

							//오버런 처리
							m_pExecuteInfo->FlagOverRunInfo.bCheck = true;
							m_pExecuteInfo->FlagOverRunInfo.OverrunType = 0x01; //주행
							m_pExecuteInfo->FlagOverRunInfo.dDrivingInitPosition = OFFSET_TO_CHECK_FIRST_NODE;

							ERR_LOG("markOnNode: ERR_BCR_READTIMEOUT, %d Pos:%6.1lf(%6.1lf,%6.1lf,%6.1lf)"
								,nTmpTargetID, dRealPositionOfNow, dRealPositionOfFirstDetect, dRealPositionOfSecondDetect, dRealPositionOfSmallAddCheck);
						}
						else
						{
							m_DiagManager->IncreasePreviosDiagCount(PREVIOS_DIAG_DBT);
							m_mccparam.bBCRReadFail = true;
							ADD_MD_LOG("DBT Cur Node 3 : %d",m_pExecuteInfo->nFinishOfNode);
							if(IsManual == true)
							{
								nTmpError = ERR_BCR_READTIMEOUT;
								ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d/1",
										ERR_BCR_READTIMEOUT,
										m_pOHTMainStatus->StatusCommon.CurNodeID,
										m_pExecuteInfo->ExecutePositionInfo.NextNode,
										m_pOHTMainStatus->StatusCommon.CurNodeOffset,
										m_pOHTMainStatus->StatusCommon.ExistFoup,
										m_pOHTMainStatus->StatusCommon.StopStationID);
							}
							else
								pMarkState->Arrived = true;
						}

						*pnID = nTmpTargetID;//ID_NONE;

                	}
				}
				else
				{
					dwTriggerTime = timeGetTime();
					*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
					m_mccparam.nBCRTriggerCount++;
                }
            }
        }

    }
    //2 1) Recovery 후 멈춤
    else if(PreMarkState.Recovery==true)
    {
        if(bStopWithoutFrontDetect==true)
        {
            // 정위치 센서 미감지
            if(bDetectSecond==false)
            {
                // 정위치 위해 전진
                if(PreMarkState.OnMoveCmd==false)
                {
                    pMarkState->OnMoveCmd=true;

                    pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet;
                    pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;
                    pCtrlInfo->Dynamic.dSpeed   = MarkParam.Speed.dOfSecondMet;
                    pCtrlInfo->Dynamic.dDist    = dRealPositionOfNow + MarkParam.Dist.dForwardMoveDistLimit;
                    memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
//                  pCtrlInfo->Dynamic.AdditionalInfo.bStartOnSpeedDown         = true;
					pCtrlInfo->Dynamic.AdditionalInfo.bUseSmallAdd              = true;
#if((OHT_NAME == OHT_NAME_STD_V80)||(OHT_NAME == OHT_NAME_STD_V81)|| (OHT_NAME == OHT_NAME_STD_V80_RETICLE))
					pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 51;
#elif((OHT_NAME == OHT_NAME_STD_V85) || (OHT_NAME == OHT_NAME_STD_V81S)||(OHT_NAME == OHT_NAME_STD_V85S)||(OHT_NAME == OHT_NAME_STD_V82)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
					pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 54;
#else
					pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 52;
#endif
                    pCtrlInfo->Dynamic.AdditionalInfo.bIsTriggerOnRisingEdge    = false;// Second Sensor 통과해서 정지  //  B접점
                    pCtrlInfo->Dynamic.AdditionalInfo.dSmallDistance            = MarkParam.Dist.dAddDistAfterSecondMet;
                    pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;

                    ADD_LOG("D_239/%6.1lf/%6.1lf/%6.1lf/%6.1lf"
                        , dRealPositionOfNow, dRealPositionOfFirstDetect, dRealPositionOfSecondDetect, dRealPositionOfSmallAddCheck);

                }
            }
            // 정위치 센서 감지
            else
            {
//              pMarkState->OnMoveCmd=false;
                // 정위치 확인
				bool bRecoveryMarkInPos = (
					(fabs(dRealPositionOfNow-dRealPositionOfSmallAddCheck)<(MarkParam.Dist.dAddDistAfterSecondMet+MarkInPosition_OnNode)) &&
					(fabs(dRealPositionOfNow-dRealPositionOfSmallAddCheck)>(MarkParam.Dist.dAddDistAfterSecondMet-MarkInPosition_OnNode)) &&
                    (dRealPositionOfSmallAddCheck!=0.0) && ( bAxis1InPosition==true)
				);
				// AMOHTV80F-1599 Driving Abnormal Stop 개선 - case1 재발 개선
				bool bE1069Case1MarkInPos = (m_isE1069Case1 &&
					(fabs(dRealPositionOfNow-dRealPositionOfSecondDetect)<(MarkParam.Dist.dAddDistAfterSecondMet+MarkInPosition_OnNode)) &&
					(fabs(dRealPositionOfNow-dRealPositionOfSecondDetect)>(MarkParam.Dist.dAddDistAfterSecondMet-MarkInPosition_OnNode)) &&
                    (dRealPositionOfSecondDetect!=0.0) && ( bAxis1InPosition==true)
				);
                if(bRecoveryMarkInPos || bE1069Case1MarkInPos)
                {
                    if(pnID==NULL)
                    {
                        pMarkState->Arrived=true;
                        ADD_LOG("D_240/%6.1lf/%6.1lf/%6.1lf/%6.1lf"
                            , dRealPositionOfNow, dRealPositionOfFirstDetect, dRealPositionOfSecondDetect, dRealPositionOfSmallAddCheck);
                    }
                    else
                    {
                        pMarkState->IdCheck=true;
                        *pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
						m_mccparam.nBCRTriggerCount++;
						dwCheckTime = dwCurrTime;   // ID 확인 되지 않을 때에 대한 TimeOut 처리 목적
						dwTriggerTime = dwCurrTime;
                        ADD_LOG("D_241/%6.1lf/%6.1lf/%6.1lf/%6.1lf"
                            , dRealPositionOfNow, dRealPositionOfFirstDetect, dRealPositionOfSecondDetect, dRealPositionOfSmallAddCheck);
                    }
					ADD_LOG("markOnNode: Recovery - InPos, Normal: %d, E1069-Case1: %d", bRecoveryMarkInPos, bE1069Case1MarkInPos);
                }
                // 정위치 아닐 경우 OverRun 처리 재 시도
                else
				{
					if(OHTUTILITY::PreventOverflowGetTimeMs(dwCheckTime) > 1500) // 정지 후 정위치 되지 않을 때에 대한 TimeOut 처리 목적
					{
						if(nRecoveryLimitCount < RecoveryLimitCountForMarkOnNode)
						{
							nRecoveryLimitCount++;
							pMarkState->Recovery = false;

							ADD_LOG("D_242/%d/%6.1lf/%6.1lf/%6.1lf/%6.1lf",
								nRecoveryLimitCount,
								dRealPositionOfNow,
								dRealPositionOfFirstDetect,
								dRealPositionOfSecondDetect,
								dRealPositionOfSmallAddCheck);
						}
						else
						{
							nRecoveryLimitCount = 0;

							pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
							pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
							nTmpError = ERR_NOTMATCH_TAGLENGTH_FINALNODE_IN_POSITION_ERROR;

							ADD_LOG("D_243/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%d",
								dRealPositionOfNow,
								dRealPositionOfSmallAddCheck,
								MarkParam.Dist.dAddDistAfterSecondMet,
								MarkInPosition_OnNode,
								dRealPositionOfSmallAddCheck,
								bAxis1InPosition);
							ADD_FDC_LOG("ERR/%d/1/10/%06d/%06d/%d/%d/%06d/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%d",
										ERR_NOTMATCH_TAGLENGTH_FINALNODE_IN_POSITION_ERROR,
										m_pOHTMainStatus->StatusCommon.CurNodeID,
										m_pExecuteInfo->ExecutePositionInfo.NextNode,
										m_pOHTMainStatus->StatusCommon.CurNodeOffset,
										m_pOHTMainStatus->StatusCommon.ExistFoup,
										m_pOHTMainStatus->StatusCommon.StopStationID,
										dRealPositionOfNow,
										dRealPositionOfSmallAddCheck,
										MarkParam.Dist.dAddDistAfterSecondMet,
										MarkInPosition_OnNode,
										bAxis1InPosition);

							return nTmpError;
						}
					}

					ADD_LOG("D_244/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%d/%6.1lf/%6.1lf/%6.1lf/%6.1lf" ,
                        dRealPositionOfNow, dRealPositionOfSmallAddCheck, MarkParam.Dist.dAddDistAfterSecondMet, MarkInPosition_OnNode,
                        dRealPositionOfSmallAddCheck, bAxis1InPosition
                        , dRealPositionOfNow, dRealPositionOfFirstDetect, dRealPositionOfSecondDetect, dRealPositionOfSmallAddCheck);
                }
            }
        }
        else if(bAxis1Running==true)
        {
            dwCheckTime = dwCurrTime;   // 정지 후 정위치 되지 않을 때에 대한 TimeOut 처리 목적
            if(pMarkState->OnMoveCmd==true)
            {
                pMarkState->OnMoveCmd=false;
                ADD_LOG("D_245/%6.1lf/%6.1lf/%6.1lf/%6.1lf"
                    , dRealPositionOfNow, dRealPositionOfFirstDetect, dRealPositionOfSecondDetect, dRealPositionOfSmallAddCheck);
            }
        }
    }
    //2 2) OverRun 후 멈춤
    else if(PreMarkState.OverRun==true)
    {
        if(bStopWithoutFrontDetect==true)
        {
            if(PreMarkState.OnMoveCmd==false) // OverRun 인 경우 뒤로 이동이 필수이다.(움직이면 OnMoveCmd이 false가 된다)
            {
                //반사판 사이즈보다 작을 경우, 해당 위치로 MoveDS 이동처리
				if(fabs(dRealPositionOfNow-dRealPositionOfSecondDetect) < (MarkParam.Dist.dAddDistAfterSecondMet) && (dRealPositionOfSecondDetect !=0.0))
				{
					pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet;
					pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;
					pCtrlInfo->Dynamic.dSpeed   = MarkParam.Speed.dOfSecondMet;
					pCtrlInfo->Dynamic.dDist    = dRealPositionOfSecondDetect + MarkParam.Dist.dAddDistAfterSecondMet;
					memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));

					pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;
#if((OHT_NAME == OHT_NAME_STD_V80) ||(OHT_NAME == OHT_NAME_STD_V81) || (OHT_NAME == OHT_NAME_STD_V81S)  ||(OHT_NAME == OHT_NAME_STD_V85)|| (OHT_NAME == OHT_NAME_STD_V80_RETICLE))
#else
                    pMarkState->OnMoveCmd=true; //AMOHTV80F-1001 Overrun 발생 시 명령값까지 도달하지 못했으나 Second met 상태로 마크 완료 처리 위하여

					m_isE1069Case1 = true;
					ADD_LOG("[markOnNode]E1069-case1, Overrun Target Dist : %6.1lf",dRealPositionOfSecondDetect + MarkParam.Dist.dAddDistAfterSecondMet);
#endif
				}
				else
				{

					pMarkState->OnMoveCmd=true;

					pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet;
					pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;
					pCtrlInfo->Dynamic.dSpeed   = MarkParam.Speed.dOfSecondMet;
					pCtrlInfo->Dynamic.dDist    = dRealPositionOfNow - 250;//MarkParam.Dist.dBackMoveDistLimit;
					memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
	//              pCtrlInfo->Dynamic.AdditionalInfo.bStartOnSpeedDown         = true;
					pCtrlInfo->Dynamic.AdditionalInfo.bUseSmallAdd              = true;
#if((OHT_NAME == OHT_NAME_STD_V80) ||(OHT_NAME == OHT_NAME_STD_V81)|| (OHT_NAME == OHT_NAME_STD_V80_RETICLE))
					pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 51;
#elif((OHT_NAME == OHT_NAME_STD_V85) || (OHT_NAME == OHT_NAME_STD_V81S)||(OHT_NAME == OHT_NAME_STD_V85S)||(OHT_NAME == OHT_NAME_STD_V82)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
                    pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 54;
#else
					pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 52;
#endif
					// Back Limit Error 관련 Edge 변경
					if(bOverrunReverse == true && bDetectSecond == false)
					{
						pCtrlInfo->Dynamic.AdditionalInfo.bIsTriggerOnRisingEdge    = false;
						ADD_LOG("bOverrunReverse == true && bDetectSecond == false");
					}
					else
					{
						pCtrlInfo->Dynamic.AdditionalInfo.bIsTriggerOnRisingEdge    = true;// Second Sensor 통과해서 정지  //  B접점
                        ADD_LOG("!(bOverrunReverse == true && bDetectSecond == false)");
					}
					pCtrlInfo->Dynamic.AdditionalInfo.dSmallDistance            = MarkParam.Dist.dAddDistAfterSecondMet;

					pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;

					bOverrunReverse = false;
				}

				ADD_LOG("D_246/%6.1lf/%6.1lf/%6.1lf/%6.1lf"
					, dRealPositionOfNow, dRealPositionOfFirstDetect, dRealPositionOfSecondDetect, dRealPositionOfSmallAddCheck);
			}
//          else    // OverRun 인 경우 뒤로 이동이 필수이다.
//          {
//              pMarkState->OnMoveCmd=false;
//              pMarkState->Recovery=true;
//              ADD_LOG("D-160");
//          }

		}
		else if(bAxis1Running==true)
		{
			if(pMarkState->OnMoveCmd==true)
            {
                pMarkState->OnMoveCmd=false;
                pMarkState->Recovery=true;
                dwCheckTime = dwCurrTime;   // 정지 후 정위치 되지 않을 때에 대한 TimeOut 처리 목적
                ADD_LOG("D_247/%6.1lf/%6.1lf/%6.1lf/%6.1lf"
                    , dRealPositionOfNow, dRealPositionOfFirstDetect, dRealPositionOfSecondDetect, dRealPositionOfSmallAddCheck);
            }
        }
    }
    //2 3) OverRun 진입 시
    else if(PreMarkState.OverRun==false && bOverRunTrigger==true)
    {
        pMarkState->OverRun=true;

        if(bStopWithoutFrontDetect==false)
        {
            pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
            pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
            ADD_LOG("D_248/%6.1lf/%6.1lf/%6.1lf/%6.1lf"
                , dRealPositionOfNow, dRealPositionOfFirstDetect, dRealPositionOfSecondDetect, dRealPositionOfSmallAddCheck);
        }
    }
    //2 4) SecondMet 후 멈춤
    else if(PreMarkState.SecondMet==true)
    {
        if(bStopWithoutFrontDetect==true)
        {

			if( (fabs(dRealPositionOfNow-dRealPositionOfSecondDetect)<(MarkParam.Dist.dAddDistAfterSecondMet+MarkInPosition_OnNode)) &&
				(fabs(dRealPositionOfNow-dRealPositionOfSecondDetect)>(MarkParam.Dist.dAddDistAfterSecondMet-MarkInPosition_OnNode)) &&
				(dRealPositionOfSmallAddCheck!=0.0) && ( bAxis1InPosition==true))
			{
				if(pnID==NULL)
                {
					pMarkState->Arrived=true;
					ADD_LOG("D_249/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%6.1lf"
                        , dRealPositionOfNow, dRealPositionOfFirstDetect, dRealPositionOfSecondDetect, dRealPositionOfSmallAddCheck,dRealDistSumToTarget);
                }
                else
                {
					pMarkState->IdCheck=true;
                    *pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
					m_mccparam.nBCRTriggerCount++;
					dwCheckTime = dwCurrTime;   // ID 확인 되지 않을 때에 대한 TimeOut 처리 목적
					dwTriggerTime = dwCurrTime;
					ADD_LOG("D_250/%6.1lf/%6.1lf/%6.1lf/%6.1lf"
                        , dRealPositionOfNow, dRealPositionOfFirstDetect, dRealPositionOfSecondDetect, dRealPositionOfSmallAddCheck);
                }
            }
            else
            {
				if(OHTUTILITY::PreventOverflowGetTimeMs(dwCheckTime) > 500) // 정지 후 정위치 되지 않을 때에 대한 TimeOut 처리 목적
                {
                    pMarkState->OverRun=true;
                    ADD_LOG("D_251/%6.1lf/%6.1lf/%6.1lf/%6.1lf"
                        , dRealPositionOfNow, dRealPositionOfFirstDetect, dRealPositionOfSecondDetect, dRealPositionOfSmallAddCheck);
                }

                ADD_LOG("D_252/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%d/%6.1lf/%6.1lf/%6.1lf/%6.1lf"
                    , dRealPositionOfNow
                    , dRealPositionOfSmallAddCheck
                    , (dRealPositionOfNow-dRealPositionOfSmallAddCheck)
                    , MarkParam.Dist.dAddDistAfterSecondMet
                    , MarkInPosition_OnNode
                    , dRealPositionOfSmallAddCheck
                    , bAxis1InPosition
					, dRealPositionOfNow
                    , dRealPositionOfFirstDetect
                    , dRealPositionOfSecondDetect
                    , dRealPositionOfSmallAddCheck);

            }
        }
        else
        {
            dwCheckTime = dwCurrTime;   // 정지 후 정위치 되지 않을 때에 대한 TimeOut 처리 목적
        }
    }
    //2 5) SecondMet 진입 시
    else if(PreMarkState.SecondMet==false && bSecondMetTrigger==true)
    {
        pMarkState->SecondMet=true;
		dwCheckTime = dwCurrTime;   // 정지 후 정위치 되지 않을 때에 대한 TimeOut 처리 목적
    }
	//2 6) FirstMet 후 멈춤
	else if(PreMarkState.FirstMet==true)
	{
		if(bStopWithoutFrontDetect==true)
		{
            if(dRealPositionOfNow<(dRealDistSumToTarget+MarkParam.Dist.dForwardMoveDistLimit))
			{
				// 350 -> 500  AMC Thread 지연 시간 반영
				if(OHTUTILITY::PreventOverflowGetTimeMs(dwMoveDSTriggerTime) > 500) // 연속 명령에 대한 부분 방지.
				{

					pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet;
					pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;
					pCtrlInfo->Dynamic.dSpeed   = MarkParam.Speed.dOfSecondMet;
					pCtrlInfo->Dynamic.dDist    = dRealDistSumToTarget+MarkParam.Dist.dForwardMoveDistLimit;
					memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
		//          pCtrlInfo->Dynamic.AdditionalInfo.bStartOnSpeedDown         = true;
					pCtrlInfo->Dynamic.AdditionalInfo.bUseSmallAdd              = true;
#if((OHT_NAME == OHT_NAME_STD_V80)||(OHT_NAME == OHT_NAME_STD_V81)|| (OHT_NAME == OHT_NAME_STD_V80_RETICLE))
					pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 51;
#elif((OHT_NAME == OHT_NAME_STD_V85) || (OHT_NAME == OHT_NAME_STD_V81S)||(OHT_NAME == OHT_NAME_STD_V85S)||(OHT_NAME == OHT_NAME_STD_V82)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
					pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 54;
#else
					pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 52;
#endif
					pCtrlInfo->Dynamic.AdditionalInfo.bIsTriggerOnRisingEdge    = false;// B접점
					pCtrlInfo->Dynamic.AdditionalInfo.dSmallDistance            = MarkParam.Dist.dAddDistAfterSecondMet;
					pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;
					ADD_LOG("D_253/%6.1lf/%6.1lf/%6.1lf/%6.1lf"
					, dRealPositionOfNow, dRealPositionOfFirstDetect, dRealPositionOfSecondDetect, dRealPositionOfSmallAddCheck);

					dwMoveDSTriggerTime = timeGetTime();
				}

            }
            else
            {
                nTmpError = 10000;// 에러 처리
                ERR_LOG("markOnNode: OverRun Err, Pos:%6.1lf(%6.1lf,%6.1lf,%6.1lf)"
                    , dRealPositionOfNow, dRealPositionOfFirstDetect, dRealPositionOfSecondDetect, dRealPositionOfSmallAddCheck);
            }
        }
    }
    //2 7) FirstMet 진입 시
    else if(PreMarkState.FirstMet==false && bFirstMetTrigger==true)
    {
        pMarkState->FirstMet=true;

        pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet;
        pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;
        pCtrlInfo->Dynamic.dSpeed   = MarkParam.Speed.dOfSecondMet;
        pCtrlInfo->Dynamic.dDist    = dRealDistSumToTarget+MarkParam.Dist.dForwardMoveDistLimit;
        memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
//      pCtrlInfo->Dynamic.AdditionalInfo.bStartOnSpeedDown         = true;
        pCtrlInfo->Dynamic.AdditionalInfo.bUseSmallAdd              = true;
#if((OHT_NAME == OHT_NAME_STD_V80)||(OHT_NAME == OHT_NAME_STD_V81)|| (OHT_NAME == OHT_NAME_STD_V80_RETICLE))
		pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 51;
#elif((OHT_NAME == OHT_NAME_STD_V85) || (OHT_NAME == OHT_NAME_STD_V81S)||(OHT_NAME == OHT_NAME_STD_V85S)||(OHT_NAME == OHT_NAME_STD_V82)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
		pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 54;
#else
        pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 52;
#endif
        pCtrlInfo->Dynamic.AdditionalInfo.bIsTriggerOnRisingEdge    = false;// B접점
        pCtrlInfo->Dynamic.AdditionalInfo.dSmallDistance            = MarkParam.Dist.dAddDistAfterSecondMet;
		pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;
		ADD_LOG("D_254/%6.1lf/%6.1lf/%6.1lf/%6.1lf"
			, dRealPositionOfNow, dRealPositionOfFirstDetect, dRealPositionOfSecondDetect, dRealPositionOfSmallAddCheck);

		dwMoveDSTriggerTime = timeGetTime();
    }
    //2 8) PreCheck 만난 직후 처리
    else if(bFirstMetMoveDist==true)
    {
		pMarkState->OnRoutineIn=true;

		pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfFirstMet;	//dOfSecondMet;
		if(pHWSet->GetAMCDecelStatus() >= AMCDECEL_VHLDETECT)
			pCtrlInfo->Dynamic.dDecel   = VHLDETECT_DECEL;
		else
            pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfFirstMet;	//dOfSecondMet;
        pCtrlInfo->Dynamic.dSpeed   = FirstMetSpeed_OnNode;			//dOfSecondMet;
        pCtrlInfo->Dynamic.dDist    = dStartDistToSecond;
        memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
        pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;

		dwMoveDSRetryTime = timeGetTime();

        ADD_LOG("D_255/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%6.1lf"
            ,dStartDistToSecond , dRealPositionOfNow, dRealPositionOfFirstDetect, dRealPositionOfSecondDetect, dRealPositionOfSmallAddCheck);
    }
    //2 9) RoutineIn 진입 처리
    else if(PreMarkState.OnRoutineIn==false && bRoutineInTrigger==true)
    {
        pMarkState->OnRoutineIn=true;

        pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfFirstMet;	//dOfSecondMet;
		if(pHWSet->GetAMCDecelStatus() >= AMCDECEL_VHLDETECT)
			pCtrlInfo->Dynamic.dDecel   = VHLDETECT_DECEL;
		else
            pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfFirstMet;	//dOfSecondMet;
        pCtrlInfo->Dynamic.dSpeed   = FirstMetSpeed_OnNode;			//dOfSecondMet;
        pCtrlInfo->Dynamic.dDist    = dRealDistSumToTarget+MarkParam.Dist.dForwardMoveDistLimit;
        memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
//      pCtrlInfo->Dynamic.AdditionalInfo.bStartOnSpeedDown         = true;
		pCtrlInfo->Dynamic.AdditionalInfo.bUseSmallAdd              = true;
#if((OHT_NAME == OHT_NAME_STD_V80)||(OHT_NAME == OHT_NAME_STD_V81)|| (OHT_NAME == OHT_NAME_STD_V80_RETICLE))
		pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 52;//52
#elif((OHT_NAME == OHT_NAME_STD_V85) || (OHT_NAME == OHT_NAME_STD_V81S)||(OHT_NAME == OHT_NAME_STD_V85S)||(OHT_NAME == OHT_NAME_STD_V82)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
		pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 55;
#else
		pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 50;//52
#endif
        pCtrlInfo->Dynamic.AdditionalInfo.bIsTriggerOnRisingEdge    = true;//1      true로 하면 안됨// B접점
        pCtrlInfo->Dynamic.AdditionalInfo.dSmallDistance            = MarkParam.Dist.dAddDistAfetrFirstMet;//dAddDistAfterSecondMet;
        pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;

		ADD_LOG("D_256/%d/%6.1lf/%6.1lf/%6.1lf/%6.1lf"
            , bFirstPassedState
            , dRealPositionOfNow, dRealPositionOfFirstDetect, dRealPositionOfSecondDetect, dRealPositionOfSmallAddCheck);
    }

    //2 10) Flag 정리
    if(bRoutineInTrigger==true)pMarkState->OnRoutineIn=true;
    if(bFirstMetTrigger==true)pMarkState->FirstMet=true;
    if(bSecondMetTrigger==true)pMarkState->SecondMet=true;
    if(bOverRunTrigger==true)pMarkState->OverRun=true;

	//2 11) 최저속도 처리
    pCtrlInfo->Dynamic.dSpeed = MIN(pCtrlInfo->Dynamic.dSpeed, dSpeedLimit);

	if((pMarkState->Arrived == true) && (m_mccparam.bMarkStartFlag == true))
	{
		ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,NODE MARK,End,%s,%06d,%06d,%06d,%d,%3.3lf,Mark Type,%d,Node Mark Dist,%6.1lf,Node Sensor Dist,%6.1lf,Node Mark Start Speed,%3.3lf,Node Mark First Detect Speed,%3.3lf,Node Mark Second Detect Speed,%3.3lf,Driving BCR Read Fail,%d,Driving BCR Trigger Count,%d,Marking OHT Detect And STOP,%d,PreCheck Sensor Haunting Count,%d,Stop Sensor Haunting Count,%d",
					m_defualtparam->VHLName,m_mccparam.cCarrierType,
					m_mccparam.uSourceNode,
					m_mccparam.uTargetNode,
					m_pExecuteInfo->ExecutePositionInfo.CurrNode,
					m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
					dSpeedOfNow,
					m_InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType,
					dRealPositionOfFirstDetect - m_mccparam.dMarkStartDist,
					dRealPositionOfSecondDetect - dRealPositionOfFirstDetect,
					m_mccparam.dMarkStartSpeed,
					m_mccparam.dMarkFirstDetectSpeed,
					m_mccparam.dMarkSecondDetectSpeed,
					m_mccparam.bBCRReadFail,
					m_mccparam.nBCRTriggerCount,
					m_mccparam.bMarkingOHTDetectStop,
					m_mccparam.nPreCheckSensorHauntingCount,
					m_mccparam.nStopSensorHauntingCount);
		m_mccparam.bMarkStartFlag = false;
		m_mccparam.dMarkStartSpeed = 0.0;
		m_mccparam.dMarkStartDist = 0.0;
		m_mccparam.bBCRReadFail = false;
		m_mccparam.nBCRTriggerCount = 0;
		m_mccparam.dMarkFirstDetectSpeed = 0.0;
		m_mccparam.dMarkSecondDetectSpeed = 0.0;
		m_mccparam.nPreCheckSensorHauntingCount = 0;
		m_mccparam.nStopSensorHauntingCount = 0;
	}

    return nTmpError;

}

/**
@brief   DrivingControl Mark 구동 정보 획득 함수(TagStation)
@author  임태웅
@date    2013.07.01
*/
int DrivingControl::markOnTagStation(DRIVING_HW_INFO_SET HwInfo, double dRealDistSumToTarget, double dSpeedLimit, int nTargetID, DRIVING_MARK_STATE* pMarkState, CTRL_INFO_OF_SYNC_AXIS_MOVE* pCtrlInfo, CTRL_INFO_OF_ID_READER_CMD_TYPE *pIdReaderCmdType, int* pnID,bool bOverrunIngn)
{
	int     nTmpID = 0;
    static int nReadedID = 0;
    static int nTmpTargetID =0;
	static bool bIdReaded = false;
	static bool bIsOHTDetectIngnore = false;
	static DWORD dwCheckTime = 0;
	static DWORD dwTriggerTime = 0;
	static DWORD dwWaitHwBCRTrgTime = 0; //BCR READ TRIGGER CHECK TIME
	static bool IsManual = false;

	static DWORD dwSecendCheckTime = 0;
	static DWORD dwE250RecoveryCheckTime = 0;
	DWORD   dwCurrTime = timeGetTime();


    int     nTmpError = NO_ERR;

    memset(pCtrlInfo, 0x00, sizeof(CTRL_INFO_OF_SYNC_AXIS_MOVE));
	*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_NONE;

	DRIVING_MARK_STATE PreMarkState = *pMarkState;
    DRIVING_MARK_PARAM MarkParam = m_pParamSet->Mark[1];

    static bool bNoSensorDetected = false;  // Mark Routine 시작 할 때 Front/Rear가 모두 Off 되었을 때 True
    static bool bPauseSecondSmallMove = false;  // bNoSensorDetected 사 true 인 경우 Second Small Move를 정위치 근처까지 지연 시키는 Flag
    static double dRealPositionOfFirstMetWithNoDetectStart = 0.0;   // Front 감지 되지 않은 상태에서 Mark 시작하여 처음 감지된 때, Front 감지된 위치
    static double dRealPositionOfSecondMet = 0.0;   // Front 감지 되지 않은 상태에서 Mark 시작하여 처음 감지된 때, Front 감지된 위치
    static bool bCheckTargetIsNearTargetDist = false;   // Target이 dRealDistSumToTarget 근처에 있는 경우로 nTargetID 이 0이 아닐 경우 true로 설정
    static bool bIgnoreFrontRearDetect = false; // Target이 dRealDistSumToTarget 근처에 있는 경우 Target 근처 이외에에서의 Front 센서 감지 무시

    // --------------------------------------------------------------------------------------------------------------------------------------
    //1 0. 정보 획득
    // --------------------------------------------------------------------------------------------------------------------------------------
	nTmpID = HwInfo.TagStaion.nBcrId;


	bool    bDetectFirst                = HwInfo.IO.TagStationFrontOn;
    bool    bDetectSecond               = HwInfo.IO.TagStationRearOn;

	bool    bAxis1InPosition            = HwInfo.IO.Axis1InPosition;
	bool	bAxis1Running				= HwInfo.IO.Axis1Running;

	static  TIME_CHECK  StopWithoutFrontDetect;

	static	int			nRecoveryLimitCount4TagStation = 0;
	static	int			nRecoveryCountTagStation2 = 0;    //puting 1069에 의한 리트라이 추가.
   static	int			nRecoveryCountTagStationOverrun = 0;    //puting 1069에 의한 리트라이 추가.

	bool    bStopWithoutFrontDetect = false;

	double dForwardLimit = 0.0;

	if(bOverrunIngn ==false)
		dForwardLimit = MarkParam.Dist.dForwardMoveDistLimit;
	else
		dForwardLimit = 100.0;


#if(UBG_SENSOR_ENABLE == ON)
//	if(bAxis1Running==false && HwInfo.IO.ObsStatus!=DETECT_AND_STOP && HwInfo.IO.DetectStatus!=DETECT_AND_STOP)
	if(bAxis1Running==false
	&& ((HwInfo.IO.DetectStatus!=DETECT_AND_STOP && HwInfo.IO.ObsStatus!=DETECT_AND_STOP)
	   ||(pHWSet->GetAMCVHLDetectStatus() ==0)))
#else
	if(HwInfo.IO.Axis1Running===false
	&& ((HwInfo.IO.DetectStatus!=DETECT_AND_STOP) || (pHWSet->GetAMCVHLDetectStatus() ==0)))
#endif
	{
        if(StopWithoutFrontDetect.bFlag==false)
        {
            StopWithoutFrontDetect.dwTime = dwCurrTime;
            StopWithoutFrontDetect.bFlag = true;
        }
        else if(OHTUTILITY::PreventOverflowGetTimeMs(StopWithoutFrontDetect.dwTime)>200)
        {
			bStopWithoutFrontDetect = true;   //일반 정지일때
		}
	}
	else
	{
		StopWithoutFrontDetect.bFlag = false;
		bStopWithoutFrontDetect = false;     //대차감지 멈춤
	}


    double  dRealDistSumToLimit             = (dRealDistSumToTarget+MarkParam.Dist.dForwardMoveDistLimit);  ///< 전지 거리
	double  dSpeedOfNow                     = HwInfo.Axis1.dSpeed;              //m_pDrivingAxis->GetCurrentPosition(); //미보정 현재 위치
    double  dRealPositionOfNow              = HwInfo.Axis1.dCurrPos;            //m_pDrivingAxis->GetCurrentPosition(); //미보정 현재 위치
    double  dRealPositionOfFirstDetect      = HwInfo.TagStaion.dFrontPosition;  // First Sensor 감지 미보정 엔코더 값
    double  dRealPositionOfSecondDetect     = HwInfo.TagStaion.dRearPosition;   // Final Sensor 감지 미보정 엔코더 값
    double  dRealPositionOfSmallAddCheck    = HwInfo.Axis1.dSmallAddCheckPos;   // SmallAddCheck 위치
    static  double  dRealPositionOfMostPositive = 0.0;                      // 최대로 멀리갔을 때의 거리
	static  double  dRealPositionOfIdReaded     = 0.0;                      // 최대로 멀리갔을 때의 거리
	static  double  dRealPositionOfIdReadedCheckingPoint     = 0.0;                      // 최대로 멀리갔을 때의 거리
	static  double dRefSpeedOnSecondMeet = 0.2;
	//// 300mm 대응 무시 구간 추가 코드 puting
	static  bool  bCheckInit = false;
	static  bool  bCheckInitStop = false;

	///E2312 관련 플래그 추가 2018 01 28
	static  bool  bCheckFrontBackStep = false;
	static double dRealCheckFrontBackPoint = 0.0;
	static int nCountFrontDetect = 0;

	static double  dCheckRealPositionOfFirstDetect      = 0.0;
	static int nCheckCountFirstDetect = 0;
	static bool bCheckFirstDetectInterlock = false;
	static double dRealPositionOfFirstDetectCheck = 0.0;
	static double dFirstDetectPercent = 1.0;
	static int AR_CurStation = 0;
	static bool bRearCheckFirst = false;
	static bool bCheckFrontRearOffFirst = false;
	//static bool bE250Recovery = false;
	static bool bCheckMarkComp = false;
	if(PreMarkState.OnRoutineIn==false)
    {
		StopWithoutFrontDetect.bFlag = false;
		StopWithoutFrontDetect.dwTime = dwCurrTime;
		dwCheckTime = dwCurrTime;
		dwTriggerTime = dwCurrTime;
		dwSecendCheckTime = dwCurrTime;
		nReadedID = 0;
		bIdReaded = false;
		b_ReadBcr = false;
		b_WaitTrg = false;

		if(nTargetID ==0)
			IsManual = true;
		else
			IsManual = false;

		nTmpTargetID = nTargetID;
		//// 300mm 대응 무시 구간 추가 코드 puting
		bIsOHTDetectIngnore = false;
		bCheckInit = false;
		bCheckInitStop = false;
		bCheckFrontBackStep = false;
		dRealCheckFrontBackPoint = 0.0;
		nCountFrontDetect = 0;
		bCheckTargetIsNearTargetDist = (nTargetID==0)?false:true;
		bIgnoreFrontRearDetect = (bCheckTargetIsNearTargetDist==true)?true:false;
		dRealPositionOfMostPositive = dRealPositionOfNow;
		dRealPositionOfIdReaded     = dRealPositionOfNow;//0.0;
		bCheckFirstDetectInterlock = false;

		dCheckRealPositionOfFirstDetect = 0.0;
		nCheckCountFirstDetect = 0;
		dRealPositionOfFirstDetectCheck = dRealPositionOfNow;
		dFirstDetectPercent = 1.0;

		if((dRealDistSumToTarget < 400) && (dRealDistSumToTarget > 200))    //이적재 -> 이적재 이슈내용 적용
		   dRealPositionOfIdReaded = dRealPositionOfNow+80;

		dRealPositionOfIdReadedCheckingPoint = dRealPositionOfNow;//0.0;
		bNoSensorDetected = (bDetectFirst==false&&bDetectSecond==false)?true:false;
		bPauseSecondSmallMove = (bNoSensorDetected==true)?true:false;
		dRealPositionOfFirstMetWithNoDetectStart = 0.0;
        dRealPositionOfSecondMet = 0.0;
        dRefSpeedOnSecondMeet = sqrt(2*MarkParam.Accel.dOfFirstMet*MarkParam.Dist.dAddDistAfterSecondMet);  // v = sqrt( 2 * a * S) : 감속 거리의 최대 진입 속도
		dRefSpeedOnSecondMeet = MAX(MarkParam.Speed.dOfSecondMet, dRefSpeedOnSecondMeet);
		nRecoveryLimitCount4TagStation = 0;
		nRecoveryCountTagStation2 = 0;
		nRecoveryCountTagStationOverrun = 0;
		ADD_LOG("D_257/%d/%d/%d/%6d"
			, bDetectFirst, bDetectSecond, bNoSensorDetected, nTmpTargetID);

		if(bDetectFirst)
			m_mccparam.bFStopOnStartPos = true;
		else
			m_mccparam.bFStopOnStartPos = false;

		ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,STATION MARK,Start,%s,%06d,%06d,%06d,%d,%3.3lf,Mark Type,%d",
					m_defualtparam->VHLName,m_mccparam.cCarrierType,
					m_mccparam.uSourceNode,
					m_mccparam.uTargetNode,
					m_pExecuteInfo->ExecutePositionInfo.CurrNode,
					m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
					dSpeedOfNow,
					m_InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType);

		m_mccparam.bMarkStartFlag = true;
		m_mccparam.dMarkStartSpeed = dSpeedOfNow;
		m_mccparam.dMarkStartDist = dRealPositionOfNow;
		m_mccparam.nBCRTriggerCount = 0;
		m_mccparam.bMarkingOHTDetectStop = false;
		m_mccparam.nFrontSensorHauntingCount = 0;
		m_mccparam.nRearSensorHauntingCount = 0;
		m_mccparam.bPreRearSensorDetect = false;
		m_bE250RearOnCheck = false;
		nCheckAutoRecoveryTry = 0;
		m_bE250AutoRecoveryFlag =false;
		m_bE231xAutoRecovery = false;
		m_bE231xAutoRecovery_RearCheck = false;
		m_dE231xAutoRecoveryDist = 0.0;
		m_bE231xAutoRecoveryCase2 =false;
		m_bE231xAutoRecoveryCase2_DistCheck = false;
		m_dE231xFront2RearDist = 0.0;
		m_dChekRearDist = 0.0;
		m_dE231xFront2CurPositionDist = 0.0;
		m_dE250RearOffPosition = 0.0;
		m_dE250RearOnPosition = 0.0;
		m_nE231xAutoRecoveryCase2Count = 0;
		MarkRetryErrorCase = AUTORECOVERY_NO_ACTION;

		bRearCheckFirst = false;
		bCheckFrontRearOffFirst = false;
		bCheckMarkComp = false;
    }
    else
	{
		if((dCheckRealPositionOfFirstDetect != HwInfo.TagStaion.dFrontPosition) &&
			(bCheckFirstDetectInterlock ==false)   &&
			(bDetectFirst == true) &&
			(dRealPositionOfFirstDetectCheck <  HwInfo.TagStaion.dFrontPosition))
		{
			nCheckCountFirstDetect++;

			if(dSpeedOfNow > 0.5)//속도가 0.5m/s 이하일 경우에만 사용
				dFirstDetectPercent = 0.625;

			//Rear 반사판 크기 보다 클때 사용함.
			if((nCheckCountFirstDetect >3)  && (dRealPositionOfNow - HwInfo.TagStaion.dFrontPosition > 5.0))
			{
				bCheckFirstDetectInterlock = true;
				dCheckRealPositionOfFirstDetect  =  HwInfo.TagStaion.dFrontPosition;
				ADD_LOG("D_258/%f/%f/%f",dCheckRealPositionOfFirstDetect, dSpeedOfNow,dFirstDetectPercent);

			}
		}
		else
		{
			nCheckCountFirstDetect = 0;
		}

        dRealPositionOfMostPositive = (dRealPositionOfNow>dRealPositionOfMostPositive)?dRealPositionOfNow:dRealPositionOfMostPositive;
    }

	if((bDetectFirst == true) && (m_mccparam.dMarkFirstDetectSpeed == 0.0))
	{
		m_mccparam.dMarkFirstDetectSpeed = dSpeedOfNow;
	}
	if(bDetectSecond == true)
	{
		if(m_mccparam.dMarkSecondDetectSpeed == 0.0)
		{
			m_mccparam.dMarkSecondDetectSpeed = dSpeedOfNow;
		}
		else if(m_mccparam.bPreRearSensorDetect == true)
		{
			m_mccparam.nRearSensorHauntingCount++;
			m_mccparam.bPreRearSensorDetect = false;
		}
	}
	else
	{
        if(m_mccparam.dMarkSecondDetectSpeed != 0.0)
		{
			m_mccparam.bPreRearSensorDetect = true;
		}
    }

	// Read ID
	if(IsManual==true && nTmpID!=0)
    {
        nTmpTargetID = nTmpID;
		ADD_LOG("D_259/%d/%d", nTmpID, nTmpTargetID);
    }

	if((nTmpID!=0)&& (nTmpTargetID!=0))
    {
		bIdReaded = true;

		//// 300mm 대응 무시 구간 추가 코드 puting
		if((nReadedID != nTmpID)  && (nTmpTargetID != nTmpID))
		{
			dRealPositionOfIdReaded = dRealPositionOfNow+180;
			dRealPositionOfFirstDetectCheck = dRealPositionOfNow+100;  //E250로직으로인해추가됨.
			bCheckFirstDetectInterlock = false;
			bCheckInit  = true;
			bCheckInitStop = true;
		}


		if(nReadedID != nTmpID)
		{
			ADD_LOG("D_260/%d/%6.1lf/%6.11f/%6.1lf/%6.1lf/%6.1lf/%d/%d"
				, bIdReaded
				, dRealPositionOfIdReaded
				, dRealPositionOfNow
				, dRealPositionOfFirstDetect
				, dRealPositionOfSecondDetect
				, dRealPositionOfSmallAddCheck
				, nReadedID
				, nTmpID);
		}

		nReadedID = nTmpID;
    }


	//2 주행 중 이전 Tag 만난 경우 채터링
#if 1
    if(bIgnoreFrontRearDetect==true)
	{
//		ADD_LOG("D_261/%f/%f",dRealPositionOfNow,dRealPositionOfIdReaded);
		//// 300mm 대응 무시 구간 추가 코드 puting
		if(((dRealPositionOfNow<(dRealDistSumToTarget-280)) && (dRealDistSumToTarget > 280)) ||
			(dRealPositionOfNow < dRealPositionOfIdReaded))
		{

//			memset(&PreMarkState, 0x00, sizeof(DRIVING_MARK_STATE));
//			memset(pMarkState, 0x00, sizeof(DRIVING_MARK_STATE));

			if((bDetectFirst==true) || (bDetectSecond==true))
			{
				bDetectFirst = false;
				bDetectSecond = false;
				bNoSensorDetected = true;
				bPauseSecondSmallMove=false;
			}
		}
		else
		{
			dRealPositionOfIdReadedCheckingPoint = dRealPositionOfNow;

			bIgnoreFrontRearDetect=false;// 무시 구간 지나가면 동일 처리
			if(bDetectFirst==true)
			{
				bNoSensorDetected = (bDetectFirst==false&&bDetectSecond==false)?true:false;
				bPauseSecondSmallMove = (bNoSensorDetected==true)?true:false;
//				PreMarkState.OnRoutineIn = false;
			}
			//// 300mm 대응 무시 구간 추가 코드 puting
			memset(&PreMarkState, 0x00, sizeof(DRIVING_MARK_STATE));
			memset(pMarkState, 0x00, sizeof(DRIVING_MARK_STATE));
		}
	}else
	{
		//특수구간 지난 이후에 Front 센서 감지유무 확인 puting
		if((bDetectFirst) && (bCheckFrontBackStep ==false))
		{
			nCountFrontDetect++;
			if(nCountFrontDetect >1)
			{
				bCheckFrontBackStep = true;
				if(dRealDistSumToTarget >150.0)
					dRealCheckFrontBackPoint = dRealPositionOfNow+180.0; //front감지된 최초 위치 설정.
				else
				   	dRealCheckFrontBackPoint = dRealDistSumToTarget+30.0;

				ADD_LOG("D_262/%6.11f/%6.11f",dRealCheckFrontBackPoint,dRealDistSumToTarget);
			}
		}
	}
#endif

    //2 First 만나고 일정 거리 경과 및 감속 후, 두번째 Small Add(저속) 지연해서 실시 하기 위해
    if((bNoSensorDetected==true) && ((bDetectFirst==true)||(bDetectSecond==true)) )
    {
        bNoSensorDetected=false;
        dRealPositionOfFirstMetWithNoDetectStart = dRealPositionOfNow;
    }
    if((bNoSensorDetected==false)&&(bPauseSecondSmallMove==true))
    {
        if(((dRealPositionOfNow-dRealPositionOfFirstMetWithNoDetectStart)<(MarkParam.Dist.dAddDistAfetrFirstMet/2))||
            (dSpeedOfNow>(dRefSpeedOnSecondMeet+2.0)))  //2.0 은 안전율 ( 1.0m/s2 감속 시 0.2초동안 감속되는 속도 )
        {
            bPauseSecondSmallMove=false;
        }
        else
        {
			ADD_LOG("D_263/%d/%6.1lf/%6.1lf/%6.1lf/%d/%6.1lf/%6.1lf",
				((dRealPositionOfNow-dRealPositionOfFirstMetWithNoDetectStart)<(MarkParam.Dist.dAddDistAfetrFirstMet/2)),
                dRealPositionOfNow, dRealPositionOfFirstMetWithNoDetectStart, MarkParam.Dist.dAddDistAfetrFirstMet,
                (dSpeedOfNow>(dRefSpeedOnSecondMeet+2.0)),
				dSpeedOfNow, dRefSpeedOnSecondMeet);
		}
	}

	//E231x Auto Recovery 유형 1 대응 Rear가 한번이라도 인식된 경우
	if(m_bE231xAutoRecovery ==false&& bDetectFirst ==  true /*&& bDetectSecond == false*/ &&m_bE250AutoRecoveryFlag==false&& dRealPositionOfSecondDetect > dCheckRealPositionOfFirstDetect &&
	(dRealPositionOfSecondDetect - dCheckRealPositionOfFirstDetect > STATION_FRONT_REAR_DIST/*Front,Rear Spec 155 ± 2.5*/  && dRealPositionOfSecondDetect - dCheckRealPositionOfFirstDetect < STATION_FRONT_REAR_DIST+2.0))          // 절대값으로 안하면 이전 인식위치는 아님
	{
		if(bRearCheckFirst == false && bDetectSecond == true)
		{
			m_dE231xAutoRecoveryDist = dRealPositionOfSecondDetect;
			bRearCheckFirst = true;
			m_dE231xFront2RearDist = dRealPositionOfSecondDetect - dCheckRealPositionOfFirstDetect;
			ADD_LOG("[AutoRecovery][E231x-유형1]AutoRecovery STEP - 1-1, Recovery Ready, dRealPositionOfNow : %f,dCheckRealPositionOfFirstDetect : %f, m_dE231xAutoRecoveryDist : %f, m_dE231xFront2RearDist : %f",dRealPositionOfNow, dCheckRealPositionOfFirstDetect,m_dE231xAutoRecoveryDist,m_dE231xFront2RearDist);
		}
		if(bRearCheckFirst == true && bDetectSecond == false)
		{
			m_bE231xAutoRecovery = true;
			m_bE231xAutoRecoveryCase2 = false;   //case1 진입 시, case2 불가하도록 추가
			ADD_LOG("[AutoRecovery][E231x-유형1]AutoRecovery STEP - 1-2, Recovery Start, dRealPositionOfNow : %f, dRealPositionOfSecondDetect : %f, dCheckRealPositionOfFirstDetect : %f, m_dE231xAutoRecoveryDist : %f ",dRealPositionOfNow, dRealPositionOfSecondDetect,dCheckRealPositionOfFirstDetect,m_dE231xAutoRecoveryDist);

		}

	}
	//E231x Auto Recovery 유형2,4 Rear가 한번도 인식 안된 경우
	if(m_bE231xAutoRecoveryCase2 ==  false&& bRearCheckFirst ==false && bDetectFirst ==  true && bDetectSecond == false && m_bE250AutoRecoveryFlag == false && dRealPositionOfNow - dCheckRealPositionOfFirstDetect > STATION_FRONT_REAR_DIST/*Front,Rear Spec 155 ± 2.5*/ && dRealPositionOfNow - dCheckRealPositionOfFirstDetect < STATION_FRONT_REAR_DIST+5.0/*Front Off되는 case확인 시 159 ~ 160mm*/ && dCheckRealPositionOfFirstDetect < dRealPositionOfNow )
	{
		m_bE231xAutoRecoveryCase2 = true;
		m_dE231xFront2CurPositionDist = dRealPositionOfNow - dCheckRealPositionOfFirstDetect;
		ADD_LOG("[AutoRecovery][E231x-유형2]AutoRecovery STEP - 1, Recovery Start,dRealPositionOfNow : %f,dCheckRealPositionOfFirstDetect : %f ", dRealPositionOfNow,dCheckRealPositionOfFirstDetect);

	}


	//2 근접 제어 센서를 Off 및 무시 시키는 조건
	//if(pMarkState->FollowCtrlOffArea==false)
	if(CanIgnoreVHLDetect())
	{
		if(bDetectFirst==true)
		{
			//대차 무시설정
			if((bIsOHTDetectIngnore == true) || (PreMarkState.SecondMet==true))
			{
				m_pDrivingAxis->SetVHLDetectIgnor();
				m_bIsAMCVHLDetectIgnore = true;
				ADD_LOG("D_264/%6.1lf", dRealPositionOfNow - dRealPositionOfFirstDetect);
			}
		}
	}

	//AOHC-249 BCR READ TRIGGER SEQUENCE 개선
	//AS_IS : Trans_F Met이후 80mm 지점부터 Trigger On #Jrespect.im 2019.08.26
	//TO_BE : Trans_F Met이후 Data Readed인(길이 1이상)경우 바로 S/W Trigger On, Data Read Fail인 경우(아무것도 없는 경우) 200ms 주기로 S/W Trigger On
    if(bDetectFirst==true)
	{
		//1-2 H/W Trigger로 읽힌 Data가 Error인 경우 S/W BCR READ TRIGGER ON (200ms주기)
		//BCR DATA가 읽히지 않은 경우 200ms대기 후 Trigger On
		if(nReadedID == false)
		{
			if(OHTUTILITY::PreventOverflowGetTimeMs( dwWaitHwBCRTrgTime) > 200)    //20191104 KDS
			{
				*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON; //DrivingControl::markOnTagStation
				dwWaitHwBCRTrgTime = timeGetTime();
				ADD_LOG("D_267/%6.1lf", dRealPositionOfNow - dRealPositionOfFirstDetect);
                                m_mccparam.nBCRTriggerCount++;
			}
		}

	}
	else
	{
		dwWaitHwBCRTrgTime = timeGetTime();
	}


	if(pMarkState->FollowCtrlOffArea==false)
	{
		if(PreMarkState.Arrived==true)
			pMarkState->FollowCtrlOffArea=true;
    }
//////////////////////////////////////////////////////////////////////////////

	if(pMarkState->FollowCtrlOffArea==false)
	{
		if(PreMarkState.Arrived==true)
		{
			pMarkState->FollowCtrlOffArea=true;
		}
	}

	// --------------------------------------------------------------------------------------------------------------------------------------
	//1 0. 에러 처리
	// --------------------------------------------------------------------------------------------------------------------------------------

	 //AutoRecovery Case 2
	 if(m_bE231xAutoRecoveryCase2_DistCheck == true && m_bE231xAutoRecoveryCase2 == true&&(bDetectFirst ==  false || bDetectSecond == false)&&(dRealPositionOfNow < dRealDistSumToTarget))  //case2는 Target 지점 도달 후 한바퀴 돌릴 목적
	{
	   if(m_nAutoRecoveyCount >= 1)
	   {
			if(nTmpTargetID == AR_CurStation)
			{
				ADD_LOG("[AutoRecovery][E231x]AutoRecovery,%d회 수행Fail........;;;",m_nAutoRecoveyCount);
				m_nAutoRecoveyCount =0;
				AR_CurStation =0;
				pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
				pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
				nTmpError = ERR_NOTMATCH_TAGLENGTH_FINALSTATION_TAG_MET_LATE;
			}
			else
			m_nAutoRecoveyCount = 0;

	   }
	   else
	   {
			m_nAutoRecoveyCount++;

			m_DiagManager->IncreasePreviosDiagCount(PREVIOS_DIAG_TBT);
			m_mccparam.bBCRReadFail = true;

			ADD_MD_LOG("AutoRecovery Cur Station : %d",nTmpTargetID);
			ADD_LOG("[AutoRecovery][E231x]AutoRecovery,%d회 수행/m_bE231xAutoRecoveryCase2_DistCheck :%d/m_bE231xAutoRecoveryCase2:%d/m_bE231xAutoRecovery:%d/m_bE231xAutoRecovery_RearCheck:%d"
			,m_nAutoRecoveyCount,m_bE231xAutoRecoveryCase2_DistCheck,m_bE231xAutoRecoveryCase2,m_bE231xAutoRecovery,m_bE231xAutoRecovery_RearCheck);
		   ADD_LOG("[AutoRecovery][E231x]AutoRecovery ,bDetectFirst:%d,bDetectSecond:%d dRealPositionOfNow : %f, m_dChekRearDist: %f, dRealDistSumToTarget:%f",bDetectFirst,bDetectSecond,dRealPositionOfNow,m_dChekRearDist,dRealDistSumToTarget);

			nTmpError = ERR_BCR_READTIMEOUT;       //오버런을 위해 E402로 발생함..
			*pnID = nTmpTargetID;//nTmpTargetID;//ID_NONE;/ID_NONE;

			//오버런 처리
			m_pExecuteInfo->FlagOverRunInfo.bCheck = true;
			m_pExecuteInfo->FlagOverRunInfo.OverrunType = 0x02; //이적재
			m_pExecuteInfo->FlagOverRunInfo.nFinalNode = nTmpTargetID;    //주행은 주행, 이적재는 이적재
			m_PositionInfo.CurrStation = nTmpTargetID;
			m_pExecuteInfo->FlagOverRunInfo.dDrivingInitPosition = 0.0;
			AR_CurStation = nTmpTargetID;
			MarkRetryErrorCase = AUTORECOVERY_E231X_CASE2;

				AUTO_RECOV_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,STATION MARK RECOVERY,End,%s,%06d,%06d,%06d,%d,%3.3lf,Mark Type,%d,Station Mark Dist,%6.1lf,Station Sensor Dist,%6.1lf,Station Mark Start Speed,%3.3lf,Station Mark First Detect Speed,%3.3lf,Station Mark Second Detect Speed,%3.3lf,Front Sensor Haunting Count,%d,Rear Sensor Haunting Count,%d,Mark Retry Error Case,%d,Mark Retry Strart Dist Case1,%3.3lf,Mark Retry Strart Dist Case2,%3.3lf,Mark Retry Case2 Front Haunting Count,%d,E250 Mark Complete Dist,%3.3lf,E250 Mark Rear Off Dist,%3.3lf,Mark Comp,%d,CurrentPos,%6.1lf,FrontDetectpos,%6.1lf,RearDetectpos,%6.1lf",
							m_defualtparam->VHLName,m_mccparam.cCarrierType,
							m_mccparam.uSourceNode,
							m_mccparam.uTargetNode,
							m_pExecuteInfo->ExecutePositionInfo.CurrNode,
							m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
							dSpeedOfNow,
							m_InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType,
							dRealPositionOfFirstDetect - m_mccparam.dMarkStartDist,
							dRealPositionOfSecondDetect - dRealPositionOfFirstDetect,
							m_mccparam.dMarkStartSpeed,
							m_mccparam.dMarkFirstDetectSpeed,
							m_mccparam.dMarkSecondDetectSpeed,
							m_mccparam.nFrontSensorHauntingCount,
							m_mccparam.nRearSensorHauntingCount,
							MarkRetryErrorCase,m_dE231xFront2RearDist,m_dE231xFront2CurPositionDist,m_nE231xAutoRecoveryCase2Count,m_dE250RearOnPosition,m_dE250RearOffPosition,bCheckMarkComp, dRealPositionOfNow,dCheckRealPositionOfFirstDetect,dRealPositionOfSecondDetect);

//initInfoSet();에서 초기화하므로 해당 로직에서 초기화 불필요
//			m_mccparam.bMarkStartFlag = false;
//			m_mccparam.dMarkStartSpeed = 0.0;
//			m_mccparam.dMarkStartDist = 0.0;
//			m_mccparam.nFrontSensorHauntingCount = 0;
//			m_mccparam.nRearSensorHauntingCount = 0;
//			m_mccparam.dMarkFirstDetectSpeed = 0.0;
//			m_mccparam.dMarkSecondDetectSpeed = 0.0;
	   }
		return nTmpError;
	}

	if(dRealPositionOfNow > dRealDistSumToTarget + dForwardLimit)
	{
        pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
		pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
		nTmpError = ERR_NOTMATCH_TAGLENGTH_FINALSTATION_TAG_MET_LATE;

		ERR_LOG("[Tag] ERR_NOTMATCH_TAGLENGTH_FINALSTATION_TAG_MET_LATE : %6.1lf > %6.1lf (%6.1lf + %6.1lf) Pos=%6.1lf(F:%6.1lf,R:%6.1lf,S:%6.1lf)"
            , dRealPositionOfNow, dRealDistSumToLimit, dRealDistSumToTarget, dForwardLimit
            , dRealPositionOfNow
            , dRealPositionOfFirstDetect
			, dRealPositionOfSecondDetect
            , dRealPositionOfSmallAddCheck
            );
		ADD_FDC_LOG("ERR/%d/2/6/%06d/%06d/%d/%d/%06d/%f",
					ERR_NOTMATCH_TAGLENGTH_FINALSTATION_TAG_MET_LATE,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pExecuteInfo->ExecutePositionInfo.NextNode,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					m_pOHTMainStatus->StatusCommon.ExistFoup,
					m_pOHTMainStatus->StatusCommon.StopStationID,
					dRealPositionOfNow - (dRealDistSumToTarget + dForwardLimit));
        return nTmpError;
	}
	else if(dRealPositionOfNow<(dRealPositionOfMostPositive-MarkParam.Dist.dBackMoveDistLimit))
    {
        pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
		pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;

		if(((fabs(dRealPositionOfNow - dRealPositionOfSecondDetect)) > 40.0) ||
		   (m_ClassifiedCmd.TargetInfo.dOffset < 250) ||
		   ((m_ClassifiedCmd.TargetInfo.dLength - m_ClassifiedCmd.TargetInfo.dOffset) < 250))
		{
		  nTmpError = ERR_NOTMATCH_TAGLENGTH_FINALSTATION_TAG_MOVE_BACK_LIMIT;

		  	ERR_LOG("[Tag] ERR_NOTMATCH_TAGLENGTH_FINALSTATION_TAG_MOVE_BACK_LIMIT : %6.1lf < %6.1lf (%6.1lf - %6.1lf) Pos=%6.1lf(F:%6.1lf,R:%6.1lf,S:%6.1lf)"
            , dRealPositionOfNow, (dRealPositionOfMostPositive-MarkParam.Dist.dBackMoveDistLimit)
            , dRealPositionOfMostPositive, MarkParam.Dist.dBackMoveDistLimit
			, dRealPositionOfNow
            , dRealPositionOfFirstDetect
			, dRealPositionOfSecondDetect
			, dRealPositionOfSmallAddCheck
			);
			ADD_FDC_LOG("ERR/%d/1/8/%06d/%06d/%d/%d/%06d/%f/%f/%f",
					ERR_NOTMATCH_TAGLENGTH_FINALSTATION_TAG_MOVE_BACK_LIMIT,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pExecuteInfo->ExecutePositionInfo.NextNode,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					m_pOHTMainStatus->StatusCommon.ExistFoup,
					m_pOHTMainStatus->StatusCommon.StopStationID,
					dRealPositionOfNow,
					dRealPositionOfMostPositive,
					MarkParam.Dist.dBackMoveDistLimit);
		}
		else //OverRun 1회 실시 후 Error처리
		{
			//AOHC-374
			if((m_OverRunCount >= 1) || (m_pExecuteInfo->nFinishOfStation != nTmpTargetID))
			{
			   m_OverRunCount = 0;
			   nTmpError = ERR_NOTMATCH_TAGLENGTH_FINALSTATION_TAG_MOVE_BACK_LIMIT;
               ERR_LOG("[OverRun Retry] ERR_NOTMATCH_TAGLENGTH_FINALSTATION_TAG_MOVE_BACK_LIMIT : %6.1lf < %6.1lf (%6.1lf - %6.1lf) Pos=%6.1lf(F:%6.1lf,R:%6.1lf,S:%6.1lf)"
				, dRealPositionOfNow, (dRealPositionOfMostPositive-MarkParam.Dist.dBackMoveDistLimit)
				, dRealPositionOfMostPositive, MarkParam.Dist.dBackMoveDistLimit
				, dRealPositionOfNow
				, dRealPositionOfFirstDetect
				, dRealPositionOfSecondDetect
				, dRealPositionOfSmallAddCheck
				);
				ADD_FDC_LOG("ERR/%d/2/8/%06d/%06d/%d/%d/%06d/%f/%f/%f",
					ERR_NOTMATCH_TAGLENGTH_FINALSTATION_TAG_MOVE_BACK_LIMIT,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pExecuteInfo->ExecutePositionInfo.NextNode,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					m_pOHTMainStatus->StatusCommon.ExistFoup,
					m_pOHTMainStatus->StatusCommon.StopStationID,
					dRealPositionOfNow,
					dRealPositionOfMostPositive,
					MarkParam.Dist.dBackMoveDistLimit);
			}
			else
			{
				m_OverRunCount++;
				m_DiagManager->IncreasePreviosDiagCount(PREVIOS_DIAG_TBT);
				m_mccparam.bBCRReadFail = true;
				ADD_MD_LOG("TBT Cur Station 4 : %d",nTmpTargetID);
				nTmpError = ERR_BCR_READTIMEOUT;       //오버런을 위해 E402로 발생함..
				*pnID = nTmpTargetID;//nTmpTargetID;//ID_NONE;/ID_NONE;

				//오버런 처리
				m_pExecuteInfo->FlagOverRunInfo.bCheck = true;
				m_pExecuteInfo->FlagOverRunInfo.OverrunType = 0x02; //이적재
				m_pExecuteInfo->FlagOverRunInfo.nFinalNode = nTmpTargetID;    //주행은 주행, 이적재는 이적재
				m_PositionInfo.CurrStation = nTmpTargetID;
				m_pExecuteInfo->FlagOverRunInfo.dDrivingInitPosition = 0.0;

				m_PositionInfo.CurrStation = nTmpTargetID;

				ERR_LOG("[OverRun] ERR_NOTMATCH_TAGLENGTH_FINALSTATION_TAG_MOVE_BACK_LIMIT : %6.1lf < %6.1lf (%6.1lf - %6.1lf) Pos=%6.1lf(F:%6.1lf,R:%6.1lf,S:%6.1lf)"
				, dRealPositionOfNow, (dRealPositionOfMostPositive-MarkParam.Dist.dBackMoveDistLimit)
				, dRealPositionOfMostPositive, MarkParam.Dist.dBackMoveDistLimit
				, dRealPositionOfNow
				, dRealPositionOfFirstDetect
				, dRealPositionOfSecondDetect
				, dRealPositionOfSmallAddCheck
				);

			}
		}



        return nTmpError;
    }

    // --------------------------------------------------------------------------------------------------------------------------------------
    //1 1. Second 감지된 경우
    // --------------------------------------------------------------------------------------------------------------------------------------
    if( bDetectSecond==true )
	{
		bIsOHTDetectIngnore = true;
        //2 1) 마크 루틴 완료 후 id를 확인하는 절차
		if( PreMarkState.IdCheck==true)
		{
            if(pnID==NULL)
            {
				*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_NONE;
                pMarkState->Arrived = true;
            }
            else
            {
                if(bIdReaded==true)
				{
					if(nTmpTargetID == nReadedID)
					{
						*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_NONE;

						if(m_bE250AutoRecoveryFlag != true)
						{
						ADD_LOG("D_271/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%d"
							, dRealPositionOfNow
							, dRealPositionOfFirstDetect
							, dRealPositionOfSecondDetect
							, dRealPositionOfSmallAddCheck
							, dRealDistSumToTarget
							, nTmpTargetID
							);
                        }

						if(m_bE231xAutoRecoveryCase2 == true && bDetectFirst==true)
						   m_bE231xAutoRecoveryCase2 = false; // mark 완료 시 Auto Recovery case2 안타게 하기 위해서

					   if(((dCheckRealPositionOfFirstDetect !=0.0) &&      //처음위치가 Front on인 경우 무시
						  (dRealPositionOfSecondDetect > m_pParamSet->ScatteredReflection) &&  //처음위치가 Front On인 경우 무시
						  (( (dRealPositionOfSecondDetect - dCheckRealPositionOfFirstDetect) < STATION_FRONT_REAR_DIST - 5.0 /*150.0*/ && m_mccparam.nRearSensorHauntingCount > 2 ) ||
					   ((dRealPositionOfSecondDetect - dCheckRealPositionOfFirstDetect) <  (m_pParamSet->ScatteredReflection * dFirstDetectPercent) )))
						 || (m_bE250AutoRecoveryFlag ==true))
					   {
						   //현재 Rear 인식된 위치(현재위치) - Front 인식된 위치 >153 (150?)
						   //최초 E250 진입이 Auto Recovery 수행 유무 판단 부분
						   m_bIsRecovery = true;
						   //STATION_FRONT_REAR_DIST 값에 따라서 Mask 130 ~ 141, 그 외 재하150 ~ 161 구분
						   if(( m_bE250AutoRecoveryFlag==false)&&((dRealPositionOfNow - dCheckRealPositionOfFirstDetect)>STATION_FRONT_REAR_DIST - 5.0/*150*/ && (dRealPositionOfNow - dCheckRealPositionOfFirstDetect)<STATION_FRONT_REAR_DIST + 6.0/*161*/ ))   //수치는 어디까지 적용할지 검토
						   {
								m_bE250AutoRecoveryFlag = true;
								MarkRetryErrorCase = AUTORECOVERY_E250;

								AUTO_RECOV_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,STATION MARK RECOVERY,Start,%s,%06d,%06d,%06d,%d,%3.3lf,Mark Type,%d,Mark Retry Error Case,%d",
								m_defualtparam->VHLName,m_mccparam.cCarrierType,
								m_mccparam.uSourceNode,
								m_mccparam.uTargetNode,
								m_pExecuteInfo->ExecutePositionInfo.CurrNode,
								m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
								dSpeedOfNow,
								m_InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType,MarkRetryErrorCase);

						   }



						   //E250 Recovery 수행에 의해 처리되는 부분
						   if(m_bE250AutoRecoveryFlag == true)
						   {
							   if(bStopWithoutFrontDetect==true)
							   {
									if(/*bDetectSecond==true && */m_bE250RearOnCheck == true)  // Recovery 이동 후 Rear 센서 On 상태로 마크 처리
									{
										if((dRealPositionOfNow - dCheckRealPositionOfFirstDetect)>STATION_FRONT_REAR_DIST - 5.0 /*150.0*/ && (dRealPositionOfNow - dCheckRealPositionOfFirstDetect)<STATION_FRONT_REAR_DIST + 6.0/*161.0*/ )   //수치는 어디까지 적용할지 검토
										{
											m_dStationMarkInpos = dRealPositionOfNow; //최종 현재 위치 저장
											*pnID = nTmpTargetID;
											pMarkState->Arrived = true;
											m_OverRunCount = 0;
											m_nAutoRecoveyCount =0;
											AR_CurStation =0;
											nCheckAutoRecoveryTry = 0;
											m_bE250AutoRecoveryFlag = false;
											MarkRetryErrorCase = AUTORECOVERY_E250;
											bCheckMarkComp = true;
											m_dE250RearOnPosition = dRealPositionOfNow-dCheckRealPositionOfFirstDetect;
											ADD_LOG("[AutoRecovery][E250] Auto Recovery success");

												AUTO_RECOV_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,STATION MARK RECOVERY,End,%s,%06d,%06d,%06d,%d,%3.3lf,Mark Type,%d,Station Mark Dist,%6.1lf,Station Sensor Dist,%6.1lf,Station Mark Start Speed,%3.3lf,Station Mark First Detect Speed,%3.3lf,Station Mark Second Detect Speed,%3.3lf,Front Sensor Haunting Count,%d,Rear Sensor Haunting Count,%d,Mark Retry Error Case,%d,Mark Retry Strart Dist Case1,%3.3lf,Mark Retry Strart Dist Case2,%3.3lf,Mark Retry Case2 Front Haunting Count,%d,E250 Mark Complete Dist,%3.3lf,E250 Mark Rear Off Dist,%3.3lf,Mark Comp,%d,Currentpos,%6.1lf,FrontDetectpos,%6.1lf,RearDetectpos,%6.1lf",
														m_defualtparam->VHLName,m_mccparam.cCarrierType,
														m_mccparam.uSourceNode,
														m_mccparam.uTargetNode,
														m_pExecuteInfo->ExecutePositionInfo.CurrNode,
														m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
														dSpeedOfNow,
														m_InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType,
														dRealPositionOfFirstDetect - m_mccparam.dMarkStartDist,
														dRealPositionOfSecondDetect - dRealPositionOfFirstDetect,
														m_mccparam.dMarkStartSpeed,
														m_mccparam.dMarkFirstDetectSpeed,
														m_mccparam.dMarkSecondDetectSpeed,
														m_mccparam.nFrontSensorHauntingCount,
														m_mccparam.nRearSensorHauntingCount,
															MarkRetryErrorCase,m_dE231xFront2RearDist,m_dE231xFront2CurPositionDist,m_nE231xAutoRecoveryCase2Count,m_dE250RearOnPosition,m_dE250RearOffPosition,bCheckMarkComp,dRealPositionOfNow,dCheckRealPositionOfFirstDetect,dRealPositionOfSecondDetect);
												//Arrived되면,STATION MARK, End에서 데이터 로그 남길때 기록안됨.(확인 필요)
													//initInfoSet();에서 초기화하므로 해당 로직에서 초기화 불필요
		//										m_mccparam.bMarkStartFlag = false;
		//										m_mccparam.dMarkStartSpeed = 0.0;
		//										m_mccparam.dMarkStartDist = 0.0;
		//										m_mccparam.nFrontSensorHauntingCount = 0;
		//										m_mccparam.nRearSensorHauntingCount = 0;
		//										m_mccparam.dMarkFirstDetectSpeed = 0.0;
		//										m_mccparam.dMarkSecondDetectSpeed = 0.0;
										}
										else	//E250 Retry 실패 시
										{
											nTmpError = ERR_MARK_RSTOPSEN_OFF;
											ADD_LOG("[E250]AutoRecovery Error 2");
										}
									}
									//Auto Recovery로 앞으로 이동, Rear 센서 Off될때까지
									else if(OHTUTILITY::PreventOverflowGetTimeMs(dwE250RecoveryCheckTime)> 300)
									{

										if(nCheckAutoRecoveryTry < 5)
										{
											nCheckAutoRecoveryTry++;

											dwE250RecoveryCheckTime = dwCurrTime;

											pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet;
											pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;
											pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfSecondMet);

											pCtrlInfo->Dynamic.dDist    = dRealPositionOfNow + 1.0;

											memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));

											pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;
											ADD_LOG("[AutoRecovery][E250]AutoRecovery STEP - 2, Recovering..... CheckAutoRecoveryTry : %d",nCheckAutoRecoveryTry);
										}else
										{
											nTmpError = ERR_MARK_RSTOPSEN_OFF;
											ADD_LOG("[E250]AutoRecovery Error 1");
										}
									}
								}

						   }
						   else
						   {
								if(((fabs(dRealPositionOfNow - dRealPositionOfSecondDetect)) > 40.0) ||
								(m_ClassifiedCmd.TargetInfo.dOffset < 250) ||
								((m_ClassifiedCmd.TargetInfo.dLength - m_ClassifiedCmd.TargetInfo.dOffset) < 250))
								{
									pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
									pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
									nTmpError = ERR_MARK_RSTOPSEN_OFF;
									ADD_LOG("ERR_MARK_RSTOPSEN_OFF_1");
									ADD_FDC_LOG("ERR/%d/1/8/%06d/%06d/%d/%d/%06d/%d/%6.1lf/%6.1lf",
												ERR_MARK_RSTOPSEN_OFF,
												m_pOHTMainStatus->StatusCommon.CurNodeID,
												m_pExecuteInfo->ExecutePositionInfo.NextNode,
												m_pOHTMainStatus->StatusCommon.CurNodeOffset,
												m_pOHTMainStatus->StatusCommon.ExistFoup,
												m_pOHTMainStatus->StatusCommon.StopStationID,
												bAxis1InPosition,
												dRealPositionOfNow,
												dRealPositionOfSmallAddCheck);
								}
								else
								{
									if(m_OverRunCount >= 1)
									{
									   m_OverRunCount = 0;
									   nTmpError = ERR_MARK_RSTOPSEN_OFF;
									   ADD_LOG("D-161");
									   ADD_FDC_LOG("ERR/%d/1/8/%06d/%06d/%d/%d/%06d/%d/%6.1lf/%6.1lf",
												ERR_MARK_RSTOPSEN_OFF,
												m_pOHTMainStatus->StatusCommon.CurNodeID,
												m_pExecuteInfo->ExecutePositionInfo.NextNode,
												m_pOHTMainStatus->StatusCommon.CurNodeOffset,
												m_pOHTMainStatus->StatusCommon.ExistFoup,
												m_pOHTMainStatus->StatusCommon.StopStationID,
												bAxis1InPosition,
												dRealPositionOfNow,
												dRealPositionOfSmallAddCheck);
									}
									else
									{
										//AOHC-374
										if(m_pExecuteInfo->nFinishOfStation == nTmpTargetID)
										{
											m_OverRunCount++;
											nTmpError = ERR_BCR_READTIMEOUT;       //오버런을 위해 E402로 발생함..
											*pnID = nTmpTargetID;//nTmpTargetID;//ID_NONE;/ID_NONE;

											//오버런 처리
											m_pExecuteInfo->FlagOverRunInfo.bCheck = true;
											m_pExecuteInfo->FlagOverRunInfo.OverrunType = 0x02; //이적재
											m_pExecuteInfo->FlagOverRunInfo.nFinalNode = nTmpTargetID;    //주행은 주행, 이적재는 이적재
											m_PositionInfo.CurrStation = nTmpTargetID;
											m_pExecuteInfo->FlagOverRunInfo.dDrivingInitPosition =0.0;

											m_PositionInfo.CurrStation = nTmpTargetID;
											ADD_LOG("D-162");
										}
										else
										{
											ERR_LOG("[Check]AOHC-374_2/%d",nTmpTargetID);
											m_dStationMarkInpos =dRealPositionOfNow; //최종 현재 위치 저장
											pMarkState->Arrived = true;
											*pnID = nTmpTargetID;//nTmpTargetID;//ID_NONE;/ID_NONE;
											m_OverRunCount = 0;
											m_nAutoRecoveyCount =0;
											AR_CurStation =0;
										}

									}
								}
						   }
					   }
					   else
					   {
							if((dRealPositionOfNow - dCheckRealPositionOfFirstDetect) < STATION_FRONT_REAR_DIST - 5.0 ||(dRealPositionOfSecondDetect-dCheckRealPositionOfFirstDetect)< STATION_FRONT_REAR_DIST - 5.0 )
							{
                              	m_bIsRecovery = true;
								ERR_LOG("Mark Complete-m_bIsRecovery = true");
                            }
							m_dStationMarkInpos =dRealPositionOfNow; //최종 현재 위치 저장
							*pnID = nTmpTargetID;//nTmpTargetID;//ID_NONE;/ID_NONE;
							pMarkState->Arrived = true;
							m_OverRunCount = 0;
							m_nAutoRecoveyCount =0;
							AR_CurStation =0;
							ERR_LOG("m_nAutoRecoveyCount:%d, AR_CurStation:%d",m_nAutoRecoveyCount,AR_CurStation);
					   }

					}
					else
					{
						*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_NONE;
						pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
						pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;

						////AOHC-374
						if(m_pExecuteInfo->nFinishOfStation == nTmpTargetID)
						{
							m_DiagManager->IncreasePreviosDiagCount(PREVIOS_DIAG_TBT);
							m_mccparam.bBCRReadFail = true;
							ADD_MD_LOG("TBT Cur Station 5 : %d",nTmpTargetID);
							nTmpError = ERR_BCR_READTIMEOUT;
							*pnID = nTmpTargetID;//nTmpTargetID;//ID_NONE;/ID_NONE;
													//오버런 처리
							m_pExecuteInfo->FlagOverRunInfo.bCheck = true;
							m_pExecuteInfo->FlagOverRunInfo.OverrunType = 0x02; //이적재
							m_pExecuteInfo->FlagOverRunInfo.nFinalNode = nTmpTargetID;    //주행은 주행, 이적재는 이적재
							m_PositionInfo.CurrStation = nTmpTargetID;
							m_pExecuteInfo->FlagOverRunInfo.dDrivingInitPosition =0.0;

							ADD_FDC_LOG("ERR/%d/2/6/%06d/%06d/%d/%d/%06d/2",
											ERR_BCR_READTIMEOUT,
											m_pOHTMainStatus->StatusCommon.CurNodeID,
											m_pExecuteInfo->ExecutePositionInfo.NextNode,
											m_pOHTMainStatus->StatusCommon.CurNodeOffset,
											m_pOHTMainStatus->StatusCommon.ExistFoup,
											m_pOHTMainStatus->StatusCommon.StopStationID);
						}
						else
						{
							ERR_LOG("[Check]AOHC-374_3/%d",nTmpTargetID);
							m_dStationMarkInpos =dRealPositionOfNow; //최종 현재 위치 저장
							*pnID = nTmpTargetID;//nTmpTargetID;//ID_NONE;/ID_NONE;
							pMarkState->Arrived = true;
							m_OverRunCount = 0;
						}

					}


				}
				else if(OHTUTILITY::PreventOverflowGetTimeMs(dwTriggerTime) > 200)
                {
					if(OHTUTILITY::PreventOverflowGetTimeMs(dwCheckTime) > 3500)// Time Over
					{
						*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_NONE;
                        pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
						pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;

						//AOHC-374
						if(m_pExecuteInfo->nFinishOfStation == nTmpTargetID)
						{
							m_DiagManager->IncreasePreviosDiagCount(PREVIOS_DIAG_TBT);
							m_mccparam.bBCRReadFail = true;
							ADD_MD_LOG("TBT Cur Station 6 : %d",nTmpTargetID);
							nTmpError = ERR_BCR_READTIMEOUT;
							*pnID = nTmpTargetID;//nTmpTargetID;//ID_NONE;/ID_NONE;

							//오버런 처리
							m_pExecuteInfo->FlagOverRunInfo.bCheck = true;
							m_pExecuteInfo->FlagOverRunInfo.OverrunType = 0x02; //이적재
							m_pExecuteInfo->FlagOverRunInfo.nFinalNode = nTmpTargetID;    //주행은 주행, 이적재는 이적재
							m_PositionInfo.CurrStation = nTmpTargetID;
							m_pExecuteInfo->FlagOverRunInfo.dDrivingInitPosition =0.0;

							m_PositionInfo.CurrStation = nTmpTargetID;

							ADD_LOG("D_272/%6.1lf/%6.1lf/%6.1lf/%6.1lf"
								, dRealPositionOfNow
								, dRealPositionOfFirstDetect
								, dRealPositionOfSecondDetect
								, dRealPositionOfSmallAddCheck );
							ADD_FDC_LOG("ERR/%d/2/6/%06d/%06d/%d/%d/%06d/2",
											ERR_BCR_READTIMEOUT,
											m_pOHTMainStatus->StatusCommon.CurNodeID,
											m_pExecuteInfo->ExecutePositionInfo.NextNode,
											m_pOHTMainStatus->StatusCommon.CurNodeOffset,
											m_pOHTMainStatus->StatusCommon.ExistFoup,
											m_pOHTMainStatus->StatusCommon.StopStationID);
						}
						else
						{
							ERR_LOG("[Check]AOHC-374_4/%d",nTmpTargetID);
							m_dStationMarkInpos =dRealPositionOfNow; //최종 현재 위치 저장
							pMarkState->Arrived = true;
                         	*pnID = nTmpTargetID;//nTmpTargetID;//ID_NONE;/ID_NONE;
						}
					}
					else
					{
						dwTriggerTime = timeGetTime();
                        *pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
						m_mccparam.nBCRTriggerCount++;
                    }
                }
            }
        }
        //2 2)  마크 루틴 처음 들어왔을 때 Rear 감지된 경우: 뒤로 5mm 이동 후 2. Front 감지 처리로 처리
        else if( PreMarkState.FirstMet == false )
        {

            // Second Met을 활성화 하지 않은 이유:  First 만나고 아래 정상 루틴으로 들어가게 하려함
            // First Met을 활성화 하지 않은 이유:       5mm 이동 완료 시 까지 이부분 계속 호출 시키려고
            pMarkState->OnRoutineIn = true;

            if( bStopWithoutFrontDetect==true && PreMarkState.OnMoveCmd==false) // 정지 시 뒤로 이동
            {
                pMarkState->OnMoveCmd=true;

                //1 >>>엔코더 값이 -10mm이하일 경우 에러 처리
                //1 >>>Small Add Move -2.5mm(Second 벗어날때까지)
                pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet; //Tag.AccelOfSecond;
                pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet; //Tag.AccelOfSecond;
                pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfSecondMet);   //Tag.SpeedOfSecond;
                pCtrlInfo->Dynamic.dDist    = dRealPositionOfNow - (2*MarkParam.Dist.dLengthOfSecond);//.LengthOfSecond);   // 현재 위치에서 Second 길이의 2배 위치까지

                memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
//              pCtrlInfo->Dynamic.AdditionalInfo.bStartOnSpeedDown     = true;
				pCtrlInfo->Dynamic.AdditionalInfo.bUseSmallAdd              = true;

#if((OHT_NAME == OHT_NAME_STD_V85) || (OHT_NAME == OHT_NAME_STD_V81S)||(OHT_NAME == OHT_NAME_STD_V85S)||(OHT_NAME == OHT_NAME_STD_V82)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
				pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 57;
#else
				pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 54;
#endif

                pCtrlInfo->Dynamic.AdditionalInfo.bIsTriggerOnRisingEdge    = true;
                pCtrlInfo->Dynamic.AdditionalInfo.dSmallDistance            = MarkParam.Dist.dAddDistAfterSecondMet;//Tag.AddLengthForSecond;

                pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;//Event.Flag.MarkEvent_SecondMet = true;
                ADD_LOG("D_273/%6.1lf/%6.1lf/%6.1lf/%6.1lf"
                    , dRealPositionOfNow
                    , dRealPositionOfFirstDetect
                    , dRealPositionOfSecondDetect
                    , dRealPositionOfSmallAddCheck
                    );
            }
        }
        //2 3)  정상 Routine으로 Rear 센서가 처음 들어온 경우: 정지 대기
        else if( PreMarkState.SecondMet==false)//pMarkStatus->StateOnSecondMet == false)
        {
            pMarkState->SecondMet = true;   //pMarkStatus->StateOnSecondMet = true;
            dRealPositionOfSecondMet = dRealPositionOfNow;
            ADD_LOG("D_274/%7.1lf/%6.1lf/%6.1lf/%6.1lf/%6.1lf"
                , HwInfo.Axis1.dCurrPos
                , dRealPositionOfNow
                , dRealPositionOfFirstDetect
                , dRealPositionOfSecondDetect
                , dRealPositionOfSmallAddCheck
                );
		}
        //2 4)  정지 한 경우: 정위치 확인 및 완료 처리
        else if( bStopWithoutFrontDetect == true )
		{

            ADD_LOG("D_275/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%6.1lf"
                , dRealPositionOfNow, dRealPositionOfSmallAddCheck
                , (dRealPositionOfNow-dRealPositionOfSmallAddCheck)
				, dRealPositionOfNow
                , dRealPositionOfFirstDetect
                , dRealPositionOfSecondDetect
                , dRealPositionOfSmallAddCheck
                );


            //1 >>>Arrived
            // 도착위치와 센서 감지 위치를 비교하여 차가 2.5mm ±0.5 이면 정상 처리함 (전진 후진에 대해 모두 처리)
			if( (fabs(dRealPositionOfNow-dRealPositionOfSmallAddCheck)<(MarkParam.Dist.dAddDistAfterSecondMet+MarkParam.Dist.dMarkInPosLimit)) &&
				(fabs(dRealPositionOfNow-dRealPositionOfSmallAddCheck)>(MarkParam.Dist.dAddDistAfterSecondMet-MarkParam.Dist.dMarkInPosLimit)) &&
				(dRealPositionOfSmallAddCheck!=0.0) && (bAxis1InPosition == true) )
			{
				if( bDetectFirst==true && bDetectSecond==true )//m_pTransStopTag->IsOnFrontSensor()==true )
                {
                    pMarkState->IdCheck=true;
                    *pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
					m_mccparam.nBCRTriggerCount++;
					dwCheckTime = dwCurrTime;   // ID 확인 되지 않을 때에 대한 TimeOut 처리 목적
					dwTriggerTime = dwCurrTime;
				}
			}
			else if( (fabs(dRealPositionOfNow-dRealPositionOfSecondDetect)<(MarkParam.Dist.dAddDistAfterSecondMet+MarkParam.Dist.dMarkInPosLimit)) &&
					(fabs(dRealPositionOfNow-dRealPositionOfSecondDetect)>(MarkParam.Dist.dAddDistAfterSecondMet-MarkParam.Dist.dMarkInPosLimit)) &&
					(dRealPositionOfSecondDetect!=0.0) && (bAxis1InPosition == true) )
			{
				if( bDetectFirst==true && bDetectSecond==true )//m_pTransStopTag->IsOnFrontSensor()==true )
				{
					pMarkState->IdCheck=true;
					*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
					m_mccparam.nBCRTriggerCount++;
					dwCheckTime = dwCurrTime;   // ID 확인 되지 않을 때에 대한 TimeOut 처리 목적
					dwTriggerTime = dwCurrTime;
				}
			}
			else    // 멈췄으나 정위치 되지 않을 때에 대한 처리
			{

				if(OHTUTILITY::PreventOverflowGetTimeMs(dwSecendCheckTime)> 300)
				{
					if(nRecoveryLimitCount4TagStation < RecoveryLimitCountForMarkOnTagStation)
					{
						if(bStopWithoutFrontDetect==true)
						{
							nRecoveryLimitCount4TagStation++;

							dwSecendCheckTime = dwCurrTime;

							pMarkState->Recovery=true;

							pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet;
							pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;
							pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfSecondMet);

							pCtrlInfo->Dynamic.dDist    = dRealPositionOfNow - 1.0;

						   //	pCtrlInfo->Dynamic.dDist    = dRealPositionOfSecondDetect+MarkParam.Dist.dAddDistAfterSecondMet;

							memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));

	//						pCtrlInfo->Dynamic.AdditionalInfo.bUseSmallAdd              = true;
	//
	//						pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 54;
	//
	//						pCtrlInfo->Dynamic.AdditionalInfo.bIsTriggerOnRisingEdge    = true;
	//						pCtrlInfo->Dynamic.AdditionalInfo.dSmallDistance            = MarkParam.Dist.dAddDistAfterSecondMet;

							pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;

							ADD_LOG("D_276/%d/%6.1lf/%6.1lf/%6.1lf/%6.1lf"
								, bAxis1InPosition
								, dRealPositionOfNow
								, dRealPositionOfSmallAddCheck
								, MarkParam.Dist.dAddDistAfterSecondMet
								, MarkParam.Dist.dMarkInPosLimit );
						}
					}
					else
					{
						nRecoveryLimitCount4TagStation = 0;

						pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
						pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
						//E2314 Overrun 조건 추가 2018.07.18 JRESPECT.IM
						if(((fabs(dRealPositionOfNow - dRealPositionOfSecondDetect)) > 40.0) ||
							(m_ClassifiedCmd.TargetInfo.dOffset < 250) ||
							((m_ClassifiedCmd.TargetInfo.dLength - m_ClassifiedCmd.TargetInfo.dOffset) < 250))
						{
							nTmpError = ERR_NOTMATCH_TAGLENGTH_FINALSTATION_IN_POSITION_ERROR;

							ADD_LOG("D_277/%d/%6.1lf/%6.1lf/%6.1lf/%6.1lf"
									, bAxis1InPosition
									, dRealPositionOfNow
									, dRealPositionOfSmallAddCheck
									, MarkParam.Dist.dAddDistAfterSecondMet
									, MarkParam.Dist.dMarkInPosLimit);
							ADD_FDC_LOG("ERR/%d/1/10/%06d/%06d/%d/%d/%06d/%%6.1lf/%%6.1lf/%%6.1lf/%%6.1lf/%d",
										ERR_NOTMATCH_TAGLENGTH_FINALSTATION_IN_POSITION_ERROR,
										m_pOHTMainStatus->StatusCommon.CurNodeID,
										m_pExecuteInfo->ExecutePositionInfo.NextNode,
										m_pOHTMainStatus->StatusCommon.CurNodeOffset,
										m_pOHTMainStatus->StatusCommon.ExistFoup,
										m_pOHTMainStatus->StatusCommon.StopStationID,
										dRealPositionOfNow,
										dRealPositionOfSmallAddCheck,
										MarkParam.Dist.dAddDistAfterSecondMet,
										MarkParam.Dist.dMarkInPosLimit,
										bAxis1InPosition);

							return nTmpError;
						}
						else
						{
							////AOHC-374
							if((m_OverRunCount >= 1)   || (m_pExecuteInfo->nFinishOfStation != nTmpTargetID))
							{
								m_OverRunCount = 0;
								nTmpError = ERR_NOTMATCH_TAGLENGTH_FINALSTATION_IN_POSITION_ERROR;
								ADD_LOG("D_278/%d/%6.1lf/%6.1lf/%6.1lf/%6.1lf"
										, bAxis1InPosition
										, dRealPositionOfNow
										, dRealPositionOfSmallAddCheck
										, MarkParam.Dist.dAddDistAfterSecondMet
										, MarkParam.Dist.dMarkInPosLimit);
								ADD_FDC_LOG("ERR/%d/2/10/%06d/%06d/%d/%d/%06d/%%6.1lf/%%6.1lf/%%6.1lf/%%6.1lf/%d",
										ERR_NOTMATCH_TAGLENGTH_FINALSTATION_IN_POSITION_ERROR,
										m_pOHTMainStatus->StatusCommon.CurNodeID,
										m_pExecuteInfo->ExecutePositionInfo.NextNode,
										m_pOHTMainStatus->StatusCommon.CurNodeOffset,
										m_pOHTMainStatus->StatusCommon.ExistFoup,
										m_pOHTMainStatus->StatusCommon.StopStationID,
										dRealPositionOfNow,
										dRealPositionOfSmallAddCheck,
										MarkParam.Dist.dAddDistAfterSecondMet,
										MarkParam.Dist.dMarkInPosLimit,
										bAxis1InPosition);
							}
							else
							{
								m_OverRunCount++;
								nTmpError = ERR_BCR_READTIMEOUT;       //오버런을 위해 E402로 발생함..
								*pnID = nTmpTargetID;//nTmpTargetID;//ID_NONE;/ID_NONE;

								//오버런 처리
								m_pExecuteInfo->FlagOverRunInfo.bCheck = true;
								m_pExecuteInfo->FlagOverRunInfo.OverrunType = 0x02; //이적재
								m_pExecuteInfo->FlagOverRunInfo.nFinalNode = nTmpTargetID;    //주행은 주행, 이적재는 이적재
								m_PositionInfo.CurrStation = nTmpTargetID;
								m_pExecuteInfo->FlagOverRunInfo.dDrivingInitPosition =0.0;

								m_PositionInfo.CurrStation = nTmpTargetID;
								ADD_LOG("D_279/%d/%6.1lf/%6.1lf/%6.1lf/%6.1lf"
										, bAxis1InPosition
										, dRealPositionOfNow
										, dRealPositionOfSmallAddCheck
										, MarkParam.Dist.dAddDistAfterSecondMet
										, MarkParam.Dist.dMarkInPosLimit );
							}
						}
					}
				}
			}
		}else
		{
			dwSecendCheckTime = timeGetTime();
		}

		if((pMarkState->Arrived == true) && (m_mccparam.bMarkStartFlag == true))
		{
			STATION_DATA *pSData;
			pSData = OHTMainForm->GetStationDataManager()->Find(m_mccparam.uTargetNode);

			UINT temp_parent_id = 0;
			int temp_parent_offset = 0;
			int temp_current_offset = m_pOHTMainStatus->StatusCommon.CurNodeOffset;

			if(pSData != NULL)
			{
				temp_parent_id = pSData->ParentNodeID;
				temp_parent_offset = pSData->StationOffset;

				if(temp_parent_offset == 0)
				{
					DRIVING_CMD_INFO_OF_PATH* pPathInfo = NULL;
					int nCount = m_ClassifiedCmd.PathList.getCount() - 2;
					if(nCount >= 0)
					{
						pPathInfo = m_ClassifiedCmd.PathList.refer(nCount);
						temp_current_offset = pPathInfo->dLength - temp_current_offset;
					}
				}
			}
			bCheckMarkComp = true;

			ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,STATION MARK,End,%s,%06d,%06d,%06d,%d,%3.3lf,Mark Type,%d,Station Mark Dist,%6.1lf,Station Sensor Dist,%6.1lf,Station Mark Start Speed,%3.3lf,Station Mark First Detect Speed,%3.3lf,Station Mark Second Detect Speed,%3.3lf,Front Sensor Haunting Count,%d,ParentNode Offset Difference,%d,Trans BCR Read Fail,%d,Trans BCR Trigger Count,%d,Marking OHT Detect And STOP,%d,Front Stop On Start Pos,%d,Rear Sensor Haunting Count,%d,Parent Node,%d,Parent Node Offset,%d,CurrentPos,%6.1lf,FrontDetectpos,%6.1lf,RearDetectpos,%6.1lf",
						m_defualtparam->VHLName,m_mccparam.cCarrierType,
						m_mccparam.uSourceNode,
						m_mccparam.uTargetNode,
						m_pExecuteInfo->ExecutePositionInfo.CurrNode,
						m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
						dSpeedOfNow,
						m_InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType,
						dRealPositionOfFirstDetect - m_mccparam.dMarkStartDist,
						dRealPositionOfSecondDetect - dRealPositionOfFirstDetect,
						m_mccparam.dMarkStartSpeed,
						m_mccparam.dMarkFirstDetectSpeed,
						m_mccparam.dMarkSecondDetectSpeed,
						m_mccparam.nFrontSensorHauntingCount,
						temp_parent_offset - temp_current_offset,
						m_mccparam.bBCRReadFail,
						m_mccparam.nBCRTriggerCount,
						m_mccparam.bMarkingOHTDetectStop,
						m_mccparam.bFStopOnStartPos,
						m_mccparam.nRearSensorHauntingCount,
						temp_parent_id, temp_parent_offset, dRealPositionOfNow,dCheckRealPositionOfFirstDetect,dRealPositionOfSecondDetect);
			//오토리커버리 수행 후 마크 완료한 경우 기록
			if((m_bE231xAutoRecoveryCase2_DistCheck == true && m_bE231xAutoRecoveryCase2 == true) || (m_bE231xAutoRecovery_RearCheck == true && m_bE231xAutoRecovery == true))
			{   ADD_LOG("AutoRecovery 유형으로 마크 완료!!");
				AUTO_RECOV_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,STATION MARK RECOVERY,End,%s,%06d,%06d,%06d,%d,%3.3lf,Mark Type,%d,Station Mark Dist,%6.1lf,Station Sensor Dist,%6.1lf,Station Mark Start Speed,%3.3lf,Station Mark First Detect Speed,%3.3lf,Station Mark Second Detect Speed,%3.3lf,Front Sensor Haunting Count,%d,Rear Sensor Haunting Count,%d,Mark Retry Error Case,%d,Mark Retry Strart Dist Case1,%3.3lf,Mark Retry Strart Dist Case2,%3.3lf,Mark Retry Case2 Front Haunting Count,%d,E250 Mark Complete Dist,%3.3lf,E250 Mark Rear Off Dist,%3.3lf,Mark Comp,%d,CurrentPos,%6.1lf,FrontDetectpos,%6.1lf,RearDetectpos,%6.1lf",
							m_defualtparam->VHLName,m_mccparam.cCarrierType,
							m_mccparam.uSourceNode,
							m_mccparam.uTargetNode,
							m_pExecuteInfo->ExecutePositionInfo.CurrNode,
							m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
							dSpeedOfNow,
							m_InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType,
							dRealPositionOfFirstDetect - m_mccparam.dMarkStartDist,
							dRealPositionOfSecondDetect - dRealPositionOfFirstDetect,
							m_mccparam.dMarkStartSpeed,
							m_mccparam.dMarkFirstDetectSpeed,
							m_mccparam.dMarkSecondDetectSpeed,
							m_mccparam.nFrontSensorHauntingCount,
							m_mccparam.nRearSensorHauntingCount,
							MarkRetryErrorCase,m_dE231xFront2RearDist,m_dE231xFront2CurPositionDist,m_nE231xAutoRecoveryCase2Count,m_dE250RearOnPosition,m_dE250RearOffPosition,bCheckMarkComp,dRealPositionOfNow,dCheckRealPositionOfFirstDetect,dRealPositionOfSecondDetect);

			}
			m_mccparam.bMarkStartFlag = false;
			m_mccparam.dMarkStartSpeed = 0.0;
			m_mccparam.dMarkStartDist = 0.0;
			m_mccparam.nFrontSensorHauntingCount = 0;
			m_mccparam.nRearSensorHauntingCount = 0;
			m_mccparam.bBCRReadFail = false;
			m_mccparam.nBCRTriggerCount = 0;
			m_mccparam.dMarkFirstDetectSpeed = 0.0;
			m_mccparam.dMarkSecondDetectSpeed = 0.0;
			m_mccparam.bFStopOnStartPos = false;
		}

		return nTmpError;
	}

	// --------------------------------------------------------------------------------------------------------------------------------------
    //1 2. First 감지 된 경우
    // --------------------------------------------------------------------------------------------------------------------------------------
	else if( bDetectFirst==true )
	{

		//E231x Auto Recovery 유형1 → Rear 한번이라도 정상 인식된 경우
		//155-a < Rear - Front 위치 < 157 인 경우에 Rear 센서 미감지되면 m_nAutoRecoveryDist = Rear - Front 인식 위치 저장
		//+2.5mm 1회 이동해서 Rear 센서 OK되면 m_nAutoRecoveryDist 만큼 이동하고 Overrun 처리
		//+2.5mm 이동 시 Front 센서 Off되는 경우도 있으니 Front Off 조건에서도 m_nAutoRecoveryDist 만큼 이동하고 Overrun 처리 추가 필요
		if(m_bE231xAutoRecovery == true)
		{
			if(bStopWithoutFrontDetect==true)
			{
			   //	pMarkState->Recovery=true;
				if((m_bE231xAutoRecovery_RearCheck == false) && (dRealPositionOfNow < m_dE231xAutoRecoveryDist))
				{
					pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet;
					pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;
					pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfSecondMet);

					pCtrlInfo->Dynamic.dDist    = m_dE231xAutoRecoveryDist+50;     // Rear 인식 위치 + 50 만큼 이동하도록 명령

					memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));

					pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;
					m_bE231xAutoRecovery_RearCheck = true;
					MarkRetryErrorCase = AUTORECOVERY_E231X_CASE1;
					ADD_LOG("[AutoRecovery][E231x-유형1]AutoRecovery STEP - 2,Front On, Rear Off Recovering.....(1) m_bE231xAutoRecovery_RearCheck, :%dm_dE231xAutoRecoveryDist : %f" ,m_bE231xAutoRecovery_RearCheck,m_dE231xAutoRecoveryDist);

					AUTO_RECOV_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,STATION MARK RECOVERY,Start,%s,%06d,%06d,%06d,%d,%3.3lf,Mark Type,%d,Mark Retry Error Case,%d",
					m_defualtparam->VHLName,m_mccparam.cCarrierType,
					m_mccparam.uSourceNode,
					m_mccparam.uTargetNode,
					m_pExecuteInfo->ExecutePositionInfo.CurrNode,
					m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
					dSpeedOfNow,
					m_InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType,MarkRetryErrorCase);
				}
				else
				{
					//Front 센서만 On 상태인데, Rear 센서 처음 인식한 위치보다 앞인경우 오버런 처리
					if(dRealPositionOfNow > m_dE231xAutoRecoveryDist + MarkParam.Dist.dAddDistAfterSecondMet ) //+2.5
					{
					   if(m_nAutoRecoveyCount >= 1)
					   {
							if(nTmpTargetID == AR_CurStation)
							{
								ADD_LOG("[AutoRecovery][E231x-유형1]AutoRecovery,%d회 수행Fail........;;;",m_nAutoRecoveyCount);
								m_nAutoRecoveyCount =0;
								AR_CurStation =0;
								pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
								pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
								nTmpError = ERR_NOTMATCH_TAGLENGTH_FINALSTATION_TAG_MET_LATE;
							}
							else
							m_nAutoRecoveyCount = 0;

					   }
					   else
					   {
							m_nAutoRecoveyCount++;

							m_DiagManager->IncreasePreviosDiagCount(PREVIOS_DIAG_TBT);
							m_mccparam.bBCRReadFail = true;

							ADD_MD_LOG("AutoRecovery Cur Station : %d",nTmpTargetID);
							ADD_LOG("[AutoRecovery][E231x-유형1]AutoRecovery,%d회 수행/m_bE231xAutoRecoveryCase2_DistCheck :%d/m_bE231xAutoRecoveryCase2:%d/m_bE231xAutoRecovery:%d/m_bE231xAutoRecovery_RearCheck:%d"
							,m_nAutoRecoveyCount,m_bE231xAutoRecoveryCase2_DistCheck,m_bE231xAutoRecoveryCase2,m_bE231xAutoRecovery,m_bE231xAutoRecovery_RearCheck);
							ADD_LOG("[AutoRecovery][E231x-유형1]AutoRecovery ,bDetectFirst:%d,bDetectSecond:%d dRealPositionOfNow : %f, m_dChekRearDist: %f, dRealDistSumToTarget:%f",bDetectFirst,bDetectSecond,dRealPositionOfNow,m_dChekRearDist,dRealDistSumToTarget);

							nTmpError = ERR_BCR_READTIMEOUT;       //오버런을 위해 E402로 발생함..
							*pnID = nTmpTargetID;//nTmpTargetID;//ID_NONE;/ID_NONE;

							//오버런 처리
							m_pExecuteInfo->FlagOverRunInfo.bCheck = true;
							m_pExecuteInfo->FlagOverRunInfo.OverrunType = 0x02; //이적재
							m_pExecuteInfo->FlagOverRunInfo.nFinalNode = nTmpTargetID;    //주행은 주행, 이적재는 이적재
							m_PositionInfo.CurrStation = nTmpTargetID;
							m_pExecuteInfo->FlagOverRunInfo.dDrivingInitPosition = 0.0;
							AR_CurStation = nTmpTargetID;
							MarkRetryErrorCase = AUTORECOVERY_E231X_CASE1;

							AUTO_RECOV_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,STATION MARK RECOVERY,End,%s,%06d,%06d,%06d,%d,%3.3lf,Mark Type,%d,Station Mark Dist,%6.1lf,Station Sensor Dist,%6.1lf,Station Mark Start Speed,%3.3lf,Station Mark First Detect Speed,%3.3lf,Station Mark Second Detect Speed,%3.3lf,Front Sensor Haunting Count,%d,Rear Sensor Haunting Count,%d,Mark Retry Error Case,%d,Mark Retry Strart Dist Case1,%3.3lf,Mark Retry Strart Dist Case2,%3.3lf,Mark Retry Case2 Front Haunting Count,%d,E250 Mark Complete Dist,%3.3lf,E250 Mark Rear Off Dist,%3.3lf,Mark Comp,%d,CurrentPos,%6.1lf,FrontDetectpos,%6.1lf,RearDetectpos,%6.1lf",
										m_defualtparam->VHLName,m_mccparam.cCarrierType,
										m_mccparam.uSourceNode,
										m_mccparam.uTargetNode,
										m_pExecuteInfo->ExecutePositionInfo.CurrNode,
										m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
										dSpeedOfNow,
										m_InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType,
										dRealPositionOfFirstDetect - m_mccparam.dMarkStartDist,
										dRealPositionOfSecondDetect - dRealPositionOfFirstDetect,
										m_mccparam.dMarkStartSpeed,
										m_mccparam.dMarkFirstDetectSpeed,
										m_mccparam.dMarkSecondDetectSpeed,
										m_mccparam.nFrontSensorHauntingCount,
										m_mccparam.nRearSensorHauntingCount,
										MarkRetryErrorCase,m_dE231xFront2RearDist,m_dE231xFront2CurPositionDist,m_nE231xAutoRecoveryCase2Count,m_dE250RearOnPosition,m_dE250RearOffPosition,bCheckMarkComp,dRealPositionOfNow,dCheckRealPositionOfFirstDetect,dRealPositionOfSecondDetect);
//initInfoSet();에서 초기화하므로 해당 로직에서 초기화 불필요
//							m_mccparam.bMarkStartFlag = false;
//							m_mccparam.dMarkStartSpeed = 0.0;
//							m_mccparam.dMarkStartDist = 0.0;
//							m_mccparam.nFrontSensorHauntingCount = 0;
//							m_mccparam.nRearSensorHauntingCount = 0;
//							m_mccparam.dMarkFirstDetectSpeed = 0.0;
//							m_mccparam.dMarkSecondDetectSpeed = 0.0;
					   }
						return nTmpError;


					}

				}
			}

		}
		//[E250]Auto Recovery로 앞으로 이동 후, Rear 센서 다시 Off 된경우 뒤로 2.5mm 이동하고 센서 정상 On이면 마크 완료 처리
		//뒤로 2.5mm 이동하고 센서 Off이면 E250 발생
		if(m_bE250AutoRecoveryFlag == true)
		{
			if(bStopWithoutFrontDetect==true)
			{
				if(OHTUTILITY::PreventOverflowGetTimeMs(dwE250RecoveryCheckTime)> 300)
				{
					if(m_bE250RearOnCheck == true)   // Recovery 이동 후에도 Rear 센서 Off 상태로 에러 처리
					{
						pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
						pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
						nTmpError = ERR_MARK_RSTOPSEN_OFF;
						ADD_LOG("[ERR_MARK_RSTOPSEN_OFF]E250 Auto Recovery fail:Front On,Rear Off");
					}
					else
					{
						if(nCheckAutoRecoveryTry < 5)
						{
							nCheckAutoRecoveryTry++;

							dwE250RecoveryCheckTime = dwCurrTime;

							pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet;
							pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;
							pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfSecondMet);

							pCtrlInfo->Dynamic.dDist    = dRealPositionOfNow + 1.0;

							memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));

							pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;
							ADD_LOG("[AutoRecovery][E250]AutoRecovery STEP - 2-1, Recovering..... CheckAutoRecoveryTry : %d",nCheckAutoRecoveryTry);
						}else
						{
							nTmpError = ERR_MARK_RSTOPSEN_OFF;
							ADD_LOG("[E250]AutoRecovery Error 1-1");
						}


					}
				}
			}
		}

		else if(PreMarkState.Recovery==true) //pMarkStatus->StateOnOverRunBack==true)
		{
			if(bStopWithoutFrontDetect == true)
			{
				bIsOHTDetectIngnore = true;
			   //	nRecoveryCountTagStationOverrun = 0;
				//1 >>>에러 처리
				if(nRecoveryCountTagStationOverrun <50)
				{
					nRecoveryCountTagStationOverrun++;
					pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet;//Tag.AccelOfSecond;
					pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;//Tag.AccelOfSecond;
					pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfSecondMet);//Tag.SpeedOfSecond;

					memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));


					if((((dRealPositionOfSecondDetect - MarkParam.Dist.dAddDistAfterSecondMet-MarkParam.Dist.dMarkInPosLimit)> dRealPositionOfNow) && ( dRealPositionOfSecondDetect < dRealDistSumToLimit)) ||   //Sensor감지된 위치가 현재보다 전방에 있고, Limit거리가 안넘었을 경우는 전방으로 탐색
						((dRealPositionOfIdReadedCheckingPoint < dRealPositionOfNow) && (dRealPositionOfSecondDetect < dRealPositionOfFirstDetect)) ||   //Front가 SecondDetect보다 클경우는 전방으로 탐색
						(dRealPositionOfSecondDetect ==0)) //Front or RearDectect가 하나라도 0일 경우는 전방으로 탐색
						pCtrlInfo->Dynamic.dDist    = dRealDistSumToLimit;      // 현재 위치에서 Second 길이의 2배 위치까지
					else
						pCtrlInfo->Dynamic.dDist    = dRealPositionOfNow -35.0;     // 현재 위치에서 Second 감지 거리의 2배 위치까지


					pCtrlInfo->Dynamic.AdditionalInfo.bUseSmallAdd              = true;

#if((OHT_NAME == OHT_NAME_STD_V85) || (OHT_NAME == OHT_NAME_STD_V81S)||(OHT_NAME == OHT_NAME_STD_V85S)||(OHT_NAME == OHT_NAME_STD_V82)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
					pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 57;
#else
					pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 54;
#endif

					pCtrlInfo->Dynamic.AdditionalInfo.bIsTriggerOnRisingEdge    = false;
					pCtrlInfo->Dynamic.AdditionalInfo.dSmallDistance            = MarkParam.Dist.dAddDistAfterSecondMet;//Tag.AddLengthForSecond;


					pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;//Event.Flag.MarkEvent_BackFromOverRun= true;

					ADD_LOG("D_280/%7.1lf/%6.1lf/%6.1lf/%6.1lf/%6.1lf"
					, HwInfo.Axis1.dCurrPos
					, dRealPositionOfNow
					, dRealPositionOfFirstDetect
					, dRealPositionOfSecondDetect
					, dRealPositionOfSmallAddCheck
					);
				}
				else
				{
						nRecoveryCountTagStationOverrun = 0;

						pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
						pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
						nTmpError = ERR_MARK_FSTOPSEN_OFF;

						ADD_LOG("D_281/%d/%6.1lf/%6.1lf/%6.1lf/%6.1lf"
								, bAxis1InPosition
								, dRealPositionOfNow
								, dRealPositionOfSmallAddCheck
								, MarkParam.Dist.dAddDistAfterSecondMet
								, MarkParam.Dist.dMarkInPosLimit );

						ADD_FDC_LOG("ERR/%d/1/8/%06d/%06d/%d/%d/%06d/%d/%6.1lf/%6.1lf",
									ERR_MARK_FSTOPSEN_OFF,
									m_pOHTMainStatus->StatusCommon.CurNodeID,
									m_pExecuteInfo->ExecutePositionInfo.NextNode,
									m_pOHTMainStatus->StatusCommon.CurNodeOffset,
									m_pOHTMainStatus->StatusCommon.ExistFoup,
									m_pOHTMainStatus->StatusCommon.StopStationID,
									bAxis1InPosition,
									dRealPositionOfNow,
									dRealPositionOfSmallAddCheck);

						return nTmpError;
				}

			}
        }
        //2 1)  마크 루틴 처음 들어왔을 때 Front 감지된 경우: small add move 시작(2.5mm : 0.05mm/msec : 0.0005 mm/msec2 )
        else if( PreMarkState.OnRoutineIn==false )//pMarkStatus->StateOnStopRoutineIn == false)
		{
            pMarkState->FirstMet = true;        //pMarkStatus->StateOnFirstMet = true;
            pMarkState->OnRoutineIn = true; //pMarkStatus->StateOnStopRoutineIn = true;

            //1 >>>Small Add Move 2.5mm
            pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet;//Tag.AccelOfSecond;
            pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;//Tag.AccelOfSecond;
            pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfSecondMet);//Tag.SpeedOfSecond;
            pCtrlInfo->Dynamic.dDist    = dRealDistSumToLimit;      // 현재 위치에서 Second 길이의 2배 위치까지

            memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
//          pCtrlInfo->Dynamic.AdditionalInfo.bStartOnSpeedDown     = true;
            pCtrlInfo->Dynamic.AdditionalInfo.bUseSmallAdd              = true;

#if((OHT_NAME == OHT_NAME_STD_V85) || (OHT_NAME == OHT_NAME_STD_V81S)||(OHT_NAME == OHT_NAME_STD_V85S)||(OHT_NAME == OHT_NAME_STD_V82)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
			pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 57;
#else
			pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 54;
#endif

            pCtrlInfo->Dynamic.AdditionalInfo.bIsTriggerOnRisingEdge    = false;
            pCtrlInfo->Dynamic.AdditionalInfo.dSmallDistance            = MarkParam.Dist.dAddDistAfterSecondMet;//Tag.AddLengthForSecond;

            pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;//Event.Flag.MarkEvent_FirstMet = true;

            ADD_LOG("D_282/%6.1lf/%6.1lf/%6.1lf/%6.1lf"
                , dRealPositionOfNow
                , dRealPositionOfFirstDetect
                , dRealPositionOfSecondDetect
                , dRealPositionOfSmallAddCheck
                );


        }
        //2 2)  정상 Routine으로 Rear 센서가 처음 들어온 경우: small add move 시작(2.5mm : 0.05mm/msec : 0.0005 mm/msec2 )
        else if( PreMarkState.FirstMet == false )//pMarkStatus->StateOnFirstMet == false)
        {
            //1 정상 루틴으로 들어온 경우 지연 처리
			if(bPauseSecondSmallMove==false)
            {
                pMarkState->FirstMet = true;  //pMarkStatus->StateOnFirstMet = true;

                //1 >>>Small Add Move 2.5mm
                pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet;//Tag.AccelOfSecond;
                pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;//Tag.AccelOfSecond;
                pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfSecondMet);//Tag.SpeedOfSecond;
				pCtrlInfo->Dynamic.dDist    = dRealDistSumToLimit;      // 현재 위치에서 Second 길이의 2배 위치까지

                memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
//              pCtrlInfo->Dynamic.AdditionalInfo.bStartOnSpeedDown     = true;
                pCtrlInfo->Dynamic.AdditionalInfo.bUseSmallAdd              = true;

#if((OHT_NAME == OHT_NAME_STD_V85) || (OHT_NAME == OHT_NAME_STD_V81S)||(OHT_NAME == OHT_NAME_STD_V85S)||(OHT_NAME == OHT_NAME_STD_V82)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
				pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 57;
#else
				pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 54;
#endif

                pCtrlInfo->Dynamic.AdditionalInfo.bIsTriggerOnRisingEdge    = false;
                pCtrlInfo->Dynamic.AdditionalInfo.dSmallDistance            = MarkParam.Dist.dAddDistAfterSecondMet;//Tag.AddLengthForSecond;

                pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;//Event.Flag.MarkEvent_FirstMet = true;
				//BCR H/W Trigger ON
				ADD_LOG("D_283/%6.1lf", dRealPositionOfNow - dRealPositionOfFirstDetect);
				ADD_LOG("D_284/%6.1lf/%6.1lf/%6.1lf/%6.1lf"
                    , dRealPositionOfNow
                    , dRealPositionOfFirstDetect
                    , dRealPositionOfSecondDetect
                    , dRealPositionOfSmallAddCheck
                    );

				//Moon Front Sensor 정상 감지된 경우 속도 저장
				m_mccparam.dMarkFirstDetectSpeed = dSpeedOfNow;
            }

        }
        //2 3)  정지 한 경우: 현재 위치 확인 후 에러  혹은 small add move
        else if( bStopWithoutFrontDetect == true )
        {
            //1 >>>Small Add Move 2.5mm
			if(PreMarkState.OverRun==true)
			{
				bIsOHTDetectIngnore = true;
				pMarkState->Recovery=true;
				// Second Met을 활성화 하는 이유:   Second 만나고 아래 완료 루틴으로 들어가게 하려함
//                  pMarkState->OverRun = true; //pMarkStatus->StateOnOverRunBack = true;
				//1     >>>Second 넘어간 경우:  Small Add Move -2.5mm
				pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet;//Tag.AccelOfSecond;
				pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;//Tag.AccelOfSecond;
				pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfSecondMet);//Tag.SpeedOfSecond;


				if(((dRealPositionOfSecondDetect > dRealPositionOfNow) && ( dRealPositionOfSecondDetect < dRealDistSumToLimit)) ||   //Sensor감지된 위치가 현재보다 전방에 있고, Limit거리가 안넘었을 경우는 전방으로 탐색
					((dRealPositionOfIdReadedCheckingPoint <dRealPositionOfNow) && (dRealPositionOfSecondDetect < dRealPositionOfFirstDetect)) ||   //Front가 SecondDetect보다 클경우는 전방으로 탐색
					(dRealPositionOfSecondDetect ==0)) //Front or RearDectect가 하나라도 0일 경우는 전방으로 탐색
//				if((dRealPositionOfSecondDetect > dRealPositionOfNow) && ( dRealPositionOfSecondDetect < dRealDistSumToLimit))
				{
					pCtrlInfo->Dynamic.dDist    = dRealDistSumToLimit;      // 현재 위치에서 Second 길이의 2배 위치까지
                          //프론트가 감지된상태에서는 안함.
//					if((bCheckFrontBackStep == true) &&	(dRealPositionOfNow > dRealCheckFrontBackPoint + 180.0))
//					{
//						pCtrlInfo->Dynamic.dDist = dRealPositionOfNow - 60.0;//
//					}

					memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
		//          pCtrlInfo->Dynamic.AdditionalInfo.bStartOnSpeedDown     = true;
					pCtrlInfo->Dynamic.AdditionalInfo.bUseSmallAdd              = true;

#if((OHT_NAME == OHT_NAME_STD_V85) || (OHT_NAME == OHT_NAME_STD_V81S)||(OHT_NAME == OHT_NAME_STD_V85S)||(OHT_NAME == OHT_NAME_STD_V82)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
					pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 57;
#else
					pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 54;
#endif

					pCtrlInfo->Dynamic.AdditionalInfo.bIsTriggerOnRisingEdge    = false;
					pCtrlInfo->Dynamic.AdditionalInfo.dSmallDistance            = MarkParam.Dist.dAddDistAfterSecondMet;//Tag.AddLengthForSecond;

				}
				else
				{


					pCtrlInfo->Dynamic.dDist    = dRealPositionOfNow-35.0;     // 현재 위치에서 Second 감지 거리의 2배 위치까지
//					pCtrlInfo->Dynamic.dDist    = dRealPositionOfSecondDetect+MarkParam.Dist.dAddDistAfterSecondMet;
//					if((bCheckFrontBackStep == true) &&	(dRealPositionOfNow > dRealCheckFrontBackPoint + 180.0))
//					{
//						pCtrlInfo->Dynamic.dDist = dRealPositionOfNow - 60.0;//
//					}
					memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
	//                  pCtrlInfo->Dynamic.AdditionalInfo.bStartOnSpeedDown     = true;
					pCtrlInfo->Dynamic.AdditionalInfo.bUseSmallAdd              = true;

#if((OHT_NAME == OHT_NAME_STD_V85) || (OHT_NAME == OHT_NAME_STD_V81S)||(OHT_NAME == OHT_NAME_STD_V85S)||(OHT_NAME == OHT_NAME_STD_V82)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
					pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 57;
#else
					pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 54;
#endif
					pCtrlInfo->Dynamic.AdditionalInfo.bIsTriggerOnRisingEdge    = false;
					pCtrlInfo->Dynamic.AdditionalInfo.dSmallDistance            = MarkParam.Dist.dAddDistAfterSecondMet;//Tag.AddLengthForSecond;
				}

				pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;//Event.Flag.MarkEvent_BackFromOverRun= true;

				ADD_LOG("D_285/%6.1lf/%6.1lf/%6.1lf/%6.1lf"
					, dRealPositionOfNow
					, dRealPositionOfFirstDetect
					, dRealPositionOfSecondDetect
					, dRealPositionOfSmallAddCheck
					);


			}
			else
			{

				pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet;//Tag.AccelOfSecond;
				pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;//Tag.AccelOfSecond;
				pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfSecondMet);//Tag.SpeedOfSecond;
				pCtrlInfo->Dynamic.dDist    = dRealDistSumToLimit;      // 현재 위치에서 Second 길이의 2배 위치까지

				memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
	//          pCtrlInfo->Dynamic.AdditionalInfo.bStartOnSpeedDown     = true;
				pCtrlInfo->Dynamic.AdditionalInfo.bUseSmallAdd              = true;

#if((OHT_NAME == OHT_NAME_STD_V85) || (OHT_NAME == OHT_NAME_STD_V81S)||(OHT_NAME == OHT_NAME_STD_V85S)||(OHT_NAME == OHT_NAME_STD_V82)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
				pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 57;
#else
				pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 54;
#endif

				pCtrlInfo->Dynamic.AdditionalInfo.bIsTriggerOnRisingEdge    = false;
				pCtrlInfo->Dynamic.AdditionalInfo.dSmallDistance            = MarkParam.Dist.dAddDistAfterSecondMet;//Tag.AddLengthForSecond;

				pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;//Event.Flag.MarkEvent_FirstMet = true;

				ADD_LOG("D_286/%6.1lf/%6.1lf/%6.1lf/%6.1lf"
					, dRealPositionOfNow
					, dRealPositionOfFirstDetect
					, dRealPositionOfSecondDetect
					, dRealPositionOfSmallAddCheck
					);
			}

		}
		//2 4)  기타 이동 중 처리
		else
		{

		}


		//추가된 부분
		if((pMarkState->FirstMet == true) && (bIsOHTDetectIngnore ==false))
		{
			double dTempDistance = dRealPositionOfNow - dRealPositionOfFirstDetect;

			if((dTempDistance >80) &&(dTempDistance < 300))
				bIsOHTDetectIngnore = true;
		}
        return nTmpError;
    }
    // --------------------------------------------------------------------------------------------------------------------------------------
    //1 3. Rear/Front 미감지 된 경우
    // --------------------------------------------------------------------------------------------------------------------------------------
    else
	{
		if((PreMarkState.FirstMet == true) && ( PreMarkState.SecondMet == false ))
		{
			  if(bDetectFirst==false)
			  {
				m_DiagManager->IncreasePreviosDiagCount(PREVIOS_DIAG_TR);
					m_mccparam.nFrontSensorHauntingCount++;
				ADD_MD_LOG("TR Cur Station : %6d", nTmpTargetID);
			  }
        }

        //2 1)  Front 감지되었다가 넘어간 경우
		if(( PreMarkState.FirstMet == true ) || ( PreMarkState.SecondMet == true ))//pMarkStatus->StateOnFirstMet == true )
		{
			if(m_bE231xAutoRecovery == true)
			{
				if(bStopWithoutFrontDetect==true)
				{
				   //	pMarkState->Recovery=true;
					if((m_bE231xAutoRecovery_RearCheck == false) &&(dRealPositionOfNow > m_dE231xAutoRecoveryDist))
					{
						pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet;
						pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;
						pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfSecondMet);

						pCtrlInfo->Dynamic.dDist    = m_dE231xAutoRecoveryDist - 50;   // Rear 인식 위치 - 50 만큼 이동하도록 명령

						memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));

						pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;
						m_bE231xAutoRecovery_RearCheck = true;
						MarkRetryErrorCase = AUTORECOVERY_E231X_CASE1;
						ADD_LOG("[AutoRecovery][E231x-유형1]AutoRecovery STEP - 2,Front Off, Rear Off Recovering.....(2) m_bE231xAutoRecovery_RearCheck, :%dm_dE231xAutoRecoveryDist : %f" ,m_bE231xAutoRecovery_RearCheck,m_dE231xAutoRecoveryDist);

						AUTO_RECOV_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,STATION MARK RECOVERY,Start,%s,%06d,%06d,%06d,%d,%3.3lf,Mark Type,%d,Mark Retry Error Case,%d",
						m_defualtparam->VHLName,m_mccparam.cCarrierType,
						m_mccparam.uSourceNode,
						m_mccparam.uTargetNode,
						m_pExecuteInfo->ExecutePositionInfo.CurrNode,
						m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
						dSpeedOfNow,
						m_InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType,MarkRetryErrorCase);
					}
					else
					{
						//Front, Rear 모두 off 상태인데 Rear 센서 처음 인식한 위치보다 뒤에 있으면 오버런 처리
						if(dRealPositionOfNow < m_dE231xAutoRecoveryDist)
						{
						   if(m_nAutoRecoveyCount >= 1)
						   {
								if(nTmpTargetID == AR_CurStation)
								{
									ADD_LOG("[AutoRecovery][E231x]AutoRecovery,%d회 수행Fail........;;;",m_nAutoRecoveyCount);
									m_nAutoRecoveyCount =0;
									AR_CurStation =0;
									pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
									pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
									nTmpError = ERR_NOTMATCH_TAGLENGTH_FINALSTATION_TAG_MET_LATE;
								}
								else
								m_nAutoRecoveyCount = 0;

						   }
						   else
						   {
								m_nAutoRecoveyCount++;

								m_DiagManager->IncreasePreviosDiagCount(PREVIOS_DIAG_TBT);
								m_mccparam.bBCRReadFail = true;

								ADD_MD_LOG("AutoRecovery Cur Station : %d",nTmpTargetID);
								ADD_LOG("[AutoRecovery][E231x]AutoRecovery,%d회 수행/m_bE231xAutoRecoveryCase2_DistCheck :%d/m_bE231xAutoRecoveryCase2:%d/m_bE231xAutoRecovery:%d/m_bE231xAutoRecovery_RearCheck:%d"
								,m_nAutoRecoveyCount,m_bE231xAutoRecoveryCase2_DistCheck,m_bE231xAutoRecoveryCase2,m_bE231xAutoRecovery,m_bE231xAutoRecovery_RearCheck);
								ADD_LOG("[AutoRecovery][E231x]AutoRecovery ,bDetectFirst:%d,bDetectSecond:%d dRealPositionOfNow : %f, m_dChekRearDist: %f, dRealDistSumToTarget:%f",bDetectFirst,bDetectSecond,dRealPositionOfNow,m_dChekRearDist,dRealDistSumToTarget);

								nTmpError = ERR_BCR_READTIMEOUT;       //오버런을 위해 E402로 발생함..
								*pnID = nTmpTargetID;//nTmpTargetID;//ID_NONE;/ID_NONE;

								//오버런 처리
								m_pExecuteInfo->FlagOverRunInfo.bCheck = true;
								m_pExecuteInfo->FlagOverRunInfo.OverrunType = 0x02; //이적재
								m_pExecuteInfo->FlagOverRunInfo.nFinalNode = nTmpTargetID;    //주행은 주행, 이적재는 이적재
								m_PositionInfo.CurrStation = nTmpTargetID;
								m_pExecuteInfo->FlagOverRunInfo.dDrivingInitPosition = 0.0;
								AR_CurStation = nTmpTargetID;
								MarkRetryErrorCase = AUTORECOVERY_E231X_CASE1;

								AUTO_RECOV_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,STATION MARK RECOVERY,End,%s,%06d,%06d,%06d,%d,%3.3lf,Mark Type,%d,Station Mark Dist,%6.1lf,Station Sensor Dist,%6.1lf,Station Mark Start Speed,%3.3lf,Station Mark First Detect Speed,%3.3lf,Station Mark Second Detect Speed,%3.3lf,Front Sensor Haunting Count,%d,Rear Sensor Haunting Count,%d,Mark Retry Error Case,%d,Mark Retry Strart Dist Case1,%3.3lf,Mark Retry Strart Dist Case2,%3.3lf,Mark Retry Case2 Front Haunting Count,%d,E250 Mark Complete Dist,%3.3lf,E250 Mark Rear Off Dist,%3.3lf,Mark Comp,%d,CurrentPos,%6.1lf,FrontDetectpos,%6.1lf,RearDetectpos,%6.1lf",
											m_defualtparam->VHLName,m_mccparam.cCarrierType,
											m_mccparam.uSourceNode,
											m_mccparam.uTargetNode,
											m_pExecuteInfo->ExecutePositionInfo.CurrNode,
											m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
											dSpeedOfNow,
											m_InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType,
											dRealPositionOfFirstDetect - m_mccparam.dMarkStartDist,
											dRealPositionOfSecondDetect - dRealPositionOfFirstDetect,
											m_mccparam.dMarkStartSpeed,
											m_mccparam.dMarkFirstDetectSpeed,
											m_mccparam.dMarkSecondDetectSpeed,
											m_mccparam.nFrontSensorHauntingCount,
											m_mccparam.nRearSensorHauntingCount,
											MarkRetryErrorCase,m_dE231xFront2RearDist,m_dE231xFront2CurPositionDist,m_nE231xAutoRecoveryCase2Count,m_dE250RearOnPosition,m_dE250RearOffPosition,bCheckMarkComp, dRealPositionOfNow,dCheckRealPositionOfFirstDetect,dRealPositionOfSecondDetect);

//initInfoSet();에서 초기화하므로 해당 로직에서 초기화 불필요
//								m_mccparam.bMarkStartFlag = false;
//								m_mccparam.dMarkStartSpeed = 0.0;
//								m_mccparam.dMarkStartDist = 0.0;
//								m_mccparam.nFrontSensorHauntingCount = 0;
//								m_mccparam.nRearSensorHauntingCount = 0;
//								m_mccparam.dMarkFirstDetectSpeed = 0.0;
//								m_mccparam.dMarkSecondDetectSpeed = 0.0;
						   }
							return nTmpError;


						}

					}
				}
			}
			if(m_bE231xAutoRecoveryCase2 == true)
			{
				   //AutoRecovery start 기록
				   if(m_nE231xAutoRecoveryCase2Count==0)
				   {
						MarkRetryErrorCase = AUTORECOVERY_E231X_CASE2;

						AUTO_RECOV_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,STATION MARK RECOVERY,Start,%s,%06d,%06d,%06d,%d,%3.3lf,Mark Type,%d,Mark Retry Error Case,%d",
						m_defualtparam->VHLName,m_mccparam.cCarrierType,
						m_mccparam.uSourceNode,
						m_mccparam.uTargetNode,
						m_pExecuteInfo->ExecutePositionInfo.CurrNode,
						m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
						dSpeedOfNow,
						m_InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType,MarkRetryErrorCase);
				   }

				   if((m_nE231xAutoRecoveryCase2Count < 20) && (bCheckFrontRearOffFirst == false)) // Front 센서 헌팅 20*5msec 무시
				   {
						m_nE231xAutoRecoveryCase2Count++;
						MarkRetryErrorCase = AUTORECOVERY_E231X_CASE2;
						ADD_LOG("[AutoRecovery][E231x-유형2]AutoRecovery STEP - 2,Front off, Rear off, Recovering 1 ... Count : %d",m_nE231xAutoRecoveryCase2Count);
				   }
				   else if(bStopWithoutFrontDetect == true)
				   {

						pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet;
						pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;
						pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfSecondMet);

						pCtrlInfo->Dynamic.dDist    = dRealDistSumToTarget;   //dRealDistSumToTarget 이게 맞을지 거리 값 확인 필요

						memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
						pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;

						ADD_LOG("[AutoRecovery][E231x-유형2]AutoRecovery STEP - 2,Front off, Rear off, Recovering 2 ... Count : %d,Target : %f, SumToTarget : %f",m_nE231xAutoRecoveryCase2Count,pCtrlInfo->Dynamic.dDist,dRealDistSumToTarget);
						m_bE231xAutoRecoveryCase2_DistCheck = true;
						m_nE231xAutoRecoveryCase2Count = 0;
						bCheckFrontRearOffFirst = true;
				   }

			}
                        if(m_bE250AutoRecoveryFlag == true)
			{
				if(OHTUTILITY::PreventOverflowGetTimeMs(dwE250RecoveryCheckTime)> 300) //300msec가 이동하기에 충분한 시간??
				{
					if(bStopWithoutFrontDetect == true)   // Recovery 이동 후에도 Rear 센서 Off 상태로 에러 처리
					{
						if(m_bE250RearOnCheck == false)
						{
							pMarkState->OnMoveCmd=true;
							m_dE250RearOffPosition = dRealPositionOfNow-dCheckRealPositionOfFirstDetect;
							pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet; //Tag.AccelOfSecond;
							pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet; //Tag.AccelOfSecond;
							pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfSecondMet);   //Tag.SpeedOfSecond;
							pCtrlInfo->Dynamic.dDist    = dRealPositionOfNow - (0.5*MarkParam.Dist.dLengthOfSecond);//.LengthOfSecond);   // 현재 위치에서 Second 길이의 반절만 이동

							memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
			//              pCtrlInfo->Dynamic.AdditionalInfo.bStartOnSpeedDown     = true;
							pCtrlInfo->Dynamic.AdditionalInfo.bUseSmallAdd              = true;

#if((OHT_NAME == OHT_NAME_STD_V85) || (OHT_NAME == OHT_NAME_STD_V81S)||(OHT_NAME == OHT_NAME_STD_V85S)||(OHT_NAME == OHT_NAME_STD_V82)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
							pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 57;
#else
							pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 54;
#endif
							pCtrlInfo->Dynamic.AdditionalInfo.bIsTriggerOnRisingEdge    = false;
							pCtrlInfo->Dynamic.AdditionalInfo.dSmallDistance            = MarkParam.Dist.dAddDistAfterSecondMet;//Tag.AddLengthForSecond;

							pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;//Event.Flag.MarkEvent_SecondMet = true;
							ADD_LOG("[AutoRecovery][E250]AutoRecovery STEP - 3");
							m_bE250RearOnCheck = true;

						}
						else
						{

							pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
							pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
							nTmpError = ERR_MARK_RSTOPSEN_OFF;
							ADD_LOG("[ERR_MARK_RSTOPSEN_OFF]E250 Auto Recovery fail:Front Off,Rear Off");
						}
					}
					dwE250RecoveryCheckTime = dwCurrTime;
				}
			}

			else if( PreMarkState.OverRun==false)//pMarkStatus->StateOnOverRunBack==false && CurrStatus->StopWithoutFrontDetect == false )
			{
				if( bStopWithoutFrontDetect == false )
				{
					if( (bCheckTargetIsNearTargetDist==false)   // Manual 명령 처리
					||  (dRealPositionOfNow>dRealDistSumToTarget+120)    // 타겟 거리보다 20mm 더 먼 곳
					||  (   (dRealPositionOfFirstMetWithNoDetectStart!=0.0) // Front 시작 점 부터 거리
						&&	(dRealPositionOfFirstMetWithNoDetectStart > dRealPositionOfIdReadedCheckingPoint)
						&&  (dRealPositionOfNow>dRealPositionOfFirstMetWithNoDetectStart
												+MarkParam.Dist.dDistFromFirstToSecond
												+MarkParam.Dist.dLengthOfSecond+80)
						)
					||  (   (dRealPositionOfSecondMet!=0.0) // Rear 만난 경우 그 위치에서 Rear 감지거리 만큼 더
						&&  (dRealPositionOfSecondMet > dRealPositionOfIdReadedCheckingPoint)
					    &&  (dRealPositionOfSecondDetect > dRealPositionOfFirstDetect)
						&&  (dRealPositionOfNow>dRealPositionOfSecondMet
												+MarkParam.Dist.dLengthOfSecond)
						)
					||  ( 	(bCheckFrontBackStep == true)
						&&	(dRealPositionOfNow > dRealCheckFrontBackPoint)
					)
					)
					{
                        pMarkState->OverRun = true;
                        //1 >>>MoveStop
						pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfFirstMet*2;//Tag.AccelOfSecond;
                        pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;

                        ADD_LOG("D_287/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%6.11f"
                            , dRealPositionOfNow
                            , dRealPositionOfFirstDetect
                            , dRealPositionOfSecondDetect
							, dRealPositionOfSmallAddCheck
                            , dRealDistSumToTarget
                            , dRealPositionOfFirstMetWithNoDetectStart
							, dRealPositionOfSecondMet
							, dRealCheckFrontBackPoint
							);


					}

				}
				else
				{
					//Auto Manual 모두 동일하게 처리 mark 동작 Test 진행해볼 것
					if(//(bCheckTargetIsNearTargetDist==true) &&  //메뉴얼 명령이 아닐때만
						(dRealPositionOfSecondDetect==0.0) // Front만 감지되고 멈춘경우
						||((dRealPositionOfSecondDetect!=0.0) // Rear 만난 경우 그 위치에서 Rear 감지거리 만큼 더
						&&  (dRealPositionOfSecondDetect > dRealPositionOfIdReadedCheckingPoint)
						&&  (dRealPositionOfSecondDetect > dRealPositionOfFirstDetect)
						&&  (dRealPositionOfNow>dRealPositionOfSecondDetect)))
						{
							pMarkState->OverRun = true;
							//1 >>>MoveStop
							pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfFirstMet*2;//Tag.AccelOfSecond;
							pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;

							ADD_LOG("D_288/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%6.1lf"
								, dRealPositionOfNow
								, dRealPositionOfFirstDetect
								, dRealPositionOfSecondDetect
								, dRealPositionOfSmallAddCheck
								, dRealDistSumToTarget
								, dRealPositionOfFirstMetWithNoDetectStart
								, dRealPositionOfSecondMet
								);
						}

						ADD_LOG("D_289/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%6.1lf"
                            , dRealPositionOfNow
                            , dRealPositionOfFirstDetect
                            , dRealPositionOfSecondDetect
							, dRealPositionOfSmallAddCheck
                            , dRealDistSumToTarget
                            , dRealPositionOfFirstMetWithNoDetectStart
                            , dRealPositionOfSecondMet
							);

				}
			}
			else if(PreMarkState.OverRun==true)
			{
				if( bStopWithoutFrontDetect == true)
				{
					pMarkState->Recovery=true;

					if(nRecoveryCountTagStation2 < 7)
					{
						Sleep(50);
						nRecoveryCountTagStation2++;
						// Second Met을 활성화 하는 이유:   Second 만나고 아래 완료 루틴으로 들어가게 하려함
	//                  pMarkState->OverRun = true; //pMarkStatus->StateOnOverRunBack = true;
						//1     >>>Second 넘어간 경우:  Small Add Move -2.5mm
						pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet;//Tag.AccelOfSecond;                        123123
						pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;//Tag.AccelOfSecond;
						pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfSecondMet);//Tag.SpeedOfSecond;

						if(((dRealPositionOfSecondDetect > dRealPositionOfNow) && ( dRealPositionOfSecondDetect < dRealDistSumToLimit)) ||   //Sensor감지된 위치가 현재보다 전방에 있고, Limit거리가 안넘었을 경우는 전방으로 탐색
							((dRealPositionOfIdReadedCheckingPoint <dRealPositionOfNow) && (dRealPositionOfSecondDetect < dRealPositionOfFirstDetect)) ||   //Front가 SecondDetect보다 클경우는 전방으로 탐색
							((dRealPositionOfFirstDetect ==0) || (dRealPositionOfSecondDetect ==0))) //Front or RearDectect가 하나라도 0일 경우는 전방으로 탐색
							pCtrlInfo->Dynamic.dDist    = dRealDistSumToLimit;      // 현재 위치에서 Second 길이의 2배 위치까지
						else
							pCtrlInfo->Dynamic.dDist = dRealPositionOfNow - 50.0;     // 현재 위치에서 Second 감지 거리의 2배 위치까지

						if((bCheckFrontBackStep == true) &&	(dRealPositionOfNow > dRealCheckFrontBackPoint))
						{
							pCtrlInfo->Dynamic.dDist = dRealPositionOfNow - 60.0;//
						}
						memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));

						pCtrlInfo->Dynamic.AdditionalInfo.bUseSmallAdd              = true;
#if((OHT_NAME == OHT_NAME_STD_V85) || (OHT_NAME == OHT_NAME_STD_V81S)||(OHT_NAME == OHT_NAME_STD_V85S)||(OHT_NAME == OHT_NAME_STD_V82)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
						pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 57;
#else
						pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 54;
#endif

						pCtrlInfo->Dynamic.AdditionalInfo.bIsTriggerOnRisingEdge    = false;
						pCtrlInfo->Dynamic.AdditionalInfo.dSmallDistance            = MarkParam.Dist.dAddDistAfterSecondMet;//Tag.AddLengthForSecond;


						pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;//Event.Flag.MarkEvent_BackFromOverRun= true;

						ADD_LOG("D_290/%6.1lf/%6.1lf/%6.1lf/%6.1lf"
							, dRealPositionOfNow
							, dRealPositionOfFirstDetect
							, dRealPositionOfSecondDetect
							, dRealPositionOfSmallAddCheck
							);
					}
					else
					{
						nRecoveryCountTagStation2 = 0;

						pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
						pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
						nTmpError = ERR_NOTMATCH_TAGLENGTH_FINALSTATION_IN_POSITION_ERROR;
						ADD_FDC_LOG("ERR/%d/3/10/%06d/%06d/%d/%d/%06d/%%6.1lf/%%6.1lf/%%6.1lf/%%6.1lf/%d",
										ERR_NOTMATCH_TAGLENGTH_FINALSTATION_IN_POSITION_ERROR,
										m_pOHTMainStatus->StatusCommon.CurNodeID,
										m_pExecuteInfo->ExecutePositionInfo.NextNode,
										m_pOHTMainStatus->StatusCommon.CurNodeOffset,
										m_pOHTMainStatus->StatusCommon.ExistFoup,
										m_pOHTMainStatus->StatusCommon.StopStationID,
										dRealPositionOfNow,
										dRealPositionOfSmallAddCheck,
										MarkParam.Dist.dAddDistAfterSecondMet,
										MarkParam.Dist.dMarkInPosLimit,
										bAxis1InPosition);
					}
                }

			}
        }
        //2 2)  정상 Routine으로 센서가 아직 감지되지 않은 경우: small add move 시작(125mm : 0.50mm/msec : 0.0010 mm/msec2 )
        else if( PreMarkState.OnRoutineIn == false )//pMarkStatus->StateOnStopRoutineIn== false)
		{

				pMarkState->OnRoutineIn = true; //pMarkStatus->StateOnStopRoutineIn = true;

				//1 >>>Small Add Move 125mm
				pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfFirstMet;//Tag.AccelOfFirst;
				if(pHWSet->GetAMCDecelStatus() >= AMCDECEL_VHLDETECT)
					pCtrlInfo->Dynamic.dDecel   = VHLDETECT_DECEL;
				else
				    pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfFirstMet;//Tag.AccelOfFirst;
				pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfFirstMet);//Tag.SpeedOfFirst;
				pCtrlInfo->Dynamic.dDist    = dRealDistSumToLimit;      // 현재 위치에서 Second 길이의 2배 위치까지

				memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
	//          pCtrlInfo->Dynamic.AdditionalInfo.bStartOnSpeedDown     = true;
				pCtrlInfo->Dynamic.AdditionalInfo.bUseSmallAdd              = true;
#if((OHT_NAME == OHT_NAME_STD_V85) || (OHT_NAME == OHT_NAME_STD_V81S)||(OHT_NAME == OHT_NAME_STD_V85S)||(OHT_NAME == OHT_NAME_STD_V82)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
				pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 56;
#else
				pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 53;
#endif
				pCtrlInfo->Dynamic.AdditionalInfo.bIsTriggerOnRisingEdge    = false;
				pCtrlInfo->Dynamic.AdditionalInfo.dSmallDistance            = MarkParam.Dist.dAddDistAfetrFirstMet;//125;//Tag.AddLengthForFirst;

				pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;//Event.Flag.MarkEvent_NextIsStop_and_SpeedDown   = true;

				ADD_LOG("D_291/%6.1lf/%6.1lf/%6.1lf/%6.1lf"
					, dRealPositionOfNow
					, dRealPositionOfFirstDetect
					, dRealPositionOfSecondDetect
					, dRealPositionOfSmallAddCheck
					);

		}
        //// 300mm 대응 무시 구간 추가 코드 puting
		else if(bCheckInit == true)
		{
			////// 300mm 대응 무시 구간 추가 코드 puting
			if(bCheckInitStop == true)
			{
				bCheckInitStop = false;
				pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;//Tag.AccelOfSecond;
				pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;

				return nTmpError;
			}
			bCheckInit = false;

			pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfFirstMet;//Tag.AccelOfFirst;
			if(pHWSet->GetAMCDecelStatus() >= AMCDECEL_VHLDETECT)
				pCtrlInfo->Dynamic.dDecel   = VHLDETECT_DECEL;
			else
			    pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfFirstMet;//Tag.AccelOfFirst;
			pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfFirstMet);//Tag.SpeedOfFirst;
			pCtrlInfo->Dynamic.dDist    = dRealDistSumToLimit;      // 현재 위치에서 Second 길이의 2배 위치까지

			memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));

			pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;//Event.Flag.MarkEvent_NextIsStop_and_SpeedDown   = true;

			ADD_LOG("D_292/%6.1lf/%6.1lf/%6.1lf/%6.1lf"
				, dRealPositionOfNow
				, dRealPositionOfFirstDetect
				, dRealPositionOfSecondDetect
				, dRealPositionOfSmallAddCheck
				);

		}
		//2 3)  정지 한 경우: 현재 위치 확인 후 에러  혹은 small add move
        else if( bStopWithoutFrontDetect == true )
        {
            //1 >>>Small Add Move 125mm
            pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfFirstMet;//Tag.AccelOfFirst;
            pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfFirstMet;//Tag.AccelOfFirst;
            pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfFirstMet);//Tag.SpeedOfFirst;
            pCtrlInfo->Dynamic.dDist    = dRealDistSumToLimit;      // 현재 위치에서 Second 길이의 2배 위치까지

            memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
//          pCtrlInfo->Dynamic.AdditionalInfo.bStartOnSpeedDown     = true;
            pCtrlInfo->Dynamic.AdditionalInfo.bUseSmallAdd              = true;

#if((OHT_NAME == OHT_NAME_STD_V85) || (OHT_NAME ==OHT_NAME_STD_V81S) ||(OHT_NAME == OHT_NAME_STD_V85S)||(OHT_NAME == OHT_NAME_STD_V82)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
			pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 56;
#else
			pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 53;
#endif

            pCtrlInfo->Dynamic.AdditionalInfo.bIsTriggerOnRisingEdge    = false;
            pCtrlInfo->Dynamic.AdditionalInfo.dSmallDistance            = MarkParam.Dist.dAddDistAfetrFirstMet;//125;//Tag.AddLengthForFirst;

            pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;//Event.Flag.MarkEvent_NextIsStop_and_SpeedDown   = true;

            ADD_LOG("D_293/%6.1lf/%6.1lf/%6.1lf/%6.1lf"
                , dRealPositionOfNow
                , dRealPositionOfFirstDetect
                , dRealPositionOfSecondDetect
                , dRealPositionOfSmallAddCheck
                );
        }
        //2 4)  기타 이동 중 처리
        else
        {

        }
        return nTmpError;
    }

    return nTmpError;

}

/**
@brief   DrivingControl Mark 구동 정보 획득 함수(TagStation_Back)
@author  puting
@date    2013.07.01
*/
int DrivingControl::markOnTagStationBack(DRIVING_HW_INFO_SET HwInfo, double dRealDistSumToTarget, double dSpeedLimit, int nTargetID, DRIVING_MARK_STATE* pMarkState, CTRL_INFO_OF_SYNC_AXIS_MOVE* pCtrlInfo, CTRL_INFO_OF_ID_READER_CMD_TYPE *pIdReaderCmdType, int* pnID)
{
	int     nTmpID = 0;
    static int nReadedID = 0;
    static int nTmpTargetID =0;
    static bool bIdReaded = false;
	static DWORD dwCheckTime = 0;
	static DWORD dwTriggerTime = 0;
	DWORD   dwCurrTime = timeGetTime();


    int     nTmpError = NO_ERR;

    memset(pCtrlInfo, 0x00, sizeof(CTRL_INFO_OF_SYNC_AXIS_MOVE));
	*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_NONE;

    DRIVING_MARK_STATE PreMarkState = *pMarkState;
    DRIVING_MARK_PARAM MarkParam = m_pParamSet->Mark[1];

    static bool bNoSensorDetected = false;  // Mark Routine 시작 할 때 Front/Rear가 모두 Off 되었을 때 True
    static bool bPauseSecondSmallMove = false;  // bNoSensorDetected 사 true 인 경우 Second Small Move를 정위치 근처까지 지연 시키는 Flag
    static double dRealPositionOfFirstMetWithNoDetectStart = 0.0;   // Front 감지 되지 않은 상태에서 Mark 시작하여 처음 감지된 때, Front 감지된 위치
    static double dRealPositionOfSecondMet = 0.0;   // Front 감지 되지 않은 상태에서 Mark 시작하여 처음 감지된 때, Front 감지된 위치
    static bool bCheckTargetIsNearTargetDist = false;   // Target이 dRealDistSumToTarget 근처에 있는 경우로 nTargetID 이 0이 아닐 경우 true로 설정
    static bool bIgnoreFrontRearDetect = false; // Target이 dRealDistSumToTarget 근처에 있는 경우 Target 근처 이외에에서의 Front 센서 감지 무시

    // --------------------------------------------------------------------------------------------------------------------------------------
    //1 0. 정보 획득
    // --------------------------------------------------------------------------------------------------------------------------------------
    nTmpID = HwInfo.TagStaion.nBcrId;

    bool    bDetectFirst                = HwInfo.IO.TagStationFrontOn;
    bool    bDetectSecond               = HwInfo.IO.TagStationRearOn;

	bool    bAxis1InPosition            = HwInfo.IO.Axis1InPosition;
	bool	bAxis1Running				= HwInfo.IO.Axis1Running;

    static  TIME_CHECK  StopWithoutFrontDetect;

	static	int			nRecoveryLimitCount4TagStation = 0;

	bool    bStopWithoutFrontDetect = false;

#if(UBG_SENSOR_ENABLE == ON)
//   if(bAxis1Running==false && HwInfo.IO.ObsStatus!=DETECT_AND_STOP && HwInfo.IO.DetectStatus!=DETECT_AND_STOP)
 		if(bAxis1Running==false
	&& ((HwInfo.IO.DetectStatus!=DETECT_AND_STOP) || (pHWSet->GetAMCVHLDetectStatus() ==0)))
#else
    if(bAxis1Running==false && HwInfo.IO.ObsStatus!=DETECT_AND_STOP)
#endif
	{
        if(StopWithoutFrontDetect.bFlag==false)
        {
            StopWithoutFrontDetect.dwTime = dwCurrTime;
            StopWithoutFrontDetect.bFlag = true;
        }
		else if(OHTUTILITY::PreventOverflowGetTimeMs(StopWithoutFrontDetect.dwTime)>200)
        {
			bStopWithoutFrontDetect = true;
		}
    }
    else
    {
        StopWithoutFrontDetect.bFlag = false;
        bStopWithoutFrontDetect = false;
    }


	double  dRealDistSumToLimit             = (dRealDistSumToTarget-(MarkParam.Dist.dForwardMoveDistLimit));  ///< 전지 거리
	double  dSpeedOfNow                     = HwInfo.Axis1.dSpeed;              //m_pDrivingAxis->GetCurrentPosition(); //미보정 현재 위치
    double  dRealPositionOfNow              = HwInfo.Axis1.dCurrPos;            //m_pDrivingAxis->GetCurrentPosition(); //미보정 현재 위치
    double  dRealPositionOfFirstDetect      = HwInfo.TagStaion.dFrontPosition;  // First Sensor 감지 미보정 엔코더 값
    double  dRealPositionOfSecondDetect     = HwInfo.TagStaion.dRearPosition;   // Final Sensor 감지 미보정 엔코더 값
    double  dRealPositionOfSmallAddCheck    = HwInfo.Axis1.dSmallAddCheckPos;   // SmallAddCheck 위치
    static  double  dRealPositionOfMostPositive = 0.0;                      // 최대로 멀리갔을 때의 거리
    static  double  dRealPositionOfIdReaded     = 0.0;                      // 최대로 멀리갔을 때의 거리
	static  double dRefSpeedOnSecondMeet = 0.2;

    if(PreMarkState.OnRoutineIn==false)
    {
        StopWithoutFrontDetect.bFlag = false;
        StopWithoutFrontDetect.dwTime = dwCurrTime;
		dwCheckTime = dwCurrTime;
		dwTriggerTime = dwCurrTime;
        nReadedID = 0;
        nTmpTargetID = nTargetID;
        bCheckTargetIsNearTargetDist = (nTargetID==0)?false:true;
        bIgnoreFrontRearDetect = (bCheckTargetIsNearTargetDist==true)?true:false;
        bIdReaded = false;
        dRealPositionOfMostPositive = dRealPositionOfNow;
        dRealPositionOfIdReaded     = 0.0;
        bNoSensorDetected = (bDetectFirst==false&&bDetectSecond==false)?true:false;
        bPauseSecondSmallMove = (bNoSensorDetected==true)?true:false;
        dRealPositionOfFirstMetWithNoDetectStart = 0.0;
        dRealPositionOfSecondMet = 0.0;
        dRefSpeedOnSecondMeet = sqrt(2*MarkParam.Accel.dOfFirstMet*MarkParam.Dist.dAddDistAfterSecondMet);  // v = sqrt( 2 * a * S) : 감속 거리의 최대 진입 속도
		dRefSpeedOnSecondMeet = MAX(MarkParam.Speed.dOfSecondMet, dRefSpeedOnSecondMeet);
		nRecoveryLimitCount4TagStation = 0;
		ADD_LOG("D_294/%d/%d/%d/%6d/%f"
			, bDetectFirst, bDetectSecond, bNoSensorDetected, nTmpTargetID,dRealDistSumToLimit);
    }
    else
    {
        dRealPositionOfMostPositive = (dRealPositionOfNow<dRealPositionOfMostPositive)?dRealPositionOfNow:dRealPositionOfMostPositive;
		//ADD_LOG("D_295/%6.11f",dRealPositionOfMostPositive);
	}


    //2 주행 중 이전 Tag 만난 경우 채터링
#if 0
    if(bIgnoreFrontRearDetect==true)
	{
//		ADD_LOG("D-163");
		if(dRealPositionOfNow>(dRealDistSumToTarget+300))
		{
//			ADD_LOG("D-164");

			if(bDetectFirst==true)
			{
				bDetectFirst = false;
				bDetectSecond = false;
				bNoSensorDetected = true;
				bPauseSecondSmallMove=false;
//				ADD_LOG("D-165");
			}
		}
		else
		{
//			ADD_LOG("D-166");

			bIgnoreFrontRearDetect=false;// 무시 구간 지나가면 동일 처리
			if(bDetectFirst==true)
			{
				bNoSensorDetected = (bDetectFirst==false&&bDetectSecond==false)?true:false;
				bPauseSecondSmallMove = (bNoSensorDetected==true)?true:false;
				PreMarkState.OnRoutineIn = false;
//				ADD_LOG("D-167");
            }
        }
    }
#endif

    //2 First 만나고 일정 거리 경과 및 감속 후, 두번째 Small Add(저속) 지연해서 실시 하기 위해
    if((bNoSensorDetected==true) && ((bDetectFirst==true)||(bDetectSecond==true)) )
    {
        bNoSensorDetected=false;
        dRealPositionOfFirstMetWithNoDetectStart = dRealPositionOfNow;
    }
	if((bNoSensorDetected==false)&&(bPauseSecondSmallMove==true))
    {
        if(((dRealPositionOfNow-dRealPositionOfFirstMetWithNoDetectStart)<(MarkParam.Dist.dAddDistAfetrFirstMet/2))||
            (dSpeedOfNow>(dRefSpeedOnSecondMeet+2.0)))  //2.0 은 안전율 ( 1.0m/s2 감속 시 0.2초동안 감속되는 속도 )
        {
            bPauseSecondSmallMove=false;
        }
        else
        {
			ADD_LOG("D_296/%d/%6.1lf/%6.1lf/%6.1lf/%d/%6.1lf/%6.1lf",
                ((dRealPositionOfNow-dRealPositionOfFirstMetWithNoDetectStart)<(MarkParam.Dist.dAddDistAfetrFirstMet/2)),
                dRealPositionOfNow, dRealPositionOfFirstMetWithNoDetectStart, MarkParam.Dist.dAddDistAfetrFirstMet,
                (dSpeedOfNow>(dRefSpeedOnSecondMeet+2.0)),
                dSpeedOfNow, dRefSpeedOnSecondMeet);
        }
	}

    if(nTmpTargetID==0 && nTmpID!=0)
    {
        nTmpTargetID = nTmpID;
		ADD_LOG("D_297/%d/%d", nTmpID, nTmpTargetID);
	}

	if(nTmpID==nTmpTargetID&&nTmpTargetID!=0)
	{
		bIdReaded = true;
		dRealPositionOfIdReaded = dRealPositionOfNow;
		nReadedID = nTmpID;
		ADD_LOG("D_298/%d/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%d"
            , bIdReaded
            , dRealPositionOfIdReaded
            , dRealPositionOfFirstDetect
            , dRealPositionOfSecondDetect
            , dRealPositionOfSmallAddCheck
            , nReadedID);
    }
	else if(nTmpID!=0)
	{
     	ADD_LOG("D_299/%d/%d"
            , bIdReaded,nTmpID);
    }


    //2 근접 제어 센서를 Off 시키는 조건
    if(pMarkState->FollowCtrlOffArea==false)
    {
		pMarkState->FollowCtrlOffArea=true;
    }

	if(CanIgnoreVHLDetect())
	{
		m_pDrivingAxis->SetVHLDetectIgnor();
		m_bIsAMCVHLDetectIgnore = true;
	}

	// --------------------------------------------------------------------------------------------------------------------------------------
    //1 0. 에러 처리
    // --------------------------------------------------------------------------------------------------------------------------------------
    if(dRealPositionOfNow < dRealDistSumToLimit)
    {
        pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
        pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
		nTmpError = ERR_NOTMATCH_TAGLENGTH_FINALSTATION_TAG_MET_LATE;

		ERR_LOG("[Tag Back] ERR_NOTMATCH_TAGLENGTH_FINALSTATION_TAG_MET_LATE : %6.1lf > %6.1lf (%6.1lf + %6.1lf) Pos=%6.1lf(F:%6.1lf,R:%6.1lf,S:%6.1lf)"
			, dRealPositionOfNow, dRealDistSumToLimit, dRealDistSumToTarget, MarkParam.Dist.dForwardMoveDistLimit
			, dRealPositionOfNow
			, dRealPositionOfFirstDetect
			, dRealPositionOfSecondDetect
			, dRealPositionOfSmallAddCheck
			);
		return nTmpError;
	}
	else if(dRealPositionOfNow>(dRealPositionOfMostPositive+(MarkParam.Dist.dBackMoveDistLimit*200)))
	{
		pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
		pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
		nTmpError = ERR_NOTMATCH_TAGLENGTH_FINALSTATION_TAG_MOVE_BACK_LIMIT;
        ERR_LOG("[Tag Back] ERR_NOTMATCH_TAGLENGTH_FINALSTATION_TAG_MOVE_BACK_LIMIT : %6.1lf < %6.1lf (%6.1lf - %6.1lf) Pos=%6.1lf(F:%6.1lf,R:%6.1lf,S:%6.1lf)"
            , dRealPositionOfNow, (dRealPositionOfMostPositive-MarkParam.Dist.dBackMoveDistLimit)
            , dRealPositionOfMostPositive, MarkParam.Dist.dBackMoveDistLimit
            , dRealPositionOfNow
            , dRealPositionOfFirstDetect
            , dRealPositionOfSecondDetect
			, dRealPositionOfSmallAddCheck
            );
        return nTmpError;
	}


    // --------------------------------------------------------------------------------------------------------------------------------------
    //1 1. Second 감지된 경우
    // --------------------------------------------------------------------------------------------------------------------------------------
    if( bDetectSecond==true )
	{
//		ADD_LOG("D-168");
        //2 1) 마크 루틴 완료 후 id를 확인하는 절차
        if( PreMarkState.IdCheck==true)
        {
			if(pnID==NULL)
            {
				*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_NONE;
				pMarkState->Arrived = true;
            }
            else
            {
                if(bIdReaded==true)
                {
					*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_NONE;
					ADD_LOG("D_300/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%d/%d/%d"
						, dRealPositionOfNow
                        , dRealPositionOfFirstDetect
                        , dRealPositionOfSecondDetect
						, dRealPositionOfSmallAddCheck
						, dRealDistSumToTarget
						, nReadedID
						,bDetectFirst
						,bDetectSecond
                        );
					pMarkState->Arrived = true;
					*pnID = nReadedID;
				}
				else if(OHTUTILITY::PreventOverflowGetTimeMs(dwTriggerTime) > 200)
                {
					if(OHTUTILITY::PreventOverflowGetTimeMs(dwCheckTime) > 3500)// Time Over
                    {
						*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_NONE;
                        pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
                        pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
						nTmpError = ERR_BCR_BACK_READTIMEOUT;
						*pnID = nTmpTargetID;//ID_NONE;/ID_NONE;


                        ADD_LOG("D_301/%6.1lf/%6.1lf/%6.1lf/%6.1lf"
                            , dRealPositionOfNow
							, dRealPositionOfFirstDetect
							, dRealPositionOfSecondDetect
							, dRealPositionOfSmallAddCheck );
					}
					else
					{
						dwTriggerTime = timeGetTime();
                        *pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
                    }
                }
            }
		}
		//처음에 Rear센서 감지된경우, 일정거리 뒤로 후진 함.  puting
		else if( PreMarkState.OnRoutineIn == false )
		{
			pMarkState->OnRoutineIn = true;

           	pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfFirstMet;//Tag.AccelOfFirst;
			pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfFirstMet;//Tag.AccelOfFirst;
			pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfFirstMet);//Tag.SpeedOfFirst;
			pCtrlInfo->Dynamic.dDist    = dRealPositionOfNow -(MarkParam.Dist.dAddDistAfetrFirstMet/3);      // 현재 위치에서 Second 길이의 2배 위치까지

			memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));

			pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;//Event.Flag.MarkEvent_NextIsStop_and_SpeedDown   = true;

			ADD_LOG("D_302/%6.1lf/%6.1lf/%6.1lf/%6.1lf"
				, dRealPositionOfNow
				, dRealPositionOfFirstDetect
				, dRealPositionOfSecondDetect
				, dRealPositionOfSmallAddCheck
				);

		}
        //2 2)  마크 루틴 처음 들어왔을 때 Rear 감지된 경우: 뒤로 5mm 이동 후 2. Front 감지 처리로 처리
		else if( PreMarkState.FirstMet == false )
        {
			ADD_LOG("D-169");
            // Second Met을 활성화 하지 않은 이유:  First 만나고 아래 정상 루틴으로 들어가게 하려함
            // First Met을 활성화 하지 않은 이유:       5mm 이동 완료 시 까지 이부분 계속 호출 시키려고
			pMarkState->OnRoutineIn = true;

            if( bStopWithoutFrontDetect==true && PreMarkState.OnMoveCmd==false) // 정지 시 뒤로 이동
			{

                pMarkState->OnMoveCmd=true;

                //1 >>>엔코더 값이 -10mm이하일 경우 에러 처리
                //1 >>>Small Add Move -2.5mm(Second 벗어날때까지)
                pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet; //Tag.AccelOfSecond;
                pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet; //Tag.AccelOfSecond;
                pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfSecondMet);   //Tag.SpeedOfSecond;
                pCtrlInfo->Dynamic.dDist    = dRealPositionOfNow - (2*MarkParam.Dist.dLengthOfSecond);//.LengthOfSecond);   // 현재 위치에서 Second 길이의 2배 위치까지

                memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
//              pCtrlInfo->Dynamic.AdditionalInfo.bStartOnSpeedDown     = true;
				pCtrlInfo->Dynamic.AdditionalInfo.bUseSmallAdd              = true;

#if((OHT_NAME == OHT_NAME_STD_V85) || (OHT_NAME == OHT_NAME_STD_V81S)||(OHT_NAME == OHT_NAME_STD_V85S)||(OHT_NAME == OHT_NAME_STD_V82)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
				pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 57;
#else
				pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 54;
#endif

				pCtrlInfo->Dynamic.AdditionalInfo.bIsTriggerOnRisingEdge    = true;
                pCtrlInfo->Dynamic.AdditionalInfo.dSmallDistance            = MarkParam.Dist.dAddDistAfterSecondMet;//Tag.AddLengthForSecond;

                pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;//Event.Flag.MarkEvent_SecondMet = true;
				ADD_LOG("D_303/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%d/%d"
					, dRealPositionOfNow
                    , dRealPositionOfFirstDetect
                    , dRealPositionOfSecondDetect
					, dRealPositionOfSmallAddCheck
					,bDetectFirst
					,bDetectSecond
                    );
            }
        }
        //2 3)  정상 Routine으로 Rear 센서가 처음 들어온 경우: 정지 대기
        else if( PreMarkState.SecondMet==false)//pMarkStatus->StateOnSecondMet == false)
        {
            pMarkState->SecondMet = true;   //pMarkStatus->StateOnSecondMet = true;
            dRealPositionOfSecondMet = dRealPositionOfNow;
            ADD_LOG("D_304/%7.1lf/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%d/%d"
                , HwInfo.Axis1.dCurrPos
                , dRealPositionOfNow
                , dRealPositionOfFirstDetect
                , dRealPositionOfSecondDetect
				, dRealPositionOfSmallAddCheck
				,bDetectFirst
				,bDetectSecond
                );
        }
        //2 4)  정지 한 경우: 정위치 확인 및 완료 처리
        else if( bStopWithoutFrontDetect == true )
        {
            ADD_LOG("D_305/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%d/%d"
                , dRealPositionOfNow, dRealPositionOfSmallAddCheck
                , (dRealPositionOfNow-dRealPositionOfSmallAddCheck)
                , dRealPositionOfNow
                , dRealPositionOfFirstDetect
                , dRealPositionOfSecondDetect
				, dRealPositionOfSmallAddCheck
				,bDetectFirst
				,bDetectSecond
                );


            //1 >>>Arrived
			// 도착위치와 센서 감지 위치를 비교하여 차가 2.5mm ±0.5 이면 정상 처리함 (전진 후진에 대해 모두 처리)
			if( (fabs(dRealPositionOfNow-dRealPositionOfSmallAddCheck)<(MarkParam.Dist.dAddDistAfterSecondMet+MarkParam.Dist.dMarkInPosLimit)) &&
				(fabs(dRealPositionOfNow-dRealPositionOfSmallAddCheck)>(MarkParam.Dist.dAddDistAfterSecondMet-MarkParam.Dist.dMarkInPosLimit)) &&
				(dRealPositionOfSmallAddCheck!=0.0) && (bAxis1InPosition == true) )
			{

				ADD_LOG("D-170");
				if( bDetectFirst==true && bDetectSecond==true )//m_pTransStopTag->IsOnFrontSensor()==true )
				{
                    ADD_LOG("D-171");
                    pMarkState->IdCheck=true;
                    *pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
					dwCheckTime = dwCurrTime;   // ID 확인 되지 않을 때에 대한 TimeOut 처리 목적
					dwTriggerTime = dwCurrTime;
                }
			}
            else    // 멈췄으나 정위치 되지 않을 때에 대한 처리
			{

				if(nRecoveryLimitCount4TagStation < RecoveryLimitCountForMarkOnTagStation)
				{

					if(bStopWithoutFrontDetect==true)
					{

						nRecoveryLimitCount4TagStation++;

						pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet;
						pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;
						pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfSecondMet);
						pCtrlInfo->Dynamic.dDist	= dRealPositionOfNow - (2*MarkParam.Dist.dLengthOfSecond);

						memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));

						pCtrlInfo->Dynamic.AdditionalInfo.bUseSmallAdd              = true;

#if((OHT_NAME == OHT_NAME_STD_V85) || (OHT_NAME == OHT_NAME_STD_V81S)||(OHT_NAME == OHT_NAME_STD_V85S)||(OHT_NAME == OHT_NAME_STD_V82)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
						pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 57;
#else
						pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 54;
#endif

						pCtrlInfo->Dynamic.AdditionalInfo.bIsTriggerOnRisingEdge    = true;
						pCtrlInfo->Dynamic.AdditionalInfo.dSmallDistance            = MarkParam.Dist.dAddDistAfterSecondMet;

						pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;

						ADD_LOG("D_306/%d/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%d/%d"
							, bAxis1InPosition
							, dRealPositionOfNow
							, dRealPositionOfSmallAddCheck
							, MarkParam.Dist.dAddDistAfterSecondMet
							, MarkParam.Dist.dMarkInPosLimit
							,bDetectFirst
							,bDetectSecond);
					}
				}
				else
				{

					nRecoveryLimitCount4TagStation = 0;

					pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
					pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
					nTmpError = ERR_NOTMATCH_TAGLENGTH_FINALSTATION_IN_POSITION_ERROR;

					ADD_LOG("D_307/%d/%6.1lf/%6.1lf/%6.1lf/%6.1lf"
							, bAxis1InPosition
							, dRealPositionOfNow
							, dRealPositionOfSmallAddCheck
							, MarkParam.Dist.dAddDistAfterSecondMet
							, MarkParam.Dist.dMarkInPosLimit );

					return nTmpError;
                }
			}
		}

		return nTmpError;
	}

	// --------------------------------------------------------------------------------------------------------------------------------------
    //1 2. First 감지 된 경우
    // --------------------------------------------------------------------------------------------------------------------------------------
    else if( bDetectFirst==true )
	{
//		ADD_LOG("D-172");
        if(PreMarkState.Recovery==true) //pMarkStatus->StateOnOverRunBack==true)
		{
			ADD_LOG("D-173");
            if( bStopWithoutFrontDetect == true )
            {

                //1 >>>에러 처리
            }
        }
        //2 1)  마크 루틴 처음 들어왔을 때 Front 감지된 경우: small add move 시작(2.5mm : 0.05mm/msec : 0.0005 mm/msec2 )
        else if( PreMarkState.OnRoutineIn==false )//pMarkStatus->StateOnStopRoutineIn == false)
        {
			pMarkState->FirstMet = true;        //pMarkStatus->StateOnFirstMet = true;
            pMarkState->OnRoutineIn = true; //pMarkStatus->StateOnStopRoutineIn = true;
            ADD_LOG("D-174");
            //1 >>>Small Add Move 2.5mm
            pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet;//Tag.AccelOfSecond;
            pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;//Tag.AccelOfSecond;
            pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfSecondMet);//Tag.SpeedOfSecond;
            pCtrlInfo->Dynamic.dDist    = dRealPositionOfNow + MarkParam.Dist.dAddDistAfetrFirstMet;      // 현재 위치에서 Second 길이의 2배 위치까지

            memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
//          pCtrlInfo->Dynamic.AdditionalInfo.bStartOnSpeedDown     = true;
            pCtrlInfo->Dynamic.AdditionalInfo.bUseSmallAdd              = true;

#if((OHT_NAME == OHT_NAME_STD_V85) || (OHT_NAME == OHT_NAME_STD_V81S)||(OHT_NAME == OHT_NAME_STD_V85S)||(OHT_NAME == OHT_NAME_STD_V82)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
			pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 57;
#else
			pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 54;
#endif

            pCtrlInfo->Dynamic.AdditionalInfo.bIsTriggerOnRisingEdge    = false;
            pCtrlInfo->Dynamic.AdditionalInfo.dSmallDistance            = MarkParam.Dist.dAddDistAfterSecondMet;//Tag.AddLengthForSecond;

            pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;//Event.Flag.MarkEvent_FirstMet = true;

            ADD_LOG("D_308/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%d/%d"
                , dRealPositionOfNow
                , dRealPositionOfFirstDetect
                , dRealPositionOfSecondDetect
				, dRealPositionOfSmallAddCheck
				,bDetectFirst
				,bDetectSecond
                );


        }
        //2 2)  정상 Routine으로 Rear 센서가 처음 들어온 경우: small add move 시작(2.5mm : 0.05mm/msec : 0.0005 mm/msec2 )
        else if( PreMarkState.FirstMet == false )//pMarkStatus->StateOnFirstMet == false)
		{

            //1 정상 루틴으로 들어온 경우 지연 처리
            if(bPauseSecondSmallMove==false)
            {
                pMarkState->FirstMet = true;//pMarkStatus->StateOnFirstMet = true;

                //1 >>>Small Add Move 2.5mm
                pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet;//Tag.AccelOfSecond;
                pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;//Tag.AccelOfSecond;
                pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfSecondMet);//Tag.SpeedOfSecond;
				pCtrlInfo->Dynamic.dDist    = dRealPositionOfNow + MarkParam.Dist.dAddDistAfetrFirstMet;      // 현재 위치에서 Second 길이의 2배 위치까지

                memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
//              pCtrlInfo->Dynamic.AdditionalInfo.bStartOnSpeedDown     = true;
                pCtrlInfo->Dynamic.AdditionalInfo.bUseSmallAdd              = true;

#if((OHT_NAME == OHT_NAME_STD_V85) || (OHT_NAME == OHT_NAME_STD_V81S)||(OHT_NAME == OHT_NAME_STD_V85S)||(OHT_NAME == OHT_NAME_STD_V82)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
				pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 57;
#else
				pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 54;
#endif

                pCtrlInfo->Dynamic.AdditionalInfo.bIsTriggerOnRisingEdge    = false;
                pCtrlInfo->Dynamic.AdditionalInfo.dSmallDistance            = MarkParam.Dist.dAddDistAfterSecondMet;//Tag.AddLengthForSecond;

                pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;//Event.Flag.MarkEvent_FirstMet = true;

                ADD_LOG("D_309/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%d/%d"
                    , dRealPositionOfNow
                    , dRealPositionOfFirstDetect
                    , dRealPositionOfSecondDetect
					, dRealPositionOfSmallAddCheck
					,bDetectFirst
					,bDetectSecond
                    );
            }

        }
        //2 3)  정지 한 경우: 현재 위치 확인 후 에러  혹은 small add move
        else if( bStopWithoutFrontDetect == true )
        {
            //1 >>>Small Add Move 2.5mm
            pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet;//Tag.AccelOfSecond;
            pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;//Tag.AccelOfSecond;
            pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfSecondMet);//Tag.SpeedOfSecond;
            pCtrlInfo->Dynamic.dDist    = dRealPositionOfNow + MarkParam.Dist.dAddDistAfetrFirstMet;      // 현재 위치에서 Second 길이의 2배 위치까지

            memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
//          pCtrlInfo->Dynamic.AdditionalInfo.bStartOnSpeedDown     = true;
            pCtrlInfo->Dynamic.AdditionalInfo.bUseSmallAdd              = true;

#if((OHT_NAME == OHT_NAME_STD_V85) || (OHT_NAME == OHT_NAME_STD_V81S)||(OHT_NAME == OHT_NAME_STD_V85S)||(OHT_NAME == OHT_NAME_STD_V82)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
			pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 57;
#else
			pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 54;
#endif

            pCtrlInfo->Dynamic.AdditionalInfo.bIsTriggerOnRisingEdge    = false;
            pCtrlInfo->Dynamic.AdditionalInfo.dSmallDistance            = MarkParam.Dist.dAddDistAfterSecondMet;//Tag.AddLengthForSecond;

            pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;//Event.Flag.MarkEvent_FirstMet = true;

            ADD_LOG("D_310/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%d/%d"
                , dRealPositionOfNow
                , dRealPositionOfFirstDetect
                , dRealPositionOfSecondDetect
				, dRealPositionOfSmallAddCheck
				,bDetectFirst
				,bDetectSecond
                );

        }
        //2 4)  기타 이동 중 처리
        else
        {

        }
        return nTmpError;
    }
    // --------------------------------------------------------------------------------------------------------------------------------------
    //1 3. Rear/Front 미감지 된 경우
    // --------------------------------------------------------------------------------------------------------------------------------------
    else
    {
        //2 1)  Front 감지되었다가 넘어간 경우
        if( PreMarkState.FirstMet == true )//pMarkStatus->StateOnFirstMet == true )
        {

            if( PreMarkState.OverRun==false)//pMarkStatus->StateOnOverRunBack==false && CurrStatus->StopWithoutFrontDetect == false )
            {
                if( bStopWithoutFrontDetect == false )
                {
                    if( (bCheckTargetIsNearTargetDist==false)   // Manual 명령 처리
                    ||  (dRealPositionOfNow>dRealDistSumToTarget+20)    // 타겟 거리보다 20mm 더 먼 곳
                    ||  (   (dRealPositionOfFirstMetWithNoDetectStart!=0.0) // Front 시작 점 부터 거리
                        &&  (dRealPositionOfNow>dRealPositionOfFirstMetWithNoDetectStart
                                                +MarkParam.Dist.dDistFromFirstToSecond
                                                +MarkParam.Dist.dLengthOfSecond)
                        )
                    ||  (   (dRealPositionOfSecondMet!=0.0) // Rear 만난 경우 그 위치에서 Rear 감지거리 만큼 더
                        &&  (dRealPositionOfNow>dRealPositionOfSecondMet
                                                +MarkParam.Dist.dLengthOfSecond)
                        )

                    )
                    {
                        pMarkState->OverRun = true;
                        //1 >>>MoveStop
                        pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;//Tag.AccelOfSecond;
                        pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;

						ADD_LOG("D_311/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%d/%d"
							, dRealPositionOfNow
							, dRealPositionOfFirstDetect
							, dRealPositionOfSecondDetect
							, dRealPositionOfSmallAddCheck
							, dRealDistSumToTarget
							, dRealPositionOfFirstMetWithNoDetectStart
							, dRealPositionOfSecondMet
							,bDetectFirst
							,bDetectSecond
                            );
                    }
                }
            }
            else if(PreMarkState.OverRun==true)
            {
                if( bStopWithoutFrontDetect == true)
                {
                    pMarkState->Recovery=true;
                    // Second Met을 활성화 하는 이유:   Second 만나고 아래 완료 루틴으로 들어가게 하려함
//                  pMarkState->OverRun = true; //pMarkStatus->StateOnOverRunBack = true;
                    //1     >>>Second 넘어간 경우:  Small Add Move -2.5mm
                    pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet;//Tag.AccelOfSecond;
                    pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;//Tag.AccelOfSecond;
                    pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfSecondMet);//Tag.SpeedOfSecond;
                    pCtrlInfo->Dynamic.dDist    = dRealPositionOfNow-100.0;     // 현재 위치에서 Second 감지 거리의 2배 위치까지

                    memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
//                  pCtrlInfo->Dynamic.AdditionalInfo.bStartOnSpeedDown     = true;
                    pCtrlInfo->Dynamic.AdditionalInfo.bUseSmallAdd              = true;

#if((OHT_NAME == OHT_NAME_STD_V85) || (OHT_NAME == OHT_NAME_STD_V81S)||(OHT_NAME == OHT_NAME_STD_V85S)||(OHT_NAME == OHT_NAME_STD_V82)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
					pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 57;
#else
					pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 54;
#endif

                    pCtrlInfo->Dynamic.AdditionalInfo.bIsTriggerOnRisingEdge    = false;
                    pCtrlInfo->Dynamic.AdditionalInfo.dSmallDistance            = MarkParam.Dist.dAddDistAfterSecondMet;//Tag.AddLengthForSecond;

                    pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;//Event.Flag.MarkEvent_BackFromOverRun= true;

                    ADD_LOG("D_312/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%d/%d"
                        , dRealPositionOfNow
                        , dRealPositionOfFirstDetect
                        , dRealPositionOfSecondDetect
						, dRealPositionOfSmallAddCheck
						,bDetectFirst
						,bDetectSecond
                        );
                }

            }
        }
        //2 2)  정상 Routine으로 센서가 아직 감지되지 않은 경우: small add move 시작(125mm : 0.50mm/msec : 0.0010 mm/msec2 )
        else if( PreMarkState.OnRoutineIn == false )//pMarkStatus->StateOnStopRoutineIn== false)
        {
            pMarkState->OnRoutineIn = true; //pMarkStatus->StateOnStopRoutineIn = true;

            //1 >>>Small Add Move 125mm
            pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfFirstMet;//Tag.AccelOfFirst;
            pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfFirstMet;//Tag.AccelOfFirst;
            pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfFirstMet);//Tag.SpeedOfFirst;
            pCtrlInfo->Dynamic.dDist    = dRealDistSumToLimit;      // 현재 위치에서 Second 길이의 2배 위치까지

            memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
//          pCtrlInfo->Dynamic.AdditionalInfo.bStartOnSpeedDown     = true;
            pCtrlInfo->Dynamic.AdditionalInfo.bUseSmallAdd              = true;

		   //	pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 53;
#if((OHT_NAME == OHT_NAME_STD_V85) || (OHT_NAME == OHT_NAME_STD_V81S)||(OHT_NAME == OHT_NAME_STD_V85S)||(OHT_NAME == OHT_NAME_STD_V82)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
			pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 57;
#else
			pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 54;
#endif

            pCtrlInfo->Dynamic.AdditionalInfo.bIsTriggerOnRisingEdge    = false;
			pCtrlInfo->Dynamic.AdditionalInfo.dSmallDistance            = (MarkParam.Dist.dAddDistAfetrFirstMet/3);//MarkParam.Dist.dAddDistAfterSecondMet;//MarkParam.Dist.dAddDistAfetrFirstMet;//125;//Tag.AddLengthForFirst;

            pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;//Event.Flag.MarkEvent_NextIsStop_and_SpeedDown   = true;

            ADD_LOG("D_313/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%d/%d"
                , dRealPositionOfNow
                , dRealPositionOfFirstDetect
                , dRealPositionOfSecondDetect
				, dRealPositionOfSmallAddCheck
				,bDetectFirst
				,bDetectSecond
				);
        }
        //2 3)  정지 한 경우: 현재 위치 확인 후 에러  혹은 small add move
        else if( bStopWithoutFrontDetect == true )
        {
            //1 >>>Small Add Move 125mm
            pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfFirstMet;//Tag.AccelOfFirst;
            pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfFirstMet;//Tag.AccelOfFirst;
            pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfFirstMet);//Tag.SpeedOfFirst;
            pCtrlInfo->Dynamic.dDist    = dRealPositionOfNow + MarkParam.Dist.dAddDistAfetrFirstMet;      // 현재 위치에서 Second 길이의 2배 위치까지

            memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
//          pCtrlInfo->Dynamic.AdditionalInfo.bStartOnSpeedDown     = true;
            pCtrlInfo->Dynamic.AdditionalInfo.bUseSmallAdd              = true;

#if((OHT_NAME == OHT_NAME_STD_V85) || (OHT_NAME == OHT_NAME_STD_V81S)||(OHT_NAME == OHT_NAME_STD_V85S)||(OHT_NAME == OHT_NAME_STD_V82)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
			pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 57;
#else
			pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 54;
#endif

            pCtrlInfo->Dynamic.AdditionalInfo.bIsTriggerOnRisingEdge    = false;
            pCtrlInfo->Dynamic.AdditionalInfo.dSmallDistance            = (MarkParam.Dist.dAddDistAfetrFirstMet/3);//125;//Tag.AddLengthForFirst;

            pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;//Event.Flag.MarkEvent_NextIsStop_and_SpeedDown   = true;

            ADD_LOG("D_314/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%d/%d"
                , dRealPositionOfNow
                , dRealPositionOfFirstDetect
                , dRealPositionOfSecondDetect
				, dRealPositionOfSmallAddCheck
				,bDetectFirst
				,bDetectSecond
                );
        }
        //2 4)  기타 이동 중 처리
        else
        {

        }
        return nTmpError;
    }

    return nTmpError;

}
/**
@brief DrivingControl Mark 구동 정보 획득 함수(QRStation)
@author
@date    2013.07.01
*/
int DrivingControl::markOnQRStationDiffType(bool bIsLeft, DRIVING_HW_INFO_SET HwInfo, double dRealDistSumToTarget, double dSpeedLimit, int nTargetID, DRIVING_MARK_STATE* pMarkState, CTRL_INFO_OF_SYNC_AXIS_MOVE* pCtrlInfo, CTRL_INFO_OF_ID_READER_CMD_TYPE *pIdReaderCmdType, int* pnID)
{
	int     nTmpID = 0;
    static int nTmpTargetID =0;
    double  dOffset  = 0.0;
    static double dStaticQRCenterPosition = 0.0;
    static int nStaticQrReenableCount = 0;
    bool    bIdReaded = false;
	static DWORD dwStaticCheckTime = 0;
	static DWORD dwQRCheckTime = 0;
	static bool bQRRestart = false;
	static bool bQRRestartCompleted = false;
	static DWORD dwStaticQRRestartTime = 0;
	DWORD   dwCurrTime = timeGetTime();
	static int nCntMarkPos = 0;

	int     nTmpError = NO_ERR;

	// Omron QR Reader 용 16.02.03
	static CTRL_INFO_OF_ID_READER_CMD_TYPE	preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_NONE;

    memset(pCtrlInfo, 0x00, sizeof(CTRL_INFO_OF_SYNC_AXIS_MOVE));
	*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_NONE;

    DRIVING_MARK_STATE PreMarkState = *pMarkState;
    DRIVING_MARK_PARAM MarkParam;

    static CTRL_INFO_OF_SYNC_AXIS_MOVE NextCtrlInfo;
	static bool bNextCtrlInfoExist = false;
	static bool bFrontDetectOffAfterMoveS = false;
	static bool bNonSenseFlag = false;

	// --------------------------------------------------------------------------------------------------------------------------------------
    //1 0. 정보 획득
    // --------------------------------------------------------------------------------------------------------------------------------------
	if(bIsLeft==true)
	{
		MarkParam = m_pParamSet->Mark[2];
        nTmpID = HwInfo.QrStaionLeft.nQrId;
        dOffset = HwInfo.QrStaionLeft.dQrOffset;
    }
    else
    {
		MarkParam = m_pParamSet->Mark[3];
		nTmpID = HwInfo.QrStaionRight.nQrId;
        dOffset = HwInfo.QrStaionRight.dQrOffset;
    }

    bool    bAxis1InPosition            = HwInfo.IO.Axis1InPosition;
    static  TIME_CHECK  StopWithoutFrontDetect;
	bool    bStopWithoutFrontDetect = false;

//    if(HwInfo.IO.Axis1Running==false && HwInfo.IO.ObsStatus!=DETECT_AND_STOP && HwInfo.IO.DetectStatus!=DETECT_AND_STOP)
	if(HwInfo.IO.Axis1Running==false
	&& ((HwInfo.IO.DetectStatus!=DETECT_AND_STOP) || (pHWSet->GetAMCVHLDetectStatus() ==0)))
	{
		if(StopWithoutFrontDetect.bFlag==false)
        {
            StopWithoutFrontDetect.dwTime = dwCurrTime;
            StopWithoutFrontDetect.bFlag = true;
        }
		else if(OHTUTILITY::PreventOverflowGetTimeMs(StopWithoutFrontDetect.dwTime)>200)
        {
            bStopWithoutFrontDetect = true;
        }
    }
    else
    {
        StopWithoutFrontDetect.bFlag = false;
        bStopWithoutFrontDetect = false;
    }


	double  dSpeedOfNow          		       	= HwInfo.Axis1.dSpeed;      //m_pDrivingAxis->GetCurrentPosition(); //미보정 현재 위치
    double  dRealPositionOfNow                  = HwInfo.Axis1.dCurrPos;    //미보정 현재 위치
    static  double  dRealPositionOfMostPositive = 0.0;                      // 최대로 멀리갔을 때의 거리

	static 	double  dRealPositionOfFirstDetect = 0.0;
	static	double  dQROffset = 0.0;

	if(PreMarkState.OnRoutineIn==false)
    {
        StopWithoutFrontDetect.bFlag = false;
        StopWithoutFrontDetect.dwTime = dwCurrTime;
        dwStaticCheckTime = dwCurrTime;
        nTmpTargetID = nTargetID;
        dRealPositionOfMostPositive = dRealPositionOfNow;
        dStaticQRCenterPosition = 0.0;
        nStaticQrReenableCount = 0;
        memset(&NextCtrlInfo, 0x00, sizeof(CTRL_INFO_OF_SYNC_AXIS_MOVE));
		bNextCtrlInfoExist = false;
		bQRRestartCompleted = false;
		bQRRestart = false;
		dwStaticQRRestartTime = dwCurrTime;
		bFrontDetectOffAfterMoveS = false;
		bNonSenseFlag= false;

		if(bIsLeft==true) m_pLeftQRR->ResetDecodeTime();
		else m_pRightQRR->ResetDecodeTime();
		nMinDecode = 0;
		nMaxDecode = 0;
		dAvgDecode = 0.0;
		nQRSetupVersion = 0;
		if (m_mccparam.bMarkStartFlag == false)
		{
			ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,QR MARK,Start,%s,%06d,%06d,%06d,%d,%3.3lf,Mark Type,%d",
					m_defualtparam->VHLName,m_mccparam.cCarrierType,
					m_mccparam.uSourceNode,
					m_mccparam.uTargetNode,
					m_pExecuteInfo->ExecutePositionInfo.CurrNode,
					m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
					dSpeedOfNow,
					m_InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType);

			AUTO_RECOV_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,QR MARK,Start,%s,%06d,%06d,%06d,%d,%3.3lf,Mark Type,%d",
						m_defualtparam->VHLName,m_mccparam.cCarrierType,
						m_mccparam.uSourceNode,
						m_mccparam.uTargetNode,
						m_pExecuteInfo->ExecutePositionInfo.CurrNode,
						m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
						dSpeedOfNow,
						m_InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType);
			m_mccparam.bMarkStartFlag = true;
			m_mccparam.dMarkStartSpeed = dSpeedOfNow;
			m_mccparam.dMarkStartDist = dRealPositionOfNow;
			m_mccparam.bMarkingOHTDetectStop = false;
		}
    }
    else
    {
        dRealPositionOfMostPositive = (dRealPositionOfNow>dRealPositionOfMostPositive)?dRealPositionOfNow:dRealPositionOfMostPositive;
    }

    if(nTmpTargetID==0 && nTmpID!=0)
    {
        nTmpTargetID = nTmpID;
    }
    bIdReaded = (nTmpID==nTmpTargetID&&nTmpTargetID!=0)?true:false;
    if(bIdReaded==true)
    {
        dStaticQRCenterPosition = dRealPositionOfNow + dOffset;
    }

	//2 근접 제어 센서를 Off 시키는 조건
//	if(pMarkState->FollowCtrlOffArea==false)
	if(CanIgnoreVHLDetect())
	{

		if(PreMarkState.FirstMet==true)
//		if(PreMarkState.Arrived==true)
		{

			m_pDrivingAxis->SetVHLDetectIgnor();
			m_bIsAMCVHLDetectIgnore = true;
//			pMarkState->FollowCtrlOffArea=true;
			bFrontDetectOffAfterMoveS = false;
			bNonSenseFlag = true;
        }
    }
	if(pMarkState->FollowCtrlOffArea==false)
	{
		if(PreMarkState.Arrived==true)
		{
        	pMarkState->FollowCtrlOffArea=true;
		}
	}

	// 근접제어 센서 off이후 Move S 명령 추가
//	if(pMarkState->FollowCtrlOffArea==true && bFrontDetectOffAfterMoveS ==false)
	if(pHWSet->GetAMCVHLDetectStatus() ==0 && bFrontDetectOffAfterMoveS ==false && bNonSenseFlag ==true)
	{
       pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
	   pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
	   bFrontDetectOffAfterMoveS = true;
	   return nTmpError;
	}

    // --------------------------------------------------------------------------------------------------------------------------------------
    //1 0. 에러 처리
    // --------------------------------------------------------------------------------------------------------------------------------------
    if(dRealPositionOfNow>(dRealDistSumToTarget+MarkParam.Dist.dForwardMoveDistLimit))
    {
		pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
        pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
		nTmpError = (bIsLeft)?ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_LEFT_MET_LATE:ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_RIGHT_MET_LATE;
		ADD_FDC_LOG("ERR/%d/2/6/%06d/%06d/%d/%d/%06d/%6.1lf",
					nTmpError,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pExecuteInfo->ExecutePositionInfo.NextNode,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					m_pOHTMainStatus->StatusCommon.ExistFoup,
					m_pOHTMainStatus->StatusCommon.StopStationID,
					dRealPositionOfNow - (dRealDistSumToTarget+MarkParam.Dist.dForwardMoveDistLimit));

//		m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset =  MarkParam.Dist.dForwardMoveDistLimit;
		ERR_LOG("[QR Mark] ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_MET_LATE(Left%d): %6.1lf > %6.1lf (%6.1lf + %6.1lf)"
            , bIsLeft, dRealPositionOfNow, (dRealDistSumToTarget+MarkParam.Dist.dForwardMoveDistLimit)
            , dRealDistSumToTarget, MarkParam.Dist.dForwardMoveDistLimit);
        return nTmpError;
    }
    else if(dRealPositionOfNow<(dRealPositionOfMostPositive-MarkParam.Dist.dBackMoveDistLimit))
    {
        pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
        pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
        nTmpError = (bIsLeft)?ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_LEFT_MOVE_BACK_LIMIT:ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_RIGHT_MOVE_BACK_LIMIT;
        ERR_LOG("[QR] ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_MOVE_BACK_LIMIT(Left%d): %6.1lf < %6.1lf (%6.1lf - %6.1lf)"
            , bIsLeft
            , dRealPositionOfNow, (dRealPositionOfMostPositive-MarkParam.Dist.dBackMoveDistLimit)
            , dRealPositionOfMostPositive, MarkParam.Dist.dBackMoveDistLimit);
		ADD_FDC_LOG("ERR/%d/1/8/%06d/%06d/%d/%d/%06d/%f/%f/%f",
					nTmpError,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pExecuteInfo->ExecutePositionInfo.NextNode,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					m_pOHTMainStatus->StatusCommon.ExistFoup,
					m_pOHTMainStatus->StatusCommon.StopStationID,
					dRealPositionOfNow,
					dRealPositionOfMostPositive,
					MarkParam.Dist.dBackMoveDistLimit);
        return nTmpError;
    }

    // --------------------------------------------------------------------------------------------------------------------------------------
    //1 1. Target 위치로 정위치 이동 중
	// --------------------------------------------------------------------------------------------------------------------------------------
    if(PreMarkState.SecondMet==true)
    {
        // 정지 했을 때
		if(bStopWithoutFrontDetect==true)
        {
			if(PreMarkState.IdCheck==false)
			{
				*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;

				preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;

				pMarkState->IdCheck = true;
				dwStaticCheckTime = dwCurrTime;
				ADD_LOG("D-175");
				nCntMarkPos++;
			}
			else
			{
//              *pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_OFF; //1 확인 필요: Trigger Off 시 읽은 이전 Trigger 정보 보내는 것도 취소 여부

				if(bIdReaded==true)
				{
					if(fabs(dOffset)<MarkParam.Dist.dMarkInPosLimit)
					{
						pMarkState->Arrived = true;
						if(pnID!=NULL)
						{
							*pnID = nTmpID;
							ADD_LOG("D_315/%6.1lf/%6X/%6.1lf"
								, dRealPositionOfNow, nTmpID, dOffset);
							ADD_LOG("D_316/%d", nCntMarkPos);
							nCntMarkPos = 0;
						}
					}
					else    // 오차 범위 가 아닐 경우 반복 보정
					{
						dwStaticCheckTime = dwCurrTime;

						//*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;

						//preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;

						pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet;
						pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;
						pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfSecondMet);
						pCtrlInfo->Dynamic.dDist    = dRealPositionOfNow+dOffset;
						memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
						pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;

						dStaticQRCenterPosition = dRealPositionOfNow+dOffset;
						nStaticQrReenableCount  = 0;

						ADD_LOG("D_317/%6.1lf/%6X/%6.1lf"
							, dRealPositionOfNow, nTmpID, dOffset);
						nCntMarkPos++;
					}
				}
				else    // 일정 시간 읽히지 않을 경우 에러 처리
				{
					if(OHTUTILITY::PreventOverflowGetTimeMs(dwStaticCheckTime)>1100/*200*/)  //1100
					{
						if((nStaticQrReenableCount)>10)// Time Over
						{
							pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
							pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;

                            //AOHC-374
							if(m_pExecuteInfo->nFinishOfStation == nTmpTargetID)
							{
								nTmpError = ERR_QRR_READTIMEOUT;
								*pnID = nTmpTargetID;
								//오버런 처리
								m_pExecuteInfo->FlagOverRunInfo.bCheck = true;
								m_pExecuteInfo->FlagOverRunInfo.OverrunType = 0x02; //이적재
								m_pExecuteInfo->FlagOverRunInfo.nFinalNode = nTmpTargetID;    //주행은 주행, 이적재는 이적재
								m_PositionInfo.CurrStation = nTmpTargetID;
								m_pExecuteInfo->FlagOverRunInfo.dDrivingInitPosition = 0.0;

								ERR_LOG("[QR Mark] 2nd Met: ERR_QRR_READTIMEOUT");

								ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d/%d",
											ERR_QRR_READTIMEOUT,
											m_pOHTMainStatus->StatusCommon.CurNodeID,
											m_pExecuteInfo->ExecutePositionInfo.NextNode,
											m_pOHTMainStatus->StatusCommon.CurNodeOffset,
											m_pOHTMainStatus->StatusCommon.ExistFoup,
											m_pOHTMainStatus->StatusCommon.StopStationID,
											bIsLeft);
							}else
							{
								ERR_LOG("[Check]AOHC-374_5/%d",nTmpTargetID);
								pMarkState->Arrived = true;
								*pnID = nTmpTargetID;
								nCntMarkPos = 0;

							}
						}
						*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;

						preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;

						nStaticQrReenableCount++;
						dwStaticCheckTime = dwCurrTime;
						ADD_LOG("D_318/%d", nStaticQrReenableCount);
					}
					else
					{

						if(preQrCmdType != CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON)
						{
							preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
							*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
						}
					}
				}
			}
		}
		else    // 이동 중일 때
		{
			*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_OFF;

			if(preQrCmdType == CTRL_INFO_OF_ID_READER_CMD_TRIGGER_OFF)
			{
				*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_NONE;
			}
			preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_OFF;

			pMarkState->IdCheck = false;
			dwStaticCheckTime = dwCurrTime;
			dwQRCheckTime = dwCurrTime;
		}
	}
	// --------------------------------------------------------------------------------------------------------------------------------------
	//1 2. Target ID 를 처음으로 만난 경우
	// --------------------------------------------------------------------------------------------------------------------------------------
	else if(PreMarkState.FirstMet==true)
	{
		if(bStopWithoutFrontDetect==true)
		{
			if(PreMarkState.IdCheck==false)
			{
				*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;

				preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;

				pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
				pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
				memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));

				pMarkState->IdCheck = true;
				dwStaticCheckTime = dwCurrTime; // time check for moving back start
				ADD_LOG("D-176");
			}
			else
			{
				if(bIdReaded==true)
				{
					pMarkState->SecondMet=true;
					dwStaticCheckTime = dwCurrTime;

					//*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_RESTART;

					//preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_RESTART;

					pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet;
					pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;
					pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfSecondMet);
					pCtrlInfo->Dynamic.dDist    = dRealPositionOfNow+dOffset;
					memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
					pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;

					dStaticQRCenterPosition = dRealPositionOfNow+dOffset;
					nStaticQrReenableCount  = 0;

					ADD_LOG("D_319/%6.1lf/%6d/%6.1lf"
						, dRealPositionOfNow, nTmpID, dOffset);
				}
				else    // 읽히지 않을 경우 뒤로 이동하며 확인
				{
					if(OHTUTILITY::PreventOverflowGetTimeMs(dwStaticCheckTime)>1100)// Time Interval Control  1100
					{
						pMarkState->OverRun=true;
						pMarkState->Recovery=true;
						dwStaticCheckTime = dwCurrTime;

						//*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_RESTART;

						//preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_RESTART;

						pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfFirstMet;
						pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfFirstMet;
						pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfFirstMet);
						pCtrlInfo->Dynamic.dDist    = dStaticQRCenterPosition
													- ((MarkParam.Dist.dAddDistAfetrFirstMet)*nStaticQrReenableCount);

						ERR_LOG("[QR Mark] 1st Met: Stoped and move back [Pos:%6.1lf BackDist:%6.1lf-%6.1lf] ReEnable[%d]"
							, dRealPositionOfNow
							, dStaticQRCenterPosition
							, ((MarkParam.Dist.dAddDistAfetrFirstMet)*nStaticQrReenableCount)
							, nStaticQrReenableCount
							);

						memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
						pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;
						nStaticQrReenableCount++;
					}
					else
					{
						if(preQrCmdType != CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON)
						{
							preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
							*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
						}
					}
				}
			}

		}
		else
		{
		/*
			if(bNextCtrlInfoExist==true)    // ID 읽혀 감속 정지 중일 경우 ID 위치로 다시 명령을 주는 Routine
			{
				*pCtrlInfo = NextCtrlInfo;
				bNextCtrlInfoExist = false;
			}
		*/
			pMarkState->IdCheck = false;
			dwStaticCheckTime = dwCurrTime;
		}
	}
	// --------------------------------------------------------------------------------------------------------------------------------------
	//1 3. Target ID 를 만나기 전 찾고 있는 경우
	// --------------------------------------------------------------------------------------------------------------------------------------
	else if(PreMarkState.OnRoutineIn==true)
	{
		if(bIdReaded==true)
		{
			pMarkState->FirstMet=true;

//			*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_RESTART;
//
//			preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_RESTART;
//
//			pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
//			pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
//			dwStaticCheckTime = dwCurrTime; // time check for moving back start
//			pMarkState->IdCheck = false;
//
//			NextCtrlInfo.Dynamic.dAccel = MarkParam.Accel.dOfFirstMet;
//			NextCtrlInfo.Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;;//MarkParam.Accel.dOfFirstMet;
//			NextCtrlInfo.Dynamic.dSpeed = MIN(dSpeedLimit, MarkParam.Speed.dOfFirstMet);
//			NextCtrlInfo.Dynamic.dDist  = dRealPositionOfNow+dOffset;
//			memset(&NextCtrlInfo.Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
//			NextCtrlInfo.byType = AXIS_CTRL_CMD_MOVE_DS;
//			bNextCtrlInfoExist = true;

//			if(m_pExecuteInfo->ExecuteMode == EXECUTE_MODE_MANUAL)
//			{
				pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
				pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;

				dwStaticCheckTime = dwCurrTime;
				pMarkState->IdCheck = false;
//			}
//			else
//			{
//				pCtrlInfo->Dynamic.dAccel = MarkParam.Accel.dOfFirstMet;
//				pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
//				pCtrlInfo->Dynamic.dSpeed = MIN(dSpeedLimit, MarkParam.Speed.dOfFirstMet);
//				pCtrlInfo->Dynamic.dDist  = dRealPositionOfNow+dOffset;
//				memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
//				pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;
//
//				dwStaticCheckTime = dwCurrTime;
//				pMarkState->IdCheck = false;
//			}

			ADD_LOG("D_320/%6.1lf/%6d/%6.1lf"
				, dRealPositionOfNow, nTmpID, dOffset);
			dRealPositionOfFirstDetect = dRealPositionOfNow;
			dQROffset = dOffset;
			if(m_mccparam.dMarkSecondDetectSpeed == 0.0)
			{
				m_mccparam.dMarkSecondDetectSpeed = dSpeedOfNow;
			}
		}
		else
		{
			if(preQrCmdType != CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON)
			{
				preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
				*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
			}

			if(OHTUTILITY::PreventOverflowGetTimeMs(dwStaticCheckTime)>1100)   // 50ms: QR 센서의 프로세싱 타임 20여ms 이므로 2배수 산정     1100
			{
				//preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_RESTART;
				//*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_RESTART;

				preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
				*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;

				dwStaticCheckTime = dwCurrTime; // time check for moving back start
			}

			if(bStopWithoutFrontDetect==true)
			{
				if(fabs(dRealPositionOfNow-(dRealDistSumToTarget+MarkParam.Dist.dForwardMoveDistLimit))<10) //+100 삭제
				{
					// 이곳에 들어오기 전에 거리 초과로 에러 발생, 만일 들어올 경우 에러 처리
					pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
					pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
					nTmpError = (bIsLeft)?ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_LEFT_MET_LATE:ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_RIGHT_MET_LATE;


					ERR_LOG("[QR Mark] On Routine: ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_MET_LATE(Left:%d) [Pos:%6.1lf ≒ %6.1lf (%6.1lf + %6.1lf + 100)]"
						, bIsLeft, dRealPositionOfNow, (dRealDistSumToTarget+MarkParam.Dist.dForwardMoveDistLimit)
						, dRealDistSumToTarget, MarkParam.Dist.dForwardMoveDistLimit);
					ADD_FDC_LOG("ERR/%d/3/6/%06d/%06d/%d/%d/%06d/%6.1lf",
								nTmpError,
								m_pOHTMainStatus->StatusCommon.CurNodeID,
								m_pExecuteInfo->ExecutePositionInfo.NextNode,
								m_pOHTMainStatus->StatusCommon.CurNodeOffset,
								m_pOHTMainStatus->StatusCommon.ExistFoup,
								m_pOHTMainStatus->StatusCommon.StopStationID,
								dRealPositionOfNow - (dRealDistSumToTarget+MarkParam.Dist.dForwardMoveDistLimit));
					return nTmpError;
				}
				else
				{
					if(bQRRestartCompleted == false)
					{
						if(bQRRestart == false)
						{
							*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;

							preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;

							bQRRestart = true;
							dwStaticQRRestartTime = dwCurrTime;
							ADD_LOG("D_321/%6.1lf", dRealPositionOfNow);
						}
						if((bQRRestart == true) && (OHTUTILITY::PreventOverflowGetTimeMs(dwStaticQRRestartTime)>200))
						{
							pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfFirstMet;
							if(pHWSet->GetAMCDecelStatus() >= AMCDECEL_VHLDETECT)
								pCtrlInfo->Dynamic.dDecel   = VHLDETECT_DECEL;
							else
							    pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfFirstMet;
							pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfFirstMet);
							pCtrlInfo->Dynamic.dDist    = dRealDistSumToTarget+MarkParam.Dist.dForwardMoveDistLimit+50;    // 50 : Dist margin to go over forward limit for checking overrun error
							memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
							pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;
							ADD_LOG("D_322/%6.1lf/%6.1lf"
								, dRealDistSumToTarget+MarkParam.Dist.dForwardMoveDistLimit+50
								, dRealPositionOfNow);
							bQRRestartCompleted = true;
							bQRRestart = false;
						}
					}
				}
            }
            else
            {
//              ADD_LOG("D-177");
                // None
            }
			if(m_mccparam.dMarkFirstDetectSpeed == 0.0)
			{
				m_mccparam.dMarkFirstDetectSpeed = dSpeedOfNow;
			}
        }
    }
	else if(PreMarkState.OnRoutineIn==false)
    {
        if((fabs(m_InfoSet.HwInfo.Axis1.dFinalPos - dRealDistSumToTarget) < ACCEPTABLE_DRIVING_POSITION_ERROR)
        || (m_InfoSet.HwInfo.Axis1.dFinalPos == 0))
        {
            pMarkState->OnRoutineIn=true;
        }

		*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;

		preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;

		pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfFirstMet;
		if(pHWSet->GetAMCDecelStatus() >= AMCDECEL_VHLDETECT)
			pCtrlInfo->Dynamic.dDecel   = VHLDETECT_DECEL;
		else
		    pCtrlInfo->Dynamic.dDecel   = QRR_MARK_FIRST_DECEL;//MarkParam.Accel.dOfFirstMet;
		pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfFirstMet);
		pCtrlInfo->Dynamic.dDist    = dRealDistSumToTarget;
        memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
		pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;
		ADD_LOG("D_323/%6.1lf/%6.1lf"
            , dRealDistSumToTarget, dRealPositionOfNow);
    }

	if((pMarkState->Arrived == true) && (m_mccparam.bMarkStartFlag == true))
	{
		STATION_DATA *pSData;
		pSData = OHTMainForm->GetStationDataManager()->Find(m_mccparam.uTargetNode);

		UINT temp_parent_id = 0;
		int temp_parent_offset = 0;
		int temp_current_offset = m_pOHTMainStatus->StatusCommon.CurNodeOffset;

		if(pSData != NULL)
		{
			temp_parent_id = pSData->ParentNodeID;
			temp_parent_offset = pSData->StationOffset;

			if(temp_parent_offset == 0)
			{
				DRIVING_CMD_INFO_OF_PATH* pPathInfo = NULL;
				int nCount = m_ClassifiedCmd.PathList.getCount() - 2;
				if(nCount >= 0)
				{
					pPathInfo = m_ClassifiedCmd.PathList.refer(nCount);
					temp_current_offset = pPathInfo->dLength - temp_current_offset;
				}
			}
		}

		if(bIsLeft==true)
		{
			nMinDecode = m_pLeftQRR->GetMinDecodeTime();
			nMaxDecode = m_pLeftQRR->GetMaxDecodeTime();
			dAvgDecode = m_pLeftQRR->GetAvgDecodeTime();
			nQRSetupVersion = m_pLeftQRR->GetSetupVersion();
		}
		else
		{
			nMinDecode = m_pRightQRR->GetMinDecodeTime();
			nMaxDecode = m_pRightQRR->GetMaxDecodeTime();
			dAvgDecode = m_pRightQRR->GetAvgDecodeTime();
			nQRSetupVersion = m_pRightQRR->GetSetupVersion();
		}
		ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,QR MARK,End,%s,%06d,%06d,%06d,%d,%3.3lf,Mark Type,%d,QR Mark Dist,%6.1lf,QR Offset,%6.1lf,QR Mark Start Speed,%3.3lf,QR Mark Detect Start Speed,%3.3lf,QR Mark First Detect Speed,%3.3lf,ParentNode Offset Difference,%d,Marking OHT Detect And STOP,%d,Parent Node,%d,Parent Node Offset,%d",
					m_defualtparam->VHLName,m_mccparam.cCarrierType,
					m_mccparam.uSourceNode,
					m_mccparam.uTargetNode,
					m_pExecuteInfo->ExecutePositionInfo.CurrNode,
					m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
					dSpeedOfNow,
					m_InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType,
					dRealPositionOfFirstDetect - m_mccparam.dMarkStartDist,
					dQROffset,
					m_mccparam.dMarkStartSpeed,
					m_mccparam.dMarkFirstDetectSpeed,
					m_mccparam.dMarkSecondDetectSpeed,
					temp_parent_offset - temp_current_offset,
					m_mccparam.bMarkingOHTDetectStop,
					temp_parent_id, temp_parent_offset);
		AUTO_RECOV_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,QR MARK,End,%s,%06d,%06d,%06d,%d,%3.3lf,Mark Type,%d,QR Mark Dist,%6.1lf,QR Offset,%6.1lf,QR Mark Start Speed,%3.3lf,QR Mark Detect Start Speed,%3.3lf,QR Mark First Detect Speed,%3.3lf,ParentNode Offset Difference,%d,Marking OHT Detect And STOP,%d,Parent Node,%d,Parent Node Offset,%d,QR Decode Min,%d,QR Decode Max,%d,QR Decode Avg,%3.3lf,LastSetUpVer,%d",
					m_defualtparam->VHLName,m_mccparam.cCarrierType,
					m_mccparam.uSourceNode,
					m_mccparam.uTargetNode,
					m_pExecuteInfo->ExecutePositionInfo.CurrNode,
					m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
					dSpeedOfNow,
					m_InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType,
					dRealPositionOfFirstDetect - m_mccparam.dMarkStartDist,
					dQROffset,
					m_mccparam.dMarkStartSpeed,
					m_mccparam.dMarkFirstDetectSpeed,
					m_mccparam.dMarkSecondDetectSpeed,
					temp_parent_offset - temp_current_offset,
					m_mccparam.bMarkingOHTDetectStop,
					temp_parent_id, temp_parent_offset,
					nMinDecode,nMaxDecode,dAvgDecode,nQRSetupVersion);
		m_mccparam.bMarkStartFlag = false;
		m_mccparam.dMarkStartSpeed = 0.0;
		m_mccparam.dMarkStartDist = 0.0;
		dRealPositionOfFirstDetect = 0.0;
		dQROffset = 0.0;
		m_mccparam.dMarkFirstDetectSpeed = 0.0;
		m_mccparam.dMarkSecondDetectSpeed = 0.0;
	}

    return nTmpError;

}

/**
@brief DrivingControl Mark 구동 정보 획득 함수(QRStation)
@author
@date    2013.07.01
*/
int DrivingControl::markOnQRStationDiffType2(bool bIsLeft, DRIVING_HW_INFO_SET HwInfo, double dRealDistSumToTarget, double dSpeedLimit, int nTargetID, DRIVING_MARK_STATE* pMarkState, CTRL_INFO_OF_SYNC_AXIS_MOVE* pCtrlInfo, CTRL_INFO_OF_ID_READER_CMD_TYPE *pIdReaderCmdType, int* pnID,bool bOverrunIngn,double dSTBOffset, int physicalID)
{
	int     nTmpID = 0;
    static int nTmpTargetID =0;
	double  dOffset  = 0.0;
	double  dSTBGap  = 0.0;
    static double dStaticQRCenterPosition = 0.0;
    static int nStaticQrReenableCount = 0;
    bool    bIdReaded = false;
	static DWORD dwStaticCheckTime = 0;
	static DWORD dwQRCheckTime = 0;
	static bool bQRRestart = false;
	static bool bQRRestartCompleted = false;
	static DWORD dwStaticQRRestartTime = 0;
	DWORD   dwCurrTime = timeGetTime();
	static int nCntMarkPos = 0;
	static bool IsManual = false;
	double dForwardLimit = 0.0;

	int     nTmpError = NO_ERR;

	// Omron QR Reader 용 16.02.03
	static CTRL_INFO_OF_ID_READER_CMD_TYPE	preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_NONE;

    memset(pCtrlInfo, 0x00, sizeof(CTRL_INFO_OF_SYNC_AXIS_MOVE));
	*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_NONE;

    DRIVING_MARK_STATE PreMarkState = *pMarkState;
    DRIVING_MARK_PARAM MarkParam;

    static CTRL_INFO_OF_SYNC_AXIS_MOVE NextCtrlInfo;
	static bool bNextCtrlInfoExist = false;
	static bool bFrontDetectOffAfterMoveS = false;
	static bool bNonSenseFlag = false;

	// --------------------------------------------------------------------------------------------------------------------------------------
    //1 0. 정보 획득
    // --------------------------------------------------------------------------------------------------------------------------------------
	if(bIsLeft==true)
	{
		MarkParam = m_pParamSet->Mark[2];
        nTmpID = HwInfo.QrStaionLeft.nQrId;
		dOffset = HwInfo.QrStaionLeft.dQrOffset;
        dSTBGap = dSTBOffset;
    }
    else
    {
		MarkParam = m_pParamSet->Mark[3];
		nTmpID = HwInfo.QrStaionRight.nQrId;
		dOffset = HwInfo.QrStaionRight.dQrOffset;
		dSTBGap = dSTBOffset;
    }

    bool    bAxis1InPosition            = HwInfo.IO.Axis1InPosition;
    static  TIME_CHECK  StopWithoutFrontDetect;
	bool    bStopWithoutFrontDetect = false;

//    if(HwInfo.IO.Axis1Running==false && HwInfo.IO.ObsStatus!=DETECT_AND_STOP && HwInfo.IO.DetectStatus!=DETECT_AND_STOP)
	if(HwInfo.IO.Axis1Running==false
	&& ((HwInfo.IO.DetectStatus!=DETECT_AND_STOP) || (pHWSet->GetAMCVHLDetectStatus() ==0)))
    {
        if(StopWithoutFrontDetect.bFlag==false)
        {
            StopWithoutFrontDetect.dwTime = dwCurrTime;
            StopWithoutFrontDetect.bFlag = true;
        }
		else if(OHTUTILITY::PreventOverflowGetTimeMs(StopWithoutFrontDetect.dwTime)>200)
        {
            bStopWithoutFrontDetect = true;
        }
    }
    else
    {
        StopWithoutFrontDetect.bFlag = false;
        bStopWithoutFrontDetect = false;
    }

    double  dSpeedOfNow          		       	= HwInfo.Axis1.dSpeed;      //m_pDrivingAxis->GetCurrentPosition(); //미보정 현재 위치
    double  dRealPositionOfNow                  = HwInfo.Axis1.dCurrPos;    //미보정 현재 위치
    static  double  dRealPositionOfMostPositive = 0.0;                      // 최대로 멀리갔을 때의 거리
	static 	double  dRealPositionOfFirstDetect = 0.0;
	static	double  dQROffset = 0.0;

	if(PreMarkState.OnRoutineIn==false)
    {
        StopWithoutFrontDetect.bFlag = false;
        StopWithoutFrontDetect.dwTime = dwCurrTime;
        dwStaticCheckTime = dwCurrTime;
		if(physicalID != 0) nTmpTargetID = physicalID;
		else nTmpTargetID = nTargetID;
		if(nTmpTargetID==0)	IsManual =true;
		else  IsManual =false;

        dRealPositionOfMostPositive = dRealPositionOfNow;
        dStaticQRCenterPosition = 0.0;
        nStaticQrReenableCount = 0;
        memset(&NextCtrlInfo, 0x00, sizeof(CTRL_INFO_OF_SYNC_AXIS_MOVE));
		bNextCtrlInfoExist = false;
		bQRRestartCompleted = false;
		bQRRestart = false;
		dwStaticQRRestartTime = dwCurrTime;
		bFrontDetectOffAfterMoveS = false;
		bNonSenseFlag = false;

		if(bIsLeft==true) m_pLeftQRR->ResetDecodeTime();
		else m_pRightQRR->ResetDecodeTime();
		nMinDecode = 0;
		nMaxDecode = 0;
		dAvgDecode = 0.0;
		nQRSetupVersion = 0;
		if (m_mccparam.bMarkStartFlag == false)
		{
			ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,QR MARK,Start,%s,%06d,%06d,%06d,%d,%3.3lf,Mark Type,%d",
						m_defualtparam->VHLName,m_mccparam.cCarrierType,
						m_mccparam.uSourceNode,
						m_mccparam.uTargetNode,
						m_pExecuteInfo->ExecutePositionInfo.CurrNode,
						m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
						dSpeedOfNow,
						m_InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType);
			AUTO_RECOV_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,QR MARK,Start,%s,%06d,%06d,%06d,%d,%3.3lf,Mark Type,%d",
						m_defualtparam->VHLName,m_mccparam.cCarrierType,
						m_mccparam.uSourceNode,
						m_mccparam.uTargetNode,
						m_pExecuteInfo->ExecutePositionInfo.CurrNode,
						m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
						dSpeedOfNow,
						m_InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType);
			m_mccparam.bMarkStartFlag = true;
			m_mccparam.dMarkStartSpeed = dSpeedOfNow;
			m_mccparam.dMarkStartDist = dRealPositionOfNow;
			m_mccparam.bMarkingOHTDetectStop =false;
		}
	}
    else
    {
		dRealPositionOfMostPositive = (dRealPositionOfNow>dRealPositionOfMostPositive)?dRealPositionOfNow:dRealPositionOfMostPositive;
	}

	if(IsManual==true && nTmpID!=0)
    {
        nTmpTargetID = nTmpID;
    }
    bIdReaded = (nTmpID==nTmpTargetID&&nTmpTargetID!=0)?true:false;
    if(bIdReaded==true)
    {
        dStaticQRCenterPosition = dRealPositionOfNow + dOffset + dSTBGap;
    }

	//2 근접 제어 센서를 Off 시키는 조건
//	if(pMarkState->FollowCtrlOffArea==false)
	if(CanIgnoreVHLDetect())
	{

		if(PreMarkState.FirstMet==true)
//		if(PreMarkState.Arrived==true)
		{

			m_pDrivingAxis->SetVHLDetectIgnor();
			m_bIsAMCVHLDetectIgnore = true;
//			pMarkState->FollowCtrlOffArea=true;
			bFrontDetectOffAfterMoveS = false;
			bNonSenseFlag = true;
        }
	}
	if(pMarkState->FollowCtrlOffArea==false)
	{
		if(PreMarkState.Arrived==true)
			pMarkState->FollowCtrlOffArea=true;
	}

	// 근접제어 센서 off이후 Move S 명령 추가
//	if(pMarkState->FollowCtrlOffArea==true && bFrontDetectOffAfterMoveS ==false)
	if(pHWSet->GetAMCVHLDetectStatus() == 0 && bFrontDetectOffAfterMoveS ==false && bNonSenseFlag ==true)
	{
       pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
	   pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
	   bFrontDetectOffAfterMoveS = true;
	   return nTmpError;
	}

    // --------------------------------------------------------------------------------------------------------------------------------------
    //1 0. 에러 처리
	// --------------------------------------------------------------------------------------------------------------------------------------

	if(bOverrunIngn ==false)
		dForwardLimit = MarkParam.Dist.dForwardMoveDistLimit;
	else
		dForwardLimit = 100.0;

	if(dRealPositionOfNow>(dRealDistSumToTarget+dForwardLimit))
	{
		pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
		pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
		nTmpError = (bIsLeft)?ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_LEFT_MET_LATE:ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_RIGHT_MET_LATE;

//		m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset =  MarkParam.Dist.dForwardMoveDistLimit;
		ERR_LOG("[QR Mark] ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_MET_LATE(Left%d): %6.1lf > %6.1lf (%6.1lf + %6.1lf)"
			, bIsLeft, dRealPositionOfNow, (dRealDistSumToTarget+dForwardLimit)
			, dRealDistSumToTarget, dForwardLimit);
		ADD_FDC_LOG("ERR/%d/2/6/%06d/%06d/%d/%d/%06d/%6.1lf",
					nTmpError,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pExecuteInfo->ExecutePositionInfo.NextNode,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					m_pOHTMainStatus->StatusCommon.ExistFoup,
					m_pOHTMainStatus->StatusCommon.StopStationID,
					dRealPositionOfNow - (dRealDistSumToTarget+dForwardLimit));
        return nTmpError;
    }
    else if(dRealPositionOfNow<(dRealPositionOfMostPositive-MarkParam.Dist.dBackMoveDistLimit))
    {
        pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
        pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
        nTmpError = (bIsLeft)?ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_LEFT_MOVE_BACK_LIMIT:ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_RIGHT_MOVE_BACK_LIMIT;
        ERR_LOG("[QR] ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_MOVE_BACK_LIMIT(Left%d): %6.1lf < %6.1lf (%6.1lf - %6.1lf)"
            , bIsLeft
            , dRealPositionOfNow, (dRealPositionOfMostPositive-MarkParam.Dist.dBackMoveDistLimit)
            , dRealPositionOfMostPositive, MarkParam.Dist.dBackMoveDistLimit);
		ADD_FDC_LOG("ERR/%d/1/8/%06d/%06d/%d/%d/%06d/%f/%f/%f",
					nTmpError,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pExecuteInfo->ExecutePositionInfo.NextNode,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					m_pOHTMainStatus->StatusCommon.ExistFoup,
					m_pOHTMainStatus->StatusCommon.StopStationID,
					dRealPositionOfNow,
					dRealPositionOfMostPositive,
					MarkParam.Dist.dBackMoveDistLimit);
        return nTmpError;
    }

    // --------------------------------------------------------------------------------------------------------------------------------------
    //1 1. Target 위치로 정위치 이동 중
	// --------------------------------------------------------------------------------------------------------------------------------------
    if(PreMarkState.SecondMet==true)
    {
        // 정지 했을 때
		if(bStopWithoutFrontDetect==true)
        {
			if(PreMarkState.IdCheck==false)
			{
				*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;

				preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;

				pMarkState->IdCheck = true;
				dwStaticCheckTime = dwCurrTime;
				ADD_LOG("D-178");
				nCntMarkPos++;
			}
			else
			{
//              *pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_OFF; //1 확인 필요: Trigger Off 시 읽은 이전 Trigger 정보 보내는 것도 취소 여부

				if(bIdReaded==true)
				{
                    if(fabs(dOffset+dSTBGap)<MarkParam.Dist.dMarkInPosLimit)
//					if(fabs(dOffset)<MarkParam.Dist.dMarkInPosLimit)
					{
						pMarkState->Arrived = true;
						if(pnID!=NULL)
						{
							//*pnID = nTmpID;
							if(physicalID != 0) *pnID = nTargetID;
							else *pnID = nTmpTargetID;
//							ADD_LOG("D_324/%6.1lf/%6X/%6.1lf/%6.11f"
//								, dRealPositionOfNow, nTmpID, dOffset,dSTBGap);
							ADD_LOG("D_324/%6.1lf/%d/%6.1lf/%6.11f"
								, dRealPositionOfNow, *pnID, dOffset,dSTBGap);
							ADD_LOG("D_325/%d", nCntMarkPos);
							nCntMarkPos = 0;
						}
					}
					else    // 오차 범위 가 아닐 경우 반복 보정
					{
						dwStaticCheckTime = dwCurrTime;

						//*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;

						//preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;

						pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet;
						pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;
						pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfSecondMet);
						pCtrlInfo->Dynamic.dDist    = dRealPositionOfNow+dOffset+dSTBGap;
						memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
						pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;

						dStaticQRCenterPosition = dRealPositionOfNow+dOffset+dSTBGap;
						nStaticQrReenableCount  = 0;

						ADD_LOG("D_326/%6.1lf/%6X/%6.1lf/%6.11f"
							, dRealPositionOfNow, nTmpID, dOffset, dSTBGap);
						nCntMarkPos++;
					}
				}
				else    // 일정 시간 읽히지 않을 경우 에러 처리
				{
					if(OHTUTILITY::PreventOverflowGetTimeMs(dwStaticCheckTime)>500/*200*/)  //1100
					{
						if((nStaticQrReenableCount)>10)// Time Over
						{
							pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
							pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
							////AOHC-374
							if(m_pExecuteInfo->nFinishOfStation == nTmpTargetID)
							{
								nTmpError = ERR_QRR_READTIMEOUT;
								if(physicalID != 0) *pnID = nTargetID;
								else *pnID = nTmpTargetID;
								//오버런 처리
								m_pExecuteInfo->FlagOverRunInfo.bCheck = true;
								m_pExecuteInfo->FlagOverRunInfo.OverrunType = 0x02; //이적재
								m_pExecuteInfo->FlagOverRunInfo.nFinalNode = *pnID;    //주행은 주행, 이적재는 이적재
								m_PositionInfo.CurrStation = *pnID;
								m_pExecuteInfo->FlagOverRunInfo.dDrivingInitPosition = 0;

								ERR_LOG("[QR Mark] 2nd Met: ERR_QRR_READTIMEOUT");
								ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d/%d",
											ERR_QRR_READTIMEOUT,
											m_pOHTMainStatus->StatusCommon.CurNodeID,
											m_pExecuteInfo->ExecutePositionInfo.NextNode,
											m_pOHTMainStatus->StatusCommon.CurNodeOffset,
											m_pOHTMainStatus->StatusCommon.ExistFoup,
											m_pOHTMainStatus->StatusCommon.StopStationID,
											bIsLeft);
							}else
							{

								ERR_LOG("[Check]AOHC-374_6/%d",nTmpTargetID);
                            	pMarkState->Arrived = true;
								*pnID = nTmpTargetID;
								nCntMarkPos = 0;
							}
						}

						if(fabs(dRealPositionOfNow - dStaticQRCenterPosition) > 35.0)
						{
							if(fabs(dRealPositionOfNow - dStaticQRCenterPosition) < 69.0)
							{
								pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet;
								pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;
								pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfSecondMet);
								pCtrlInfo->Dynamic.dDist    = dStaticQRCenterPosition;
								memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
								pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;
							}
							else
                               nStaticQrReenableCount = 10;

							ERR_LOG("[QR Mark] 2nd Met: OverRun CurrPos:%f QRCenterPos:%f", dRealPositionOfNow,dStaticQRCenterPosition);
						}

						*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;

						preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;

						nStaticQrReenableCount++;
						dwStaticCheckTime = dwCurrTime;
						ADD_LOG("D_327/%d", nStaticQrReenableCount);
					}
					else
					{

						if(preQrCmdType != CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON)
						{
							preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
							*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
						}
					}
				}
			}
		}
		else    // 이동 중일 때
		{
			*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_OFF;

			if(preQrCmdType == CTRL_INFO_OF_ID_READER_CMD_TRIGGER_OFF)
			{
				*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_NONE;
			}
			preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_OFF;

			pMarkState->IdCheck = false;
			dwStaticCheckTime = dwCurrTime;
			dwQRCheckTime = dwCurrTime;
		}
	}
	// --------------------------------------------------------------------------------------------------------------------------------------
	//1 2. Target ID 를 처음으로 만난 경우
	// --------------------------------------------------------------------------------------------------------------------------------------
	else if(PreMarkState.FirstMet==true)
	{
		if(bStopWithoutFrontDetect==true)
		{
			if(PreMarkState.IdCheck==false)
			{
				*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;

				preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;

				pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
				pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
				memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));

				pMarkState->IdCheck = true;
				dwStaticCheckTime = dwCurrTime; // time check for moving back start
				ADD_LOG("D-179");
			}
			else
			{
				if(bIdReaded==true)
				{
					pMarkState->SecondMet=true;
					dwStaticCheckTime = dwCurrTime;

					//*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_RESTART;

					//preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_RESTART;

					pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet;
					pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;
					pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfSecondMet);
					pCtrlInfo->Dynamic.dDist    = dRealPositionOfNow+dOffset +dSTBGap;
					memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
					pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;

					dStaticQRCenterPosition = dRealPositionOfNow+dOffset+dSTBGap;
					nStaticQrReenableCount  = 0;

					ADD_LOG("D_328/%6.1lf/%6d/%6.1lf/%6.11f"
						, dRealPositionOfNow, nTmpID, dOffset, dSTBGap);
				}
				else    // 읽히지 않을 경우 뒤로 이동하며 확인
				{
					if(OHTUTILITY::PreventOverflowGetTimeMs(dwStaticCheckTime)>500)// Time Interval Control  1100
					{
						pMarkState->OverRun=true;
						pMarkState->Recovery=true;
						dwStaticCheckTime = dwCurrTime;

						//*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_RESTART;

						//preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_RESTART;

						pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfFirstMet;
						pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfFirstMet;
						pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfFirstMet);
						pCtrlInfo->Dynamic.dDist    = dStaticQRCenterPosition
													- ((MarkParam.Dist.dAddDistAfetrFirstMet)*nStaticQrReenableCount);

						ERR_LOG("[QR Mark] 1st Met: Stoped and move back [Pos:%6.1lf BackDist:%6.1lf-%6.1lf] ReEnable[%d]"
							, dRealPositionOfNow
							, dStaticQRCenterPosition
							, ((MarkParam.Dist.dAddDistAfetrFirstMet)*nStaticQrReenableCount)
							, nStaticQrReenableCount
							);

						memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
						pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;
						nStaticQrReenableCount++;
					}
					else
					{
						if(preQrCmdType != CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON)
						{
							preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
							*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
						}
					}
				}
			}

		}
		else
		{
		/*
			if(bNextCtrlInfoExist==true)    // ID 읽혀 감속 정지 중일 경우 ID 위치로 다시 명령을 주는 Routine
			{
				*pCtrlInfo = NextCtrlInfo;
				bNextCtrlInfoExist = false;
			}
		*/
			pMarkState->IdCheck = false;
			dwStaticCheckTime = dwCurrTime;
		}
	}
	// --------------------------------------------------------------------------------------------------------------------------------------
	//1 3. Target ID 를 만나기 전 찾고 있는 경우
	// --------------------------------------------------------------------------------------------------------------------------------------
	else if(PreMarkState.OnRoutineIn==true)
	{
		if(bIdReaded==true)
		{
			pMarkState->FirstMet=true;

//			*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_RESTART;
//
//			preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_RESTART;
//
//			pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
//			pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
//			dwStaticCheckTime = dwCurrTime; // time check for moving back start
//			pMarkState->IdCheck = false;
//
//			NextCtrlInfo.Dynamic.dAccel = MarkParam.Accel.dOfFirstMet;
//			NextCtrlInfo.Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;;//MarkParam.Accel.dOfFirstMet;
//			NextCtrlInfo.Dynamic.dSpeed = MIN(dSpeedLimit, MarkParam.Speed.dOfFirstMet);
//			NextCtrlInfo.Dynamic.dDist  = dRealPositionOfNow+dOffset;
//			memset(&NextCtrlInfo.Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
//			NextCtrlInfo.byType = AXIS_CTRL_CMD_MOVE_DS;
//			bNextCtrlInfoExist = true;

//			if(m_pExecuteInfo->ExecuteMode == EXECUTE_MODE_MANUAL)
//			{
				pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
				pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;

				dwStaticCheckTime = dwCurrTime;
				pMarkState->IdCheck = false;
//			}
//			else
//			{
//				pCtrlInfo->Dynamic.dAccel = MarkParam.Accel.dOfFirstMet;
//				pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
//				pCtrlInfo->Dynamic.dSpeed = MIN(dSpeedLimit, MarkParam.Speed.dOfFirstMet);
//				pCtrlInfo->Dynamic.dDist  = dRealPositionOfNow+dOffset;
//				memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
//				pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;
//
//				dwStaticCheckTime = dwCurrTime;
//				pMarkState->IdCheck = false;
//			}

			ADD_LOG("D_329/%6.1lf/%6d/%6.1lf/%6.1lf"
				, dRealPositionOfNow, nTmpID, dOffset, dSTBGap);
			dRealPositionOfFirstDetect = dRealPositionOfNow;
			dQROffset = dOffset;

			if(m_mccparam.dMarkSecondDetectSpeed == 0.0)
			{
				m_mccparam.dMarkSecondDetectSpeed = dSpeedOfNow;
			}
		}
		else
		{
			if(preQrCmdType != CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON)
			{
				preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
				*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
			}

			if(OHTUTILITY::PreventOverflowGetTimeMs(dwStaticCheckTime)>200)   //QR 노출량 추가로 QR Trigger Time 100 ->  200으로 증가
			{
				//preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_RESTART;
				//*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_RESTART;

				preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
				*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;

				dwStaticCheckTime = dwCurrTime; // time check for moving back start
			}

			if(bStopWithoutFrontDetect==true)
			{
				if(fabs(dRealPositionOfNow-(dRealDistSumToTarget+dForwardLimit))<10) //+100 삭제
				{
					// 이곳에 들어오기 전에 거리 초과로 에러 발생, 만일 들어올 경우 에러 처리
					pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
					pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
					nTmpError = (bIsLeft)?ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_LEFT_MET_LATE:ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_RIGHT_MET_LATE;

					ERR_LOG("[QR Mark] On Routine: ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_MET_LATE(Left:%d) [Pos:%6.1lf ≒ %6.1lf (%6.1lf + %6.1lf + 100)]"
						, bIsLeft, dRealPositionOfNow, (dRealDistSumToTarget+dForwardLimit)
						, dRealDistSumToTarget, dForwardLimit);
					ADD_FDC_LOG("ERR/%d/3/6/%06d/%06d/%d/%d/%06d/%6.1lf",
								nTmpError,
								m_pOHTMainStatus->StatusCommon.CurNodeID,
								m_pExecuteInfo->ExecutePositionInfo.NextNode,
								m_pOHTMainStatus->StatusCommon.CurNodeOffset,
								m_pOHTMainStatus->StatusCommon.ExistFoup,
								m_pOHTMainStatus->StatusCommon.StopStationID,
								dRealPositionOfNow - (dRealDistSumToTarget+dForwardLimit));
					return nTmpError;
				}
				else
				{
					if(bQRRestartCompleted == false)
					{
						if(bQRRestart == false)
						{
							*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;

							preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;

							bQRRestart = true;
							dwStaticQRRestartTime = dwCurrTime;
							ADD_LOG("D_330/%6.1lf", dRealPositionOfNow);
						}
						if((bQRRestart == true) && (OHTUTILITY::PreventOverflowGetTimeMs(dwStaticQRRestartTime)>200))
						{
							pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfFirstMet;
							if(pHWSet->GetAMCDecelStatus() >= AMCDECEL_VHLDETECT)
								pCtrlInfo->Dynamic.dDecel   = VHLDETECT_DECEL;
							else
							    pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfFirstMet;
							pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfFirstMet);
							pCtrlInfo->Dynamic.dDist    = dRealDistSumToTarget+MarkParam.Dist.dForwardMoveDistLimit+50;    // 50 : Dist margin to go over forward limit for checking overrun error
							memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
							pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;
							ADD_LOG("D_331/%6.1lf/%6.1lf"
								, dRealDistSumToTarget+MarkParam.Dist.dForwardMoveDistLimit+50
								, dRealPositionOfNow);
							bQRRestartCompleted = true;
							bQRRestart = false;
						}
					}
				}
            }
            else
            {
//              ADD_LOG("D-180");
                // None
            }
			if(m_mccparam.dMarkFirstDetectSpeed == 0.0)
			{
				m_mccparam.dMarkFirstDetectSpeed = dSpeedOfNow;
			}
        }
	}
	else if(PreMarkState.OnRoutineIn==false)
    {
		if((m_defualtparam->bUseVisionTeaching == true) && (m_pExecuteInfo->ExecuteMode != EXECUTE_MODE_AUTO))
		{
        	if((fabs(m_InfoSet.HwInfo.Axis1.dFinalPos - dRealDistSumToTarget) < ACCEPTABLE_DRIVING_POSITION_ERROR_ON_QR_WAIT + 1)
			|| (m_InfoSet.HwInfo.Axis1.dFinalPos == 0))
			{
				pMarkState->OnRoutineIn=true;
			}
		}
		else
		{
			if((fabs(m_InfoSet.HwInfo.Axis1.dFinalPos - dRealDistSumToTarget) < ACCEPTABLE_DRIVING_POSITION_ERROR)
			|| (m_InfoSet.HwInfo.Axis1.dFinalPos == 0))
			{
				pMarkState->OnRoutineIn=true;
			}
		}


		*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;

		preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;

		pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfFirstMet;
		if(pHWSet->GetAMCDecelStatus() >= AMCDECEL_VHLDETECT)
		    pCtrlInfo->Dynamic.dDecel   = VHLDETECT_DECEL;
		else
		    pCtrlInfo->Dynamic.dDecel   = QRR_MARK_FIRST_DECEL;//MarkParam.Accel.dOfFirstMet;
		pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfFirstMet);

		if((m_defualtparam->bUseVisionTeaching == true) && (m_pExecuteInfo->ExecuteMode != EXECUTE_MODE_AUTO))
			pCtrlInfo->Dynamic.dDist    = dRealDistSumToTarget + 5;
		else
			pCtrlInfo->Dynamic.dDist    = dRealDistSumToTarget;

        memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
		pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;
		ADD_LOG("D_332/%6.1lf/%6.1lf"
            , dRealDistSumToTarget, dRealPositionOfNow);
    }

	if((pMarkState->Arrived == true) && (m_mccparam.bMarkStartFlag == true))
	{
		STATION_DATA *pSData;
		pSData = OHTMainForm->GetStationDataManager()->Find(m_mccparam.uTargetNode);

		UINT temp_parent_id = 0;
		int temp_parent_offset = 0;
		int temp_current_offset = m_pOHTMainStatus->StatusCommon.CurNodeOffset;

		if(pSData != NULL)
		{
			temp_parent_id = pSData->ParentNodeID;
			temp_parent_offset = pSData->StationOffset;

			if(temp_parent_offset == 0)
			{
				DRIVING_CMD_INFO_OF_PATH* pPathInfo = NULL;
				int nCount = m_ClassifiedCmd.PathList.getCount() - 2;
				if(nCount >= 0)
				{
					pPathInfo = m_ClassifiedCmd.PathList.refer(nCount);
					temp_current_offset = pPathInfo->dLength - temp_current_offset;
				}
			}
		}
		if(bIsLeft==true)
		{
			nMinDecode = m_pLeftQRR->GetMinDecodeTime();
			nMaxDecode = m_pLeftQRR->GetMaxDecodeTime();
			dAvgDecode = m_pLeftQRR->GetAvgDecodeTime();
			nQRSetupVersion = m_pLeftQRR->GetSetupVersion();
		}
		else
		{
			nMinDecode = m_pRightQRR->GetMinDecodeTime();
			nMaxDecode = m_pRightQRR->GetMaxDecodeTime();
			dAvgDecode = m_pRightQRR->GetAvgDecodeTime();
			nQRSetupVersion = m_pRightQRR->GetSetupVersion();
		}
		ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,QR MARK,End,%s,%06d,%06d,%06d,%d,%3.3lf,Mark Type,%d,QR Mark Dist,%6.1lf,QR Offset,%6.1lf,QR Mark Start Speed,%3.3lf,QR Mark Detect Start Speed,%3.3lf,QR Mark First Detect Speed,%3.3lf,ParentNode Offset Difference,%d,Marking OHT Detect And STOP,%d,Parent Node,%d,Parent Node Offset,%d",
					m_defualtparam->VHLName,m_mccparam.cCarrierType,
					m_mccparam.uSourceNode,
					m_mccparam.uTargetNode,
					m_pExecuteInfo->ExecutePositionInfo.CurrNode,
					m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
					dSpeedOfNow,
					m_InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType,
					dRealPositionOfFirstDetect - m_mccparam.dMarkStartDist,
					dQROffset,
					m_mccparam.dMarkStartSpeed,
					m_mccparam.dMarkFirstDetectSpeed,
					m_mccparam.dMarkSecondDetectSpeed,
					temp_parent_offset - temp_current_offset,
					m_mccparam.bMarkingOHTDetectStop,
					temp_parent_id, temp_parent_offset);
		AUTO_RECOV_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,QR MARK,End,%s,%06d,%06d,%06d,%d,%3.3lf,Mark Type,%d,QR Mark Dist,%6.1lf,QR Offset,%6.1lf,QR Mark Start Speed,%3.3lf,QR Mark Detect Start Speed,%3.3lf,QR Mark First Detect Speed,%3.3lf,ParentNode Offset Difference,%d,Marking OHT Detect And STOP,%d,Parent Node,%d,Parent Node Offset,%d,QR Decode Min,%d,QR Decode Max,%d,QR Decode Avg,%3.3lf,LastSetUpVer,%d",
					m_defualtparam->VHLName,m_mccparam.cCarrierType,
					m_mccparam.uSourceNode,
					m_mccparam.uTargetNode,
					m_pExecuteInfo->ExecutePositionInfo.CurrNode,
					m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
					dSpeedOfNow,
					m_InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType,
					dRealPositionOfFirstDetect - m_mccparam.dMarkStartDist,
					dQROffset,
					m_mccparam.dMarkStartSpeed,
					m_mccparam.dMarkFirstDetectSpeed,
					m_mccparam.dMarkSecondDetectSpeed,
					temp_parent_offset - temp_current_offset,
					m_mccparam.bMarkingOHTDetectStop,
					temp_parent_id, temp_parent_offset,
					nMinDecode,nMaxDecode,dAvgDecode,nQRSetupVersion);

		m_mccparam.bMarkStartFlag = false;
		m_mccparam.dMarkStartSpeed = 0.0;
		m_mccparam.dMarkStartDist = 0.0;
		dRealPositionOfFirstDetect = 0.0;
		dQROffset = 0.0;
		m_mccparam.dMarkFirstDetectSpeed = 0.0;
		m_mccparam.dMarkSecondDetectSpeed = 0.0;
	}
    return nTmpError;

}

/**
@brief DrivingControl Mark 구동 정보 획득 함수(QRStation)
@author  임태웅
@date    2013.07.01
*/
int DrivingControl::markOnQRStation(bool bIsLeft, DRIVING_HW_INFO_SET HwInfo, double dRealDistSumToTarget, double dSpeedLimit, int nTargetID, DRIVING_MARK_STATE* pMarkState, CTRL_INFO_OF_SYNC_AXIS_MOVE* pCtrlInfo, CTRL_INFO_OF_ID_READER_CMD_TYPE *pIdReaderCmdType, int* pnID)
{
	int     nTmpID = 0;
	static int nTmpTargetID =0;
	double  dOffset  = 0.0;
	static double dStaticQRCenterPosition = 0.0;
	static int nStaticQrReTriggerCount = 0;
	static int nStaticQrRetryCount = 0;
	bool    bIdReaded = false;
	static DWORD dwStaticCheckTime = 0;
	static bool bQRMoveTargetPosition = false;
	static DWORD dwStaticQRRestartTime = 0;
	DWORD   dwCurrTime = timeGetTime();

	int     nTmpError = NO_ERR;

	memset(pCtrlInfo, 0x00, sizeof(CTRL_INFO_OF_SYNC_AXIS_MOVE));
	*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_NONE;

	DRIVING_MARK_STATE PreMarkState = *pMarkState;
	DRIVING_MARK_PARAM MarkParam;

	static CTRL_INFO_OF_SYNC_AXIS_MOVE NextCtrlInfo;
	static bool bNextCtrlInfoExist = false;

	// --------------------------------------------------------------------------------------------------------------------------------------
    //1 0. 정보 획득
    // --------------------------------------------------------------------------------------------------------------------------------------
	if(bIsLeft==true)
    {
        MarkParam = m_pParamSet->Mark[2];
        nTmpID = HwInfo.QrStaionLeft.nQrId;
        dOffset = HwInfo.QrStaionLeft.dQrOffset;
    }
    else
	{
        MarkParam = m_pParamSet->Mark[3];
		nTmpID = HwInfo.QrStaionRight.nQrId;
        dOffset = HwInfo.QrStaionRight.dQrOffset;
    }

    bool    bAxis1InPosition            = HwInfo.IO.Axis1InPosition;
    static  TIME_CHECK  StopWithoutFrontDetect;
	bool    bStopWithoutFrontDetect = false;

#if(UBG_SENSOR_ENABLE == ON)
//	if(HwInfo.IO.Axis1Running==false && HwInfo.IO.ObsStatus!=DETECT_AND_STOP && HwInfo.IO.DetectStatus!=DETECT_AND_STOP)
	if(HwInfo.IO.Axis1Running==false
	&& ((HwInfo.IO.DetectStatus!=DETECT_AND_STOP) || (pHWSet->GetAMCVHLDetectStatus() ==0)))
#else
	if(HwInfo.IO.Axis1Running==false && HwInfo.IO.ObsStatus!=DETECT_AND_STOP)
#endif
	{
        if(StopWithoutFrontDetect.bFlag==false)
        {
            StopWithoutFrontDetect.dwTime = dwCurrTime;
            StopWithoutFrontDetect.bFlag = true;
        }
		else if(OHTUTILITY::PreventOverflowGetTimeMs(StopWithoutFrontDetect.dwTime)>200)
        {
            bStopWithoutFrontDetect = true;
        }
    }
    else
    {
        StopWithoutFrontDetect.bFlag = false;
		bStopWithoutFrontDetect = false;
	}

    double  dSpeedOfNow          		       	= HwInfo.Axis1.dSpeed;      //m_pDrivingAxis->GetCurrentPosition(); //미보정 현재 위치
    double  dRealPositionOfNow                  = HwInfo.Axis1.dCurrPos;    //미보정 현재 위치
	static  double  dRealPositionOfMostPositive = 0.0;                      // 최대로 멀리갔을 때의 거리
	static 	double  dRealPositionOfFirstDetect = 0.0;
	static	double  dQROffset = 0.0;

	if(PreMarkState.OnRoutineIn==false)
    {
        StopWithoutFrontDetect.bFlag = false;
        StopWithoutFrontDetect.dwTime = dwCurrTime;
        dwStaticCheckTime = dwCurrTime;
		nTmpTargetID = nTargetID;
        dRealPositionOfMostPositive = dRealPositionOfNow;
		dStaticQRCenterPosition = 0.0;
		nStaticQrRetryCount = 0;
		nStaticQrReTriggerCount = 0;
        memset(&NextCtrlInfo, 0x00, sizeof(CTRL_INFO_OF_SYNC_AXIS_MOVE));
		bNextCtrlInfoExist = false;
		bQRMoveTargetPosition = false;
		dwStaticQRRestartTime = dwCurrTime;

		if(bIsLeft==true) m_pLeftQRR->ResetDecodeTime();
		else m_pRightQRR->ResetDecodeTime();
		nMinDecode = 0;
		nMaxDecode = 0;
		dAvgDecode = 0.0;
		nQRSetupVersion = 0;
		if (m_mccparam.bMarkStartFlag == false)
		{
			ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,QR MARK,Start,%s,%06d,%06d,%06d,%d,%3.3lf,Mark Type,%d",
					m_defualtparam->VHLName,m_mccparam.cCarrierType,
					m_mccparam.uSourceNode,
					m_mccparam.uTargetNode,
					m_pExecuteInfo->ExecutePositionInfo.CurrNode,
					m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
					dSpeedOfNow,
					m_InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType);
			AUTO_RECOV_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,QR MARK,Start,%s,%06d,%06d,%06d,%d,%3.3lf,Mark Type,%d",
						m_defualtparam->VHLName,m_mccparam.cCarrierType,
						m_mccparam.uSourceNode,
						m_mccparam.uTargetNode,
						m_pExecuteInfo->ExecutePositionInfo.CurrNode,
						m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
						dSpeedOfNow,
						m_InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType);
			m_mccparam.bMarkStartFlag = true;
			m_mccparam.dMarkStartSpeed = dSpeedOfNow;
			m_mccparam.dMarkStartDist = dRealPositionOfNow;
			m_mccparam.bMarkingOHTDetectStop = false;
		}
	}
    else
    {
		dRealPositionOfMostPositive = (dRealPositionOfNow>dRealPositionOfMostPositive)?dRealPositionOfNow:dRealPositionOfMostPositive;
    }

    if(nTmpTargetID==0 && nTmpID!=0)
    {
        nTmpTargetID = nTmpID;
	}

	bIdReaded = (nTmpID==nTmpTargetID&&nTmpTargetID!=0)?true:false;

    if(bIdReaded==true)
    {
        dStaticQRCenterPosition = dRealPositionOfNow + dOffset;
    }

    //2 근접 제어 센서를 Off 시키는 조건
//	if(pMarkState->FollowCtrlOffArea==false)
	if(CanIgnoreVHLDetect())
	{

		if(PreMarkState.FirstMet==true)
//		if(PreMarkState.Arrived==true)
		{

			m_pDrivingAxis->SetVHLDetectIgnor();
			m_bIsAMCVHLDetectIgnore = true;
//			pMarkState->FollowCtrlOffArea=true;
		}
	}
	if(pMarkState->FollowCtrlOffArea==false)
	{
		if(PreMarkState.FirstMet==true)
			pMarkState->FollowCtrlOffArea=true;
	}

    // --------------------------------------------------------------------------------------------------------------------------------------
    //1 0. 에러 처리
    // --------------------------------------------------------------------------------------------------------------------------------------
	if(dRealPositionOfNow>(dRealDistSumToTarget+MarkParam.Dist.dForwardMoveDistLimit))
    {
        pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
        pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
		nTmpError = (bIsLeft)?ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_LEFT_MET_LATE:ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_RIGHT_MET_LATE;


		ERR_LOG("[QR Mark] ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_MET_LATE(Left%d): %6.1lf > %6.1lf (%6.1lf + %6.1lf)"
            , bIsLeft, dRealPositionOfNow, (dRealDistSumToTarget+MarkParam.Dist.dForwardMoveDistLimit)
            , dRealDistSumToTarget, MarkParam.Dist.dForwardMoveDistLimit);
		ADD_FDC_LOG("ERR/%d/2/6/%06d/%06d/%d/%d/%06d/%6.1lf",
					nTmpError,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pExecuteInfo->ExecutePositionInfo.NextNode,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					m_pOHTMainStatus->StatusCommon.ExistFoup,
					m_pOHTMainStatus->StatusCommon.StopStationID,
					dRealPositionOfNow - (dRealDistSumToTarget+MarkParam.Dist.dForwardMoveDistLimit));
        return nTmpError;
    }
    else if(dRealPositionOfNow<(dRealPositionOfMostPositive-MarkParam.Dist.dBackMoveDistLimit))
    {
        pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
		pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
        nTmpError = (bIsLeft)?ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_LEFT_MOVE_BACK_LIMIT:ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_RIGHT_MOVE_BACK_LIMIT;
        ERR_LOG("[QR] ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_MOVE_BACK_LIMIT(Left%d): %6.1lf < %6.1lf (%6.1lf - %6.1lf)"
            , bIsLeft
            , dRealPositionOfNow, (dRealPositionOfMostPositive-MarkParam.Dist.dBackMoveDistLimit)
			, dRealPositionOfMostPositive, MarkParam.Dist.dBackMoveDistLimit);
		ADD_FDC_LOG("ERR/%d/1/8/%06d/%06d/%d/%d/%06d/%f/%f/%f",
					nTmpError,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pExecuteInfo->ExecutePositionInfo.NextNode,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					m_pOHTMainStatus->StatusCommon.ExistFoup,
					m_pOHTMainStatus->StatusCommon.StopStationID,
					dRealPositionOfNow,
					dRealPositionOfMostPositive,
					MarkParam.Dist.dBackMoveDistLimit);
        return nTmpError;
    }

    // --------------------------------------------------------------------------------------------------------------------------------------
    //1 1. Target 위치로 정위치 이동 중
    // --------------------------------------------------------------------------------------------------------------------------------------
    if(PreMarkState.SecondMet==true)
    {
		// 정지 했을 때
        if(bStopWithoutFrontDetect==true)
		{
			if(PreMarkState.IdCheck==false)
            {
				*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
				pMarkState->IdCheck = true;
				dwStaticCheckTime = dwCurrTime;
				ADD_LOG("D-181");
            }
            else
			{
				if(bIdReaded==true)
                {
                    if(fabs(dOffset)<MarkParam.Dist.dMarkInPosLimit)
                    {
						pMarkState->Arrived = true;
                        if(pnID!=NULL)
                        {
                            *pnID = nTmpID;
							ADD_LOG("D_333/%6.1lf/%6X/%6.1lf", dRealPositionOfNow, nTmpID, dOffset);
						}
					}
					else if(nStaticQrRetryCount > 20 )
					{
						pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
						pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
                        //AOHC-374
						if(m_pExecuteInfo->nFinishOfStation == nTmpTargetID)
						{
							nTmpError = ERR_QRR_READTIMEOUT;
							*pnID = nTmpTargetID;
							//오버런 처리
							m_pExecuteInfo->FlagOverRunInfo.bCheck = true;
							m_pExecuteInfo->FlagOverRunInfo.OverrunType = 0x02; //이적재
							m_pExecuteInfo->FlagOverRunInfo.nFinalNode = nTmpTargetID;    //주행은 주행, 이적재는 이적재
							m_PositionInfo.CurrStation = nTmpTargetID;
							m_pExecuteInfo->FlagOverRunInfo.dDrivingInitPosition = 0.0;

							ADD_LOG("D_334/%6.1lf/%6X/%6.1lf", dRealPositionOfNow, nTmpID, dOffset);
							ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d/%d",
											ERR_QRR_READTIMEOUT,
											m_pOHTMainStatus->StatusCommon.CurNodeID,
											m_pExecuteInfo->ExecutePositionInfo.NextNode,
											m_pOHTMainStatus->StatusCommon.CurNodeOffset,
											m_pOHTMainStatus->StatusCommon.ExistFoup,
											m_pOHTMainStatus->StatusCommon.StopStationID,
											bIsLeft);
						}else
						{
							ERR_LOG("[Check]AOHC-374_7/%d",nTmpTargetID);
							pMarkState->Arrived = true;
							*pnID = nTmpTargetID;
						}
					}
					else    // 오차 범위 가 아닐 경우 반복 보정
					{
						dwStaticCheckTime = dwCurrTime;

						pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet;
						pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;
						pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfSecondMet);
						pCtrlInfo->Dynamic.dDist    = dRealPositionOfNow+dOffset;
						memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
						pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;

						dStaticQRCenterPosition = dRealPositionOfNow+dOffset;
						nStaticQrRetryCount++;
						nStaticQrReTriggerCount  = 0;

						ADD_LOG("D_335/%6.1lf/%6X/%6.1lf", dRealPositionOfNow, nTmpID, dOffset);
					}
				}
				else    // 일정 시간 읽히지 않을 경우 에러 처리
				{
					if(OHTUTILITY::PreventOverflowGetTimeMs(dwStaticCheckTime)>200)
					{
						if((nStaticQrReTriggerCount)>10)	// Time Over
						{
							pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
							pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
                            //AOHC-374
							if(m_pExecuteInfo->nFinishOfStation == nTmpTargetID)
							{
								nTmpError = ERR_QRR_READTIMEOUT;
								*pnID = nTmpTargetID;

								//오버런 처리
								m_pExecuteInfo->FlagOverRunInfo.bCheck = true;
								m_pExecuteInfo->FlagOverRunInfo.OverrunType = 0x02; //이적재
								m_pExecuteInfo->FlagOverRunInfo.nFinalNode = nTmpTargetID;    //주행은 주행, 이적재는 이적재
								m_PositionInfo.CurrStation = nTmpTargetID;
								m_pExecuteInfo->FlagOverRunInfo.dDrivingInitPosition = 0.0;

								ERR_LOG("[QR Mark] 2nd Met: ERR_QRR_READTIMEOUT");
								ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d/%d",
											ERR_QRR_READTIMEOUT,
											m_pOHTMainStatus->StatusCommon.CurNodeID,
											m_pExecuteInfo->ExecutePositionInfo.NextNode,
											m_pOHTMainStatus->StatusCommon.CurNodeOffset,
											m_pOHTMainStatus->StatusCommon.ExistFoup,
											m_pOHTMainStatus->StatusCommon.StopStationID,
											bIsLeft);
							}else
							{
								ERR_LOG("[Check]AOHC-374_8/%d",nTmpTargetID);
								pMarkState->Arrived = true;
								*pnID = nTmpTargetID;
							}
						}

						*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;   //Trigger on
						nStaticQrReTriggerCount++;
						dwStaticCheckTime = dwCurrTime;
						ADD_LOG("D_336/%d", nStaticQrReTriggerCount);
					}
				}
			}
		}
		else    // 이동 중일 때
		{
			pMarkState->IdCheck = false;
            dwStaticCheckTime = dwCurrTime;
		}
	}
    // --------------------------------------------------------------------------------------------------------------------------------------
    //1 2. Target ID 를 처음으로 만난 경우
    // --------------------------------------------------------------------------------------------------------------------------------------
	else if(PreMarkState.FirstMet==true)
    {
        if(bStopWithoutFrontDetect==true)
		{
			if(PreMarkState.IdCheck==false)
			{
				*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
				pMarkState->IdCheck = true;

				pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
				pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
				memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));

				dwStaticCheckTime = dwCurrTime; // time check for moving back start
				ADD_LOG("D-182");
			}
			else
			{
				if(bIdReaded==true)
				{
					pMarkState->SecondMet=true;
					dwStaticCheckTime = dwCurrTime;

					pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet;
					pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;
					pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfSecondMet);
					pCtrlInfo->Dynamic.dDist    = dRealPositionOfNow+dOffset;
					memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
					pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;

					dStaticQRCenterPosition = dRealPositionOfNow+dOffset;
					nStaticQrReTriggerCount  = 0;

					ADD_LOG("D_337/%6.1lf/%6d/%6.1lf", dRealPositionOfNow, nTmpID, dOffset);
				}
				else    // 읽히지 않을 경우 뒤로 이동하며 확인
				{
					if(OHTUTILITY::PreventOverflowGetTimeMs(dwStaticCheckTime)>200)								// Time Interval Control
					{
						pMarkState->OverRun=true;
						pMarkState->Recovery=true;
						dwStaticCheckTime = dwCurrTime;

						*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;      // Trigger on

						pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfFirstMet;
						pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfFirstMet;
						pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfFirstMet);
						pCtrlInfo->Dynamic.dDist    = dStaticQRCenterPosition - (10.0*nStaticQrReTriggerCount);

						ERR_LOG("[QR Mark] 1st Met: Stoped and move back [Pos:%6.1lf BackDist:%6.1lf-%6.1lf] ReEnable[%d]"
							, dRealPositionOfNow
							, dStaticQRCenterPosition
							, ((MarkParam.Dist.dAddDistAfetrFirstMet)*nStaticQrReTriggerCount)
							, nStaticQrReTriggerCount
							);

						memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
						pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;
						nStaticQrReTriggerCount++;
					}
				}
			}
		}
		else
		{
			pMarkState->IdCheck = false;
			dwStaticCheckTime = dwCurrTime;
		}
	}
	// --------------------------------------------------------------------------------------------------------------------------------------
	//1 3. Target ID 를 만나기 전 찾고 있는 경우
	// --------------------------------------------------------------------------------------------------------------------------------------
	else if(PreMarkState.OnRoutineIn==true)
	{
		if(bIdReaded==true)
		{
			pMarkState->FirstMet = true;

			if(m_pExecuteInfo->ExecuteMode == EXECUTE_MODE_MANUAL)
			{
				pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
				pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;

				dwStaticCheckTime = dwCurrTime;
				pMarkState->IdCheck = false;
			}
			else
			{
				pCtrlInfo->Dynamic.dAccel = MarkParam.Accel.dOfFirstMet;
				pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
				pCtrlInfo->Dynamic.dSpeed = MIN(dSpeedLimit, MarkParam.Speed.dOfFirstMet);
				pCtrlInfo->Dynamic.dDist  = dRealPositionOfNow+dOffset;
				memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
				pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;

				dwStaticCheckTime = dwCurrTime;
				pMarkState->IdCheck = false;
			}

			ADD_LOG("D_338/%6.1lf/%6d/%6.1lf", dRealPositionOfNow, nTmpID, dOffset);
			dRealPositionOfFirstDetect = dRealPositionOfNow;
			dQROffset = dOffset;

			if(m_mccparam.dMarkSecondDetectSpeed == 0.0)
			{
				m_mccparam.dMarkSecondDetectSpeed = dSpeedOfNow;
			}
		}
		else
		{
			if(OHTUTILITY::PreventOverflowGetTimeMs(dwStaticCheckTime)>200)	// 50ms: QR 센서의 프로세싱 타임 20여ms 이므로 2배수 산정
			{
				*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
				dwStaticCheckTime = dwCurrTime;		// time check for moving back start
			}

			if(bStopWithoutFrontDetect==true)
			{
				if(fabs(dRealPositionOfNow-(dRealDistSumToTarget+MarkParam.Dist.dForwardMoveDistLimit))<10) //+100 삭제
				{
					// 이곳에 들어오기 전에 거리 초과로 에러 발생, 만일 들어올 경우 에러 처리
					pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
					pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
					nTmpError = (bIsLeft)?ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_LEFT_MET_LATE:ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_RIGHT_MET_LATE;


					ERR_LOG("[QR Mark] On Routine: ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_MET_LATE(Left:%d) [Pos:%6.1lf ≒ %6.1lf (%6.1lf + %6.1lf + 100)]", bIsLeft, dRealPositionOfNow, (dRealDistSumToTarget+MarkParam.Dist.dForwardMoveDistLimit+100)
						, dRealDistSumToTarget, MarkParam.Dist.dForwardMoveDistLimit);
					ADD_FDC_LOG("ERR/%d/3/6/%06d/%06d/%d/%d/%06d/%6.1lf",
								nTmpError,
								m_pOHTMainStatus->StatusCommon.CurNodeID,
								m_pExecuteInfo->ExecutePositionInfo.NextNode,
								m_pOHTMainStatus->StatusCommon.CurNodeOffset,
								m_pOHTMainStatus->StatusCommon.ExistFoup,
								m_pOHTMainStatus->StatusCommon.StopStationID,
								dRealPositionOfNow - (dRealDistSumToTarget+MarkParam.Dist.dForwardMoveDistLimit));

					return nTmpError;
				}
				else
				{
					if(bQRMoveTargetPosition == false)
					{
						pCtrlInfo->Dynamic.dAccel = MarkParam.Accel.dOfFirstMet;
						pCtrlInfo->Dynamic.dDecel = MarkParam.Accel.dOfFirstMet;
						pCtrlInfo->Dynamic.dSpeed = MIN(dSpeedLimit, MarkParam.Speed.dOfFirstMet);
						pCtrlInfo->Dynamic.dDist  = dRealDistSumToTarget+MarkParam.Dist.dForwardMoveDistLimit+50;    // 50 : Dist margin to go over forward limit for checking overrun error
						memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
						pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;
						bQRMoveTargetPosition = true;

						ADD_LOG("D_339/%6.1lf/%6.1lf", dRealDistSumToTarget+MarkParam.Dist.dForwardMoveDistLimit+100, dRealPositionOfNow);
					}
				}
			}
			if(m_mccparam.dMarkFirstDetectSpeed == 0.0)
			{
				m_mccparam.dMarkFirstDetectSpeed = dSpeedOfNow;
			}
		}
	}
	else if(PreMarkState.OnRoutineIn==false)
	{
		if((fabs(m_InfoSet.HwInfo.Axis1.dFinalPos - dRealDistSumToTarget) < ACCEPTABLE_DRIVING_POSITION_ERROR)
        || (m_InfoSet.HwInfo.Axis1.dFinalPos == 0))
        {
            pMarkState->OnRoutineIn=true;
        }


		*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
		dwStaticCheckTime = dwCurrTime;

		pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfFirstMet;
		pCtrlInfo->Dynamic.dDecel   = QRR_MARK_FIRST_DECEL;
		pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, QRR_MARK_FIRST_SPEED);
		pCtrlInfo->Dynamic.dDist    = dRealDistSumToTarget;
		memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
		pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;

		ADD_LOG("D_340/%6.1lf/%6.1lf", dRealDistSumToTarget, dRealPositionOfNow);
	}

	if((pMarkState->Arrived == true) && (m_mccparam.bMarkStartFlag == true))
	{
		STATION_DATA *pSData;
		pSData = OHTMainForm->GetStationDataManager()->Find(m_mccparam.uTargetNode);

		UINT temp_parent_id = 0;
		int temp_parent_offset = 0;
		int temp_current_offset = m_pOHTMainStatus->StatusCommon.CurNodeOffset;

		if(pSData != NULL)
		{
			temp_parent_id = pSData->ParentNodeID;
			temp_parent_offset = pSData->StationOffset;

			if(temp_parent_offset == 0)
			{
				DRIVING_CMD_INFO_OF_PATH* pPathInfo = NULL;
				int nCount = m_ClassifiedCmd.PathList.getCount() - 2;
				if(nCount >= 0)
				{
					pPathInfo = m_ClassifiedCmd.PathList.refer(nCount);
					temp_current_offset = pPathInfo->dLength - temp_current_offset;
				}
			}
		}

		if(bIsLeft==true)
		{
			nMinDecode = m_pLeftQRR->GetMinDecodeTime();
			nMaxDecode = m_pLeftQRR->GetMaxDecodeTime();
			dAvgDecode = m_pLeftQRR->GetAvgDecodeTime();
			nQRSetupVersion = m_pLeftQRR->GetSetupVersion();
		}
		else
		{
			nMinDecode = m_pRightQRR->GetMinDecodeTime();
			nMaxDecode = m_pRightQRR->GetMaxDecodeTime();
			dAvgDecode = m_pRightQRR->GetAvgDecodeTime();
			nQRSetupVersion = m_pRightQRR->GetSetupVersion();
		}
		ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,QR MARK,End,%s,%06d,%06d,%06d,%d,%3.3lf,Mark Type,%d,QR Mark Dist,%6.1lf,QR Offset,%6.1lf,QR Mark Start Speed,%3.3lf,QR Mark Detect Start Speed,%3.3lf,QR Mark First Detect Speed,%3.3lf,ParentNode Offset Difference,%d,Marking OHT Detect And STOP,%d,Parent Node,%d,Parent Node Offset,%d",
					m_defualtparam->VHLName,m_mccparam.cCarrierType,
					m_mccparam.uSourceNode,
					m_mccparam.uTargetNode,
					m_pExecuteInfo->ExecutePositionInfo.CurrNode,
					m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
					dSpeedOfNow,
					m_InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType,
					dRealPositionOfFirstDetect - m_mccparam.dMarkStartDist,
					dQROffset,
					m_mccparam.dMarkStartSpeed,
					m_mccparam.dMarkFirstDetectSpeed,
					m_mccparam.dMarkSecondDetectSpeed,
					temp_parent_offset - temp_current_offset,
					m_mccparam.bMarkingOHTDetectStop,
					temp_parent_id, temp_parent_offset);
		AUTO_RECOV_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,QR MARK,End,%s,%06d,%06d,%06d,%d,%3.3lf,Mark Type,%d,QR Mark Dist,%6.1lf,QR Offset,%6.1lf,QR Mark Start Speed,%3.3lf,QR Mark Detect Start Speed,%3.3lf,QR Mark First Detect Speed,%3.3lf,ParentNode Offset Difference,%d,Marking OHT Detect And STOP,%d,Parent Node,%d,Parent Node Offset,%d,QR Decode Min,%d,QR Decode Max,%d,QR Decode Avg,%3.3lf,LastSetUpVer,%d",
					m_defualtparam->VHLName,m_mccparam.cCarrierType,
					m_mccparam.uSourceNode,
					m_mccparam.uTargetNode,
					m_pExecuteInfo->ExecutePositionInfo.CurrNode,
					m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
					dSpeedOfNow,
					m_InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType,
					dRealPositionOfFirstDetect - m_mccparam.dMarkStartDist,
					dQROffset,
					m_mccparam.dMarkStartSpeed,
					m_mccparam.dMarkFirstDetectSpeed,
					m_mccparam.dMarkSecondDetectSpeed,
					temp_parent_offset - temp_current_offset,
					m_mccparam.bMarkingOHTDetectStop,
					temp_parent_id, temp_parent_offset,
					nMinDecode,nMaxDecode,dAvgDecode,nQRSetupVersion);
		m_mccparam.bMarkStartFlag = false;
		m_mccparam.dMarkStartSpeed = 0.0;
		m_mccparam.dMarkStartDist = 0.0;
		dRealPositionOfFirstDetect = 0.0;
		dQROffset = 0.0;
		m_mccparam.dMarkFirstDetectSpeed = 0.0;
		m_mccparam.dMarkSecondDetectSpeed = 0.0;
	}

	return nTmpError;
}

/**
@brief   DrivingControl Axis 동작 가능 여부 확인 및 가능 상태로 가기 위해 필요한 Command 작성
@author  임태웅
@date    2013.07.01
*/
bool DrivingControl::checkReadyToRun(DRIVING_HW_INFO_SET HwInfo, USER_DETECT_INFO DetectCtrl, CTRL_INFO_OF_SYNC_AXIS_MOVE* pAxisCmd, CTRL_INFO_OF_STEER* pSteerCmd, CTRL_INFO_OF_FRONT_DETECT* pDetectCtrl, bool bIsManual)
{
    bool bAllReady = false;
    bool bAxisHome = false;
    bool bAxisAmpOn = false;
    bool bNodeCountReset = false;
    bool bSteerFrontReady = false;
	bool bSteerRearReady = false;

	bool bDrivingBreakRelease = m_pDrivingAxis->IsBrakeReleased();
	bool TempbAllReady = false;

	bool bAxisReady = false;
	bool bSteerReady = false;
	bool bFrontDetectReady = false;
	bool bInnerLimitTorque = false;

	static bool bIsLastNodeCountReset = false;
#if((OHT_NAME == OHT_NAME_STD_V82)|| (OHT_NAME == OHT_NAME_STD_V85S)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
	//2 기본 플래그 획득
	memset(pAxisCmd, 0x00, sizeof(CTRL_INFO_OF_SYNC_AXIS_MOVE));
	DRIVING_CMD_INFO_OF_NODE* pNodeInfo = getNodeInfo(0);
#endif

	//2 기본 플래그 획득
	if((fabs(HwInfo.Axis1.dCurrPos)<5.0) && (fabs(HwInfo.Axis2.dCurrPos)<5.0))
	{
        m_RunOffsetDistance =  m_InfoSet.Position.Compensation.dPreArriveOffset;
		bAxisHome = true;
	}
	else
		bIsLastNodeCountReset =false;

    if(HwInfo.IO.Axis1AmpOn==true && HwInfo.IO.Axis2AmpOn==true)
    {
		bAxisAmpOn = true;
	}

	if((bAxisHome==true) &&     		//엔코더가 Hmone이 아니고,
	  (bIsLastNodeCountReset ==true) && //마지막 한번더 처리
	  ((HwInfo.Node.nNodeCount==0) && ((HwInfo.Node.nPreCheckCount==0) || (HwInfo.IO.NodePreCheckOn ==true))))
	{
		m_RunOffsetDistance =  m_InfoSet.Position.Compensation.dPreArriveOffset;
		bNodeCountReset = true;
	}
	//2 Pass : 구동중, 근접제어 정지
	if(HwInfo.IO.Axis1AmpOn==true)
	{
	/*
		if( (HwInfo.IO.Axis1Running==true) && (HwInfo.IO.Axis2Running==true))
		{
			bAllReady=true;
			return bAllReady;
		}
	*/
#if(OHT_NAME != OHT_NAME_STD_V81S)
#if(UBG_SENSOR_ENABLE == ON)
		if((HwInfo.IO.ObsStatus==DETECT_AND_STOP) || (HwInfo.IO.DetectStatus==DETECT_AND_STOP) )
#else
		if(HwInfo.IO.ObsStatus==DETECT_AND_STOP)
#endif
		{
            bAllReady=false;
            return bAllReady;
		}
#endif


	}
   //1 Axis: Home 상태 + Amp Enable + NodeCount Reset
	if(bAxisHome==true && bAxisAmpOn==true && bNodeCountReset==true)
	{
		bAxisReady = true;
	}

	else if(bAxisHome==false && bAxisAmpOn==true)
	{
#if((OHT_NAME == OHT_NAME_STD_V82)|| (OHT_NAME == OHT_NAME_STD_V85S)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
		if(bIsManual == false)    // auto 일때만 엔코더 리셋 가능
		{
			if(pNodeInfo->NodeType ==SLOPE_NTYPE)
			{
				//경사로로 인해서 브레이크 유무 확인 후 서버 Off처리
				if(bDrivingBreakRelease ==false)
				{
					pAxisCmd->byType = AXIS_CTRL_CMD_STATIC;
					pAxisCmd->Static.Axis1AmpCmdOn = true;
					pAxisCmd->Static.Axis1AmpOn = false;
					pAxisCmd->Static.Axis2AmpCmdOn = true;
					pAxisCmd->Static.Axis2AmpOn = false;
					ADD_LOG("[checkReadyToRun]Auto Slope Node Brake On, Servo Off");
				}
				else
				{
					m_pDrivingAxis->SetBrakeRelease(false);
				}
			}
			else
			{
					pAxisCmd->byType = AXIS_CTRL_CMD_STATIC;
					pAxisCmd->Static.Axis1AmpCmdOn = true;
					pAxisCmd->Static.Axis1AmpOn = false;
					pAxisCmd->Static.Axis2AmpCmdOn = true;
					pAxisCmd->Static.Axis2AmpOn = false;
					ADD_LOG("[checkReadyToRun]Auto Normal Node Brake Off, Servo Off");
			}


		}
		else
		{        //manual 마크 시 위치가 어디인지 모르니 항상 brake on하고 amp off
				if(bDrivingBreakRelease ==false)
				{
					pAxisCmd->byType = AXIS_CTRL_CMD_STATIC;
					pAxisCmd->Static.Axis1AmpCmdOn = true;
					pAxisCmd->Static.Axis1AmpOn = false;
					pAxisCmd->Static.Axis2AmpCmdOn = true;
					pAxisCmd->Static.Axis2AmpOn = false;
					ADD_LOG("[checkReadyToRun]Manual Node Brake On, Servo Off");
				}
				else
				{
					m_pDrivingAxis->SetBrakeRelease(false);
				}

		}
#else
//		if(pNodeInfo->SlopeInfo ==NODE_SLOPE)
//		{

			//경사로로 인해서 브레이크 유무 확인 후 서버 Off처리
			if(bDrivingBreakRelease ==false)
			{
				pAxisCmd->byType = AXIS_CTRL_CMD_STATIC;
				pAxisCmd->Static.Axis1AmpCmdOn = true;
				pAxisCmd->Static.Axis1AmpOn = false;
				pAxisCmd->Static.Axis2AmpCmdOn = true;
				pAxisCmd->Static.Axis2AmpOn = false;
			}
			else
			{
				m_pDrivingAxis->SetBrakeRelease(false);
			}

//			ADD_LOG("D-183");
//		}else
////		{
//				pAxisCmd->byType = AXIS_CTRL_CMD_STATIC;
//				pAxisCmd->Static.Axis1AmpCmdOn = true;
//				pAxisCmd->Static.Axis1AmpOn = false;
//				pAxisCmd->Static.Axis2AmpCmdOn = true;
//				pAxisCmd->Static.Axis2AmpOn = false;
//
//				ADD_LOG("D-184");
////		}

//		m_pDrivingAxis->SetBrakeRelease(false);
#endif
	}
	else if(bAxisHome==true && bAxisAmpOn==false)
	{
		pAxisCmd->byType = AXIS_CTRL_CMD_STATIC;
		pAxisCmd->Static.Axis1AmpCmdOn = true;
		pAxisCmd->Static.Axis1AmpOn = true;
		pAxisCmd->Static.Axis2AmpCmdOn = true;
		pAxisCmd->Static.Axis2AmpOn = true;

//		m_pDrivingAxis->SetBrakeRelease(true);
	}
	else if(bAxisHome==false && bAxisAmpOn==false)
	{
		pAxisCmd->byType = AXIS_CTRL_CMD_STATIC;
		pAxisCmd->Static.Axis1SetHomeCmdOn = true;
#if((OHT_NAME == OHT_NAME_STD_V82)|| (OHT_NAME == OHT_NAME_STD_V85S)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
#else
		pAxisCmd->Static.Axis2SetHomeCmdOn = true;
#endif
	}

    //1 NodeCount Reset
	if((bNodeCountReset==false) && (bAxisHome==true)) // Node Count Reset 지속 실행 -> 엔코더가 클리어되고나서 노드카운트 클리어실시
    {
		pAxisCmd->byType = AXIS_CTRL_CMD_STATIC;
		pAxisCmd->Static.NodeCountReset = true;
		bIsLastNodeCountReset= true; //엔코더가 클리어 되고나서 최초 회는 실행하기 위해

	}

	//1 Steer 현재 방향에 맞추는 명령
    if( ((HwInfo.IO.SteerFrontLeftInOn==true) && (HwInfo.IO.SteerFrontDirCmd==DRIVING_IO_STEER_DIRECTION_CMD_LEFT))     ||
        ((HwInfo.IO.SteerFrontRightInOn==true) && (HwInfo.IO.SteerFrontDirCmd==DRIVING_IO_STEER_DIRECTION_CMD_RIGHT))   ||
        ((HwInfo.IO.SteerFrontLeftInOn==false) && (HwInfo.IO.SteerFrontRightInOn==false))   )
    {
        bSteerFrontReady = true;
    }
    if( ((HwInfo.IO.SteerRearLeftInOn==true) && (HwInfo.IO.SteerRearDirCmd==DRIVING_IO_STEER_DIRECTION_CMD_LEFT))   ||
        ((HwInfo.IO.SteerRearRightInOn==true) && (HwInfo.IO.SteerRearDirCmd==DRIVING_IO_STEER_DIRECTION_CMD_RIGHT)) ||
        ((HwInfo.IO.SteerRearLeftInOn==false) && (HwInfo.IO.SteerRearRightInOn==false))     )
    {
        bSteerRearReady = true;
    }

    if(bSteerFrontReady==true &&  bSteerRearReady==true)
    {
        bSteerReady = true;
    }
    else
    {
        *pSteerCmd = setSteerCmdToCurrPosition(HwInfo);
    }

    //1 전방 감시 상태 확인
	//todo: 변경 확인 기능 추가
		if(m_bOnBackMove == true)
		{
			ADD_LOG("D-185");
			memset(&DetectCtrl,0,sizeof(USER_DETECT_INFO));

			if((DetectCtrl.UseFollowControlFlag != pDetectCtrl->Info.UseFollowControlFlag)
#if(USE_CHANGENODE == 1)
			|| (DetectCtrl.OHTDetectType != pDetectCtrl->Info.OHTDetectType)
			|| (DetectCtrl.OBSDetectType != pDetectCtrl->Info.OBSDetectType)
#else
			|| (DetectCtrl.Type != pDetectCtrl->Info.Type)
#endif
			|| (DetectCtrl.NodeCount != pDetectCtrl->Info.NodeCount)
			|| (DetectCtrl.DistSumOfStraightPath != pDetectCtrl->Info.DistSumOfStraightPath)
			|| (DetectCtrl.FollowCommandType != pDetectCtrl->Info.FollowCommandType)
			|| (DetectCtrl.PBSIgnoreFlag != pDetectCtrl->Info.PBSIgnoreFlag)
			)
			{
				if(bAxisReady == true)
				{
					pDetectCtrl->bCmdOn = true;
					pDetectCtrl->Info = DetectCtrl;
				}
	//			bFrontDetectReady=false;
			}
			else
			  bFrontDetectReady=true;
		}
		else
		{
			if((DetectCtrl.UseFollowControlFlag != pDetectCtrl->Info.UseFollowControlFlag)
#if(USE_CHANGENODE == 1)
			|| (DetectCtrl.OHTDetectType != pDetectCtrl->Info.OHTDetectType)
			|| (DetectCtrl.OBSDetectType != pDetectCtrl->Info.OBSDetectType)
#else
			|| (DetectCtrl.Type != pDetectCtrl->Info.Type)
#endif
			|| (DetectCtrl.NodeCount != pDetectCtrl->Info.NodeCount)
			|| (DetectCtrl.DistSumOfStraightPath != pDetectCtrl->Info.DistSumOfStraightPath)
			|| (DetectCtrl.FollowCommandType != pDetectCtrl->Info.FollowCommandType)
			|| (DetectCtrl.PBSIgnoreFlag != pDetectCtrl->Info.PBSIgnoreFlag)
			|| ((pHWSet->GetAMCVHLDetectStatus() ==0) && (bIsManual ==false)))
			{
				if(bAxisReady == true)
				{
					pDetectCtrl->bCmdOn = true;
					pDetectCtrl->Info = DetectCtrl;
				}
	//			bFrontDetectReady=false;
			}
			else
			  bFrontDetectReady=true;
		}
#if((OHT_NAME == OHT_NAME_STD_V82)|| (OHT_NAME == OHT_NAME_STD_V85S)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
	if((m_pDrivingAxis->IsBrakeReleased()==false) && (bAxisReady == true))
	{
		m_pDrivingAxis->SetBrakeRelease(true);
		ADD_LOG("D-187");
	}
	if(m_pDrivingAxis->IsBrakeReleased()==true)
		bInnerLimitTorque = true;
#else
		if(m_defualtparam->bUseRSA==true)
		{
			if(m_pRSAControl->IsSetInnerLimitTorque_300() == false)
			{
			   m_pRSAControl->SetInnerLimitTorque_300();
			   ADD_LOG("D-186");
			}
			if((m_pDrivingAxis->IsBrakeReleased()==false) && (bAxisReady == true))
			{
				m_pDrivingAxis->SetBrakeRelease(true);
				ADD_LOG("D-187");
			}
			if((m_pDrivingAxis->IsBrakeReleased()==true) &&  (m_pRSAControl->IsSetInnerLimitTorque_300() ==true))
				bInnerLimitTorque = true;
		}
		else
		{
			if(m_pServoControl->IsSetInnerLimitTorque_800() ==false)
			{
				m_pServoControl->SetInnerLimitTorque_800();
				ADD_LOG("D-186");
			}
			if((m_pDrivingAxis->IsBrakeReleased()==false) && (bAxisReady == true))
			{
				m_pDrivingAxis->SetBrakeRelease(true);
				ADD_LOG("D-187");
			}
			if((m_pDrivingAxis->IsBrakeReleased()==true) &&  (m_pServoControl->IsSetInnerLimitTorque_800() ==true))
				bInnerLimitTorque = true;
		}
#endif


	//1 Ready 정보 확인 및 return
	bAllReady = bAxisReady & bSteerReady & bFrontDetectReady & bInnerLimitTorque;


	ADD_LOG("D_341/%d/%d/%d/%d/%d/%d/%d/%d/%d/%6.1lf/%d/%6.1lf/%d/%d/%d/%d"
		, bAllReady, bAxisReady, bSteerReady, bFrontDetectReady, pHWSet->GetAMCVHLDetectStatus(),bInnerLimitTorque
		, bAxisHome, bAxisAmpOn, bNodeCountReset
        , HwInfo.Axis1.dCurrPos, HwInfo.IO.Axis1AmpOn
        , HwInfo.Axis2.dCurrPos, HwInfo.IO.Axis2AmpOn
		, HwInfo.Node.nNodeCount,HwInfo.Node.nPreCheckCount,HwInfo.IO.NodePreCheckOn);

	return bAllReady;
}
/**
@brief   DrivingControl Axis 동작 완료 여부 확인 및 완료 상태로 가기 위해 필요한 Command 작성
@author  임태웅
@date    2013.07.01
*/
bool DrivingControl::checkCompletion    (DRIVING_HW_INFO_SET HwInfo, CTRL_INFO_OF_SYNC_AXIS_MOVE* pAxisCmd, CTRL_INFO_OF_STEER* pSteerCmd, CTRL_INFO_OF_FRONT_DETECT* pDetectCtrl)
{
    bool bAllCompleted = false;

    bool bSteerFrontCompleted = false;
    bool bSteerRearCompleted = false;

    bool bAxisAmpOn = true;

    bool bAxisCompleted = false;
    bool bSteerCompleted = false;
    bool bFrontDetectCompleted = false;
	bool bNodeCountCleared = true;
	bool bInnerLimitTorque = false;

	static DWORD dwRearSensorChatteringStart = timeGetTime();
	static DWORD dwRearSensorChattering = timeGetTime();
    static int nRearSensorCheckcnt = 0;



    //2 기본 플래그 획득
    memset(pAxisCmd, 0x00, sizeof(CTRL_INFO_OF_SYNC_AXIS_MOVE));

    if(HwInfo.IO.Axis1AmpOn==true && HwInfo.IO.Axis2AmpOn==false)
    {
		bAxisAmpOn = false;
    }

	//1 Axis: Home 상태 + Amp Enable
	if(m_cSlopeNodeInfo ==SLOPE_NTYPE)
	{
#if((OHT_NAME == OHT_NAME_STD_V82)|| (OHT_NAME == OHT_NAME_STD_V85S)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
		if(HwInfo.IO.Axis1AmpOn==true)      //CIS
		{
			bAxisAmpOn = false;
		}

		//1 Axis: Home 상태 + Amp Enable
		if( bAxisAmpOn==false)
		{
			bAxisCompleted = true;
		}
#else
        if(HwInfo.IO.Axis1AmpOn==true && HwInfo.IO.Axis2AmpOn==true)
		{
			bAxisAmpOn = false;
		}

		//1 Axis: Home 상태 + Amp Enable
		if( bAxisAmpOn==false)
		{
			bAxisCompleted = true;
		}
		else
		{
			pAxisCmd->byType = AXIS_CTRL_CMD_STATIC;
			pAxisCmd->Static.Axis2AmpCmdOn = true;
			pAxisCmd->Static.Axis2AmpOn = true;
		}
#endif
	}else
	{
#if((OHT_NAME == OHT_NAME_STD_V82)|| (OHT_NAME == OHT_NAME_STD_V85S)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
 		if(HwInfo.IO.Axis1AmpOn==true)   //CIS
		{
			bAxisAmpOn = false;
		}

#else
		if(HwInfo.IO.Axis1AmpOn==true && HwInfo.IO.Axis2AmpOn==false)
		{
			bAxisAmpOn = false;
		}
#endif
	   //1 Axis: Home 상태 + Amp Enable
        // Rearm Motor Off된 상태
		if( bAxisAmpOn==false)
		{
            // Mark 수행한 Tag가 Station의 경우 Rear Stop 센서 채터링 기능 추가
			if(m_ClassifiedCmd.TargetInfo.Type == MARK_TYPE_TAG_STATION)
			{
#if((OHT_NAME == OHT_NAME_STD_V82)|| (OHT_NAME == OHT_NAME_STD_V85S)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
				if(OHTUTILITY::PreventOverflowGetTimeMs(dwRearSensorChatteringDelayV82) > 500)
				{
					 bAxisCompleted = true;
					 ADD_LOG("D_342/%d", nRearSensorCheckcnt);

				}
#else
				if(HwInfo.IO.TagStationRearOn == true)
				{
					 if(OHTUTILITY::PreventOverflowGetTimeMs(dwRearSensorChatteringStart) > 500)
					{
						bAxisCompleted = true;
						ADD_LOG("D_342/%d", nRearSensorCheckcnt);
					}


				}
				else
				{
					 // Rear Servo OFF 상태에서 Rear가 OFF되어 있는 경우
					// 최대 1500msec 대기하면서 Rear Stop 센서 Check 수행
					if(OHTUTILITY::PreventOverflowGetTimeMs(dwRearSensorChattering) > 2000)
					{
						bAxisCompleted = true;
						ADD_LOG("D_343/%d", nRearSensorCheckcnt);

					}
					else
					{
						nRearSensorCheckcnt++;
					}
				}
#endif

			}
			else
			{
				bAxisCompleted = true;
			}
			/*
			bAxisCompleted = true;
			*/
		}
        else
		{
			dwRearSensorChatteringStart = timeGetTime();
			dwRearSensorChattering = timeGetTime();

			nRearSensorCheckcnt = 0;
#if((OHT_NAME == OHT_NAME_STD_V82)|| (OHT_NAME == OHT_NAME_STD_V85S)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
#else
            pAxisCmd->byType = AXIS_CTRL_CMD_STATIC;
            pAxisCmd->Static.Axis2AmpCmdOn = true;
			pAxisCmd->Static.Axis2AmpOn = false;
#endif
        }
    }



    //1 Steer 현재 방향에 맞추는 명령
    if( ((HwInfo.IO.SteerFrontLeftInOn==true) && (HwInfo.IO.SteerFrontDirCmd==DRIVING_IO_STEER_DIRECTION_CMD_LEFT))     ||
        ((HwInfo.IO.SteerFrontRightInOn==true) && (HwInfo.IO.SteerFrontDirCmd==DRIVING_IO_STEER_DIRECTION_CMD_RIGHT))   ||
        ((HwInfo.IO.SteerFrontLeftInOn==false) && (HwInfo.IO.SteerFrontRightInOn==false))   )
    {
        bSteerFrontCompleted = true;
    }
    if( ((HwInfo.IO.SteerRearLeftInOn==true) && (HwInfo.IO.SteerRearDirCmd==DRIVING_IO_STEER_DIRECTION_CMD_LEFT))   ||
        ((HwInfo.IO.SteerRearRightInOn==true) && (HwInfo.IO.SteerRearDirCmd==DRIVING_IO_STEER_DIRECTION_CMD_RIGHT)) ||
        ((HwInfo.IO.SteerRearLeftInOn==false) && (HwInfo.IO.SteerRearRightInOn==false))     )
    {
        bSteerRearCompleted = true;
    }

    if(bSteerFrontCompleted==true &&  bSteerRearCompleted==true)
    {
        bSteerCompleted = true;
    }
    else
    {
        *pSteerCmd = setSteerCmdToCurrPosition(HwInfo);
    }

    //1 전방 감시 상태 확인
    //todo: 변경 확인 기능 추가
    if(pDetectCtrl!=NULL)
	{
		if(bAxisCompleted && bNodeCountCleared)
		{
			pDetectCtrl->bCmdOn = true;
			pDetectCtrl->Info.UseFollowControlFlag = false;
#if(USE_CHANGENODE == 1)
			pDetectCtrl->Info.OHTDetectType = PATH_DIRECTION_NO_USE;
			pDetectCtrl->Info.OBSDetectType = PATH_OBS_DIRECTION_NO_USE;
#else
			pDetectCtrl->Info.Type = PATH_DIRECTION_NO_USE;
#endif
			pDetectCtrl->Info.NodeCount = 0;
			pDetectCtrl->Info.DistSumOfStraightPath = 0;

			bFrontDetectCompleted=true;
        }
	}
#if((OHT_NAME != OHT_NAME_STD_V82) && (OHT_NAME != OHT_NAME_STD_V85S)&&(OHT_NAME != OHT_NAME_STD_V86)&&(OHT_NAME != OHT_NAME_P4_MASK))
	if(m_defualtparam->bUseRSA==true)
	{
		if(m_cSlopeNodeInfo ==SLOPE_NTYPE)
		{
		   if(m_pRSAControl->IsSetInnerLimitTorque_90() == true)
			{
				m_cSlopeNodeInfo = INIT_NTYPE;
				bInnerLimitTorque = true;
				ADD_LOG("D-188");
			}
			else
			{
				m_pRSAControl->SetInnerLimitTorque_90();
			}
		}
		else
			bInnerLimitTorque = true;
	}
	else
	{
		if(m_cSlopeNodeInfo ==SLOPE_NTYPE)
		{
			if(m_pServoControl->IsSetInnerLimitTorque_90() == true)
			{
				m_cSlopeNodeInfo = INIT_NTYPE;
				bInnerLimitTorque = true;
				ADD_LOG("D-188");
			}
			else
			{
				m_pServoControl->SetInnerLimitTorque_90();
			}
		}
		else
			bInnerLimitTorque = true;
	}
#else
	if(m_cSlopeNodeInfo ==SLOPE_NTYPE)
	{
		m_cSlopeNodeInfo = INIT_NTYPE;
		ADD_LOG("checkCompletion - bInnerLimitTorque");
	}

	bInnerLimitTorque = true; //OHT_NAME_STD_V90, OHT_NAME_STD_V85S 는 토크 제한이 불필요,,,,,,,,,,,,,    m_cSlopeNodeInfo = INIT_NTYPE; 이걸 어디 넣어주지?
#endif

	//1 Ready 정보 확인 및 return
	bAllCompleted = bAxisCompleted & bSteerCompleted & bFrontDetectCompleted & bNodeCountCleared & bInnerLimitTorque;


//    ADD_LOG("D_344/%d/%d/%d/%d/%d", bAllCompleted, bAxisCompleted, bSteerCompleted, bFrontDetectCompleted, bNodeCountCleared);
    return bAllCompleted;

}

/**
@brief   DrivingControl Steering을 HW 방향에 맞춰 명령을 변경
@author  임태웅
@date    2013.07.10
*/
CTRL_INFO_OF_STEER DrivingControl::setSteerCmdToCurrPosition(DRIVING_HW_INFO_SET    HwInfo)
{
    CTRL_INFO_OF_STEER SteerCmd;

    if(HwInfo.IO.SteerFrontLeftInOn==true)
    {
        SteerCmd.FrontDirection = DRIVING_IO_STEER_DIRECTION_CMD_LEFT;
    }
    else if(HwInfo.IO.SteerFrontRightInOn==true)
	{
		SteerCmd.FrontDirection = DRIVING_IO_STEER_DIRECTION_CMD_RIGHT;
    }
    else
    {
        SteerCmd.FrontDirection = HwInfo.IO.SteerFrontDirCmd;
    }

    if(HwInfo.IO.SteerRearLeftInOn==true)
    {
        SteerCmd.RearDirection = DRIVING_IO_STEER_DIRECTION_CMD_LEFT;
    }
    else if(HwInfo.IO.SteerRearRightInOn==true)
    {
        SteerCmd.RearDirection = DRIVING_IO_STEER_DIRECTION_CMD_RIGHT;
    }
    else
    {
        SteerCmd.RearDirection = HwInfo.IO.SteerFrontDirCmd;
    }

    SteerCmd.FrontCmdOn = true;
    SteerCmd.FrontTorque = DRIVING_IO_STEER_TORQUE_CMD_STOP;

    SteerCmd.RearCmdOn= true;
    SteerCmd.RearTorque= DRIVING_IO_STEER_TORQUE_CMD_STOP;

    return SteerCmd;
}


int DrivingControl::manual_Mark(MARK_TYPE MarkType)
{
    static DRIVING_MARK_STATE MarkState;
    static int nIdResult = 0;
    int nTmpError = NO_ERR;
    DRIVING_HW_INFO_SET HwInfo = getHWInfo();

    DRIVING_CTRL_INFO_SET CtrlInfo;
    memset(&CtrlInfo, 0, sizeof(CtrlInfo));

	CTRL_INFO_OF_ID_READER_CMD_TYPE IdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_NONE;

    USER_DETECT_INFO DetectCtrl;
    memset(&DetectCtrl, 0, sizeof(DetectCtrl));
	DetectCtrl.UseFollowControlFlag = false;


	double dRealDistSumToTarget = 50;
    double dSpeedLimit = 0.2;   //1 임시 0.2m/s
    int nID = 0;
	int nTargetID = 0;

	int nTempNodeID = 0;
	int nNodeIndex = 0;
	NODE_INFO	*pNODE_INFO		= NULL;	// Node 정보
	STATION_DATA *pSData  =NULL; //Station 정보

    static int nNodeCount = 1; // for MARK_TYPE_NODE

	double dNodeDistOffset = 0.0;
	int nSTBQROffset = 0;

	static manual_Mark_cnt = 0;
	int SteerFront=0;
	int CIDResetNode_arr = INDEX_NONE;
	int CIDResetNode = 0;
	int CIDResetNodeType = 0;
//     ADD_LOG("D_345/%d",  m_StatusSet.uStep);
	//1 처음 시작이면 위치 정보 초기화: 추후 변경 필요

    if(m_StatusSet.uStep==DRIVING_CTRL_STEP_NONE)
    {
        //1 NEW
        initCommandSet();
        initInfoSet();
        initPreviousArrivalInfo();

		m_PositionInfo.Marked = false;
		m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uStation = 0x00;
        m_PositionInfo.CurrStation=0x00;

        m_pDrivingBCR->ReStart();
        m_pTransBCR->ReStart();
        m_pLeftQRR->ReStart();
        m_pRightQRR->ReStart();

        if(m_pSteer->IsLeftPos(BOTH)==false && m_pSteer->IsRightPos(BOTH)==false)
        {
            nTmpError   = ERR_STEER_NOTSAMESTATUS;
            m_StatusSet.byStatus    = STS_ERROR;
            m_StatusSet.uError      = nTmpError;
            return nTmpError;
        }

        m_StatusSet.uStep = DRIVING_CTRL_STEP_MANUAL_MARK_INIT;
    }
//    ADD_LOG("D_346/%d",  m_StatusSet.uStep);
	//1 명령 생성
    switch(m_StatusSet.uStep)
    {
    case DRIVING_CTRL_STEP_MANUAL_MARK_INIT:
        //2 정보 초기화
        m_StatusSet.bIsOnProcess    = true;
        m_StatusSet.byStatus        = STS_RUNNING;

        memset(&MarkState, 0, sizeof(MarkState));
        nIdResult = 0;
		manual_Mark_cnt = 0;

        setMarkStatusFalse();

        //2 Node Count Reset
        m_pDrivingAxis->ClearNodeCountInfo();

        //2 근젭제어 Off
        m_Detect.UseFollowControlFlag = false;
        m_Detect.NodeCount = 0;
		CtrlInfo.FrontObservation.Info = m_Detect;

		CheckReadyToRunTime_ManualMark = timeGetTime();
        m_StatusSet.uStep = DRIVING_CTRL_STEP_MANUAL_MARK_PREPARE;
		break;
    case DRIVING_CTRL_STEP_MANUAL_MARK_PREPARE:
		if(checkReadyToRun(HwInfo, DetectCtrl, &(CtrlInfo.Axis), &(CtrlInfo.Steer), &(CtrlInfo.FrontObservation),true)==true)
		{
			m_StatusSet.uStep = DRIVING_CTRL_STEP_MANUAL_MARK_RUN;
			ADD_LOG("D_347/%d", m_StatusSet.uStep);
			nNodeCount = (HwInfo.IO.NodeOn==true)?0:1;   // for MARK_TYPE_NODE
		}
		else
		{
#if((OHT_NAME == OHT_NAME_STD_V82)|| (OHT_NAME == OHT_NAME_STD_V85S)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
#else
                        if(OHTUTILITY::PreventOverflowGetTimeMs(CheckReadyToRunTime_ManualMark) > DRIVING_SETTING_TIME)
			{
				if(m_defualtparam->bUseRSA==true)
				{
					if(m_pRSAControl->IsSetInnerLimitTorque_300() == false)
					{
						nTmpError=ERR_SERVO_DRIVING_ALARM;
						CheckReadyToRunTime_ManualMark = timeGetTime();
						ADD_LOG("D-189");
					}
				}
				else
				{
					if(m_pServoControl->IsSetInnerLimitTorque_800() ==false)
					{
						nTmpError=ERR_SERVO_DRIVING_ALARM;
						CheckReadyToRunTime_ManualMark = timeGetTime();
						ADD_LOG("D-189");
					}
				}
			}
#endif
		}
        break;

    case DRIVING_CTRL_STEP_MANUAL_MARK_RUN:
        switch(MarkType)
        {
			case MARK_TYPE_NODE:
	//          dRealDistSumToTarget = m_pParamSet->Mark[0].Dist.dDistFromFirstToSecond-40;
				nTmpError = markOnNode(HwInfo, dRealDistSumToTarget, dSpeedLimit, nTargetID, nNodeCount, &MarkState, &(CtrlInfo.Axis), &IdReaderCmdType, &nID);
			break;
			case MARK_TYPE_TAG_STATION:
				nTmpError = markOnTagStation(HwInfo, dRealDistSumToTarget, dSpeedLimit, nTargetID, &MarkState, &(CtrlInfo.Axis), &IdReaderCmdType, &nID,false);
			break;
			case MARK_TYPE_QR_STATION_LEFT:
			case MARK_TYPE_QR_LEFT_TOP:
			case MARK_TYPE_QR_LEFT_BOTTOM:
			case MARK_TYPE_QR_LEFT_BOTTOM_S:
			case MARK_TYPE_QR_PSTB_LEFT:
				if(HwInfo.QrStaionLeft.nQrId !=0)
				{
					TEACHING_DATA *teachingData = OHTMainForm->GetTeachingDataManager()->Find(HwInfo.QrStaionLeft.nQrId, PORT_TYPE_STB_L);
					if (teachingData != NULL)
					{
                     	nSTBQROffset = teachingData->STBOffSet;
					}

					ADD_LOG("D_348/%d/%d",nSTBQROffset,HwInfo.QrStaionLeft.nQrId);
                }
				if(m_pParamSet->Mark[2].MakerType ==MAKER_TYPE_KEYENCE)
					nTmpError = markOnQRStation(true, HwInfo, dRealDistSumToTarget, dSpeedLimit, nTargetID, &MarkState, &(CtrlInfo.Axis), &IdReaderCmdType, &nID);
				else if(m_pParamSet->Mark[2].MakerType ==MAKER_TYPE_OMRON)
					nTmpError = markOnQRStationDiffType(true, HwInfo, dRealDistSumToTarget, dSpeedLimit, nTargetID, &MarkState, &(CtrlInfo.Axis), &IdReaderCmdType, &nID);
				else
					nTmpError = markOnQRStationDiffType2(true, HwInfo, dRealDistSumToTarget, dSpeedLimit, nTargetID, &MarkState, &(CtrlInfo.Axis), &IdReaderCmdType, &nID, false,nSTBQROffset);
			break;
			case MARK_TYPE_QR_STATION_RIGHT:
			case MARK_TYPE_QR_RIGHT_TOP:
			case MARK_TYPE_QR_RIGHT_BOTTOM:
			case MARK_TYPE_QR_RIGHT_BOTTOM_S:
			case MARK_TYPE_QR_PSTB_RIGHT:
				if(HwInfo.QrStaionRight.nQrId !=0)
				{
					TEACHING_DATA *teachingData = OHTMainForm->GetTeachingDataManager()->Find(HwInfo.QrStaionRight.nQrId, PORT_TYPE_STB_R);
					if (teachingData != NULL)
					{
						nSTBQROffset = teachingData->STBOffSet;

						ADD_LOG("D_349/%d/%d/%d",teachingData->Shift, teachingData->Hoist,teachingData->STBOffSet);
					}

					ADD_LOG("D_350/%d/%d",nSTBQROffset, HwInfo.QrStaionRight.nQrId);
                }
				if(m_pParamSet->Mark[3].MakerType ==MAKER_TYPE_KEYENCE)
					nTmpError = markOnQRStation(false, HwInfo, dRealDistSumToTarget, dSpeedLimit, nTargetID, &MarkState, &(CtrlInfo.Axis), &IdReaderCmdType, &nID);
				else if(m_pParamSet->Mark[3].MakerType ==MAKER_TYPE_OMRON)
					nTmpError = markOnQRStationDiffType(false, HwInfo, dRealDistSumToTarget, dSpeedLimit, nTargetID, &MarkState, &(CtrlInfo.Axis), &IdReaderCmdType, &nID);
				else
					nTmpError = markOnQRStationDiffType2(false, HwInfo, dRealDistSumToTarget, dSpeedLimit, nTargetID, &MarkState, &(CtrlInfo.Axis), &IdReaderCmdType, &nID, false,nSTBQROffset);
			break;
	//추가
		   case MARK_TYPE_TAG_STATION_BACK:
				dRealDistSumToTarget = -dRealDistSumToTarget;
				nTmpError = markOnTagStationBack(HwInfo, dRealDistSumToTarget, dSpeedLimit, nTargetID, &MarkState, &(CtrlInfo.Axis), &IdReaderCmdType, &nID);
			break;
		}

		//1 조향 방향 찾기
		SteerFront = pHWSet->m_pSteer->GetFrontPos();

		manual_Mark_cnt++;
#if(OHT_NAME != OHT_NAME_P4_MASK)
		//2 CID 모드 선택(CID모드 및 매뉴얼 설정)
		pHWSet->m_pCID->ElevetorOperatingModeSet(ON);//CID Mode
		//ADD_LOG_TASKCONTROL("C-109");

		//3 Select ON
		if(SteerFront == HW_STEER_DIRECTION_RIGHT)
		{
			pHWSet->m_pCID->CID_Out_Manual(ON);
			pHWSet->m_pCID->CID_Out_Left_Select(OFF);
			Sleep(20);
			pHWSet->m_pCID->CID_Out_Right_Select(ON);

			//ADD_LOG("C-110");
		}
		else if(SteerFront == HW_STEER_DIRECTION_LEFT)
		{
			pHWSet->m_pCID->CID_Out_Manual(ON);
			pHWSet->m_pCID->CID_Out_Right_Select(OFF);
			Sleep(20);
			pHWSet->m_pCID->CID_Out_Left_Select(ON);
			//ADD_LOG("C-111");
		}
		else
		{}

		//4 Link 확인 후 점유
		if(pHWSet->m_pCID->IsLinkOK() == ON)
		{
			CIDResetNode_arr = INDEX_NONE;
			CIDResetNode = 0;
			CIDResetNodeType = 0;
			if(m_pExecuteInfo->ExecutePositionInfo.CurrNode != 0) // Node 정보를 아는 경우
			{
				CIDResetNode_arr = OHTMainForm->GetMap()->FindNodeIndexFromCIDStop_1(m_pExecuteInfo->ExecutePositionInfo.CurrNode);
				if (CIDResetNode_arr != INDEX_NONE)
				{
					if(pHWSet->m_pCID->IsInterlock_ON() == false)
					{
						pHWSet->m_pCID->CID_Occup_OK();
						ADD_LOG("C-112");
					}
				}
				else
				{
					CIDResetNode_arr = OHTMainForm->GetMap()->FindNodeIndexFromCIDStop_2(m_pExecuteInfo->ExecutePositionInfo.CurrNode);
					if (CIDResetNode_arr != INDEX_NONE)
					{
						if(pHWSet->m_pCID->IsInterlock_ON() == false)
						{
							pHWSet->m_pCID->CID_Occup_OK();
							ADD_LOG("C-113");
						}
					}
					else
					{
						ADD_LOG("C-114");
					}
				}
			}
			else // Node 정보를 모르는 경우
			{
				if(pHWSet->m_pCID->IsInterlock_ON() == false)
				{
					pHWSet->m_pCID->CID_Occup_OK();
					ADD_LOG("C-115");
				}
			}
		}
#endif

        if(MarkState.Arrived==true)
        {
            nIdResult = nID;
			m_StatusSet.uStep = DRIVING_CTRL_STEP_MANUAL_MARK_COMPLETE;
			CheckComplete_ManualMark = timeGetTime();
            ADD_LOG("D_351/%d", m_StatusSet.uStep);
        }
        break;
    case DRIVING_CTRL_STEP_MANUAL_MARK_COMPLETE: //2  완료
		if( checkCompletion(HwInfo, &(CtrlInfo.Axis), &(CtrlInfo.Steer) , &(CtrlInfo.FrontObservation))==true )
		{
			//경사로 유무 확인 ---정위치 일 경우.
			if(MarkType == MARK_TYPE_NODE)
			{
				nNodeIndex =	OHTMainForm->GetMap()->FindNodeIndex(nIdResult);
				if(nNodeIndex!=INDEX_NONE) pNODE_INFO = &(OHTMainForm->GetMap()->m_NodeArray[nNodeIndex]);		// Node 정보

#if(OHT_NAME != OHT_NAME_P4_MASK)
				m_nCidControlStep = CID_STEP_CONNECTING;
				//3 마크 동작 후 CID 점유 해제
				pHWSet->m_pCID->CID_Occup_return(6);
#endif
			}
			else
			{
				pSData = OHTMainForm->GetStationDataManager()->Find(nIdResult);
				if (pSData != NULL)
				{
					nNodeIndex =	OHTMainForm->GetMap()->FindNodeIndex(pSData->ParentNodeID);
					if(nNodeIndex!=INDEX_NONE) pNODE_INFO = &(OHTMainForm->GetMap()->m_NodeArray[nNodeIndex]);		// Node 정보
#if(OHT_NAME != OHT_NAME_P4_MASK)
					//3 마크 동작 후 CID 점유 해제
					CIDResetNode_arr = INDEX_NONE;
					CIDResetNode = 0;
					CIDResetNodeType = 0;

					CIDResetNode_arr = OHTMainForm->GetMap()->FindNodeIndexFromCIDReset(pSData->NextNodeID);
					if (CIDResetNode_arr != INDEX_NONE)
					{
					  CIDResetNode = OHTMainForm->GetCID_STD()->m_NodeArray[CIDResetNode_arr].ResetNode;
					  CIDResetNodeType = OHTMainForm->GetCID_STD()->m_NodeArray[CIDResetNode_arr].ResetNodeType;
					}

					ADD_LOG("C_131/%d/%d", pSData->NextNodeID, CIDResetNode);

					if(CIDResetNode == pSData->NextNodeID)//StationData.NextNodeID 가 Resetnode 이면, 점유 유지
					{
						//nop
					}
					else
					{
						pHWSet->m_pCID->CID_Occup_return(7);
					}
#endif
				}
			}

             if(pNODE_INFO !=NULL)
			 {
				m_cSlopeNodeInfo = pNODE_INFO->InOutInfo ;

				if(pNODE_INFO->InOutInfo ==SLOPE_NTYPE)
				{
					if(m_pDrivingAxis->IsSlaveAMPEnable() ==false)     //E2302대응
						m_pDrivingAxis->SetSlaveAMPEnable(true);
#if((OHT_NAME == OHT_NAME_STD_V82)|| (OHT_NAME == OHT_NAME_STD_V85S)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
#else
					DWORD dwCurrTime  = timeGetTime();
					if(m_defualtparam->bUseRSA==true)
					{
						while(OHTUTILITY::PreventOverflowGetTimeMs(dwCurrTime)<1000)
						{
							 if(m_pRSAControl->IsSetInnerLimitTorque_90() == true)
								break;

							m_pRSAControl->SetInnerLimitTorque_90();
							ADD_LOG("D-190");
							Sleep(5);
						}
						if(m_pRSAControl->IsSetInnerLimitTorque_90() ==false)
						{
						   nTmpError = ERR_SERVO_DRIVING_ALARM;
						   ERR_LOG("[manual_Mark] Fail SetInnerLimitTorque_90");
						}
						else
						{
							//ERR_LOG("[manual_Mark1] Success SetInnerLimitTorque_90");
						}
					}
					else
					{
						while(OHTUTILITY::PreventOverflowGetTimeMs(dwCurrTime)<1000)
						{
							if(m_pServoControl->IsSetInnerLimitTorque_90() ==true)

								break;

							m_pServoControl->SetInnerLimitTorque_90();  //DrivingControl::manual_Mark Retry 존재 Error 처리 0
							ADD_LOG("D-190");
							Sleep(5);
						}
						if(m_pServoControl->IsSetInnerLimitTorque_90() == false)
						{
						   nTmpError = ERR_SERVO_DRIVING_ALARM;
						   ERR_LOG("[manual_Mark] Fail SetInnerLimitTorque_90");
						}
						else
						{
							//ERR_LOG("[manual_Mark1] Success SetInnerLimitTorque_90");
						}
					}
#endif
				}
				else
                {
#if((OHT_NAME == OHT_NAME_STD_V80) ||(OHT_NAME == OHT_NAME_STD_V81) || (OHT_NAME == OHT_NAME_STD_V81S)  ||(OHT_NAME == OHT_NAME_STD_V85)|| (OHT_NAME == OHT_NAME_STD_V80_RETICLE))
				    m_pDrivingAxis->SetSlaveAMPEnable(false);
#endif
				}
			 }
			 else
			 {
#if((OHT_NAME == OHT_NAME_STD_V80) ||(OHT_NAME == OHT_NAME_STD_V81) || (OHT_NAME == OHT_NAME_STD_V81S)  ||(OHT_NAME == OHT_NAME_STD_V85)|| (OHT_NAME == OHT_NAME_STD_V80_RETICLE))
			   	 m_pDrivingAxis->SetSlaveAMPEnable(false);
#endif
			 }


//			if(m_pExecuteInfo->bJogInterlockIgnore == true)
//			{
//				EnterCriticalSection(&OHTMainForm->m_CS);
//				m_pExecuteInfo->bJogInterlockIgnore = false;
//				LeaveCriticalSection(&OHTMainForm->m_CS);
//			}

//          m_nCMDType = 0;
            m_StatusSet.byStatus    = STS_COMPLETE;
            m_StatusSet.uError      = NO_ERR;
            m_StatusSet.uStep       = 0;


            //1 NEW
            //------------------------------------------------------------------------------------------------------------------------
//          m_PreviousArrivalInfo.bMarked = true;
//          m_PreviousArrivalInfo.uRealArrivedNode = (MarkType==MARK_TYPE_NODE)?nIdResult:0;
//          m_PreviousArrivalInfo.Info.MarkType = MarkType;
//          m_PreviousArrivalInfo.Info.uNode = (MarkType==MARK_TYPE_NODE)?nIdResult:0;
//          m_PreviousArrivalInfo.Info.uNextNode = 0;
//          m_PreviousArrivalInfo.Info.uStation = (MarkType!=MARK_TYPE_NODE)?nIdResult:0;
//          m_PreviousArrivalInfo.Info.dOffset = 0;
//          m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus = m_PreviousArrivalInfo;

            //1 결과 정리

            dNodeDistOffset = (MarkType==MARK_TYPE_NODE)?m_pParamSet->Mark[0].Dist.dAddDistAfterSecondMet:0.0;

            //2  현재 위치 정리
            m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.bMarked = true;
			if(pSData==NULL)
            {
	            m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.uRealArrivedNode = (MarkType==MARK_TYPE_NODE)?nIdResult:0;
                m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode = (MarkType==MARK_TYPE_NODE)?nIdResult:0;
			}else
			{
				m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.uRealArrivedNode = (MarkType==MARK_TYPE_NODE)?nIdResult:pSData->ParentNodeID;
				m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode = (MarkType==MARK_TYPE_NODE)?nIdResult:pSData->ParentNodeID;
            }
            m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.MarkType =  MarkType;
			m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNextNode = 0;
            m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uStation = (MarkType!=MARK_TYPE_NODE)?nIdResult:0;
            m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset = dNodeDistOffset;


            //2 마크 정보로 정리
            m_InfoSet.Position.Mark.dFrontPosition  = HwInfo.Axis1.dCurrPos;
            m_InfoSet.Position.Mark.dRearPosition   = HwInfo.Axis2.dCurrPos;
            m_InfoSet.Position.Mark.PositionStatus  = m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus;

            //2 마크 정보를 멤버변수로 저장
            setPreviousArrivalInfo(m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus);

            getPostionInfoOnMarked(m_InfoSet, &m_PositionInfo);

            //------------------------------------------------------------------------------------------------------------------------
            ADD_LOG("D_352/%d", m_StatusSet.uStep);

            m_StatusSet.bIsOnProcess    = false;
		}
		else
		{
			//AOHC-288
			if(OHTUTILITY::PreventOverflowGetTimeMs(CheckComplete_ManualMark) > DRIVING_SETTING_TIME)
			{
					nTmpError=ERR_SERVO_DRIVING_ALARM;
					CheckComplete_ManualMark = timeGetTime();
					ADD_LOG("D-191");
			}
		}
        break;
    }
//	ADD_LOG("D_353/%d",  m_StatusSet.uStep);
    //1 동작
    if(nTmpError==NO_ERR)   nTmpError = controlAxis(CtrlInfo.Axis);
    if(nTmpError==NO_ERR)   nTmpError = controlSteer(CtrlInfo.Steer);
    if(nTmpError==NO_ERR)   nTmpError = controlFrontObservation(CtrlInfo.FrontObservation);
//    if(IdReaderCmdType!=CTRL_INFO_OF_ID_READER_CMD_NONE)
//	{
////        ADD_LOG("D_354/%d/%d",MarkType, IdReaderCmdType);
//	}
	if(nTmpError==NO_ERR)   nTmpError = controlIdReader(MarkType, IdReaderCmdType);
//	if(IdReaderCmdType!=CTRL_INFO_OF_ID_READER_CMD_NONE)
//	{
////        ADD_LOG("D_355/%d/%d/%d",nTmpError, MarkType, IdReaderCmdType);
//	}

    //1 에러 확인
    if(nTmpError!=NO_ERR)
    {
		m_pDrivingAxis->MoveStop(0.001);
//        m_pDrivingAxis->SetSlaveAMPEnable(false);

//      m_nCMDType = 0;
        m_StatusSet.byStatus        = STS_ERROR;
        m_StatusSet.uError          = nTmpError;
        m_StatusSet.uStep           = 0;

        m_StatusSet.bIsOnProcess    = false;
    }
    return nTmpError;
}



STEER_HW_INFO_POSITION DrivingControl::getSteerPosition(bool bLeftOn, bool bRightOn)
{
    STEER_HW_INFO_POSITION Result;
    if(bLeftOn==false && bRightOn==false) Result = STEER_HW_INFO_POSITION_NONE;
    else if(bLeftOn==true && bRightOn==false) Result = STEER_HW_INFO_POSITION_LEFT;
    else if(bLeftOn==false && bRightOn==true) Result = STEER_HW_INFO_POSITION_RIGHT;
    else  Result = STEER_HW_INFO_POSITION_BOTH;
    return Result;
}

STEER_HW_INFO_POSITION DrivingControl::getSteerTotalPosition(bool bFrontLeftOn, bool bFrontRightOn, bool bRearLeftOn, bool bRearRightOn)
{
    STEER_HW_INFO_POSITION Result;
    STEER_HW_INFO_POSITION TmpValue[2];

    TmpValue[0] = getSteerPosition(bFrontLeftOn, bFrontRightOn);
    TmpValue[1] = getSteerPosition(bRearLeftOn, bRearRightOn);

    if(TmpValue[0]==STEER_HW_INFO_POSITION_NONE || TmpValue[1]==STEER_HW_INFO_POSITION_NONE) Result=STEER_HW_INFO_POSITION_NONE;
    else if(TmpValue[0]==STEER_HW_INFO_POSITION_LEFT && TmpValue[1]==STEER_HW_INFO_POSITION_LEFT) Result=STEER_HW_INFO_POSITION_LEFT;
    else if(TmpValue[0]==STEER_HW_INFO_POSITION_RIGHT && TmpValue[1]==STEER_HW_INFO_POSITION_RIGHT) Result=STEER_HW_INFO_POSITION_RIGHT;
    else if(TmpValue[0]==STEER_HW_INFO_POSITION_BOTH || TmpValue[1]==STEER_HW_INFO_POSITION_BOTH) Result=STEER_HW_INFO_POSITION_BOTH;
    else Result=STEER_HW_INFO_POSITION_NONE;

    return Result;
}


DRIVING_CMD_INFO_OF_NODE* DrivingControl::getNodeInfo(int nNodeCount)
{
    DRIVING_CMD_INFO_OF_NODE* pNodeInfo = NULL;

	int nCount = m_ClassifiedCmd.NodeList.getCount();
    for(int nIndex = 0; nIndex<nCount; nIndex++)
    {
		pNodeInfo = m_ClassifiedCmd.NodeList.refer(nIndex);
        if(pNodeInfo->nCount==nNodeCount)
        {
			return pNodeInfo;
        }
    }
    return NULL;    //없음
}

DRIVING_CMD_INFO_OF_PATH* DrivingControl::getPathInfo(int nStartNodeCount)
{
    DRIVING_CMD_INFO_OF_PATH* pPathInfo = NULL;

    int nCount = m_ClassifiedCmd.PathList.getCount();
    for(int nIndex = 0; nIndex<nCount; nIndex++)
	{
        pPathInfo = m_ClassifiedCmd.PathList.refer(nIndex);
        if(pPathInfo->nCount==(nStartNodeCount+1))
		{
            return pPathInfo;
        }
    }
    return NULL;    //없음

}

double DrivingControl::compensate(double dRealPos)
{
    double dCompensatedPos  = dRealPos
                                - m_InfoSet.Position.Compensation.dDistErrorSum
                                + m_InfoSet.Position.Compensation.dPreArriveOffset;
    return dCompensatedPos;
}
double DrivingControl::getRealPos(double dCompensatedPos)
{
    double dRealPos = dCompensatedPos
                        + m_InfoSet.Position.Compensation.dDistErrorSum
                        - m_InfoSet.Position.Compensation.dPreArriveOffset;
    return dRealPos;
}

double DrivingControl::getSpeedDownPos(double dAccel, double dSpeed, double dDist)
{
	double dSpeedDownPos = 0.0;
    dSpeedDownPos   = dDist-fabs((dSpeed*dSpeed)/(2*dAccel));   // S=(V^2)/(2*a)
    return dSpeedDownPos;
}

bool DrivingControl::isDualStageArea()
{
	bool bOnArea = false;
	bool static bPreOnArea = false;

	double dOffset = 3000.0;
	double dMarkStartPos = m_ClassifiedCmd.TargetInfo.dDistSumToNode;
	if(m_ClassifiedCmd.TargetInfo.Type != MARK_TYPE_QR_LEFT_TOP &&
	m_ClassifiedCmd.TargetInfo.Type != MARK_TYPE_QR_LEFT_BOTTOM &&
	m_ClassifiedCmd.TargetInfo.Type != MARK_TYPE_QR_LEFT_BOTTOM_S &&
	m_ClassifiedCmd.TargetInfo.Type != MARK_TYPE_QR_RIGHT_TOP &&
	m_ClassifiedCmd.TargetInfo.Type != MARK_TYPE_QR_RIGHT_BOTTOM &&
	m_ClassifiedCmd.TargetInfo.Type != MARK_TYPE_QR_RIGHT_BOTTOM_S)
	{
     	return false;
	}
	dMarkStartPos = m_ClassifiedCmd.TargetInfo.dDistSumToNode + m_ClassifiedCmd.TargetInfo.dOffset - dOffset;
	if( m_InfoSet.HwInfo.Axis1.dCurrPos >=getRealPos(dMarkStartPos) )
	{
		if(     (m_ClassifiedCmd.TargetInfo.dOffset>=dOffset)
			||  (m_ClassifiedCmd.TargetInfo.Type==MARK_TYPE_NODE)   )
		{
			bOnArea = true;
		}
		else
		{
			switch(m_ClassifiedCmd.TargetInfo.Steering)
			{
			case PATH_STEERING_NONE:
				bOnArea = true;
				break;

			case PATH_STEERING_LEFT:
			case PATH_STEERING_N_BRANCH_L2R:
				if(     (m_InfoSet.Steer.FrontPosition==STEER_HW_INFO_POSITION_LEFT)
					&&  (m_InfoSet.Steer.RearPosition==STEER_HW_INFO_POSITION_LEFT))
				{
					bOnArea = true;
				}
				break;

			case PATH_STEERING_RIGHT:
			case PATH_STEERING_N_BRANCH_R2L:
				if(     (m_InfoSet.Steer.FrontPosition==STEER_HW_INFO_POSITION_RIGHT)
					&&  (m_InfoSet.Steer.RearPosition==STEER_HW_INFO_POSITION_RIGHT))
				{
					bOnArea = true;
				}
				break;
			}
		}
	}
	if(bPreOnArea == false && bOnArea == true)
	{
		ADD_LOG("STB PIO Start, Rest Dist: %f", getRealPos(dMarkStartPos) - m_InfoSet.HwInfo.Axis1.dCurrPos);
	}
	bPreOnArea = bOnArea;
	return bOnArea;
}

bool DrivingControl::isMarkArea()
{
    bool bOnMarkArea = false;

    double dOffset = 0.0;
    double dMarkStartPos = m_ClassifiedCmd.TargetInfo.dDistSumToNode;

    switch(m_ClassifiedCmd.TargetInfo.Type)
    {
		case MARK_TYPE_NODE:
            dOffset = m_pParamSet->Mark[0].Dist.dMinLengthToNext;
        break;
		case MARK_TYPE_TAG_STATION:
			dOffset = m_pParamSet->Mark[1].Dist.dMinLengthToNext;
		break;
		case MARK_TYPE_TAG_STATION_BACK:
            dOffset = -(m_pParamSet->Mark[1].Dist.dMinLengthToNext*1.5);
		break;
        case MARK_TYPE_QR_STATION_LEFT:
		case MARK_TYPE_QR_LEFT_TOP:
		case MARK_TYPE_QR_LEFT_BOTTOM:
		case MARK_TYPE_QR_LEFT_BOTTOM_S:
		case MARK_TYPE_QR_PSTB_LEFT:
            dOffset = m_pParamSet->Mark[2].Dist.dMinLengthToNext;
        break;
        case MARK_TYPE_QR_STATION_RIGHT:
		case MARK_TYPE_QR_RIGHT_TOP:
		case MARK_TYPE_QR_RIGHT_BOTTOM:
		case MARK_TYPE_QR_RIGHT_BOTTOM_S:
		case MARK_TYPE_QR_PSTB_RIGHT:
            dOffset = m_pParamSet->Mark[3].Dist.dMinLengthToNext;
        break;
    }
    if(m_ClassifiedCmd.TargetInfo.Type==MARK_TYPE_NODE)
    {
        dMarkStartPos   = m_ClassifiedCmd.TargetInfo.dDistSumToNode
						- dOffset -50;
	}
	else
	{
		dMarkStartPos   = m_ClassifiedCmd.TargetInfo.dDistSumToNode
                        + m_ClassifiedCmd.TargetInfo.dOffset
						- dOffset -50;
//		ADD_LOG("D_356/%f",dMarkStartPos);
    }

   if(m_ClassifiedCmd.TargetInfo.Type != MARK_TYPE_TAG_STATION_BACK)
   {
		if( m_InfoSet.HwInfo.Axis1.dCurrPos >=getRealPos(dMarkStartPos) )
		{
			if(     (m_ClassifiedCmd.TargetInfo.dOffset>=dOffset)
				||  (m_ClassifiedCmd.TargetInfo.Type==MARK_TYPE_NODE)   )
			{
				bOnMarkArea = true;
			}
			else
			{
				switch(m_ClassifiedCmd.TargetInfo.Steering)
				{
				case PATH_STEERING_NONE:
					bOnMarkArea = true;
					break;

				case PATH_STEERING_LEFT:
				case PATH_STEERING_N_BRANCH_L2R:
					if(     (m_InfoSet.Steer.FrontPosition==STEER_HW_INFO_POSITION_LEFT)
						&&  (m_InfoSet.Steer.RearPosition==STEER_HW_INFO_POSITION_LEFT))
					{
						bOnMarkArea = true;
					}
					break;

				case PATH_STEERING_RIGHT:
				case PATH_STEERING_N_BRANCH_R2L:
					if(     (m_InfoSet.Steer.FrontPosition==STEER_HW_INFO_POSITION_RIGHT)
						&&  (m_InfoSet.Steer.RearPosition==STEER_HW_INFO_POSITION_RIGHT))
					{
						bOnMarkArea = true;
					}
					break;
				}
			}
		}
	 }else
	 {

		if( (double)m_InfoSet.HwInfo.Axis1.dCurrPos <=(double)getRealPos(dMarkStartPos))
		{
		   ADD_LOG("D_357/%06f/%06f/%06f/%06f",m_InfoSet.HwInfo.Axis1.dCurrPos,getRealPos(dMarkStartPos),m_ClassifiedCmd.TargetInfo.dOffset, dOffset);
//		   if((double)m_ClassifiedCmd.TargetInfo.dOffset>=(double)dOffset)
           bOnMarkArea = true;
//		   else
//		   {
//		   		switch(m_ClassifiedCmd.TargetInfo.Steering)
//				{
//				case PATH_STEERING_NONE:
//					bOnMarkArea = true;
//					break;
//
//				case PATH_STEERING_LEFT:
//				case PATH_STEERING_N_BRANCH_L2R:
//					if(     (m_InfoSet.Steer.FrontPosition==STEER_HW_INFO_POSITION_LEFT)
//						&&  (m_InfoSet.Steer.RearPosition==STEER_HW_INFO_POSITION_LEFT))
//					{
//						bOnMarkArea = true;
//					}
//					break;
//
//				case PATH_STEERING_RIGHT:
//				case PATH_STEERING_N_BRANCH_R2L:
//					if(     (m_InfoSet.Steer.FrontPosition==STEER_HW_INFO_POSITION_RIGHT)
//						&&  (m_InfoSet.Steer.RearPosition==STEER_HW_INFO_POSITION_RIGHT))
//					{
//						bOnMarkArea = true;
//					}
//					break;
//				}
//			}
        }
	 }

#if 0   // Log Test 완료 후 주석 처리
    if(bOnMarkArea==true)// && m_InfoSet.EventAndState.State.MarkArea==false)
    {
        ADD_LOG("D_358/%06d/%7.1lf/%d/%06d/%7.1lf/%06d/%7.1lf/%06d/%7.1lf"
            , m_ClassifiedCmd.TargetInfo.Node
            , m_ClassifiedCmd.TargetInfo.dDistSumToNode
            , m_ClassifiedCmd.TargetInfo.Type
            , m_ClassifiedCmd.TargetInfo.Station
            , m_ClassifiedCmd.TargetInfo.dOffset
            , m_ClassifiedCmd.TargetInfo.NextNode
            , m_ClassifiedCmd.TargetInfo.dLength
            , m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode
			, m_InfoSet.Position.Compensation.dCompensatedPosition
            )
        ADD_LOG("D_359/%7.1lf/%7.1lf/%7.1lf/%7.1lf/%7.1lf/%7.1lf/%7.1lf/%7.1lf/%7.1lf"
            , dMarkStartPos
            , m_ClassifiedCmd.TargetInfo.dDistSumToNode
            , m_ClassifiedCmd.TargetInfo.dOffset
            , dOffset
            , m_InfoSet.HwInfo.Axis1.dCurrPos
            , getRealPos(dMarkStartPos)
            , dMarkStartPos
			, m_InfoSet.Position.Compensation.dDistErrorSum
            , m_InfoSet.Position.Compensation.dPreArriveOffset
            );
    }
#endif


    return bOnMarkArea;
}



/**
@brief   입력하는 Node Count 다음의 Path들에서 추후 조향 방향 구하는 함수: 특별히 없으면 false Return
@author  임태웅
@date    2013.08.06
@param nNodeCount: Node Count
@param SteerCmd: 조향 명령(0: Left / 1: Right)
@return 명령이 있으면 true 반환, 없으면 false 반환
*/
bool DrivingControl::getSteerCmd(int nNodeCount, STEER_HW_INFO_CMD *pSteerCmd)
{
    int nListCount = m_ClassifiedCmd.SteerList.getCount();
    int nTmpIndex   = 0;
    DRIVING_CMD_INFO_OF_STEER* pItem = NULL;
    STEER_HW_INFO_CMD TmpSteerCmd;
    bool bCmdExist = false;

    //1 명령이 없을 경우
    if(nListCount==0) //명령이 없음
    {
        return false;
	}

    //1 명령이 있을 경우
    for(nTmpIndex; nTmpIndex<nListCount; nTmpIndex++)
    {
        pItem = m_ClassifiedCmd.SteerList.refer(nTmpIndex);
        if(pItem!=NULL)
        {

//          ADD_LOG("D_360/%d/%d/%d/%d/%d/%6.1lf"
//              , nTmpIndex
//              , pItem->nCount, nNodeCount, pItem->Type, pItem->NextType, pItem->dDistSumToEndNode);

            if(pItem->nCount<=nNodeCount)
            {
				continue;
            }
			else
            {
//              ADD_LOG("D_361/%d",pItem->Type);
				if(getSteerCmdTypeFrom(pItem->Type, &TmpSteerCmd)==true)
                {
                    *pSteerCmd = TmpSteerCmd;
//					ADD_LOG("D_362/%d/%d",pItem->Type,TmpSteerCmd);
//                  ADD_LOG("D_363/%d/%d/%d"
//                      ,pItem->Type, TmpSteerCmd, *pSteerCmd);
                    return true;
                }
            }
        }
    }

    //1 명령에 조향 명령이 없고 마지막에 선조향 명령이 있을 경우
    if(pItem!=NULL)
    {
		if(getSteerCmdTypeFrom(pItem->NextType, &TmpSteerCmd)==true)
		{
//			ADD_LOG("D_364/%d/%d",pItem->NextType,TmpSteerCmd);
	        *pSteerCmd = TmpSteerCmd;
			return true;
	    }
    }

    //1 명령에 조향 명령이 없고 선조향 명령도 없을 경우
    return  false;

}


bool DrivingControl::getSteerCmdOnNBranch(STEER_HW_INFO_CMD *pSteerCmd)
{
//  ADD_LOG("D_365/%d/%d"
//      , m_InfoSet.Steer.FrontPosition
//      , m_InfoSet.Steer.PathSteer);
    if(m_InfoSet.Steer.FrontPosition==STEER_HW_INFO_POSITION_NONE)
    {

        switch(m_InfoSet.Steer.PathSteer)
        {
        case PATH_STEERING_N_BRANCH_L2R:
            *pSteerCmd = STEER_HW_INFO_CMD_RIGHT;
            break;
        case PATH_STEERING_N_BRANCH_R2L:
			*pSteerCmd = STEER_HW_INFO_CMD_LEFT;
            break;
        default:
            return false;
        }
        return true;
    }
    return false;
}


bool DrivingControl::getSteerCmdTypeFrom(PATH_STEERING_INFO PathSteerInfo, STEER_HW_INFO_CMD *pSteerCmd, STEER_HW_INFO_CMD *pSteerKey)
{
    STEER_HW_INFO_CMD SteerCmd;
    STEER_HW_INFO_CMD SteerKey;

    switch(PathSteerInfo)
    {
	case PATH_STEERING_NONE:
        return false;
        break;
    case PATH_STEERING_LEFT:
		SteerCmd = STEER_HW_INFO_CMD_LEFT;
		SteerKey = STEER_HW_INFO_CMD_LEFT;
		break;
    case PATH_STEERING_RIGHT:
        SteerCmd = STEER_HW_INFO_CMD_RIGHT;
        SteerKey = STEER_HW_INFO_CMD_RIGHT;
        break;
    case PATH_STEERING_N_BRANCH_L2R:
		SteerCmd = STEER_HW_INFO_CMD_LEFT;
        SteerKey = STEER_HW_INFO_CMD_RIGHT;
        break;
    case PATH_STEERING_N_BRANCH_R2L:
        SteerCmd = STEER_HW_INFO_CMD_RIGHT;
        SteerKey = STEER_HW_INFO_CMD_LEFT;
        break;
    }
    if(pSteerCmd!=NULL)*pSteerCmd = SteerCmd;
    if(pSteerKey!=NULL)*pSteerKey = SteerKey;
    return true;
}


bool DrivingControl::getSteerCmdTypeFrom(PATH_STEERING_INFO PathSteerInfo, STEER_HW_INFO_CMD *pSteerCmd)
{
    return getSteerCmdTypeFrom(PathSteerInfo, pSteerCmd, NULL);
}


bool DrivingControl::isSteerChangeAreaByGuide()
{
	DRIVING_CMD_INFO_OF_PATH* pPathInfo = getPathInfo(m_InfoSet.HwInfo.Node.nNodeCount);

	bool bSteerChangeAreaByGuide = false;   // N분기 가이드 레일에 의해 조향이 변경되는 구간

    // N분기 영역 확인
	if(pPathInfo!=NULL)
    {
//      ADD_LOG("D_366/%d", pPathInfo->Steering);
		if(pPathInfo->Steering==STEERING_N_BRANCH_L2R||pPathInfo->Steering==STEERING_N_BRANCH_R2L)
        {
//          ADD_LOG("D_367/%6.1lf/%6.1lf/%d/%d"
//              , m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset
//              , m_pParamSet->Link.dNBranchMiddleAreaInMargin
//              , m_InfoSet.HwInfo.Node.nNodeCount
//              , m_InfoSet.HwInfo.Node.nPreCheckCount);
//
            if(     (m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset
                    >m_pParamSet->Link.dNBranchMiddleAreaInMargin )
                &&  (m_InfoSet.HwInfo.Node.nNodeCount==m_InfoSet.HwInfo.Node.nPreCheckCount)
                )
            {
				bSteerChangeAreaByGuide = true;
			}
		}
    }

	return bSteerChangeAreaByGuide;

}


bool DrivingControl::isSteerChangeAreaByGuideNodeCountAdd()
{
	DRIVING_CMD_INFO_OF_PATH* pPathInfo = getPathInfo(m_InfoSet.HwInfo.Node.nNodeCount);

	bool bSteerChangeAreaByGuide = false;   // N분기 가이드 레일에 의해 조향이 변경되는 구간

    // N분기 영역 확인
	if(pPathInfo!=NULL)
    {
//      ADD_LOG("D_368/%d", pPathInfo->Steering);
		if(pPathInfo->Steering==STEERING_N_BRANCH_L2R||pPathInfo->Steering==STEERING_N_BRANCH_R2L)
        {
//          ADD_LOG("D_369/%6.1lf/%6.1lf/%d/%d"
//              , m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset
//              , m_pParamSet->Link.dNBranchMiddleAreaInMargin
//              , m_InfoSet.HwInfo.Node.nNodeCount
//              , m_InfoSet.HwInfo.Node.nPreCheckCount);
//
            if(     (m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset
                    >m_pParamSet->Link.dNBranchMiddleAreaInMargin )
                )
            {
				bSteerChangeAreaByGuide = true;
			}
		}
    }

	return bSteerChangeAreaByGuide;

}

/**
@brief   분기 정보
@author  puting
@date    2016.11.06
*/
bool DrivingControl::getDivergenceInfo(int nNodeCount, PATH_DIVERGENCE_INFO* pDivInfo,PATH_DIVERGENCE_INFO* pPreDivInfo, int *NodeCount)
{
	int nListCount = m_ClassifiedCmd.DivList.getCount();
    int nTmpIndex   = 0;
    DRIVING_CMD_INFO_OF_DIV* pItem = NULL;
//	PATH_DIVERGENCE_INFO DetectInfo;
    bool bCmdExist = false;

    //1 명령이 없을 경우
    if(nListCount==0) //명령이 없음
    {
        return false;
    }

    //1 명령이 있을 경우
	for(nTmpIndex; nTmpIndex<nListCount; nTmpIndex++)
	{
		pItem = m_ClassifiedCmd.DivList.refer(nTmpIndex);

		if(pItem!=NULL)
		{

			if(pItem->nCount<=nNodeCount)
            {
                continue;
            }
            else
			{
				 // ADD_LOG("D_370/%d/%d/%d/%d", nNodeCount,pItem->nCount,pItem->Type, pItem->NextType);
				*pDivInfo = pItem->Type;
				*pPreDivInfo =  pItem->NextType;
				*NodeCount =  pItem->nCount;
				return true;
			}
		}
	}

	//1 명령이 없을 경우
	return  false;

}


bool DrivingControl::getFrontObservation(int nPreCheckCount, USER_DETECT_INFO* pDetectInfo)
{
    int nListCount = m_ClassifiedCmd.DirectionList.getCount();
    int nTmpIndex   = 0;
    DRIVING_CMD_INFO_OF_DIRECTION* pItem = NULL;
//	USER_DETECT_INFO DetectInfo;
    bool bCmdExist = false;

    //1 명령이 없을 경우
    if(nListCount==0) //명령이 없음
    {
        return false;
	}

    //1 명령이 있을 경우
    for(nTmpIndex; nTmpIndex<nListCount; nTmpIndex++)
    {
        pItem = m_ClassifiedCmd.DirectionList.refer(nTmpIndex);
        if(pItem!=NULL)
        {
            if(pItem->nCount<=nPreCheckCount)
            {
                continue;
            }
            else
			{
				pDetectInfo->UseFollowControlFlag = true;

#if(USE_CHANGENODE == 1)
				//인터락 보완 패턴이 없을 경우 디폴트로 직선패턴(20170219)
				if(pItem->UBGRegion == PATH_DIRECTION_NO_USE) pItem->UBGRegion = PATH_DIRECTION_NORMAL;
				if(pItem->OptUBGRegion == PATH_DIRECTION_NO_USE) pItem->OptUBGRegion = PATH_DIRECTION_NORMAL;
				if(pItem->ObstacleRegion == PATH_OBS_DIRECTION_NO_USE) pItem->ObstacleRegion = PATH_OBS_DIRECTION_NORMAL;
				if(pItem->OptObstacleRegion == PATH_OBS_DIRECTION_NO_USE) pItem->OptObstacleRegion = PATH_OBS_DIRECTION_NORMAL;

				pDetectInfo->OHTDetectType = pItem->UBGRegion;
				pDetectInfo->OBSDetectType = pItem->ObstacleRegion;
				pDetectInfo->NodeCount = nPreCheckCount;//pItem->nCount;
				pDetectInfo->DistSumOfStraightPath    = getRealPos(pItem->dDistSumToEndNode)
                                                    + m_pParamSet->FrontDetect.dObsStraightDetectMargin;
				pDetectInfo->FollowCommandType = pItem->nFollowsCommandType;
				pDetectInfo->PBSIgnoreFlag = pItem->nPBSIgnoreFlag;

				// for change node (jhoun.lim)
				pDetectInfo->NodeType = pItem->NodeType;
				pDetectInfo->DistON = pItem->OptDistance;
				pDetectInfo->DistAfterON = pItem->OptDistanceAfter;
				pDetectInfo->OHTDetectTypeOpt = pItem->OptUBGRegion;
				pDetectInfo->OBSDetectTypeOpt = pItem->OptObstacleRegion;
#else
				//인터락 보완 패턴이 없을 경우 디폴트로 직선패턴(20170219)
				if(pItem->Type == PATH_DIRECTION_NO_USE)
				{
                   pItem->Type = PATH_DIRECTION_NORMAL;
				   pItem->Type = pItem->Type | (PATH_DIRECTION_NORMAL<<4);
				}

				pDetectInfo->Type = pItem->Type;
				pDetectInfo->NodeCount = nPreCheckCount;//pItem->nCount;
				pDetectInfo->DistSumOfStraightPath    = getRealPos(pItem->dDistSumToEndNode)
                                                    + m_pParamSet->FrontDetect.dObsStraightDetectMargin;
				pDetectInfo->FollowCommandType = pItem->nFollowsCommandType;
				pDetectInfo->PBSIgnoreFlag = pItem->nPBSIgnoreFlag;
#endif
//				*pDetectInfo = DetectInfo;
				return true;
			}
        }
    }

    //1 명령이 없을 경우
    return  false;

}

bool DrivingControl::getFrontObservationNodeCount(int nPreCheckCount)
{
    int nListCount = m_ClassifiedCmd.DirectionList.getCount();
    int nTmpIndex   = 0;
    DRIVING_CMD_INFO_OF_DIRECTION* pItem = NULL;
	USER_DETECT_INFO DetectInfo;
    bool bCmdExist = false;

    //1 명령이 없을 경우
    if(nListCount==0) //명령이 없음
    {
        return false;
	}

    //1 명령이 있을 경우
    for(nTmpIndex; nTmpIndex<nListCount; nTmpIndex++)
    {
        pItem = m_ClassifiedCmd.DirectionList.refer(nTmpIndex);
        if(pItem!=NULL)
        {
            if(pItem->nCount<=nPreCheckCount)
            {
                continue;
            }
            else
			{

#if(USE_CHANGENODE == 1)
				//인터락 보완 패턴이 없을 경우 디폴트로 직선패턴(20170219)
				if(pItem->UBGRegion == PATH_DIRECTION_NO_USE) pItem->UBGRegion = PATH_DIRECTION_NORMAL;
				if(pItem->OptUBGRegion == PATH_DIRECTION_NO_USE) pItem->OptUBGRegion = PATH_DIRECTION_NORMAL;
				if(pItem->ObstacleRegion == PATH_OBS_DIRECTION_NO_USE) pItem->ObstacleRegion = PATH_OBS_DIRECTION_NORMAL;
				if(pItem->OptObstacleRegion == PATH_OBS_DIRECTION_NO_USE) pItem->OptObstacleRegion = PATH_OBS_DIRECTION_NORMAL;

				m_Dectect_Dir = pItem->UBGRegion;
				m_Dectect_OBS_Dir = pItem->ObstacleRegion;
#else
				//인터락 보완 패턴이 없을 경우 디폴트로 직선패턴(20170219)
				if(pItem->Type == PATH_DIRECTION_NO_USE)
				{
                   pItem->Type = PATH_DIRECTION_NORMAL;
				   pItem->Type = pItem->Type | (PATH_DIRECTION_NORMAL<<4);
				}

				m_Dectect_Dir = pItem->Type & 0x0F;
				m_Dectect_OBS_Dir = (pItem->Type & 0xF0) >> 4;
#endif


				return true;
			}
        }
    }

    //1 명령이 없을 경우
    return  false;

}
/**
@brief   후진 명령 생성
@author  puting
@date    2016.11.06
*/
bool DrivingControl::getAxisCmdInfoBack(DRIVING_INFO_SET *pInfoSet, CTRL_INFO_OF_SYNC_AXIS_MOVE* pCtrlInfo)

{

	bool    bCmdExist = false;          // 명령이 있다
	bool    bLowSpeed = false;          // 직진부 전후로 조향이 다른 경우
	bool    bOutInNode = false;     // Node 전후로 조향이 다른 경우
	bool    bIsToTarget = false;
	bool    bNextPathExist = false; // 명령 나간 Node 이후 Path 존재 여부 확인, 마지막 Node까지 명령이 나갔다
	int     nKeyNodeCount = 0;
	int     nResultNodeCount = 0;
	int     nCheckPointOfPosition = 0;  // 이동 거리가 산출된 곳을 확인하기 위한 변수, 실제로 사용되는 곳 없음

	int     nCurrNodeCount = pInfoSet->HwInfo.Node.nNodeCount;
	int     nCurrPreNodeCount = pInfoSet->HwInfo.Node.nPreCheckCount;




	int nPreCheckCount = pInfoSet->HwInfo.Node.nNodeCount;

	//  DRIVING_CMD_INFO_OF_PATH* pPathInfo = getPathInfo(pInfoSet->HwInfo.Node.nNodeCount);
    DRIVING_CMD_INFO_OF_PATH* pPathInfo = getPathInfo(pInfoSet->Position.CmdRefInfo.nCount);

	if(pPathInfo!=NULL)bNextPathExist=true;

	if( (nPreCheckCount==0)
	&&  (pInfoSet->Position.bPreCheckIsOverFirstNode==true)
	)
	{
		nPreCheckCount=1;
    }


	int     nCmdTargetNodeCount = pInfoSet->Position.CmdRefInfo.nCount;
	double dCurrPos = pInfoSet->HwInfo.Axis1.dCurrPos;


	double  dSafetySpeedLimit = m_pParamSet->Axis.Limit.Speed.MaxValue; // 초기화(최대값)
	double  dSpeedLimit= 0.0;
	double  dSpeedResult= 0.0;
	int     nNodeCountBySpeed = 0;
    double  dTmpSpeedLimit = 0.0;



	STEER_HW_INFO_POSITION  CurrTotalSteerPos;
    int     anNodeCountBySteer[2] = {0,};



	bool bSpeedDownPassed   = pInfoSet->EventAndState.State.SpeedDownPassed;
	double dCurrSpeed       = fabs(pInfoSet->HwInfo.Axis1.dSpeed);    //AOHC-367  명령을 + 실제는 음수로 표현됨.
	double dCurrCmdSpeed    = fabs(pInfoSet->Position.CmdRefInfo.dCmdSpeed); //AOHC-367
	double dNextPathSpeed;

	if(pPathInfo!=NULL)
	{
		dNextPathSpeed   = (bNextPathExist==true)?pPathInfo->dSpeed:0.0; // 명령 받은 Node 다음 Path의 속도
	}

	double dTmpdist = 0.0;
	double dTmpPosition = 0.0;
	double dPreCmdPosition = pInfoSet->Position.CmdRefInfo.dDist;
	double dSmoothSpeed = 0.0;
	DRIVING_CMD_INFO_OF_NODE* pNodeInfo = NULL;

	STEER_HW_INFO_CMD TmpSteerCmdForNext;   // Front 조향 변경 시 300mm 더가는 것 학인 목적
	double dMarginBeforeFinalNode = 0.0;


#if(UBG_SENSOR_ENABLE == ON)
	bool sStopWithNoReason  =   (   pInfoSet->HwInfo.IO.Axis1Running==false
									&&  pInfoSet->HwInfo.IO.DetectStatus==0
									&&  pInfoSet->HwInfo.IO.ObsStatus==0)
									?true:false;
#else
	bool sStopWithNoReason  =   (   pInfoSet->HwInfo.IO.Axis1Running==false
									&& pInfoSet->HwInfo.IO.ObsStatus==0)
									?true:false;
#endif



	double  dTmpAccel = m_pParamSet->Axis.Default.dDefaultAccel;

    double  dTmpDecel = m_pParamSet->Axis.Default.dDefaultDecel;



	//1 Node Count 시작 위치 설정
	// SpeedDown 통과 시
	if(bSpeedDownPassed==true)
	{
		// 다음 속도가 적을 경우: 다음 명령 수행
		if(dNextPathSpeed<dCurrCmdSpeed)
		{
			nKeyNodeCount = nCmdTargetNodeCount;
			pInfoSet->Position.CmdRefInfo.nKeyCount = nCmdTargetNodeCount;
   		}
		// 다음 속도가 크거나 같은 경우: 일반 처리
		else
		{
			nKeyNodeCount = nPreCheckCount;
        }
	}
	// SpeedDown 미통과 시: 일반 처리
	else
	{
        nKeyNodeCount = nPreCheckCount;
	}





	// 감속 중일 때, 적정 속도 확보
	if(nKeyNodeCount < pInfoSet->Position.CmdRefInfo.nKeyCount) // 감속 위치를 한번이라도 지나면 나타나는 현상
	{
		nKeyNodeCount = pInfoSet->Position.CmdRefInfo.nKeyCount;
		// 안전 속도 확보
		if(bNextPathExist==true)// 명령 준 Node 넘어로 Path 가 더 남아 있는 경우
		{
			dSafetySpeedLimit = MIN(dCurrCmdSpeed, dNextPathSpeed);
		}
		else    // 명령 준 Node 넘어로 남아있는 Path 가 없는 경우 , 명령 준 Node 가 마지막인 경우 마지막 명령 준 속도를 리밋으로 한다.
		 {
			 dSafetySpeedLimit = dCurrCmdSpeed;
		}

    }



	//1  명령 기준 정보 획득
    //2 속도 변화에 따른 정보 획득(Node Count, 속도, 거리) : OutLine
	bCmdExist = getAxisCmdInfoBySpeed(nKeyNodeCount, &dSpeedLimit, &nNodeCountBySpeed);
	dSpeedLimit = MIN(dSafetySpeedLimit, dSpeedLimit);// 저속 중 Node 만나서 가속 경우 : 노드 만나기 전까지  빠른 가속 방지

//	ADD_LOG("D_371/%d/%d/%d",nKeyNodeCount, bCmdExist, nNodeCountBySpeed);
	//2 Steer에 따른 정보 획득(Node Count, 속도, 거리) : --> 감속 거리
	if(bCmdExist==true)
	{
		CurrTotalSteerPos = getSteerTotalPosition(    pInfoSet->HwInfo.IO.SteerFrontLeftInOn
													, pInfoSet->HwInfo.IO.SteerFrontRightInOn
													, pInfoSet->HwInfo.IO.SteerRearLeftInOn
                                                    , pInfoSet->HwInfo.IO.SteerRearRightInOn);

		switch(CurrTotalSteerPos)
		{
		case STEER_HW_INFO_POSITION_NONE:
            break;

		case STEER_HW_INFO_POSITION_LEFT:
			if( (pInfoSet->Steer.FrontCmdDirection!=DRIVING_IO_STEER_DIRECTION_CMD_LEFT)
			||  (pInfoSet->Time.Steer.FrontSteeringArrived.bFlag==false)
			||  (pInfoSet->Time.Steer.RearSteeringArrived.bFlag==false)
			)
			{
				bCmdExist = false;
			}

            break;

		case STEER_HW_INFO_POSITION_RIGHT:
			if( (pInfoSet->Steer.FrontCmdDirection!=DRIVING_IO_STEER_DIRECTION_CMD_RIGHT)
			||  (pInfoSet->Time.Steer.FrontSteeringArrived.bFlag==false)
			||  (pInfoSet->Time.Steer.RearSteeringArrived.bFlag==false)
			)
			{
				bCmdExist = false;
			}
            break;

        case STEER_HW_INFO_POSITION_BOTH:

            break;

		}

	}



//	ADD_LOG("D_372/%d/%f",bCmdExist, CurrTotalSteerPos);



    //2 Node Count 결과 확인

	if(bCmdExist==true)
	{
		nResultNodeCount = nNodeCountBySpeed;
		bOutInNode = false;

        // Node Count 가 명령 나간 지점 보다 적어지면 명령 나간 곳으로 명령(PreCheck 지점 에서 조향 변경 중)

		if(nResultNodeCount<nCmdTargetNodeCount)
		{
			//bCmdExist=false;
            nResultNodeCount=nCmdTargetNodeCount;
        }

	}



//	ADD_LOG("D_373/%d/%f",nResultNodeCount, nCmdTargetNodeCount);



    //2 Data 결과 처리

	if(bCmdExist==true)
	{

		pNodeInfo = getNodeInfo(nResultNodeCount);
		if(pNodeInfo!=NULL)
		{

			dTmpPosition = getRealPos(pNodeInfo->dDistSum);
			nCheckPointOfPosition = 0;

			//1 속도 사다리꼴화
			dSpeedResult = dSpeedLimit;

			ADD_LOG("D_374/%f/%f/%f/%d",dTmpPosition,pNodeInfo->dDistSum,pInfoSet->HwInfo.Axis1.dCurrPos,nResultNodeCount);

			//1 거리 구하기

			if(pNodeInfo->nCount==m_ClassifiedCmd.TargetInfo.nCount)
			{

				bIsToTarget = true;

				 dMarginBeforeFinalNode = (nResultNodeCount==nCurrNodeCount)?-150:-DIST_MARGIN_TO_NODE_TO_CONPENSATE_SLIP; // 타겟 도착하기 전이면 이 값을 빼서 이동, 최종 Node 지나서 정확한 위치로 보냄
				 dTmpPosition    =(dTmpPosition+dMarginBeforeFinalNode);
				 nCheckPointOfPosition = 2;

			}
			else
			{
				dTmpPosition    =   (bSpeedDownPassed==true)
								?   MIN(dPreCmdPosition,(dTmpPosition-DIST_MARGIN_TO_NODE_TO_CONPENSATE_SLIP))
								:   (dTmpPosition-DIST_MARGIN_TO_NODE_TO_CONPENSATE_SLIP);

				nCheckPointOfPosition = 14;
			}
			ADD_LOG("D_375/%d/%f",nCheckPointOfPosition, dTmpPosition);


            //1 조향 사이 Normal Path 이동 부드럽게

			dTmpAccel   = (m_pParamSet->Axis.Default.dDefaultAccel)
						/ (getAccelDivisor(nCurrPreNodeCount));
			dTmpDecel   = (bIsToTarget)?(m_pParamSet->Axis.Default.dDefaultDecel*2/3)
						:(m_pParamSet->Axis.Default.dDefaultDecel
						/getDecelDivisor(MAX(nCurrNodeCount,(nResultNodeCount-1))));

            // 가속도 변경에 의한 고속 커브 진입 방지
			if( (pInfoSet->Position.CmdRefInfo.dRefSpeed>=dSpeedLimit)// 이전 속도가 빠르고
			&&  (pInfoSet->Position.CmdRefInfo.dCmdDecel>dTmpDecel)// 이전 감속도가 크고
			&&  (dCurrSpeed>(dSpeedLimit+m_pParamSet->Axis.Default.dDefaultDecel*16))// 현재 속도가 다음 속도보다 빠르고: 16ms(Thread 1주기)
			&&  (nCurrNodeCount<nKeyNodeCount)// 노드 카운트가 키 노드 카운트를 지나지 않았을 경우
			 )
			{
				dTmpDecel = pInfoSet->Position.CmdRefInfo.dCmdDecel;
			}


			dSpeedResult = dSpeedLimit;
			if(bLowSpeed)                  			{

				// 마지막이 아니거나, 마지막인데 Path 중간의 Node 인 경우
				if(     (m_ClassifiedCmd.TargetInfo.nCount!=pNodeInfo->nCount)
					&&  ((m_ClassifiedCmd.TargetInfo.nCount==pNodeInfo->nCount)
							&&(m_ClassifiedCmd.TargetInfo.Type==MARK_TYPE_NODE)
							&&(pNodeInfo->Type!=NORMAL_POINT))
				)
				{

					dTmpdist = getDist(anNodeCountBySteer[0], nResultNodeCount);
					dSmoothSpeed = getSmoothSpeed(dTmpDecel, dTmpdist, m_pParamSet->Steer.dwChangeTime);
					dSpeedResult = MIN(dSmoothSpeed, dSpeedResult);
					dSpeedResult = MIN(dSmoothSpeed, dSpeedLimit);

                }

			}

//          else

//          {

//              dSpeedResult = MIN(dSpeedLimit,(DRIVING_SPEED_SMOOTHING_FACTOR

//                                                  *getMaxSpeed(   dTmpAccel ,dTmpDecel ,(dTmpPosition-pInfoSet->HwInfo.Axis1.dCurrPos))));

//          }





			//2 속도 이전과 비교 처리: 사다리꼴 모양 만들기 --> 후반부 감속 처리 제거 및 초기 튐 제거
            if( (pInfoSet->Position.CmdRefInfo.nCount!=0)
			   &&  (pInfoSet->Position.CmdRefInfo.nCount==nResultNodeCount)
			&&  (pInfoSet->Position.CmdRefInfo.dCmdSpeed>dSpeedResult)
			   &&  (bSpeedDownPassed==false)
			)
            {

                if( (bNextPathExist==true)              // 다음 경로가 있고
				&&  (dNextPathSpeed<dSpeedLimit)        // 다음 경로 기준 속도가 현재 경로 기준 속도보다 느리고
				&&  (dNextPathSpeed>dSpeedResult)   // 다음 경로 속도가 현재 결과 속도보다 큰 경우
				)
				{
					dSpeedResult = dNextPathSpeed;
				}
				else
				{
					if(nCurrPreNodeCount<nResultNodeCount)
					{
						dSpeedResult = pInfoSet->Position.CmdRefInfo.dCmdSpeed;
					}
				}
            }

            //2 속도 Min Max 처리

			dSpeedResult = MAX(dSpeedResult, (m_pParamSet->Axis.Limit.Speed.MinValue));
			dSpeedResult = MIN(dSpeedResult, (m_pParamSet->Axis.Limit.Speed.MaxValue));

            //2 시작 시 뒤로 이동 방지 처리

			dTmpPosition = MIN(dCurrPos, dTmpPosition); // 뒤로 이동 방지

			//ADD_LOG("D_376/%f/%f/%f/%f/%f",dTmpPosition,dCurrPos,dTmpAccel,dTmpDecel,dSpeedResult);
			memset(pCtrlInfo, 0x00, sizeof(CTRL_INFO_OF_SYNC_AXIS_MOVE));

            pCtrlInfo->byType=AXIS_CTRL_CMD_MOVE_DS;

//          memset(&(pCtrlInfo->Dynamic.AdditionalInfo),0,sizeof(USER_MOVE_DS_ADDITIONAL_INFO));

			pCtrlInfo->Dynamic.dAccel       = dTmpAccel;
			pCtrlInfo->Dynamic.dDecel       = dTmpDecel;
			pCtrlInfo->Dynamic.dSpeed       = dSpeedResult;
			pCtrlInfo->Dynamic.dDist        = dTmpPosition;


			pInfoSet->Position.CmdRefInfo.dCmdSpeed     = dSpeedResult;
			pInfoSet->Position.CmdRefInfo.dRefSpeed     = dSpeedLimit;
			pInfoSet->Position.CmdRefInfo.dCmdDecel     = dTmpDecel;
			pInfoSet->Position.CmdRefInfo.nCount        = nResultNodeCount;
			pInfoSet->Position.CmdRefInfo.dDist         = dTmpPosition;
            pInfoSet->Position.CmdRefInfo.dSpeedDownPos = getSpeedDownPos(dTmpDecel, dSpeedResult ,dTmpPosition);

		}
    }



	if(bCmdExist==true)
    {

		ADD_LOG("D_377/%06d/%3d/%3d/%3d/%6.1lf/%8.1lf/%6.1lf/%6.4lf/%6.4lf/%3.1lf/%3.1lf/%3.1lf/%6.1lf/%6.1lf/%6.1lf/%2d/%4X/%d/%6.1lf/%d/%d/%d/%d/%d"
			, pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.uNode
			, pInfoSet->HwInfo.Node.nNodeCount
			, pInfoSet->HwInfo.Node.nPreCheckCount
			, nPreCheckCount
			, pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset
			, pInfoSet->Position.Compensation.dCompensatedPosition
			, pInfoSet->Position.Compensation.dDistErrorSum
			, pCtrlInfo->Dynamic.dAccel, pCtrlInfo->Dynamic.dDecel
			, pCtrlInfo->Dynamic.dSpeed, pInfoSet->HwInfo.Axis1.dSpeed, dSpeedLimit
			, pCtrlInfo->Dynamic.dDist
			, pInfoSet->HwInfo.Axis1.dCurrPos
			, pInfoSet->Position.Compensation.dLinkDistError
			, nCheckPointOfPosition
			, pInfoSet->EventAndState.Event
			, bSpeedDownPassed
			, pInfoSet->Position.CmdRefInfo.dSpeedDownPos
			, nKeyNodeCount
			, nResultNodeCount
			, anNodeCountBySteer[0]
			, anNodeCountBySteer[1]
			, CurrTotalSteerPos
            );

    }



    return bCmdExist;

}

// Path 속도에 의한 주행 정보 획득: 감속하는 지점까지의 정보 획득
bool DrivingControl::getAxisCmdInfoBySpeed(int nNodeCount, double *pdSpeed, int *pnStopNodeCount)
{
    int nListCount = m_ClassifiedCmd.SpeedlList.getCount();
    int nTmpIndex   = 0;
    DRIVING_CMD_INFO_OF_SPEED* pItem = NULL;

    bool bCmdExist = false;
    double dKeySpeed = 0.0;
    double dSpeed = 0.0;
    int nTmpNodeCount = 0;

    //1 명령이 없을 경우
    if(nListCount==0) //명령이 없음
    {
        return false;
    }

    //1 명령이 있을 경우
    for(nTmpIndex; nTmpIndex<nListCount; nTmpIndex++)
    {
        pItem = m_ClassifiedCmd.SpeedlList.refer(nTmpIndex);
        if(pItem!=NULL)
		{

            if(pItem->nCount<=nNodeCount)
            {
                continue;
            }
            else
            {
                if(pItem->dSpeed>=dKeySpeed)
                {
                    if(dKeySpeed==0.0)
                    {
                        dSpeed = pItem->dSpeed;
                    }
                    nTmpNodeCount = pItem->nCount;
                    dKeySpeed = pItem->dSpeed;
                }
                else
                {
                    break;
                }
            }
        }
    }

    //1 감속 없이 끝까지 온 경우
    if(dKeySpeed!=0.0)
    {
        *pdSpeed = dSpeed;
        *pnStopNodeCount = nTmpNodeCount;
        return true;    // 마지막까지 온 경우
    }
    else
    {
        return  false;
    }

}

// Path 조향에 의한 주행 정보 획득
bool DrivingControl::getAxisCmdInfoBySteer(int nNodeCount, STEER_HW_INFO_POSITION CurTotalSteerPos, int *pnStopNodeCount1, int *pnStopNodeCount2,STEER_HW_INFO_POSITION RealCurTotalSteerPos)
{
    int nListCount = m_ClassifiedCmd.SteerList.getCount();
    int nTmpIndex   = 0;
    DRIVING_CMD_INFO_OF_STEER* pItem = NULL;
    DRIVING_CMD_INFO_OF_STEER* pTmpItem = NULL;
    DRIVING_CMD_INFO_OF_STEER* pPreItem = NULL;
    STEER_HW_INFO_CMD SteerKey;
    STEER_HW_INFO_CMD TmpSteerCmd;
    STEER_HW_INFO_CMD TmpSteerKey;

    bool bOnlyNormal = false;
    bool bCmdExist = false;
    bool bBreaked = false;
    int nTmpNodeCount[2] = {0,};


    //1 시작 Key를 만듬
    switch(CurTotalSteerPos)
    {
    case STEER_HW_INFO_POSITION_NONE:
		bOnlyNormal = true;
        break;

    case STEER_HW_INFO_POSITION_LEFT:
		SteerKey = STEER_HW_INFO_CMD_LEFT;
        break;

	case STEER_HW_INFO_POSITION_RIGHT:
		SteerKey = STEER_HW_INFO_CMD_RIGHT;
        break;

    case STEER_HW_INFO_POSITION_BOTH:
        return false;
        break;
    }

    //1 추가 명령이 없을 경우
    if(nListCount==0) //그 이상의 명령이 없음
    {
        return false;
    }

    //1 추가 명령이 있을 경우
    for(nTmpIndex; nTmpIndex<nListCount; nTmpIndex++)
    {
        pPreItem = pItem;
        pItem = m_ClassifiedCmd.SteerList.refer(nTmpIndex);
        if(pItem!=NULL)
        {
            if(pItem->nCount<=nNodeCount)
            {
                continue;
            }
            else
            {
                bCmdExist = true;
                if(getSteerCmdTypeFrom(pItem->Type, &TmpSteerCmd, &TmpSteerKey)==true)
                {

//                  ADD_LOG("D_378/%d/%d/%d/%5lf/%d/%d/%d/%d/%d"
//                      , nTmpIndex, nListCount
//					  , pItem->nCount, pItem->dDistSumToEndNode, pItem->Type, pItem->NextType
//					  , SteerKey, TmpSteerCmd, TmpSteerKey);

					//2 Normal 확인
                    if(bOnlyNormal==true)
					{
						if(nTmpIndex==0)// __L/R__ⓞ
						{
							nTmpNodeCount[0] = nNodeCount;
							nTmpNodeCount[1] = nNodeCount;
						}
						else if(nTmpIndex>=1)// ____N___ⓞ__L/R__①
						{
							nTmpNodeCount[0] = nNodeCount;
							nTmpNodeCount[1] = pPreItem->nCount;

						}
						bBreaked = true;
						break;

					}

					//2     같은 조향을 만나면
					if(SteerKey==TmpSteerCmd)
					{
						SteerKey = TmpSteerKey;
					}
					//2     다른 조향을 만나면
					else
					{
						if(nTmpIndex==0)// __L/R__ⓞ // 시작 부터 다른 방향
						{
							nTmpNodeCount[0] = nNodeCount;
							nTmpNodeCount[1] = nNodeCount;
						}
						else if(nTmpIndex==1)
						{
							if(pPreItem->Type!=STEERING_NONE)// ____R___ⓞ___L___①
							{
								nTmpNodeCount[0] = pPreItem->nCount;
								nTmpNodeCount[1] = pPreItem->nCount;
                            }
                            else // ____N___ⓞ__L/R__①
                            {
                                nTmpNodeCount[0] = nNodeCount;
                                nTmpNodeCount[1] = pPreItem->nCount;
                            }
                        }
                        else if(nTmpIndex>1)
                        {
                            if(pPreItem->Type!=STEERING_NONE)// ___X___ⓞ___R___①___L___②
                            {
                                nTmpNodeCount[0] = pPreItem->nCount;
                                nTmpNodeCount[1] = pPreItem->nCount;

                            }
                            else // ___R___ⓞ___N___①___L___②
                            {
                                pTmpItem = m_ClassifiedCmd.SteerList.refer(nTmpIndex-2);
                                nTmpNodeCount[0] = pTmpItem->nCount;
                                nTmpNodeCount[1] = pPreItem->nCount;
                            }
                        }
                        bBreaked = true;
                        break;
                    }
                }
            }
        }
    }

    if(bCmdExist==true)
    {
        if(bBreaked == true)
        {
            *pnStopNodeCount1 = nTmpNodeCount[0];
            *pnStopNodeCount2 = nTmpNodeCount[1];
//          ADD_LOG("D-192");
        }
        else
		{
			/*
			if(pItem->Type==STEERING_NONE)// ____N___①
			{
				*pnStopNodeCount1 = (pPreItem!=NULL)?pPreItem->nCount:0;
				ADD_LOG("D_379/%d/%d",*pnStopNodeCount1,pItem->nCount);
			}
			else// ____X___ⓞ__L/R__①
			{
				*pnStopNodeCount1 = pItem->nCount;
				ADD_LOG("D_380/%d/%d",*pnStopNodeCount1,pItem->nCount);
			}
			*/
			*pnStopNodeCount1 = pItem->nCount;
			*pnStopNodeCount2 = pItem->nCount;
			//ADD_LOG("D_381/%d/%d",*pnStopNodeCount1,pItem->nCount);
		}
    }

//  ADD_LOG("D_382/%d/%d", *pnStopNodeCount1, *pnStopNodeCount2);

    return  bCmdExist;

}





// 속도 프로파일 생성 함수
bool DrivingControl::getAxisCmdInfo(DRIVING_INFO_SET *pInfoSet, CTRL_INFO_OF_SYNC_AXIS_MOVE* pCtrlInfo)
{

	bool    bCmdExist = false;          // 명령이 있다
    bool    bLowSpeed = false;          // 직진부 전후로 조향이 다른 경우
    bool    bOutInNode = false;     // Node 전후로 조향이 다른 경우
    bool    bIsToTarget = false;
    bool    bNextPathExist = false; // 명령 나간 Node 이후 Path 존재 여부 확인, 마지막 Node까지 명령이 나갔다
    int     nKeyNodeCount = 0;
    int     nResultNodeCount = 0;
    int     nCheckPointOfPosition = 0;  // 이동 거리가 산출된 곳을 확인하기 위한 변수, 실제로 사용되는 곳 없음

	int     nCurrNodeCount = pInfoSet->HwInfo.Node.nNodeCount;
	int     nCurrPreNodeCount = pInfoSet->HwInfo.Node.nPreCheckCount;

	//대차센서가 Off이므로 주행 명령 안줌.
	if(m_pOHTDetect->CheckSensorOff() == true)
	{
		return bCmdExist;
	}
	if(m_cSlopeNodeInfo == SLOPE_NTYPE &&( pHWSet->GetAMCPauseStatus() == STATUS_OBS_STOP || pHWSet->GetAMCPauseStatus() == STATUS_PBS_STOP || pHWSet->GetAMCPauseStatus() == STATUS_OHT_PAUSED))
	{
#if((OHT_NAME == OHT_NAME_STD_V82)|| (OHT_NAME == OHT_NAME_STD_V85S)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
		ADD_LOG("getAxisCmdInfo()-2 / SLOPE_NTYPE / GetAMCPauseStatus() : %d", pHWSet->GetAMCPauseStatus());
#else
		ADD_LOG("getAxisCmdInfo()-2 / SLOPE_NTYPE / GetAMCPauseStatus() : %d, IsSetInnerLimitTorque_800():%d ", pHWSet->GetAMCPauseStatus(),m_pServoControl->IsSetInnerLimitTorque_800());
#endif
		return bCmdExist;
	}

	if(pInfoSet->EventAndState.Event.TargetChanged == true)
	{
//		memset(&pInfoSet->Position.CmdRefInfo, 0x00, sizeof(DRIVING_CTRL_REFERENCE));
//		pInfoSet->Position.CmdRefInfo.nCount =nCurrNodeCount;
//		pInfoSet->Position.CmdRefInfo.nKeyCount =nCurrNodeCount;


//		pInfoSet->EventAndState.Event.TargetChanged  = false;

//		ADD_LOG("D_383/%d", nCurrNodeCount);

	}


    int nPreCheckCount = ((pInfoSet->HwInfo.Node.nPreCheckCount-pInfoSet->HwInfo.Node.nNodeCount)>1)
                            ?(pInfoSet->HwInfo.Node.nNodeCount+1)
							:(pInfoSet->HwInfo.Node.nPreCheckCount);

    //  DRIVING_CMD_INFO_OF_PATH* pPathInfo = getPathInfo(pInfoSet->HwInfo.Node.nNodeCount);
    DRIVING_CMD_INFO_OF_PATH* pPathInfo = getPathInfo(pInfoSet->Position.CmdRefInfo.nCount);
    if(pPathInfo!=NULL)bNextPathExist=true;

    if( (nPreCheckCount==0)
    &&  (pInfoSet->Position.bPreCheckIsOverFirstNode==true)
    )
    {
		nPreCheckCount=1;
    }


    int     nCmdTargetNodeCount = pInfoSet->Position.CmdRefInfo.nCount;

    double dCurrPos = pInfoSet->HwInfo.Axis1.dCurrPos;

    double  dSafetySpeedLimit = m_pParamSet->Axis.Limit.Speed.MaxValue; // 초기화(최대값)
    double  dSpeedLimit= 0.0;
	double  dSpeedResult= 0.0;
    int     nNodeCountBySpeed = 0;
    double  dTmpSpeedLimit = 0.0;

	STEER_HW_INFO_POSITION  CurrTotalSteerPos;
	STEER_HW_INFO_POSITION  TmepCurrTotalSteerPos;
    int     anNodeCountBySteer[2] = {0,};

    bool bSpeedDownPassed   = pInfoSet->EventAndState.State.SpeedDownPassed;
    double dCurrSpeed       = pInfoSet->HwInfo.Axis1.dSpeed;
    double dCurrCmdSpeed    = pInfoSet->Position.CmdRefInfo.dCmdSpeed;
	double dNextPathSpeed;
	if(pPathInfo!=NULL)
	{
		dNextPathSpeed   = (bNextPathExist==true)?pPathInfo->dSpeed:0.0; // 명령 받은 Node 다음 Path의 속도
	}
    double dTmpdist = 0.0;
    double dTmpPosition = 0.0;
    double dPreCmdPosition = pInfoSet->Position.CmdRefInfo.dDist;
	double dSmoothSpeed = 0.0;
    DRIVING_CMD_INFO_OF_NODE* pNodeInfo = NULL;

    STEER_HW_INFO_CMD TmpSteerCmdForNext;   // Front 조향 변경 시 300mm 더가는 것 학인 목적
    bool bNeedNextSteer;            // Front 조향 변경 시 300mm 더가는 것 학인 목적

	double dMarginBeforeFinalNode = 0.0;


#if(UBG_SENSOR_ENABLE == ON)
	bool sStopWithNoReason  =   (   pInfoSet->HwInfo.IO.Axis1Running==false
                                    &&  pInfoSet->HwInfo.IO.DetectStatus==0
                                    &&  pInfoSet->HwInfo.IO.ObsStatus==0)
                                    ?true:false;
#else
	bool sStopWithNoReason  =   (   pInfoSet->HwInfo.IO.Axis1Running==false
									&& pInfoSet->HwInfo.IO.ObsStatus==0)
									?true:false;
#endif

	double  dTmpAccel = m_pParamSet->Axis.Default.dDefaultAccel;
    double  dTmpDecel = m_pParamSet->Axis.Default.dDefaultDecel;

    //1 Node Count 시작 위치 설정
    // SpeedDown 통과 시
    if(bSpeedDownPassed==true)
	{

		// 다음 속도가 적을 경우: 다음 명령 수행
		if(dNextPathSpeed<getPathInfo(pInfoSet->HwInfo.Node.nNodeCount)->dSpeed) // -> 현재 map speed와 비교
		{
			nKeyNodeCount = nCmdTargetNodeCount;
			pInfoSet->Position.CmdRefInfo.nKeyCount = nCmdTargetNodeCount;
		}
		// 다음 속도가 크거나 같은 경우: 일반 처리
		else
		{
			nKeyNodeCount = nPreCheckCount;
		}

		/*
		// 다음 속도가 적을 경우: 다음 명령 수행
		if(dNextPathSpeed<dCurrCmdSpeed)
		{
			nKeyNodeCount = nCmdTargetNodeCount;
			pInfoSet->Position.CmdRefInfo.nKeyCount = nCmdTargetNodeCount;
		}
		// 다음 속도가 크거나 같은 경우: 일반 처리
		else
		{
			nKeyNodeCount = nPreCheckCount;
		}

		*/
    }
    // SpeedDown 미통과 시: 일반 처리
    else
    {
        nKeyNodeCount = nPreCheckCount;
	}


    // 감속 중일 때, 적정 속도 확보
    if(nKeyNodeCount < pInfoSet->Position.CmdRefInfo.nKeyCount) // 감속 위치를 한번이라도 지나면 나타나는 현상
    {
        nKeyNodeCount = pInfoSet->Position.CmdRefInfo.nKeyCount;
        // 안전 속도 확보
        if(bNextPathExist==true)// 명령 준 Node 넘어로 Path 가 더 남아 있는 경우
        {
            dSafetySpeedLimit = MIN(dCurrCmdSpeed, dNextPathSpeed);
        }
        else    // 명령 준 Node 넘어로 남아있는 Path 가 없는 경우 , 명령 준 Node 가 마지막인 경우 마지막 명령 준 속도를 리밋으로 한다.
        {
            dSafetySpeedLimit = dCurrCmdSpeed;
        }
    }



    //1  명령 기준 정보 획득
    //2 속도 변화에 따른 정보 획득(Node Count, 속도, 거리) : OutLine
    bCmdExist = getAxisCmdInfoBySpeed(nKeyNodeCount, &dSpeedLimit, &nNodeCountBySpeed);

    dSpeedLimit = MIN(dSafetySpeedLimit, dSpeedLimit);// 저속 중 Node 만나서 가속 경우 : 노드 만나기 전까지  빠른 가속 방지

//	ADD_LOG("D_384/%d/%d/%d",nKeyNodeCount, bCmdExist, nNodeCountBySpeed);

    //2 Steer에 따른 정보 획득(Node Count, 속도, 거리) : --> 감속 거리
    if(bCmdExist==true)
    {
        CurrTotalSteerPos = getSteerTotalPosition(    pInfoSet->HwInfo.IO.SteerFrontLeftInOn
                                                    , pInfoSet->HwInfo.IO.SteerFrontRightInOn
                                                    , pInfoSet->HwInfo.IO.SteerRearLeftInOn
													, pInfoSet->HwInfo.IO.SteerRearRightInOn);

		TmepCurrTotalSteerPos = CurrTotalSteerPos; //puting 20170220

        switch(CurrTotalSteerPos)
        {
        case STEER_HW_INFO_POSITION_NONE:
            break;
        case STEER_HW_INFO_POSITION_LEFT:
            if( (pInfoSet->Steer.FrontCmdDirection!=DRIVING_IO_STEER_DIRECTION_CMD_LEFT)
            ||  (pInfoSet->Time.Steer.FrontSteeringArrived.bFlag==false)
            ||  (pInfoSet->Time.Steer.RearSteeringArrived.bFlag==false)
            )
			{
//				ADD_LOG("D_385/%d/%d/%d",pInfoSet->Steer.FrontCmdDirection,pInfoSet->Time.Steer.FrontSteeringArrived.bFlag,pInfoSet->Time.Steer.RearSteeringArrived.bFlag);
                CurrTotalSteerPos = STEER_HW_INFO_POSITION_NONE;
            }
            break;
		case STEER_HW_INFO_POSITION_RIGHT:
            if( (pInfoSet->Steer.FrontCmdDirection!=DRIVING_IO_STEER_DIRECTION_CMD_RIGHT)
            ||  (pInfoSet->Time.Steer.FrontSteeringArrived.bFlag==false)
			||  (pInfoSet->Time.Steer.RearSteeringArrived.bFlag==false)
            )
			{
//				ADD_LOG("D_386/%d/%d/%d",pInfoSet->Steer.FrontCmdDirection,pInfoSet->Time.Steer.FrontSteeringArrived.bFlag,pInfoSet->Time.Steer.RearSteeringArrived.bFlag);
                CurrTotalSteerPos = STEER_HW_INFO_POSITION_NONE;
            }
            break;
        case STEER_HW_INFO_POSITION_BOTH:
            break;
		}
		bCmdExist = getAxisCmdInfoBySteer(nKeyNodeCount, CurrTotalSteerPos, anNodeCountBySteer, (anNodeCountBySteer+1),TmepCurrTotalSteerPos);
        if(bCmdExist==true && anNodeCountBySteer[0]==anNodeCountBySteer[1])
        {
            bOutInNode = true;
        }

	}



    //2 Node Count 결과 확인
    if(bCmdExist==true)
    {
		// Node Count 획득


		if(anNodeCountBySteer[0]<=nKeyNodeCount)
		{
            nResultNodeCount = MIN(anNodeCountBySteer[1],nNodeCountBySpeed);
            bLowSpeed = ((bOutInNode!=false)&&(anNodeCountBySteer[1]<=nNodeCountBySpeed))?true:false;
//          bLowSpeed = false;
        }
        else if(anNodeCountBySteer[0]<=nNodeCountBySpeed)
        {
            dTmpSpeedLimit = MAX(dSpeedLimit, (m_pParamSet->Axis.Limit.Speed.MinValue));
            if( (anNodeCountBySteer[1]<=nNodeCountBySpeed)
            &&  ((getDist(anNodeCountBySteer[0], anNodeCountBySteer[1])/dTmpSpeedLimit)
                >(m_pParamSet->Steer.dwChangeTime+m_pParamSet->Steer.dwCompleteCheckTime))
            )
            {
                nResultNodeCount = anNodeCountBySteer[1];
            }
            else if(    (anNodeCountBySteer[1]>nNodeCountBySpeed)
            &&  ((getDist(anNodeCountBySteer[0], nNodeCountBySpeed)/dTmpSpeedLimit)
                >(m_pParamSet->Steer.dwChangeTime+m_pParamSet->Steer.dwCompleteCheckTime))
            )
            {
                nResultNodeCount = nNodeCountBySpeed;
            }
            else
            {
                nResultNodeCount = anNodeCountBySteer[0];
            }
        }
        else
        {
            nResultNodeCount = nNodeCountBySpeed;
            bOutInNode = false;
        }

        // Node Count 가 명령 나간 지점 보다 적어지면 명령 나간 곳으로 명령(PreCheck 지점 에서 조향 변경 중)
		if(nResultNodeCount<nCmdTargetNodeCount)
        {
            //bCmdExist=false;
            nResultNodeCount=nCmdTargetNodeCount;
        }
    }

//	ADD_LOG("D_387/%d/%f",nResultNodeCount, nCmdTargetNodeCount);

    //2 Data 결과 처리
    if(bCmdExist==true)
	{
		if((nResultNodeCount == nCurrNodeCount) && (isSteerChangeAreaByGuideNodeCountAdd()==true))
		{
			nResultNodeCount++;
			ADD_LOG("D-193");
		}

		pNodeInfo = getNodeInfo(nResultNodeCount);
        if(pNodeInfo!=NULL)
		{
			dTmpPosition = getRealPos(pNodeInfo->dDistSum);
            nCheckPointOfPosition = 0;

			//1 속도 사다리꼴화
			if(pInfoSet->EventAndState.Event.TargetChanged == true)
			{
				dSpeedResult = MIN(dSpeedLimit,
									getMaxSpeed(   m_pParamSet->Axis.Default.dDefaultAccel
														,m_pParamSet->Axis.Default.dDefaultDecel
														,(dTmpPosition-pInfoSet->HwInfo.Axis1.dCurrPos))
									);

				ADD_LOG("D_388/%f/%f/%d",dSpeedResult,dSpeedLimit,nResultNodeCount);
			}else
			{
				dSpeedResult = MIN(dSpeedLimit,
									getMaxSpeed(   m_pParamSet->Axis.Default.dDefaultAccel
										,m_pParamSet->Axis.Default.dDefaultDecel
										,(dTmpPosition-pInfoSet->HwInfo.Axis1.dCurrPos),pInfoSet->HwInfo.Axis1.dSpeed ,dSpeedLimit)
					);
            }

			ADD_LOG("D_389/%d/%d/%d/%d/%d/%f/%f/%f/%d"
			,CurrTotalSteerPos, nKeyNodeCount, anNodeCountBySteer[0],anNodeCountBySteer[1],nNodeCountBySpeed,
			dTmpPosition,pNodeInfo->dDistSum,pInfoSet->HwInfo.Axis1.dCurrPos,nResultNodeCount);

			//1 거리 구하기
            if(pNodeInfo->nCount==m_ClassifiedCmd.TargetInfo.nCount)
            {
                bIsToTarget = true;
				switch(m_ClassifiedCmd.TargetInfo.Type)
                {
                case MARK_TYPE_NODE:
					dMarginBeforeFinalNode = (nResultNodeCount==nCurrNodeCount)?DIST_MARGIN_TO_NODE_TO_CONPENSATE_SLIP_200:DIST_MARGIN_TO_NODE_TO_CONPENSATE_SLIP_200;  // 타겟 도착하기 전이면 이 값을 빼서 이동, 최종 Node 지나서 정확한 위치로 보냄
					dTmpPosition    =(dTmpPosition-dMarginBeforeFinalNode);
                    nCheckPointOfPosition = 1;
                    break;

				case MARK_TYPE_TAG_STATION:
					dMarginBeforeFinalNode = (nResultNodeCount==nCurrNodeCount)?DIST_MARGIN_TO_NODE_TO_CONPENSATE_SLIP_200:DIST_MARGIN_TO_NODE_TO_CONPENSATE_SLIP_200; // 타겟 도착하기 전이면 이 값을 빼서 이동, 최종 Node 지나서 정확한 위치로 보냄
                    dTmpPosition    =(dTmpPosition-dMarginBeforeFinalNode-m_ClassifiedCmd.TargetInfo.dLength+m_ClassifiedCmd.TargetInfo.dOffset);
                    nCheckPointOfPosition = 2;
					break;

                case MARK_TYPE_QR_STATION_LEFT:
                case MARK_TYPE_QR_STATION_RIGHT:
				case MARK_TYPE_QR_LEFT_TOP:
				case MARK_TYPE_QR_LEFT_BOTTOM:
				case MARK_TYPE_QR_RIGHT_TOP:
				case MARK_TYPE_QR_RIGHT_BOTTOM:
				case MARK_TYPE_QR_LEFT_BOTTOM_S:
				case MARK_TYPE_QR_RIGHT_BOTTOM_S:
				case MARK_TYPE_QR_PSTB_LEFT:
				case MARK_TYPE_QR_PSTB_RIGHT:
					dMarginBeforeFinalNode = (nResultNodeCount==nCurrNodeCount)?DIST_MARGIN_TO_NODE_TO_CONPENSATE_SLIP_200:DIST_MARGIN_TO_NODE_TO_CONPENSATE_SLIP_200;  // 타겟 도착하기 전이면 이 값을 빼서 이동, 최종 Node 지나서 정확한 위치로 보냄
                    dTmpPosition    =(dTmpPosition-dMarginBeforeFinalNode-m_ClassifiedCmd.TargetInfo.dLength+m_ClassifiedCmd.TargetInfo.dOffset);
                    nCheckPointOfPosition = 3;
                    break;

                }
            }
			else
			{

                if(pInfoSet->EventAndState.State.SteerFrontCompleted==true)
                {
                    pPathInfo = getPathInfo(nResultNodeCount);
                    if(pPathInfo!=NULL)
                    {

                        bNeedNextSteer = getSteerCmdTypeFrom(pPathInfo->Steering, &TmpSteerCmdForNext);

                        if( (m_ClassifiedCmd.TargetInfo.Type!=MARK_TYPE_NODE)
                        &&  (pNodeInfo->nCount==m_ClassifiedCmd.TargetInfo.nCount-1))
                        {
							if(pInfoSet->HwInfo.IO.SteerFrontDirCmd==TmpSteerCmdForNext)
                            {
								if((pNodeInfo->nCount>0)
                                && (nCurrPreNodeCount==pNodeInfo->nCount)
								&& (pInfoSet->HwInfo.Node.dPreCheckPosition>0.0)
                                )
                                {
                                    if(m_ClassifiedCmd.TargetInfo.dOffset<m_pParamSet->Mark[0].Dist.dLengthOfSecond)
                                    {
                                        dTmpPosition=pInfoSet->HwInfo.Node.dPreCheckPosition+m_pParamSet->Mark[0].Dist.dAddDistAfetrFirstMet;
                                        nCheckPointOfPosition = 4;
                                        if(sStopWithNoReason==true)
                                        {
                                            dTmpPosition = MAX(dCurrPos+1.0, dTmpPosition);
											nCheckPointOfPosition = 5;
                                        }
									}
                                    else
                                    {
                                        dTmpPosition=pInfoSet->HwInfo.Node.dPreCheckPosition+m_pParamSet->Mark[0].Dist.dDistFromFirstToSecond;
                                        nCheckPointOfPosition = 6;
                                    }

                                }
                                else
                                {
                                    if(pNodeInfo->nCount>0)
									{
										if(pInfoSet->HwInfo.Node.nNodeCount==0)
											dTmpPosition=dTmpPosition+30;
										else
											dTmpPosition=dTmpPosition-DIST_MARGIN_TO_NODE_TO_CONPENSATE_SLIP;//1    문제 발생 가능성 있음 //+40;

										nCheckPointOfPosition = 7;
									}
								}
							}
							else
							{
								if(pInfoSet->HwInfo.Node.nNodeCount==0)
									dTmpPosition = dTmpPosition+30;//-DIST_MARGIN_TO_NODE_TO_CONPENSATE_SLIP;
								else
									dTmpPosition=dTmpPosition - DIST_MARGIN_TO_NODE_TO_CONPENSATE_SLIP;
								nCheckPointOfPosition = 8;
							}
						}
						else if(    (bNeedNextSteer==false)
						||          (pInfoSet->HwInfo.IO.SteerFrontDirCmd==TmpSteerCmdForNext))
                        {
                            if( (nPreCheckCount!=nKeyNodeCount) // SpeedDown지났거나
                            ||  (bOutInNode==true)
//                          ||  (   (nCurrNodeCount<nKeyNodeCount)
//                              &&  (pInfoSet->Position.CmdRefInfo.dRefSpeed<=dSpeedLimit)// 이전 속도가 빠르고
//                              &&  (dCurrSpeed<(dSpeedLimit+m_pParamSet->Axis.Default.dDefaultDecel*16)))// 현재 속도가 다음 속도보다 빠르고: 16ms(Thread 1주기)
                            )
                            {
                                dTmpPosition=dTmpPosition+50;//300;
                                nCheckPointOfPosition = 9;
                            }
                            else
                            {
                                dTmpPosition=dTmpPosition + 50;//+300-DIST_MARGIN_TO_NODE_TO_CONPENSATE_SLIP;
                                nCheckPointOfPosition = 10;
                            }
                        }
                        else
                        {
                            // 여기로 들어오는 케이스 없음
                            dTmpPosition    =dTmpPosition + 50;//-DIST_MARGIN_TO_NODE_TO_CONPENSATE_SLIP;
                            nCheckPointOfPosition = 11;
                        }
                    }

//					ADD_LOG("D_390/%f/%f/%f",dSpeedLimit,dSpeedResult,pPathInfo->dSpeed);
					pPathInfo = getPathInfo(nPreCheckCount);
					if(pPathInfo!=NULL)
					{
						dSpeedLimit = MIN(dSpeedLimit, dSpeedResult);
						dSpeedLimit = MIN(dSpeedResult, pPathInfo->dSpeed);
                        if(bOutInNode==true)
                        {
                            if(nCurrPreNodeCount==pNodeInfo->nCount)
                            {
                                dSpeedLimit = MIN(dSpeedResult, SPEED_OF_OUT_IN_NODE);
                            }
                        }
                    }
                }
                else
                {
                    if(bOutInNode==true)
                    {
                        if(nCurrPreNodeCount<pNodeInfo->nCount)
                        {
							dTmpPosition=(bSpeedDownPassed==true)?MAX(dPreCmdPosition,(dTmpPosition-100)):(dTmpPosition-100);
							nCheckPointOfPosition =12;
                        }
                        else if(nCurrPreNodeCount==pNodeInfo->nCount)
						{
//							dTmpPosition= (bSpeedDownPassed==true)?MAX(dPreCmdPosition,(dTmpPosition-50)):(dTmpPosition-50);
							dTmpPosition= (bSpeedDownPassed==true)?MAX(dPreCmdPosition,(dTmpPosition+50)):(dTmpPosition+50);
							nCheckPointOfPosition = 13;
							dSpeedLimit = MIN(SPEED_OF_OUT_IN_NODE,dSpeedResult);
                        }
                    }
                    else
                    {
						if( (m_ClassifiedCmd.TargetInfo.Type!=MARK_TYPE_NODE)
						&&  (pNodeInfo->nCount >=m_ClassifiedCmd.TargetInfo.nCount-1))
						{
							 dTmpPosition    =   (bSpeedDownPassed==true)
											?   MAX(dPreCmdPosition,(dTmpPosition-DIST_MARGIN_TO_NODE_TO_CONPENSATE_SLIP))
											:   (dTmpPosition-DIST_MARGIN_TO_NODE_TO_CONPENSATE_SLIP);
						}else
						{
							 dTmpPosition    =   (bSpeedDownPassed==true)
											?   MAX(dPreCmdPosition,(dTmpPosition+50))//-DIST_MARGIN_TO_NODE_TO_CONPENSATE_SLIP))
											:   (dTmpPosition+50);//-DIST_MARGIN_TO_NODE_TO_CONPENSATE_SLIP);
                        }
						nCheckPointOfPosition = 14;
					}
				}
			}

//			ADD_LOG("D_391/%d",nCheckPointOfPosition);

            //1 조향 사이 Normal Path 이동 부드럽게
			dTmpAccel   = (m_pParamSet->Axis.Default.dDefaultAccel)
						/ (getAccelDivisor(nCurrPreNodeCount));
			dTmpDecel   = (bIsToTarget)?(m_pParamSet->Axis.Default.dDefaultDecel*2/3)
						:(m_pParamSet->Axis.Default.dDefaultDecel
						/getDecelDivisor(MAX(nCurrNodeCount,(nResultNodeCount-1))));
		   /*
			// Lifter 구간에서 가속도 수정 하드코딩 by jhoun.lim (18.03.15)
			   DRIVING_CMD_INFO_OF_NODE* pNodeInfo = getNodeInfo(pInfoSet->HwInfo.Node.nNodeCount); // 현재 부모 node
			   if(((pNodeInfo->NodeType >= LIFTIN_NTYPE_LEFT) && (pNodeInfo->NodeType <= LIFTOUT_NTYPE)))
			   {
			   dTmpAccel = 0.0027;

			   ADD_LOG("D_392/%6.4lf/%6.4lf", dTmpAccel, dTmpDecel);
			   }
           */


			// 가속도 변경에 의한 고속 커브 진입 방지
            if( (pInfoSet->Position.CmdRefInfo.dRefSpeed>=dSpeedLimit)// 이전 속도가 빠르고
            &&  (pInfoSet->Position.CmdRefInfo.dCmdDecel>dTmpDecel)// 이전 감속도가 크고
			&&  (dCurrSpeed>(dSpeedLimit+m_pParamSet->Axis.Default.dDefaultDecel*16))// 현재 속도가 다음 속도보다 빠르고: 16ms(Thread 1주기)
			&&  (nCurrNodeCount<nKeyNodeCount)// 노드 카운트가 키 노드 카운트를 지나지 않았을 경우
            )
            {
				dTmpDecel = pInfoSet->Position.CmdRefInfo.dCmdDecel;
            }


//			dSpeedResult = MIN(dSpeedLimit,(DRIVING_SPEED_SMOOTHING_FACTOR
//												*getMaxSpeed(dTmpAccel ,dTmpDecel ,(dTmpPosition - pInfoSet->HwInfo.Axis1.dCurrPos))));
//

			if(pInfoSet->EventAndState.Event.TargetChanged == true)
			{
				dSpeedResult = MIN(dSpeedLimit, getMaxSpeed(dTmpAccel ,dTmpDecel ,(dTmpPosition - pInfoSet->HwInfo.Axis1.dCurrPos)));


			}else
			{
				dSpeedResult = MIN(dSpeedLimit,getMaxSpeed(dTmpAccel ,dTmpDecel ,(dTmpPosition - pInfoSet->HwInfo.Axis1.dCurrPos),pInfoSet->HwInfo.Axis1.dSpeed ,dSpeedLimit));


			}

			if(bLowSpeed)
            {
				// 마지막이 아니거나, 마지막인데 Path 중간의 Node 인 경우
				if(     (m_ClassifiedCmd.TargetInfo.nCount!=pNodeInfo->nCount)
					&&  ((m_ClassifiedCmd.TargetInfo.nCount==pNodeInfo->nCount)
                            &&(m_ClassifiedCmd.TargetInfo.Type==MARK_TYPE_NODE)
							&&(pNodeInfo->Type!=NORMAL_POINT))
                )
                {
                    dTmpdist = getDist(anNodeCountBySteer[0], nResultNodeCount);
                    dSmoothSpeed = getSmoothSpeed(dTmpDecel, dTmpdist, m_pParamSet->Steer.dwChangeTime);
					dSpeedResult = MIN(dSmoothSpeed, dSpeedResult);
                    dSpeedResult = MIN(dSmoothSpeed, dSpeedLimit);
                }
			}
//          else
//          {
//              dSpeedResult = MIN(dSpeedLimit,(DRIVING_SPEED_SMOOTHING_FACTOR
//                                                  *getMaxSpeed(   dTmpAccel ,dTmpDecel ,(dTmpPosition-pInfoSet->HwInfo.Axis1.dCurrPos))));
//          }


            //2 속도 이전과 비교 처리: 사다리꼴 모양 만들기 --> 후반부 감속 처리 제거 및 초기 튐 제거
            if( (pInfoSet->Position.CmdRefInfo.nCount!=0)
            &&  (pInfoSet->Position.CmdRefInfo.nCount==nResultNodeCount)
            &&  (pInfoSet->Position.CmdRefInfo.dCmdSpeed>dSpeedResult)
            &&  (bSpeedDownPassed==false)
//          &&  (dSpeedResult>1.0)
//          &&  (nCurrPreNodeCount<nResultNodeCount)
            )
            {
                if( (bNextPathExist==true)              // 다음 경로가 있고
                &&  (dNextPathSpeed<dSpeedLimit)        // 다음 경로 기준 속도가 현재 경로 기준 속도보다 느리고
                &&  (dNextPathSpeed>dSpeedResult)   // 다음 경로 속도가 현재 결과 속도보다 큰 경우
                )
                {
                    dSpeedResult = dNextPathSpeed;
                }
                else
                {
                    if(nCurrPreNodeCount<nResultNodeCount)
                    {
                        dSpeedResult = pInfoSet->Position.CmdRefInfo.dCmdSpeed;
                    }
                }
			}

            //2 속도 Min Max 처리
            dSpeedResult = MAX(dSpeedResult, (m_pParamSet->Axis.Limit.Speed.MinValue));
            dSpeedResult = MIN(dSpeedResult, (m_pParamSet->Axis.Limit.Speed.MaxValue));

            //2 시작 시 뒤로 이동 방지 처리
//          dTmpPosition = MAX(dCurrPos+1.0, dTmpPosition); // 뒤로 이동 방지
			dTmpPosition = MAX(dCurrPos, dTmpPosition); // 뒤로 이동 방지
            dTmpPosition = MAX(0.0, dTmpPosition);
		   //	ADD_LOG("D_393/%f/%f/%f/%f/%f/%f",dTmpPosition,dCurrPos,dTmpAccel,dTmpDecel,dSpeedResult,dSmoothSpeed);
            memset(pCtrlInfo, 0x00, sizeof(CTRL_INFO_OF_SYNC_AXIS_MOVE));

			if(dTmpPosition < RUN_TO_MARK_MINDIST)
				dSpeedResult = MIN(dSpeedResult,RUN_TO_MARK_MINSPEED);

			//AMC<->Main 감속도 동기화(1 기준값 확인)
			if(pHWSet->GetAMCDecelStatus() >= AMCDECEL_VHLDETECT)
			  //(pInfoSet->EventAndState.State.MarkArea ==false))//3.5m/s 감속도 일 경우
			{
			     //1) 최초 AMC 근접제어 감속도가 온 경우,
				if(m_dCheckAMCDecelPosition == 0.0)
				{
					m_dCheckAMCDecelPosition = m_dPreTargetPosition;    	//m_pDrivingAxis->GetFinalPosition()  //출발시 이슈가 있으므로 VHL Main이 저장함.
                	ADD_LOG("D_394/%d/%f",pHWSet->GetAMCDecelStatus(),m_dPreTargetPosition);
				}

                //2) 작업변경에 의해 타겟이 기존보다 짧아진 경우
				if((pInfoSet->EventAndState.Event.TargetChanged ==true) && (dTmpPosition < m_dCheckAMCDecelPosition))
				{
					m_dCheckAMCDecelPosition =  dTmpPosition;
					ADD_LOG("D_395/%d/%f",pHWSet->GetAMCDecelStatus(),m_dPreTargetPosition);
				}

				//3) AMC 근접제어에 의해 감속호고 있는 기존구간을 넘어간 경우
				if(pInfoSet->HwInfo.Axis1.dCurrPos > m_dCheckAMCDecelPosition)
				{
					m_dCheckAMCDecelPosition = m_dPreTargetPosition;
					ADD_LOG("D_396/%d/%f",pHWSet->GetAMCDecelStatus(),m_dPreTargetPosition);
				}

			}
			else
				m_dCheckAMCDecelPosition = 0.0;

			//AMC<->Main 감속도 동기화(2 거리 비교 및 적용 유무 판단)
			if(m_dCheckAMCDecelPosition !=0.0)
			{
			  //pInfoSet->HwInfo.Axis1.dSpeed    현재 속도
			  //pInfoSet->HwInfo.Axis1.dCurrPos  현재 위치
				double dTempMargin = 200 * m_pParamSet->Axis.Limit.Speed.MaxValue; // 200 = AMC Delay Margin
				double dTempLowSpeedMargin = (DEFAULT_EMERGENCY_MIN_SPEED*DEFAULT_EMERGENCY_MIN_SPEED)/(2*dTmpDecel); //최저 속도 감속 Margin

				double dTempDis = m_dCheckAMCDecelPosition - pInfoSet->HwInfo.Axis1.dCurrPos; //남은 거리
				double dCurrentDecelDis = (pInfoSet->HwInfo.Axis1.dSpeed * pInfoSet->HwInfo.Axis1.dSpeed)/(2*dTmpDecel) + dTempMargin + dTempLowSpeedMargin;

				if(m_dCheckAMCDecelPosition - pInfoSet->HwInfo.Axis1.dCurrPos > 0.0)
				{

					ADD_LOG("D_397/%f/%f/%f/%f/%f",dTempDis,dCurrentDecelDis,m_dCheckAMCDecelPosition,pInfoSet->HwInfo.Axis1.dCurrPos,pInfoSet->HwInfo.Axis1.dSpeed);
					if(dTempDis - dCurrentDecelDis < 0.0)
					{
#if((OHT_NAME == OHT_NAME_STD_V80) ||(OHT_NAME == OHT_NAME_STD_V81) || (OHT_NAME == OHT_NAME_STD_V81S)  ||(OHT_NAME == OHT_NAME_STD_V85)|| (OHT_NAME == OHT_NAME_STD_V80_RETICLE))
						dTmpDecel = DEFAULT_EMERGENCY_DECEL;  // 최영재 프로 확인 필요.
#else
						dTmpDecel = OHTDETECT_EMERGENCY_DECEL;  //V8.2 E1033 대응,
#endif
					}
					else
						m_dCheckAMCDecelPosition = 0.0;
				}
				else
				{
					ADD_LOG("D_398/%f/%f/%f/%f/%f",dTempDis,dCurrentDecelDis,m_dCheckAMCDecelPosition,pInfoSet->HwInfo.Axis1.dCurrPos,pInfoSet->HwInfo.Axis1.dSpeed);
					//하기 조건은 만족할수 없음.
					/*
					double dTempDis = dTmpPosition - pInfoSet->HwInfo.Axis1.dCurrPos; //남은 거리
					double dCurrentDecelDis = (pInfoSet->HwInfo.Axis1.dSpeed * pInfoSet->HwInfo.Axis1.dSpeed)/(2*dTmpDecel);

					if(dTempDis - dCurrentDecelDis < 0.0)
					{
						dTmpDecel = DEFAULT_EMERGENCY_DECEL;
					}
					else
						m_dCheckAMCDecelPosition = 0.0;
					*/

					m_dCheckAMCDecelPosition = 0.0;
			   	}
			 //
			}

			pCtrlInfo->byType=AXIS_CTRL_CMD_MOVE_DS;
//          memset(&(pCtrlInfo->Dynamic.AdditionalInfo),0,sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
            pCtrlInfo->Dynamic.dAccel       = dTmpAccel;
			pCtrlInfo->Dynamic.dDecel       = dTmpDecel;
            pCtrlInfo->Dynamic.dSpeed       = dSpeedResult;
			pCtrlInfo->Dynamic.dDist        = dTmpPosition;


            pInfoSet->Position.CmdRefInfo.dCmdSpeed     = dSpeedResult;
            pInfoSet->Position.CmdRefInfo.dRefSpeed     = dSpeedLimit;
            pInfoSet->Position.CmdRefInfo.dCmdDecel     = dTmpDecel;
            pInfoSet->Position.CmdRefInfo.nCount        = nResultNodeCount;
            pInfoSet->Position.CmdRefInfo.dDist         = dTmpPosition;
			pInfoSet->Position.CmdRefInfo.dSpeedDownPos = getSpeedDownPos(dTmpDecel, dSpeedResult ,dTmpPosition);

			m_dPreTargetPosition = dTmpPosition;

        }


	}

	//작업변경 플래그 초기화
	pInfoSet->EventAndState.Event.TargetChanged  = false;

    if(bCmdExist==true)
    {
        ADD_LOG("D_399/%06d/%3d/%3d/%3d/%6.1lf/%8.1lf/%6.1lf/%6.4lf/%6.4lf/%3.1lf/%3.1lf/%3.1lf/%6.1lf/%6.1lf/%6.1lf/%2d/%4X/%d/%6.1lf/%d/%d/%d/%d/%d/%d"
            , pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.uNode
            , pInfoSet->HwInfo.Node.nNodeCount
            , pInfoSet->HwInfo.Node.nPreCheckCount
            , nPreCheckCount
            , pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset
			, pInfoSet->Position.Compensation.dCompensatedPosition
			, pInfoSet->Position.Compensation.dDistErrorSum
            , pCtrlInfo->Dynamic.dAccel, pCtrlInfo->Dynamic.dDecel
            , pCtrlInfo->Dynamic.dSpeed, pInfoSet->HwInfo.Axis1.dSpeed, dSpeedLimit
			, pCtrlInfo->Dynamic.dDist
            , pInfoSet->HwInfo.Axis1.dCurrPos
            , pInfoSet->Position.Compensation.dLinkDistError
            , nCheckPointOfPosition
            , pInfoSet->EventAndState.Event
            , bSpeedDownPassed
            , pInfoSet->Position.CmdRefInfo.dSpeedDownPos
            , nKeyNodeCount
            , nResultNodeCount
            , anNodeCountBySteer[0]
            , anNodeCountBySteer[1]
			, CurrTotalSteerPos
			, nCheckPointOfPosition
            );
    }

    return bCmdExist;
}

// nFromNodeCount ~ nToNodeCount 의 거리를 구한다.
double DrivingControl::getDist(int nFromNodeCount, int nToNodeCount)
{
    double dDist = 0.0;
    DRIVING_CMD_INFO_OF_NODE *pNode[2];

    pNode[0] = getNodeInfo(MIN(nFromNodeCount,nToNodeCount));
    pNode[1] = getNodeInfo(MAX(nFromNodeCount,nToNodeCount));

    if(pNode[0]!=NULL && pNode[1]!=NULL)
    {
        dDist = pNode[1]->dDistSum-pNode[0]->dDistSum;
    }

    return dDist;
}

double DrivingControl::getSmoothSpeed(double dDecel, double dDist, DWORD dwTime)
{
    double  dTmpDecel = fabs(dDecel);
    double  dTmpDist = fabs(dDist);
    DWORD   dwTmpTime = fabs(dwTime);
    double dResult = 0.0;

    dResult = ((-1)*dTmpDecel*dwTmpTime)+sqrt((dTmpDecel*dTmpDecel*dwTmpTime*dwTmpTime)+(2*dTmpDecel*dTmpDist));
	return dResult;
}

double DrivingControl::getMaxSpeed(double dAccel, double dDecel, double dDist, double dCurSpeed, double dTargetSpeed)
{
     double dTmpAccel = fabs(dAccel);
    double dTmpDecel = fabs(dDecel);
    double dTmpDist = fabs(dDist);
    double dResult = 0.0;

    double dynamicVel[3]; // border of accel regions (m/sec)
    dynamicVel[0] = 1.2;
    dynamicVel[1] = 3.3;
    dynamicVel[2] = 5.0;

    double dynamicAcc[3]; // (m/sec^2)
    dynamicAcc[0] = dTmpAccel*1000;
    dynamicAcc[1] = 2;
    dynamicAcc[2] = 1;

    int numArea = 3;

    if((dCurSpeed ==0.0) && (dTargetSpeed == 0.0))
    {
        //dResult = sqrt(2*dTmpDist*((dTmpAccel*dTmpDecel)/(dTmpAccel+dTmpDecel)));
        //dResult = DRIVING_SPEED_SMOOTHING_FACTOR *dResult;
        dResult = calcMaxSpeedDynamic(dCurSpeed, dynamicVel, dynamicAcc, numArea, dTmpDecel*1000, TIME_OF_CONST_VEL, dTmpDist*0.001);
    }
    else
    {
        if(dCurSpeed > (dTargetSpeed*0.95))
        {
            //타겟 속도 적용.
            dResult = dTargetSpeed;
        }
        else
        {
            //상황에 따라 현재속도 대비
            //double dSpeedDownPos = fabs((dCurSpeed*dCurSpeed)/(2*dAccel));   // S=(V^2)/(2*a)
            //dResult = sqrt(2*(dTmpDist+dSpeedDownPos)*((dTmpAccel*dTmpDecel)/(dTmpAccel+dTmpDecel)));
            //dResult = DRIVING_SPEED_SMOOTHING_FACTOR *dResult;
            dResult = calcMaxSpeedDynamic(dCurSpeed, dynamicVel, dynamicAcc, numArea, dTmpDecel*1000, TIME_OF_CONST_VEL, dTmpDist*0.001);
        }
    }

    return dResult;
}

double DrivingControl::getAccelDivisor(int nStartNodeCount)
{
    double dDivisor[2] = {1.0,};
	DRIVING_CMD_INFO_OF_PATH* pPathInfo = getPathInfo(nStartNodeCount);
	DRIVING_CMD_INFO_OF_NODE* pNodeInfo = getNodeInfo(nStartNodeCount);

//	m_Dectect_Dir = pItem->Type & 0x0F;

	if(pPathInfo != NULL)
	{
#if(USE_CHANGENODE == 1)
		if((pPathInfo->UBGRegion == PATH_DIRECTION_NORMAL)
#else
		if(((pPathInfo->Direction & 0x0F) == PATH_DIRECTION_NORMAL)
#endif
		 &&(pPathInfo->Steering == PATH_STEERING_NONE))
		{
			dDivisor[0] = 1.0;
		}
		else
		{
			dDivisor[0] = 1.3;
		}
	}

//	if(pPathInfo!=NULL)
//	{
//		switch(pPathInfo->Direction)
//		{
//		case PATH_DIRECTION_NO_USE:// 미사용: 예전 없음
//			dDivisor[0] = 1.0;
//			break;
//		case PATH_DIRECTION_NORMAL:// 직진 구간: 예전 N
//			if(pPathInfo->dSpeed < 1.3)
//				dDivisor[0] = 1.0;  //0.6
//			else if((pPathInfo->dSpeed >= 1.3) &&(pPathInfo->dSpeed <= 3.3))
//				dDivisor[0] = 1.3;  //1.0
//			else if(pPathInfo->dSpeed > 3.3)
//				dDivisor[0] = 1.6;
//			break;
//		case PATH_DIRECTION_LEFT:// 왼쪽: 예전 L
//		case PATH_DIRECTION_SPECIAL_C_L:
//			dDivisor[0] = 1.0;  //2.0 (D사 기준으로 변경)
//			break;
//		case PATH_DIRECTION_RIGHT:// 오른쪽: 예전 R
//		case PATH_DIRECTION_SPECIAL_C_R:
//			dDivisor[0] = 1.0; //2.0 (D사 기준으로 변경)
//			break;
//		case PATH_DIRECTION_SHORT:// N분기 사용: 예전 S
//		case PATH_DIRECTION_SPECIAL_L:// N분기 사용: 예전 S
//		case PATH_DIRECTION_SPECIAL_R:// N분기 사용: 예전 S
//			dDivisor[0] = 1.0; //2.0 (D사 기준으로 변경)
//			break;
//		case PATH_DIRECTION_BOTH:// 짧은 S자형 곡선: 예전 B
//			dDivisor[0] = 2.0;
//			break;
//		case PATH_DIRECTION_NARROW:// 레일 간격이 900mm 이하일때의 짧은 S자형 곡선: 예전 V
//			dDivisor[0] = 1.0;
//			break;
//		default:
//			dDivisor[0] = 1.0;
//			break;
//		}
//
//		switch(pPathInfo->Steering)
//		{
//		case PATH_STEERING_NONE:// 없음
//			dDivisor[1] = 1.0;
//			break;
//		case PATH_STEERING_LEFT:// 왼쪽
//			dDivisor[1] = 1.0; //2.0 (D사 기준으로 변경)
//			break;
//		case PATH_STEERING_RIGHT:// 오른쪽
//			dDivisor[1] = 1.0;  //2.0 (D사 기준으로 변경)
//			break;
//		case PATH_STEERING_N_BRANCH_L2R:// N분기
//			dDivisor[1] = 1.0;  //2.0 (D사 기준으로 변경)
//			break;
//		case PATH_STEERING_N_BRANCH_R2L:// N분기
//			dDivisor[1] = 1.0;  //2.0 (D사 기준으로 변경)
//            break;
//        default:
//            dDivisor[1] = 1.0;
//            break;
//        }
//
//
//	}

		//경사로 유무 판단하는 부분
	if(pNodeInfo!=NULL)
	{
		if(pNodeInfo->NodeType ==SLOPE_NTYPE)
			dDivisor[1] = 1.4;
	}

    return MAX(dDivisor[0], dDivisor[1]);

}



double DrivingControl::getDecelDivisor(int nStartNodeCount)
{
	double dDivisor[2] = {1.0,};
    DRIVING_CMD_INFO_OF_PATH* pPathInfo = getPathInfo(nStartNodeCount);

    if(pPathInfo!=NULL)
	{
#if(USE_CHANGENODE == 1)
        switch(pPathInfo->UBGRegion)
#else
        switch(pPathInfo->Direction)
#endif
        {
        case PATH_DIRECTION_NO_USE:// 미사용: 예전 없음
            dDivisor[0] = 1.0;
			break;
		case PATH_DIRECTION_NORMAL:// 직진 구간: 예전 N
			if(pPathInfo->dSpeed < 3.0)
				dDivisor[0] = 1.0;  //0.6
			else if(pPathInfo->dSpeed < 4.0)
				dDivisor[0] = 1.3;  //1.0
			else
				dDivisor[0] = 1.6;  //1.0
			break;
		case PATH_DIRECTION_LEFT:// 왼쪽: 예전 L
		case PATH_DIRECTION_SPECIAL_C_L:
            dDivisor[0] = 1.5;
            break;
		case PATH_DIRECTION_RIGHT:// 오른쪽: 예전 R
		case PATH_DIRECTION_SPECIAL_C_R:
            dDivisor[0] = 1.5;
            break;
		case PATH_DIRECTION_SHORT:// N분기 사용: 예전 S
		case PATH_DIRECTION_SPECIAL_L:// N분기 사용: 예전 S
		case PATH_DIRECTION_SPECIAL_R:// N분기 사용: 예전 S
			dDivisor[0] = 1.5;
            break;
		case PATH_DIRECTION_BOTH:// 짧은 S자형 곡선: 예전 B
            dDivisor[0] = 1.5;
            break;
		case PATH_DIRECTION_NARROW: // 레일 간격이 900mm 이하일때의 짧은 S자형 곡선: 예전 V
            dDivisor[0] = 1.0;
            break;
        default:
			dDivisor[0] = 1.0;
            break;
        }

        switch(pPathInfo->Steering)
		{
        case PATH_STEERING_NONE:// 없음
            dDivisor[1] = 1.0;
            break;
        case PATH_STEERING_LEFT:// 왼쪽
            dDivisor[1] = 1.5;
            break;
        case PATH_STEERING_RIGHT:// 오른쪽
            dDivisor[1] = 1.5;
            break;
        case PATH_STEERING_N_BRANCH_L2R:// N분기
            dDivisor[1] = 1.5;
            break;
        case PATH_STEERING_N_BRANCH_R2L:// N분기
            dDivisor[1] = 1.5;
            break;
        default:
            dDivisor[1] = 1.0;
            break;
        }


    }

    return MAX(dDivisor[0], dDivisor[1]);

}

bool DrivingControl::getMarkStatus()
{
    return m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.bMarked;
}


void DrivingControl::setMarkStatusFalse_AutoTeahcing()
{
	m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.bMarked = false;
	m_InfoSet.Position.Mark.PositionStatus.bMarked = false;
}

void DrivingControl::setMarkStatusFalse()
{
	m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uStation = 0;
	m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.bMarked = false;
	m_InfoSet.Position.Mark.PositionStatus.Info.uStation = 0;
	m_InfoSet.Position.Mark.PositionStatus.bMarked = false;
}

/**
@brief   저장된 구조체의 정보를 이용하여 현재 위치 정보를 획득
@author  임태웅
@date    2013.8.29.
@param InfoSet: 구조체 정보
@param pCurrPositionInfo: 위치 정보
@return 현재 위치 정보를 반환
*/
void DrivingControl::getPostionInfoOnRunning(DRIVING_INFO_SET InfoSet, EXECUTE_POSITION_INFO *pCurrPositionInfo)
{
    bool bUpdate = true;
    double dOffset = 0.0;

    EXECUTE_POSITION_INFO PrePositionInfo;
	EXECUTE_POSITION_INFO TempPositionInfo;
    memset(&TempPositionInfo, 0, sizeof(EXECUTE_POSITION_INFO));

	DRIVING_CMD_INFO_OF_NODE* pNodeInfo = getNodeInfo(InfoSet.HwInfo.Node.nNodeCount);
	DRIVING_CMD_INFO_OF_PATH* pPathInfo = getPathInfo(InfoSet.HwInfo.Node.nNodeCount);

	DRIVING_CMD_INFO_OF_NODE* pPreNodeInfo = getNodeInfo(InfoSet.HwInfo.Node.nPreCheckCount);

//  int nNodeDistOffset = (InfoSet.HwInfo.Node.nNodeCount==0)?0:(int)m_pParamSet->Mark[0].Dist.dAddDistAfterSecondMet;

	if(pNodeInfo==NULL)
	{
		ADD_LOG("D_400/%d/%d",InfoSet.HwInfo.Node.nNodeCount, InfoSet.HwInfo.Node.nPreCheckCount);
        return;// bUpdate = false;
    }

    if( (   (InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType==MARK_TYPE_NODE)
        &&  (pNodeInfo->ID==InfoSet.Position.CurrentAndTarget.TargetPosition.uNode))
    ||  (   (InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType!=MARK_TYPE_NODE)
        &&  (pNodeInfo->ID==InfoSet.Position.CurrentAndTarget.TargetPosition.uNextNode))
    )
    {
        bUpdate = false;
	   //	ADD_LOG("D_401/%d/%d", bUpdate, InfoSet.HwInfo.Node.nNodeCount);

		if((InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType==MARK_TYPE_NODE)
		&&  (pNodeInfo->ID==InfoSet.Position.CurrentAndTarget.TargetPosition.uNode))
		{
			if(m_bOnBackMove == false)
			{
				pCurrPositionInfo->CurrNode = pNodeInfo->ID;
				m_pExecuteInfo->ExecutePositionInfo.CurrNode =pNodeInfo->ID;

				pCurrPositionInfo->CurrNodeOffset  = MAX(((int)InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset),0);
			}
		}
	}

    //2 CurrPositionStatus
    if(bUpdate==true)
	{
			//20160520

		if(m_bOnBackMove == false)
		{
			dOffset = MAX(((int)InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset),0);
			pCurrPositionInfo->CurrNode         = pNodeInfo->ID;
			if(pPreNodeInfo==NULL)
				pCurrPositionInfo->CurrPreCheckNode	= pNodeInfo->ID;
			else
				pCurrPositionInfo->CurrPreCheckNode	= pPreNodeInfo->ID;

		}
		else
        {
		   dOffset = InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset;
		   pCurrPositionInfo->CurrNode         = InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode;
        }

        if(InfoSet.EventAndState.State.MarkArea==true)
			pCurrPositionInfo->CurrStation      = InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uStation;
		else
		{
			if(m_pExecuteInfo->FlagOverRunInfo.bCheck ==false)
				pCurrPositionInfo->CurrStation      = 0;
		}

		pCurrPositionInfo->CurrNodeOffset   = (int)dOffset;
//      pCurrPositionInfo->CurrNodeOffset   = (InfoSet.HwInfo.Node.nPreCheckCount!=InfoSet.HwInfo.Node.nNodeCount)
//                                          ? 0:(MAX(((int)InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset-nNodeDistOffset),0));
        pCurrPositionInfo->NextNode         = (pPathInfo!=NULL)?pPathInfo->EndNID:0;
        pCurrPositionInfo->Marked           = InfoSet.Position.CurrentAndTarget.CurrPositionStatus.bMarked;
		pCurrPositionInfo->StationType      = InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.MarkType;

	   //	ADD_LOG("D_402/%d", InfoSet.HwInfo.Node.nPreCheckCount);
	}

    //2 TargetPosition
	pCurrPositionInfo->CurrCommandedNode    = InfoSet.Position.CurrentAndTarget.TargetPosition.uNode;
	pCurrPositionInfo->CurrCommandedStation = InfoSet.Position.CurrentAndTarget.TargetPosition.uStation;

	//3 puting
//	pCurrPositionInfo->dCompensatedPosition = InfoSet.Position.Compensation.dCompensatedPosition;
}

/**
@brief   저장된 구조체의 정보를 이용하여 현재 위치 정보를 획득
@author  임태웅
@date    2013.8.29.
@param InfoSet: 구조체 정보
@param pCurrPositionInfo: 위치 정보
@return 현재 위치 정보를 반환
*/
void DrivingControl::getPostionInfoOnMarked(DRIVING_INFO_SET InfoSet, EXECUTE_POSITION_INFO *pCurrPositionInfo)
{
    bool bOverRun = false;

    if( (   (m_InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType!=MARK_TYPE_NODE)
        &&  (m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode
            ==m_InfoSet.Position.CurrentAndTarget.TargetPosition.uNextNode))
    )
    {
        bOverRun = true;
    }

//  double dNodeDistOffset  = (m_InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType!=MARK_TYPE_NODE)
//                              ? 0:(int)m_pParamSet->Mark[0].Dist.dAddDistAfterSecondMet;

    //2 CurrPositionStatus
    if(bOverRun==false)
    {
//      pCurrPositionInfo->CurrNode         = InfoSet.Position.CurrentAndTarget.TargetPosition.uNode;
//      pCurrPositionInfo->CurrNodeOffset   = InfoSet.Position.CurrentAndTarget.TargetPosition.dOffset;
//      pCurrPositionInfo->NextNode         = InfoSet.Position.CurrentAndTarget.TargetPosition.uNextNode;

        pCurrPositionInfo->CurrNode         =   (InfoSet.Position.CurrentAndTarget.TargetPosition.uNode!=0)
                                            ?   InfoSet.Position.CurrentAndTarget.TargetPosition.uNode
											:   InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode;

	  	pCurrPositionInfo->CurrPreCheckNode =   (InfoSet.Position.CurrentAndTarget.TargetPosition.uNode!=0)
											?   InfoSet.Position.CurrentAndTarget.TargetPosition.uNode
											:   InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode;

        pCurrPositionInfo->CurrNodeOffset   = (m_InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType==MARK_TYPE_NODE)
                                            ?   MAX(((int)(InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset)),0)
                                            :   InfoSet.Position.CurrentAndTarget.TargetPosition.dOffset;
        pCurrPositionInfo->NextNode         =   ( InfoSet.Position.CurrentAndTarget.TargetPosition.uNextNode!=0)
                                            ?    InfoSet.Position.CurrentAndTarget.TargetPosition.uNextNode
                                            :   InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNextNode;

//      pCurrPositionInfo->CurrNode         = InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode;
//      pCurrPositionInfo->CurrNodeOffset   = MAX(((int)(InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset)),0);
//      pCurrPositionInfo->NextNode         = InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNextNode;
//		ADD_LOG("D_403/%f",pCurrPositionInfo->CurrNodeOffset);
    }

    pCurrPositionInfo->CurrStation          = InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uStation;
    pCurrPositionInfo->Marked               = InfoSet.Position.CurrentAndTarget.CurrPositionStatus.bMarked;
    pCurrPositionInfo->StationType          = InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.MarkType;

    //2 TargetPosition
	pCurrPositionInfo->CurrCommandedNode    = InfoSet.Position.CurrentAndTarget.TargetPosition.uNode;
    pCurrPositionInfo->CurrCommandedStation = InfoSet.Position.CurrentAndTarget.TargetPosition.uStation;

}

/**
@brief   저장된 구조체의 정보를 이용하여 현재 위치 정보를 획득
@author  임태웅
@date    2013.8.29.
@param InfoSet: 구조체 정보
@param pCurrPositionInfo: 위치 정보
@return 현재 위치 정보를 반환
*/
void DrivingControl::getPostionInfoOnManual(DRIVING_HW_INFO_SET HwInfo, EXECUTE_POSITION_INFO *pCurrPositionInfo)
{
    int nNodeDistOffset = (int)m_pParamSet->Mark[0].Dist.dAddDistAfterSecondMet;
	static int nCount = 0;
	static int strPreBCRLog = 0;
	nCount++;
	if(nCount > 10) nCount =0;


    if(m_StatusSet.byStatus  == STS_TURN_OFF) //기동 Off일때
	{

	   DRIVING_CMD_INFO_OF_NODE* pNodeInfo = getNodeInfo(HwInfo.Node.nNodeCount);


	   if(pNodeInfo != NULL)
	   {
			if(m_pExecuteInfo->ExecutePositionInfo.CurrNode  != pNodeInfo->ID)
			{
				ADD_LOG("D_404/%d/%d",m_pExecuteInfo->ExecutePositionInfo.CurrNode,pNodeInfo->ID);
				m_RunOffsetDistance =0.0;
				pCurrPositionInfo->CurrNode = pNodeInfo->ID;
				m_pExecuteInfo->ExecutePositionInfo.CurrNode =pNodeInfo->ID;
				if(pCurrPositionInfo->CurrNode == nRunNextNodeID)
				{
					if(cRunNextDivInfo != PATH_DIVERGENCE_NONE)
						m_pExecuteInfo->nCheckDivInfo = cRunNextDivInfo;
				}
			}
	   }
	}
	else if(HwInfo.Node.nBcrId!=0)
	{

		if(strPreBCRLog != HwInfo.Node.nBcrId)
		{
			BCR_LOG("/%6d/%d/", HwInfo.Node.nBcrId, m_InfoSet.HwInfo.Node.nNodeCount);
			strPreBCRLog = HwInfo.Node.nBcrId;
		}

		m_RunOffsetDistance =0.0;
		pCurrPositionInfo->CurrNode = HwInfo.Node.nBcrId;
	    m_pExecuteInfo->ExecutePositionInfo.CurrNode =HwInfo.Node.nBcrId;
		if(pCurrPositionInfo->CurrNode == nRunNextNodeID)
		{
			if(m_StatusSet.byStatus != STS_AUTORECOVERY_OVERRUN)
			{
				ADD_LOG("D_405/%d/%d",pCurrPositionInfo->CurrNode, cRunNextDivInfo);

				if(cRunNextDivInfo != PATH_DIVERGENCE_NONE)
					m_pExecuteInfo->nCheckDivInfo = cRunNextDivInfo;
			}
		}

	}


	if(pCurrPositionInfo->CurrNode!=0)
	{

		pCurrPositionInfo->CurrNodeOffset = ((int)(HwInfo.Axis1.dCurrPos-HwInfo.Node.dNodePosition)-10 + m_RunOffsetDistance);

		if(m_pExecuteInfo->ExecuteMode == EXECUTE_MODE_AUTO)
		{
			pCurrPositionInfo->CurrNodeOffset = MAX(((int)(pCurrPositionInfo->CurrNodeOffset)),0);
		}

		m_pExecuteInfo->dCompensatedPosition   = HwInfo.Axis1.dCurrPos - m_InfoSet.Position.Compensation.dDistErrorSum;
//		if((nCount%3) ==0)
//			ADD_LOG("D_406/%d/%f", pCurrPositionInfo->CurrNodeOffset, m_pExecuteInfo->dCompensatedPosition);

	}
    else
	{
		cRunNextDivInfo = PATH_DIVERGENCE_NONE;
		m_RunOffsetDistance =0.0;
        pCurrPositionInfo->CurrNodeOffset = 0.0;
	}

}



//void DrivingControl::checkStartCmd(EXECUTE_DRIVING_INFO *pTmpDrivingInfo)
//{
//    EXECUTE_DRIVING_INFO TmpDrivingInfo;
//    memset(&TmpDrivingInfo, 0x00, sizeof(EXECUTE_DRIVING_INFO));
//
//    if(m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.MarkType==MARK_TYPE_NODE)
//    {
//        return;  // 추후 에러 추가
//    }
//    else    // Station Marked
//    {
//        if(pTmpDrivingInfo->BasicInfo.EndNID==m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNextNode)
//        {
//            return;
//        }
//        else if(pTmpDrivingInfo->BasicInfo.StartNID==m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNextNode)
//        {
//            TmpDrivingInfo = m_LastDrivingCmdInfo;
//			memset(&(TmpDrivingInfo.AddInfo), 0x00, sizeof(EXECUTE_DRIVING_ADD_INFO));
//            makeCmdInfoLists(&TmpDrivingInfo);
//            ADD_LOG("D-194");
//        }
//        else
//        {
//            // 추후 에러 처리
//
//        }
//    }
//}


//EXECUTE_ACK DrivingControl::checkStartCmdStandard(EXECUTE_DRIVING_INFO *pTmpDrivingInfo)
//{
//	EXECUTE_ACK TmpExecuteAck = EXECUTE_ACK_ON_ERR;
//	EXECUTE_DRIVING_INFO TmpDrivingInfo;
//	memset(&TmpDrivingInfo, 0x00, sizeof(EXECUTE_DRIVING_INFO));
//
//	if(m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.MarkType==MARK_TYPE_NODE)
//	{
//		return EXECUTE_ACK_NOT_AVAILABLE_CMD;  // 추후 에러 추가
//	}
//	else    // Station Marked
//	{
//		if(pTmpDrivingInfo->BasicInfo.EndNID==m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNextNode)
//		{
//			return EXECUTE_ACK_NOT_AVAILABLE_CMD;
//		}
//		else if(pTmpDrivingInfo->BasicInfo.StartNID==m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNextNode)
//		{
//		   // TmpDrivingInfo = m_LastDrivingCmdInfo;
//		   //	memset(&(TmpDrivingInfo.AddInfo), 0x00, sizeof(EXECUTE_DRIVING_ADD_INFO));
//			TmpExecuteAck=  makeCmdInfoLists(&TmpDrivingInfo);
//			ADD_LOG("D-195");
//		}
//		else
//		{
//			// 추후 에러 처리
//
//		}
//	}
//}


double  DrivingControl::getMarkSpeedLimitOnGoing(int nCurrNodeCount)
{
    double  dSpeedLimit = m_pParamSet->Axis.Limit.Speed.MaxValue;
    DRIVING_CMD_INFO_OF_PATH* pPathInfo = NULL;

    //2 현재 Path의 최대 속도가 작을 경우 Limit Speed로 설정
    pPathInfo = getPathInfo(nCurrNodeCount);
    if(pPathInfo!=NULL)
    {
        dSpeedLimit = MIN(dSpeedLimit, pPathInfo->dSpeed);
    }

    //2 다음 Path의 최대 속도가 더 작을 경우 Limit Speed로 설정
    pPathInfo = getPathInfo(nCurrNodeCount+1);
    if(pPathInfo!=NULL)
    {
        dSpeedLimit = MIN(dSpeedLimit, pPathInfo->dSpeed);
    }

    return dSpeedLimit;

}


/**
 @brief   오버런 에러 관련 Auto Recovery 실행 함수
 @author  puting
 @date    2016.05.23
 @param   Error_AV : AutoRecovery를 하게 되는 Error Code
 @return  함수 실행 시 문제 없으면 0, 문제가 발생되면 해당 에러 코드 리턴
 */
int DrivingControl::AutoRecovery_Driving(int Error_AV)
{
	int nError = NO_ERR;
    double dVel_mmpermsec = 0.0;
	double dAccel_mmpermsec2 = 0.0;
	DWORD dwStartTime = 0;

	if((Error_AV == ERR_BCR_READTIMEOUT) ||
	   (Error_AV == ERR_QRR_READTIMEOUT))
//	   (Error_AV == ERR_MARK_FAIL))
//	   (Error_AV == ERR_NOTMATCH_TAGLENGTH_FINALSTATION_TAG_MET_LATE) ||
//	   (Error_AV == ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_LEFT_MET_LATE) ||
//	   (Error_AV == ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_RIGHT_MET_LATE))
	{

            ERR_LOG("Overrun Driving");
			m_StatusSet.byStatus = STS_AUTORECOVERY_OVERRUN;
			m_StatusSet.uError = Error_AV;
			m_StatusSet.bIsOnProcess = false;
			DrivingCMDExuteFunc(false);
			m_StatusSet.uStep = DRIVING_CTRL_STEP_NONE;

	}
	else
	{
     	nError = Error_AV;
	}
	return nError;
}

/**
@brief   pList 의 상태를 확인하고 nNodeCount 값 이전 정보를 삭제
@author  ehoto
@date    2013.7.19
@param pList: Command 리스트
@param Index: 찾기 시작하는 위치
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
template <typename T>
bool    clearListLessThan(List<T*> *pList, int nNodeCount)
{
    int nListCount      = pList->getCount();
    int nTmpIndex   = 0;
    T *pItem = NULL;

    if(nListCount==0) return true;
    for(nTmpIndex; nTmpIndex<nListCount; nTmpIndex++)
    {
        pItem   = pList->referFront();
        if(pItem!=NULL)
        {
            if(pItem->nCount>=nNodeCount)
            {
                break;
            }
            else
            {
                pItem   = pList->popFront();
                delete pItem;
                pItem   = NULL;
            }
        }
    }
    return true;
}



/**
@brief   pList 의 상태를 확인하고 nNodeID값 이후 정보를 삭제
@author  ehoto
@date    2013.7.19
@param pList: Command 리스트
@param Index: 찾기 시작하는 위치
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
template <typename T>
bool    clearListLessAfter(List<T*> *pList, int nNodeCount)
{
    int nListCount      = pList->getCount();
    int nTmpIndex   = 0;
    T *pItem = NULL;

	if(nListCount==0) return false;

	for(nTmpIndex; nTmpIndex<nListCount; nTmpIndex++)
	{
        pItem   = pList->referBack();
        if(pItem!=NULL)
        {
            if(pItem->nCount>=nNodeCount)
            {
                break;
            }
            else
            {
                pItem   = pList->popBack();
                delete pItem;
                pItem   = NULL;
            }
        }
	}

    return true;
}



/**
@brief   pList 의 상태를 확인하고 Index의 값 이후 의 정보를 삭제
@author  ehoto
@date    2013.7.19
@param pList: Command 리스트
@param Index: 찾기 시작하는 위치
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
template <typename T>
bool    clearListFrom(List<T*> *pList, int nIndex)
{
    int nListCount      = pList->getCount();
    int nTmpIndex   = nIndex;
    T *pItem = NULL;

    if(nListCount==0) return true;
    for(nTmpIndex; nTmpIndex<nListCount; nTmpIndex++)
    {
        pItem   = pList->popFront();
        if(pItem!=NULL)
        {
            delete pItem;
            pItem   = NULL;
        }
    }
    return true;
}

/**
@brief   pList 의 상태를 확인하고 모든 정보를 삭제
@author  ehoto
@date    2013.7.19
@param pList: Command 리스트
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
template <typename T>
bool    clearList(List<T*> *pList)
{
    clearListFrom(pList, 0);
}



// ===============  VHL 엘리베이터 구현 관련 추가 함수 정의 ===============

// 통과허가를 요청한다
/*
	OHT_NAME 6Byte.  Priority 2Byte. 그외 1Byte
*/
int DrivingControl::VHL_OPC_PASS_REQUEST (char* OHTNAME, unsigned char Priority,
										  unsigned char Turn, unsigned char LightGuideID)
{
	OPC_TO_TRANSPER_PKT PASS_REQ_PKT;

	PASS_REQ_PKT.STX = OPC_SERIAL_INIT_STX;
	PASS_REQ_PKT.CMD = OPC_TO_TRANSPER_CMD;

	memcpy(&PASS_REQ_PKT.OHTNAME, 		OHTNAME, 	sizeof(PASS_REQ_PKT.OHTNAME));
	PASS_REQ_PKT.Priority[ELEVETOR_HIGH_BYTE] = Priority;
	PASS_REQ_PKT.Priority[ELEVETOR_LOW_BYTE]  = Priority;
	PASS_REQ_PKT.Turn = Turn;
	PASS_REQ_PKT.LightGuideID = LightGuideID;

	CheckSum((char*)& PASS_REQ_PKT, OPC_TO_TRANSPER_PKT_CHECKSUM_LENGTH, (char*)&PASS_REQ_PKT.SUM);
	PASS_REQ_PKT.ETX = OPC_SERIAL_INIT_ETX;

	return SEND_SERIAL((char*)&PASS_REQ_PKT, sizeof(OPC_TO_TRANSPER_PKT));
	// return OPC_SERIAL_SEND_OK;
}


int DrivingControl::VHL_OPC_PASS_RESPONSE(unsigned char LightGuideID)
{
	int iReceivedByte = 0;
	AnsiString strTmp, strLog;

	char Tempbuff[255] ={0,};

	TRANSPER_TO_OPC_PKT RECV_PKT;

	iReceivedByte = pHWSet->m_pCID->ReadData((char*)&Tempbuff, (char)OPC_SERIAL_INIT_ETX);

//	strLog.sprintf("[LIFTER] VHL_OPC_PASS_RESPONSE () Byte : %d", iReceivedByte);
//	ADD_CID_LOG(strLog);

	if(iReceivedByte == 0)
		return TRANSPER_STATUS_DATA_NOT_RECEIVED;

	if(iReceivedByte == sizeof(TRANSPER_TO_OPC_PKT))
	   memmove(&RECV_PKT,&Tempbuff,sizeof(TRANSPER_TO_OPC_PKT));
	else
	   return TRANSPER_STATUS_DATA_NOT_RECEIVED;

	if(RECV_PKT.STX != OPC_SERIAL_INIT_STX)
		return TRANSPER_STATUS_OTHER_ERR;

	if(RECV_PKT.CMD != TRANSPER_TO_OPC_CMD)
		return TRANSPER_STATUS_OTHER_ERR;

	 if(m_defualtparam->VHLLifterPassEnable == 0)
	 {

		if(RECV_PKT.LightGuideID != LightGuideID)
		return TRANSPER_STATUS_OTHER_ERR;

		if(memcmp(&m_defualtparam->VHLName, &RECV_PKT.OHTNAME, sizeof(RECV_PKT.OHTNAME)) != 0)
		{
			ADD_LOG("D_407/%s",RECV_PKT.OHTNAME);
			return TRANSPER_STATUS_OTHER_ERR;
		}
	 }
	 else
	 {
       	//AOHC-217 VHLLifter 속도 개선
		// Lightguide ID 정합성 체크 제거. 181107 jhoun.lim
		//	if(RECV_PKT.LightGuideID != LightGuideID)
		//		return TRANSPER_STATUS_OTHER_ERR;

		if(memcmp(&m_defualtparam->VHLName, &RECV_PKT.OHTNAME, sizeof(RECV_PKT.OHTNAME)) != 0)
		{
			//ADD_LOG("D_408/%s",RECV_PKT.OHTNAME);
			return TRANSPER_STATUS_OTHER_ERR;
		}

		// LightGuideID 를 비교한다. (상부진입 or 하부진입 판단) 2018.06.04 by jhoun.lim
		// Lifter 진입시에 최초 1번만 실행된다.
		if(m_nElevetorDirection == PASS_DIRECTION_REQUEST_BEFORECHECK)
		{
			ADD_CID_LOG("[NEW Function] start finding lifter out node");
			m_nElevetorDirection = PASS_DIRECTION_REQUEST_ALL;
			bool isFindOutNode = false;
			int nCount = m_pExecuteInfo->ListOfCmd.getCount();
			for(int pathIndex = 0; pathIndex < nCount; pathIndex++)
			{
				EXECUTE_DRIVING_INFO* tmpDrvInfo = (EXECUTE_DRIVING_INFO*)m_pExecuteInfo->ListOfCmd.refer(pathIndex);

				int nid = tmpDrvInfo->BasicInfo.StartNID;
				int ntype = tmpDrvInfo->BasicInfo.NodeType;
				strLog.sprintf("[NEW Function] %d : nid : %d, ntype : %d", pathIndex, nid, ntype);
				ADD_CID_LOG(strLog);

				if(tmpDrvInfo->BasicInfo.NodeType == LIFTOUT_NTYPE)
				{
					isFindOutNode = true;
					if((RECV_PKT.LightGuideID == LIGHT_GUIDE_ID_INPUT_DOWN && tmpDrvInfo->BasicInfo.DivInfo == PATH_DIVERGENCE_LEFT) ||
						(RECV_PKT.LightGuideID == LIGHT_GUIDE_ID_INPUT_UP && tmpDrvInfo->BasicInfo.DivInfo == PATH_DIVERGENCE_RIGHT) ||
						(RECV_PKT.LightGuideID == LIGHT_GUIDE_ID_INPUT_DOWN_PRE && tmpDrvInfo->BasicInfo.DivInfo == PATH_DIVERGENCE_LEFT) ||
						(RECV_PKT.LightGuideID == LIGHT_GUIDE_ID_INPUT_UP_PRE && tmpDrvInfo->BasicInfo.DivInfo == PATH_DIVERGENCE_RIGHT))
					{
						ADD_CID_LOG("[NEW Function] PASS_DIRECTION_REQUEST_PASS");
						m_nElevetorDirection = PASS_DIRECTION_REQUEST_PASS;
					}
					else
					{
						ADD_CID_LOG("[NEW Function] PASS_DIRECTION_REQUEST_ALL");
					}
					break;
				}
			}
			if(!isFindOutNode)
			{
				ADD_CID_LOG("[NEW Function] can not find lifter out node!!");
			}
			return TRANSPER_STATUS_OTHER_ERR;
		}
		// for safety jhoun.lim 18.11.20
		if(m_nElevetorDirection == PASS_DIRECTION_REQUEST_PASS && RECV_PKT.PassInfo == VHL_LIFTER_TO_CID_R_ALL_PASS_OK)
		{
			m_nElevetorDirection = PASS_DIRECTION_REQUEST_ALL;
		}
	 }

	if(RECV_PKT.PassInfo == VHL_LIFTER_TO_CID_R_RIGHT_PASS_OK)
		strTmp.sprintf("우방향 통과 OK");
	else if(RECV_PKT.PassInfo == VHL_LIFTER_TO_CID_R_LEFT_PASS_OK)
		strTmp.sprintf("좌방향 통과 OK");
	else if(RECV_PKT.PassInfo == VHL_LIFTER_TO_CID_R_RIGHT_LOWSPEED_OK)
		strTmp.sprintf("우방향 저속 통과 OK");
	else if(RECV_PKT.PassInfo == VHL_LIFTER_TO_CID_R_LEFT_LOWSPEED_OK)
		strTmp.sprintf("좌방향 저속 통과 OK");

	else if(RECV_PKT.PassInfo == VHL_LIFTER_TO_CID_R_RIGHT_ONLY_OK)
		strTmp.sprintf("우방향 통과 가능");
	else if(RECV_PKT.PassInfo == VHL_LIFTER_TO_CID_R_LEFT_ONLY_OK)
		strTmp.sprintf("좌방향 통과 가능");
	else if(RECV_PKT.PassInfo == VHL_LIFTER_TO_CID_R_ALL_PASS_OK)
		strTmp.sprintf("방향지정 없이 가능");
	else if(RECV_PKT.PassInfo == VHL_LIFTER_TO_CID_R_ALL_PASS_OK_P) // jhoun.lim
		strTmp.sprintf("내부 정지 없이 통과 가능");
	else if(RECV_PKT.PassInfo == VHL_LIFTER_TO_CID_R_ALL_LOWSPEED_OK)
		strTmp.sprintf("방향없이 저속통과 가능");

	else if(RECV_PKT.PassInfo == VHL_LIFTER_TO_CID_R_PASS_NG)
		strTmp.sprintf("통과불가능");
	else if(RECV_PKT.PassInfo == VHL_LIFTER_TO_CID_R_PASS_OK)
		strTmp.sprintf("리프터 호출후 응답은 있으나 무효한 응답임");
	else if(RECV_PKT.PassInfo == VHL_LIFTER_TO_CID_R_LIFTER_OFF_STATE)
		strTmp.sprintf("리프트 기동 Off상태 (자동운전 아님)");
	else strTmp.sprintf("알수 없음");

	strLog.sprintf("[LIFTER] Pass Result : %s", strTmp);
	ADD_CID_LOG(strLog);

	if(iReceivedByte == sizeof(TRANSPER_TO_OPC_PKT))
	{
		strLog.sprintf("[LIFTER] VHL_OPC_PASS_RESPONSE () PassInfo : %c", RECV_PKT.PassInfo);
		ADD_CID_LOG(strLog);

		return RECV_PKT.PassInfo;		// TRANSPER_STATUS_DATA_RECEIVED_OK;
	}
	else
		return TRANSPER_STATUS_DATA_LENGTH_ERR;
}



// 시리얼로 1바이트를 전송한다 (항상 성공)
//int DrivingControl::SendLowSerial(char* cTemp)
//{
//	return OPC_SERIAL_SEND_OK;
//	// 실패시 OPC_SERIAL_SEND_ERR를 리턴한다
//}



// 시리얼로 문자열을 보낸다 (시뮬레이션이며, 화면에 표시해보자)
int DrivingControl::SEND_SERIAL(char* cProtocol, int iSize)
{
	return pHWSet->m_pCID->SendLGCmd(cProtocol,iSize);

}

int DrivingControl::SEND_SERIAL_NOT_CLEAR(char* cProtocol, int iSize)
{
	return pHWSet->m_pCID->SendLGCmd_NotClear(cProtocol,iSize);

}


//void DrivingControl::VHL_OPC_RESET_RESPONSE_SIMUL(OPC_INIT_PKT RECV_PKT)
//{
//	//int button = MessageBox(Handle,"VHL_OPC_RESET_RESPONSE_SIMUL. Are you sure?",
//	//		"Confirmation", MB_ICONQUESTION|MB_OKCANCEL|MB_APPLMODAL);
//
//	RECV_PKT.STX = OPC_SERIAL_INIT_STX;
//
//	//if (button == IDOK)
//		RECV_PKT.CMD = OPC_SERIAL_INIT_CMD;
//	//else
//	//	RECV_PKT.CMD = OPC_SERIAL_INIT_TEST;
//
//	RECV_PKT.Reserve[ELEVETOR_HIGH_BYTE] = OPC_SERIAL_INIT_RESERVE;
//	RECV_PKT.Reserve[ELEVETOR_LOW_BYTE]  = OPC_SERIAL_INIT_RESERVE;
//	RECV_PKT.ETX = OPC_SERIAL_INIT_ETX;
//
//	CheckSum((char*)& RECV_PKT, OPC_INIT_PKT_CHECKSUM_LENGTH, (char*)&RECV_PKT.SUM);
//}



int DrivingControl::VHL_OPC_RESET_RESPONSE()
{
	int iReceivedByte = 0;
	OPC_INIT_PKT RECV_PKT;
	AnsiString strLogTmp;

	char Tempbuff[255] ={0,};
	ADD_CID_LOG("[Elevetor] VHL_OPC_RESET_RESPONSE() - START POS");
	try{
		iReceivedByte = pHWSet->m_pCID->ReadData((char*)& Tempbuff, (char)OPC_SERIAL_INIT_ETX);
	}
	catch(...)
	{
		iReceivedByte =0;
		ADD_CID_LOG("[Elevetor] Exception Error");
	}
	strLogTmp.sprintf("[Elevetor] VHL_OPC_RESET_RESPONSE () Byte : %d", iReceivedByte);
	ADD_CID_LOG(strLogTmp);

	if(iReceivedByte == 0)
		return TRANSPER_STATUS_DATA_NOT_RECEIVED;

	if(iReceivedByte == sizeof(OPC_INIT_PKT))
	   memmove(&RECV_PKT,&Tempbuff,sizeof(OPC_INIT_PKT));
	else
	   return TRANSPER_STATUS_DATA_NOT_RECEIVED;

	if(RECV_PKT.STX != OPC_SERIAL_INIT_STX)
		return TRANSPER_STATUS_OTHER_ERR;

	if(RECV_PKT.CMD != OPC_SERIAL_INIT_CMD)
		return TRANSPER_STATUS_OTHER_ERR;

	if(iReceivedByte == sizeof(OPC_INIT_PKT))
		return TRANSPER_STATUS_DATA_RECEIVED_OK;
	else
		return TRANSPER_STATUS_DATA_LENGTH_ERR;
}

// OPC보드로 시리얼 리셋 명령을 보낸다
int DrivingControl::VHL_OPC_RESET()
{
	OPC_INIT_PKT SEND_PKT;

	SEND_PKT.STX = OPC_SERIAL_INIT_STX;
	SEND_PKT.CMD = OPC_SERIAL_INIT_CMD;
	SEND_PKT.Reserve[ELEVETOR_HIGH_BYTE] = OPC_SERIAL_INIT_RESERVE;
	SEND_PKT.Reserve[ELEVETOR_LOW_BYTE]  = OPC_SERIAL_INIT_RESERVE;
	SEND_PKT.ETX = OPC_SERIAL_INIT_ETX;

	CheckSum((char*)& SEND_PKT, OPC_INIT_PKT_CHECKSUM_LENGTH, (char*)&SEND_PKT.SUM);

	return SEND_SERIAL((char*)&SEND_PKT, sizeof(OPC_INIT_PKT));
}

// CheckSum3 - 내가 만들어본 것
// 위 함수에서 조금 고쳐서, Sum을 바로 담아준다 (호출측 코드 간략화)
AnsiString DrivingControl::CheckSum(char* buf, int len, char* check)
{
	unsigned int iCheckSum = 0;
	unsigned char cTmp = 0;


	for(int i = 1; i < len; i++)
	{
		cTmp = buf[i];
		iCheckSum = iCheckSum + cTmp;	// buf[i];
	}

	AnsiString sRv = "";   //iCheckSum = 0x0a;
	sRv.sprintf("%04X", iCheckSum);
	// sRv.sprintf("%04x", iCheckSum);

	AnsiString Tmp1, Tmp2;

	Tmp1 = sRv.SubString(3,1);
	Tmp2 = sRv.SubString(4,1);

	// 주의 : 덧셈의 결과가 나오면, 최하위 1바이트만 가지고, 체크썸에 태워야 한다
	memcpy((check + ELEVETOR_HIGH_BYTE), Tmp1.c_str(), 1);
	memcpy((check + ELEVETOR_LOW_BYTE) , Tmp2.c_str(), 1);

	return sRv; // 이전 전체 분석된 바이트 수
}


/*
	CID-O는 I5(Reserved)를 ‘1’로 설정함에 의해, MTL/Lifter 영역임을 VHL에 알릴 수 있습니다
	VHL은 I5(Reserved) 에서 ‘1’로 입력됨을 확인하고, Select Off한 후
	Operating Mode (O6)를 “0(MTL/Lifter)” 설정 후 Select On하시면 됩니다
*/
//int DrivingControl::GetCID_ELEVETORMODE_VALUE()
//{
//	return pHWSet->m_pCID->IsElevetorArea();
//}


// 엘리베이터 바깥의, LG1링크를 켜야하는 첫 포지션을 감지
// 도달했으면 true, 아니면 false반환
//bool DrivingControl::Check_Elevetor_LG1_START_AREA_Tag()
//{
//	return false;
//}


// 엘리베이터 바깥의, LG1링크의 중앙 (엘리베이터 타기전, 허가를 기다리는 곳)
// 도달했으면 true, 아니면 false반환
//bool DrivingControl::Check_Elevetor_LG1_WAIT_AREA_Tag()
//{
//	return false;
//}


// 엘리베이터 안쪽의, LG2링크의 중앙 (엘리베이터 안에서, 출발 허가를 기다리는 곳)
// 도달했으면 true, 아니면 false반환
//bool DrivingControl::Check_Elevetor_LG2_INSIDE_WAIT_AREA_Tag()
//{
//	return false;
//}



// VHL동작을 제어한다 (true : 동작, false : 정지). 리턴값 : true - 성공, false - 실패
//bool DrivingControl::MotionOnOff(bool bOnOff)
//{
//	return true;
//}

// bOnceRunReset 인수는 스테이트 머신에서 실행하면서, 불필요하게 여러번 리셋하는 것을
// 막기위한 것이다.
// true로 하면, 해당 함수 내부의 static 변수가 리셋 후, 빠져나가며 (다른 동작은 안함)
// 다음번에 실제 기능을 동작시키기 위해 호출하면 (이때 이 인수는 반드시 false) 실행후 flag가 set 된다
//
// 인수내용 (bOnceRunReset)
//   true -> 다음번에는 리셋명령을 보내야 한다 (예약만 해두고 return. I/O 명령은 보내지 않는다)
//   false -> 현재 상태를 보고, 리셋명령을 보내야 하는 경우에만 I/O 명령을 보내라
//
// 변수내용 (bOnceRun)
//	 true : 리셋명령을 실제 보내야 하는 상태 (초기상태)
//   false : 리셋명령을 이미 보낸 상태 (더이상 중복해서 보낼 필요없음)

void DrivingControl::CID_IO_SETTING_LIFTER(bool LightGuideDirectionIsLeft)
{
	int nError;
	AnsiString strLogTmp;
	static bool bOnceRun = true;

	strLogTmp.sprintf("[LIFTER] CID_IO_SETTING_LIFTER() LightGuideDirectionIsLeft : %d  ",
							LightGuideDirectionIsLeft);
	ADD_CID_LOG(strLogTmp);

	/*
	if (bOnceRunReset == true)
	{
		bOnceRun = true;
		return;
	}
	*/
	//if (bOnceRun == true)
	{
		nError = CID_SELECT_ALL_OFF();		// CID의 Select를 모두 Off한다
		if(nError != NO_ERR)
		{
			strLogTmp.sprintf("[LIFTER] SELECT all off return : %d", nError);
			ADD_CID_LOG(strLogTmp);
		}

		Sleep(DELAY_CID_COMMAND);	// 장비사양상 최소 10ms딜레이 줘야 함

		nError = CID_OPERATION_MODE_LIFTER();	// CID장치를 리프터 모드로 전환한다
		if(nError != NO_ERR)
		{
			strLogTmp.sprintf("[LIFTER] OP MODE LIFTER : %d", nError);
			ADD_CID_LOG(strLogTmp);
		}
		Sleep(DELAY_CID_COMMAND);

		// 좌,우 방향을 선택한다
		if(LightGuideDirectionIsLeft == true)
		{
			nError = CID_SELECT_DIRECTION_LEFT();
			strLogTmp.sprintf("[LIFTER] LEFT 선택 : %d", nError);
			ADD_CID_LOG(strLogTmp);
			Sleep(DELAY_CID_COMMAND);
		}
		else
		{
			nError = CID_SELECT_DIRECTION_RIGHT();
			strLogTmp.sprintf("[LIFTER] RIGHT 선택 : %d", nError);
			ADD_CID_LOG(strLogTmp);
			Sleep(DELAY_CID_COMMAND);
		}

		bOnceRun = false;
	}
}

int DrivingControl::CID_SELECT_ALL_OFF()
{
	return pHWSet->m_pCID->ElevetorSelectOff();
}

int DrivingControl::CID_OPERATION_MODE_LIFTER()
{
	return pHWSet->m_pCID->ElevetorOperatingModeSet(OFF);
}

int DrivingControl::CID_SELECT_DIRECTION_LEFT()
{
	return pHWSet->m_pCID->Left_Link_Lifter();
}

int DrivingControl::CID_OPERATION_MODE_CID()
{
	return pHWSet->m_pCID->ElevetorOperatingModeSet(ON);
}

int DrivingControl::CID_SELECT_DIRECTION_RIGHT()
{
	return pHWSet->m_pCID->Right_Link_Lifter();
}

bool DrivingControl::CID_Check_Mode_Lifter(bool LightGuideDirectionIsLeft)
{
	return  pHWSet->m_pCID->Check_Mode_Lifter(LightGuideDirectionIsLeft);
}


//int DrivingControl::ModeChg_CALL()
//{
//	// 임시 - 디버그용
//	AnsiString OHTNAME = "OHT001";
//	int Priority;
//	int Turn;
//	int LightGuideID;
//	// bool LightGuideDirectionIsLeft;
//
//	Priority = '9';
//	Turn = PASS_DIRECTION_REQUEST_ALL;
//	LightGuideID = 'A';
//	// LightGuideDirectionIsLeft = true;
//	// -----------------------------
//
//
//	int iReturn = VHL_OPC_PASS_REQUEST(m_defualtparam->VHLName, Priority, Turn, LightGuideID);
//
//	return iReturn;
//
//}



//int DrivingControl::ModeChg_UP()
//{
//
//	// 임시 - 디버그용
//	AnsiString OHTNAME = "OHT001";
//	int Priority;
//	int Turn;
//	int LightGuideID;
//
//	Priority = '9';
//	Turn = PASS_DIRECTION_REQUEST_RIGHT;
//
//	LightGuideID = 'A';

	// LightGuideID = StrToInt(OHTMainForm->Edit1->Text);


	// -----------------------------
	// ascii test

//#ifdef LIFTER_SCR_DEBUG
//	AnsiString strT;
//	strT.sprintf("지금보낸값 : %c", iTemp);
//	OHTMainForm->Memo1->Lines->Add(strT);
//#endif

//	int iReturn = VHL_OPC_PASS_REQUEST(m_defualtparam->VHLName, Priority, Turn, LightGuideID);
//
//	return iReturn;
//}



//int DrivingControl::ModeChg_DOWN()
//{
//	// 임시 - 디버그용
//	AnsiString OHTNAME = "OHT001";
//	int Priority;
//	int Turn;
//	int LightGuideID;
//
//
//	Priority = '9';
//	Turn = PASS_DIRECTION_REQUEST_LEFT;
//	LightGuideID = 'A';
//
//	// -----------------------------
//
//
//	int iReturn = VHL_OPC_PASS_REQUEST(m_defualtparam->VHLName, Priority, Turn, LightGuideID);
//
//	return iReturn;
//}


void DrivingControl::ADD_CID_LOG(AnsiString strLog)
{
	pHWSet->m_pCID->LOG_WRITE_2_CID_LOG(strLog);
}

//void DrivingControl::SetOhtName(AnsiString strName)
//{
//	m_strOhtName = strName;
//}



// 이 부분은 MAP에 리프터의 PreNode를 정의하기 전이므로, 임시로 하드코딩하여 만든 함수임
//bool DrivingControl::Lifter_Prenode_Check(UINT iNodeNum)
//{
//	AnsiString strLogTmp;
//
//
//	if ((iNodeNum == 126) || (iNodeNum == 210))
//	{
//		//strLogTmp.sprintf("[LIFTER PRE] Lifter_Prenode_Check()-true node no : %d", iNodeNum);
//		//ADD_CID_LOG(strLogTmp);
//
//		return true;
//	}
//	else
//	{
//		// strLogTmp.sprintf("[LIFTER PRE] Lifter_Prenode_Check()- FALSE!! node no : %d", iNodeNum);
//		// ADD_CID_LOG(strLogTmp);
//
//		return false;
//	}
//}

/////////////////////////////////////////
////사전동작 관련 함수 모음 -- puting////
////////////////////////////////////////
#define  EQPIO_BASE_CHANNEL         178     //LimJY_20160119 : For IR+RF PIO 시작 채널 178 (178 ~ 217 사용가능)

int DrivingControl::ExeCmdEQPIOOpen(int nPIOType, int nPIOID, int nPIOChannel,int nPIOCS)
{
	int nError = NO_ERR;

	int nTempPIOChannel = 0;

	if(nPIOChannel ==0)
	{
		nTempPIOChannel = nPIOID % 100;
		nTempPIOChannel = nTempPIOChannel % 40;
		nTempPIOChannel = EQPIO_BASE_CHANNEL + nTempPIOChannel;
	}
	else if(nPIOChannel >= EQPIO_BASE_CHANNEL && nPIOChannel < (EQPIO_BASE_CHANNEL+40) )
	{
		nTempPIOChannel = nPIOChannel;
	}
	else  //사용하지 않는 채널 번호가 적힌 경우
	{
		nTempPIOChannel = nPIOID % 100;
		nTempPIOChannel = nTempPIOChannel % 40;
		nTempPIOChannel = EQPIO_BASE_CHANNEL + nTempPIOChannel;
	}

	if(pHWSet->m_pLeftEQPIO->GetRFPIOConnectStep()!=8)
	{
		 if(nPIOType != EQ_PIO_IR)
		 {
			nError = pHWSet->m_pLeftEQPIO->Set_RFPIO_Data_RS232_Hybrid(nPIOType, nPIOID, nTempPIOChannel, nPIOCS, m_defualtparam->VHLName, true);
		 }

         {
		   // 로그 중복 방지 코드 3000ms
             static DWORD dwPrevTick = 0;
             DWORD curTick = timeGetTime();
			 if(OHTUTILITY::PreventOverflowGetTimeMs( dwPrevTick) > 3000)   //20191104 KDS
             {
                    ADD_LOG("D-196");
                    dwPrevTick = curTick;
             }

         }


	}

	return nError;

}

int DrivingControl::ExeCmdEQPIOClose()
{
	int nError = NO_ERR;

	nError = pHWSet->m_pLeftEQPIO->PIODisable(true);
//nError = m_pHWSet->m_pRightEQPIO->PIODisable(true);

	ADD_LOG("D-197");

	return nError;

}

int DrivingControl::ExeCmdEQPIOForDualStageStbLoad()
{
	int nError = NO_ERR;
	if(pHWSet->m_pLeftEQPIO->GetLoadPIOStep() <= DUAL_STAGE_STB_STEP_BEFORE_LOAD_CHECK_READY)
	{
		//ADD_LOG("pHWSet->m_pLeftEQPIO->GetLoadPIOStep(): %d",pHWSet->m_pLeftEQPIO->GetLoadPIOStep());
		nError = pHWSet->m_pLeftEQPIO->SequenceBeforeTransForDualStageStb(PIO_LOAD);
	}
	return nError;

}

int DrivingControl::ExeCmdEQPIOForDualStageStbUnload()
{
	int nError = NO_ERR;
	if(pHWSet->m_pLeftEQPIO->GetUnloadPIOStep() <= DUAL_STAGE_STB_STEP_BEFORE_LOAD_CHECK_READY)
	{
		//ADD_LOG("pHWSet->m_pLeftEQPIO->GetUnlLoadPIOStep() %d",pHWSet->m_pLeftEQPIO->GetUnloadPIOStep());
		nError = pHWSet->m_pLeftEQPIO->SequenceBeforeTransForDualStageStb(PIO_UNLOAD);
	}
	return nError;
}


int DrivingControl::ExeCmdShutterClose(double dSpeedOfNow)
{
	int nError = NO_ERR;

	if(IsInnerFoup() == true)
	{
		if(pHWSet->m_pShutter->IsOpen(BOTH) && pHWSet->m_pShutter->IsInposition(BOTH))
		{
			nError = pHWSet->m_pShutter->IO_Init();
			Sleep(200);
		}

		if(!pHWSet->m_pShutter->IsClose(BOTH))
		{
			if(pHWSet->m_pShutter->IsInposition(BOTH))
			{
			   	pHWSet->m_pShutter->SendCloseCmd_Classifying_Material();

				ADD_LOG("D-198");

				ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,SHUTTER FRONT CLOSE,Start,%s,%06d,%06d,%06d,%d,%3.3lf,Close Start Station Dist,%6.1lf",
							m_defualtparam->VHLName,m_mccparam.cCarrierType,
							m_mccparam.uSourceNode,
							m_mccparam.uTargetNode,
							m_pExecuteInfo->ExecutePositionInfo.CurrNode,
							m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
							dSpeedOfNow,
							m_InfoSet.HwInfo.Axis1.dCurrPos);
				ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,SHUTTER REAR CLOSE,Start,%s,%06d,%06d,%06d,%d,%3.3lf,Close Start Station Dist,%6.1lf",
							m_defualtparam->VHLName,m_mccparam.cCarrierType,
							m_mccparam.uSourceNode,
							m_mccparam.uTargetNode,
							m_pExecuteInfo->ExecutePositionInfo.CurrNode,
							m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
							dSpeedOfNow,
							m_InfoSet.HwInfo.Axis1.dCurrPos);
				m_mccparam.bFrontShutterFlag = true;
				m_mccparam.bRearShutterFlag = true;
				if(m_mccparam.dwShutterFrontTime == 0)
				{
					m_mccparam.dwShutterFrontTime = timeGetTime();
					m_mccparam.dwShutterRearTime = timeGetTime();
				}
			}
			else
			{
				 m_bShutterCloseMovingFlag = true;
			}
		}
		else
		{
		  nError = pHWSet->m_pShutter->IO_Init();
		  ADD_LOG("D-199");
//		  m_bShutterCloseMovingFlag = true;

		}

		m_bShutterCloseFlag = true;  //사전동작 flags
		m_bShutterOpenFlag = false;

	}



	return nError;
}

int DrivingControl::ExeCmdShutterOpen(double dSpeedOfNow)
{
	int nError = NO_ERR;
	static bCheckOpenCmd = false;

	bool bShutterFrontClose = pHWSet->m_pShutter->IsClose(FRONT) & pHWSet->m_pShutter->IsInposition(FRONT);
	bool bShutterRearClose = pHWSet->m_pShutter->IsClose(REAR) & pHWSet->m_pShutter->IsInposition(REAR);
	bool bShutterBothClose = bShutterFrontClose & bShutterRearClose;

//	bool bShutterFrontOpen = pHWSet->m_pShutter->IsOpen(FRONT);
//	bool bShutterRearOpen = pHWSet->m_pShutter->IsOpen(REAR);
//	bool bShutterBothOpen = bShutterFrontOpen & bShutterRearOpen;

	if((IsInnerFoup() == true) && (bShutterBothClose == true) && (m_bShutterOpenFlag ==false) &&(m_bShutterCloseFlag ==false))
	{
		pHWSet->m_pShutter->SendOpenCmd();
		m_bShutterOpenFlag = true;
		bCheckOpenCmd = false;

		ADD_LOG("D-200");

		ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,SHUTTER FRONT OPEN,Start,%s,%06d,%06d,%06d,%d,%3.3lf,Open Start Station Dist,%6.1lf",
					m_defualtparam->VHLName,m_mccparam.cCarrierType,
					m_mccparam.uSourceNode,
					m_mccparam.uTargetNode,
					m_pExecuteInfo->ExecutePositionInfo.CurrNode,
					m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
					dSpeedOfNow,
					m_ClassifiedCmd.TargetInfo.dDistSumToNode - m_InfoSet.HwInfo.Axis1.dCurrPos);
		ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,SHUTTER REAR OPEN,Start,%s,%06d,%06d,%06d,%d,%3.3lf,Open Start Station Dist,%6.1lf",
					m_defualtparam->VHLName,m_mccparam.cCarrierType,
					m_mccparam.uSourceNode,
					m_mccparam.uTargetNode,
					m_pExecuteInfo->ExecutePositionInfo.CurrNode,
					m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
					dSpeedOfNow,
					m_ClassifiedCmd.TargetInfo.dDistSumToNode - m_InfoSet.HwInfo.Axis1.dCurrPos);
		m_mccparam.bFrontShutterFlag = true;
		m_mccparam.bRearShutterFlag = true;
		if(m_mccparam.dwShutterFrontTime == 0)
		{
			m_mccparam.dwShutterFrontTime = timeGetTime();
			m_mccparam.dwShutterRearTime = timeGetTime();
		}
	}
	else if(m_bShutterOpenFlag == true)
	{
		if(bCheckOpenCmd == false)
		{
            //21.03.18 JHJ 확인 필요
			if(pHWSet->m_pShutter->IsAlarm(FRONT))
			{
				m_mccparam.bShutterFrontAlarm = true;
			}
			if(pHWSet->m_pShutter->IsAlarm(REAR))
			{
				m_mccparam.bShutterRearAlarm = true;
			}

			if(pHWSet->m_pShutter->IsInposition(FRONT) && pHWSet->m_pShutter->IsOpen(FRONT) && m_mccparam.bFrontShutterFlag && (m_mccparam.nShutterFrontTime != 0))
			{
				ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,SHUTTER FRONT OPEN,End,%s,%06d,%06d,%06d,%d,%3.3lf,Open End Station Dist,%6.1lf,Shutter Front Open Time,%d,Shutter Alarm,%d",
					m_defualtparam->VHLName,m_mccparam.cCarrierType,
					m_mccparam.uSourceNode,
					m_mccparam.uTargetNode,
					m_pExecuteInfo->ExecutePositionInfo.CurrNode,
					m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
					dSpeedOfNow,
					m_ClassifiedCmd.TargetInfo.dDistSumToNode - m_InfoSet.HwInfo.Axis1.dCurrPos,
					m_mccparam.nShutterFrontTime,
					m_mccparam.bShutterFrontAlarm);
				m_mccparam.dwShutterFrontTime = 0;
				m_mccparam.nShutterFrontTime = 0;
				m_mccparam.bFrontShutterFlag = false;
				m_mccparam.bShutterFrontAlarm = false;
			}
			if(pHWSet->m_pShutter->IsInposition(REAR) && pHWSet->m_pShutter->IsOpen(REAR) && m_mccparam.bRearShutterFlag && (m_mccparam.nShutterRearTime != 0))
			{
				ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,SHUTTER REAR OPEN,End,%s,%06d,%06d,%06d,%d,%3.3lf,Open End Station Dist,%6.1lf,Shutter Rear Open Time,%d,Shutter Alarm,%d",
					m_defualtparam->VHLName,m_mccparam.cCarrierType,
					m_mccparam.uSourceNode,
					m_mccparam.uTargetNode,
					m_pExecuteInfo->ExecutePositionInfo.CurrNode,
					m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
					dSpeedOfNow,
					m_ClassifiedCmd.TargetInfo.dDistSumToNode - m_InfoSet.HwInfo.Axis1.dCurrPos,
					m_mccparam.nShutterRearTime,
					m_mccparam.bShutterRearAlarm);
				m_mccparam.dwShutterRearTime = 0;
				m_mccparam.nShutterRearTime = 0;
				m_mccparam.bRearShutterFlag = false;
				m_mccparam.bShutterRearAlarm = false;
			}
			if(pHWSet->m_pShutter->CheckComplete() ==NO_ERR)
			{
				bCheckOpenCmd = true;
				ADD_LOG("D-201");
			}
		}
    }

	return nError;

}
int DrivingControl::CheckShutterClose(double dSpeedOfNow)
{
	int nError = NO_ERR;
	static DWORD dwTimeOfShutterClose = timeGetTime();
	// [ SHUTTER ] //

	bool bShutterFrontClose = pHWSet->m_pShutter->IsClose(FRONT) & pHWSet->m_pShutter->IsInposition(FRONT);
	bool bShutterRearClose = pHWSet->m_pShutter->IsClose(REAR) & pHWSet->m_pShutter->IsInposition(REAR);
	bool bShutterBothClose = bShutterFrontClose & bShutterRearClose;

//	bool bShutterFrontOpen = pHWSet->m_pShutter->IsOpen(FRONT);
//	bool bShutterRearOpen = pHWSet->m_pShutter->IsOpen(REAR);
//	bool bShutterBothOpen = bShutterFrontOpen & bShutterRearOpen;



//	ADD_LOG("D-202");

	/*
	if(bShutterBothClose == true)
	{

		if((timeGetTime() - dwTimeOfShutterClose) > 300)
		{
			nError = pHWSet->m_pShutter->CheckComplete();
			m_bShutterCloseFlag = false;  //Check 완료시 클리어.
		}
	}
	else
	{
		dwTimeOfShutterClose = timeGetTime();
	}
	*/

	if(pHWSet->m_pShutter->CheckComplete() ==NO_ERR)
	{
	if(pHWSet->m_pShutter->IsInposition(FRONT) && pHWSet->m_pShutter->IsClose(FRONT) && m_mccparam.bFrontShutterFlag && (m_mccparam.nShutterFrontTime != 0))
	{
		ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,SHUTTER FRONT CLOSE,End,%s,%06d,%06d,%06d,%d,%3.3lf,Close End Station Dist,%6.1lf,Shutter Front Close Time,%d",
			m_defualtparam->VHLName,m_mccparam.cCarrierType,
			m_mccparam.uSourceNode,
			m_mccparam.uTargetNode,
				m_pExecuteInfo->ExecutePositionInfo.CurrNode,
				m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
			dSpeedOfNow,
			m_InfoSet.HwInfo.Axis1.dCurrPos,
			m_mccparam.nShutterFrontTime);
		m_mccparam.dwShutterFrontTime = 0;
		m_mccparam.nShutterFrontTime = 0;
		m_mccparam.bFrontShutterFlag = false;
	}
	if(pHWSet->m_pShutter->IsInposition(REAR) && pHWSet->m_pShutter->IsClose(REAR) && m_mccparam.bRearShutterFlag && (m_mccparam.nShutterRearTime != 0))
	{
		ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,SHUTTER REAR CLOSE,End,%s,%06d,%06d,%06d,%d,%3.3lf,Close End Station Dist,%6.1lf,Shutter Rear Close Time,%d",
			m_defualtparam->VHLName,m_mccparam.cCarrierType,
			m_mccparam.uSourceNode,
			m_mccparam.uTargetNode,
				m_pExecuteInfo->ExecutePositionInfo.CurrNode,
				m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
			dSpeedOfNow,
			m_InfoSet.HwInfo.Axis1.dCurrPos,
			m_mccparam.nShutterRearTime);
		m_mccparam.dwShutterRearTime = 0;
		m_mccparam.nShutterRearTime = 0;
		m_mccparam.bRearShutterFlag = false;
	}

        Sleep(200);
		m_bShutterCloseFlag = false;  //Check 완료시 클리어.
	}

	return nError;
}

bool DrivingControl::IsInnerFoup()   //재하 유무 확인 플래그
{
	bool breturn = false;

	if((pHWSet->m_pHand->IsClose(BOTH) == true) &&
	   (pHWSet->m_pInnerFoup->IsFoupDetect() == true))
		breturn = true;

	return breturn;
}

int DrivingControl::CheckShutterAlarm()   //셔터 알람
{
	int nReturn = NO_ERR;

	bool bShutterFrontAlarm = pHWSet->m_pShutter->IsAlarm(FRONT);
	bool bShutterRealAlarm = pHWSet->m_pShutter->IsAlarm(REAR);
	int  nCurrNodeID  	= m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode;
	double dCurrOffset = m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset;

	static int nCehck =0;

	if((bShutterFrontAlarm == true) || (bShutterRealAlarm == true))
	{
		nCehck++;

		if(nCehck ==10)
		{
			nReturn = pHWSet->m_pShutter->IO_Init();
			Sleep(10);

			nReturn = pHWSet->m_pShutter->AlarmReset();
			ADD_MD_LOG("SHU_ALARM Cur N 1:%d, Offset:%7.1lf", nCurrNodeID, dCurrOffset);
			if(nReturn != NO_ERR)
			{
				nReturn = pHWSet->m_pShutter->AlarmReset();
				ADD_MD_LOG("SHU_ALARM Cur N 2:%d, Offset:%7.1lf ",nCurrNodeID, dCurrOffset);
			}

		}
	}else
		nCehck =0;
	return nReturn;

}

void DrivingControl::Reload_QR_Data()
{
	m_pLeftQRR->SetQRMaker(m_pParamSet->Mark[2].MakerType);
	m_pRightQRR->SetQRMaker(m_pParamSet->Mark[3].MakerType);
}


void DrivingControl::Reset_DrivingControl()
{

		m_pDrivingAxis->SetGearRatio(m_defualtparam->DrivingDefault);

		m_pDrivingAxis->SetNegativeSWLimit(-1*MAX_DRIVING_DISTANCE);
		m_pDrivingAxis->SetPositiveSWLimit(MAX_DRIVING_DISTANCE);

	//	m_pDrivingAxis->SetBrakeRelease(ON);
		m_pDrivingAxis->SetBrakeRelease(false);    //브레이 잡는거

		m_pDrivingAxis->SetAMPEnable(true); 		 //서버 On
		m_pDrivingAxis->SetSlaveAMPEnable(true);	 //서버 On

		m_cSlopeNodeInfo = INIT_NTYPE;
#if((OHT_NAME == OHT_NAME_STD_V82)|| (OHT_NAME == OHT_NAME_STD_V85S)||(OHT_NAME == OHT_NAME_STD_V86)||(OHT_NAME == OHT_NAME_P4_MASK))
#else
		if(m_defualtparam->bUseRSA==true)
			m_pRSAControl->SetInnerLimitTorque_90();
		else
			m_pServoControl->SetInnerLimitTorque_90();
#endif
		Reload_QR_Data();

		m_bOnMapMake = false;
		m_bOnBackMove = false;
	//	m_bJobChange = false;
		memset(&m_bMapMakeType, 0x00, sizeof(MAP_MAKER_TYPE));

		/*
		m_DiagManager = DiagManager::getInstance();
		*/

		//1 NEW
		initCommandSet();
		initInfoSet();
		initPreviousArrivalInfo();
		memset(&m_PositionInfo, 0, sizeof(EXECUTE_POSITION_INFO));

		init();
}

double DrivingControl::GetDefaultAccel(void)
{
	return m_pParamSet->Axis.Default.dDefaultAccel;
}

double DrivingControl::GetDefaultDecel(void)
{
	return m_pParamSet->Axis.Default.dDefaultDecel;
}

double DrivingControl::calcMaxSpeedDynamic(double velIn, const double* dynamicVel, const double* dynamicAcc, const int numDynamicArea, const double decel, const double constTime, double dist)
{
	// 감속거리 보장 안되면 v_max = in
	double decelDist = (velIn*velIn) / (2.0*decel);
	if(dist < decelDist)
	{
		return velIn;
	}

	// constTime을 보장할 수 없으면 v_max = in
	double constDist = velIn * constTime;
	if (dist < decelDist + constDist)
	{
		return velIn;
	}

	int areaIn = 0;
	for (int i = 0; i < 3; ++i)
	{
		areaIn = i;
		if (velIn < dynamicVel[i]) break;
	}

	double velMax = 0.0;
	while (1)
	{
		double acc = dynamicAcc[areaIn];
		double _acc = 1.0 / acc;

		double A = 1.0 * _acc + 1.0 / decel;
		double B = constTime;
		double C = -2.0*dist - velIn * velIn * _acc;

		// Av^2 + 2Bv + C = 0
		velMax = (-1.0*B + sqrt(B*B - A * C)) / A;

		int areaMax;
		for (int i = 0; i < numDynamicArea; ++i)
		{
			areaMax = i;
			if (velMax <= dynamicVel[i]) break;
		}

		if (areaMax <= areaIn) break;

		dist -= (dynamicVel[areaIn] * dynamicVel[areaIn] - velIn * velIn) / (2.0*acc);
		velIn = dynamicVel[areaIn++];
	}
	return velMax;
}

/**
@brief   UBG 신호 헌팅으로 인한 추돌 사전 감지 및 Error 처리 판단
@see     AMOHTV80F-1756
@return  Error 처리 여부
*/
bool DrivingControl::checkUBG_Fail3_Error()
{
	bool bResult = false;
	int nCnt;

	if (m_pParamSet->UbgFail3Err.bHourlyCheck) {
		bResult = m_pUBG_Fail3_HourCounter->updateAndCheckThreshold(m_pParamSet->UbgFail3Err.nHourCount, &nCnt);
		ERR_LOG("[UBG FAIL 3][Hour] Count : %d", nCnt);
	}

	if (m_pParamSet->UbgFail3Err.bWeeklyCheck) {
		bResult |= m_pUBG_Fail3_WeekCounter->updateAndCheckThreshold(m_pParamSet->UbgFail3Err.nWeekCount, &nCnt); // 실행은 하되, Result 가 true 에서 false 로 바뀌지 않게 논리합 처리
		ERR_LOG("[UBG FAIL 3][Week] Count : %d", nCnt);
	}

    return bResult;
}

void DrivingControl::Add_MCC_Nack_Log(BYTE &chNackToAckType)
{
	double  dSpeedOfNow                 = m_InfoSet.HwInfo.Axis1.dSpeed;

	ADD_MCC_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,NACK 13,-,%s,%06d,%06d,%06d,%d,%3.3lf,Nack Type,%d",
								m_defualtparam->VHLName,m_mccparam.cCarrierType,
								m_mccparam.uSourceNode,
								m_mccparam.uTargetNode,
								m_pExecuteInfo->ExecutePositionInfo.CurrNode,
								m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
								dSpeedOfNow,
								chNackToAckType);
}


void DrivingControl::SetUseCIDMonitoring(bool bUse, int nDelayCount)
{
	CID_Fiber_Monitoring = bUse;
	CID_SERIAL_CMD_DELAY_TURN  = nDelayCount;

	if(CID_SERIAL_CMD_DELAY_TURN < 7 || CID_SERIAL_CMD_DELAY_TURN > 12)
		CID_SERIAL_CMD_DELAY_TURN = 10;

}

//2022.11.30 sseung 메인 실행시 버전 관리 시스템을 위한 CID-O 버전 갱신용
int DrivingControl::GetCID_O_Version()
{
	return pHWSet->m_pCID->Set_CID_Monitor_Cmd(1);
}

//2023.01.02 sseung Autorecovery E309,310,764,765
int DrivingControl::AutoRecovery_Steer(int nErrorNum, DRIVING_INFO_SET *pInfoSet)
{
	int tmpError = NO_ERR;
	ADD_LOG("AutoRecovery Errornum=%d, Check_Node=%06d", nErrorNum, Check_Node);

	//조향정보가 N분기이거나 속도가 0보다 크거나 현재 노드와 에러 발생노드가 다른 경우 제외
	if(pInfoSet->Steer.PathSteer == PATH_STEERING_LEFT || pInfoSet->Steer.PathSteer == PATH_STEERING_RIGHT)
	{
	   //	if(Check_Node == m_pExecuteInfo->ExecutePositionInfo.CurrNode && pInfoSet->HwInfo.Axis1.dSpeed == 0.0)
		if(Check_AutoRecovery_PreCheck == pInfoSet->HwInfo.Node.nPreCheckCount && pInfoSet->HwInfo.Axis1.dSpeed == 0.0)
		{
			DRIVING_CMD_INFO_OF_PATH* pPathInfo = getPathInfo(pInfoSet->HwInfo.Node.nNodeCount);
			DWORD RecoveryStartTime = timeGetTime();
			CTRL_INFO_OF_STEER pSteerCtrl;
			memset(&pSteerCtrl, 0, sizeof(CTRL_INFO_OF_STEER));

			ADD_LOG("AutoRecovery_Steer In");

			if(pInfoSet->Steer.PathSteer == PATH_STEERING_LEFT)
			{
				m_nLFrontSteerRecovery_Time = timeGetTime();
				m_nLRearSteerRecovery_Time = timeGetTime();
				m_nLeftSteerRecovery_Cnt = true;
			}
			else
			{
				m_nRFrontSteerRecovery_Time = timeGetTime();
				m_nRRearSteerRecovery_Time = timeGetTime();
				m_nRightSteerRecovery_Cnt = true;
			}

			if((pInfoSet->Steer.PathSteer == PATH_STEERING_LEFT && m_pSteer->IsFrontLeftOn() == 0)
				|| (pInfoSet->Steer.PathSteer == PATH_STEERING_RIGHT && m_pSteer->IsFrontRightOn() == 0))  //Front가 안움직인 경우
			{
				ADD_LOG("Front Dir=%d", pInfoSet->HwInfo.IO.SteerFrontDirCmd);
				pSteerCtrl.FrontCmdOn = true;
				pSteerCtrl.FrontDirection = pInfoSet->HwInfo.IO.SteerFrontDirCmd;
				pSteerCtrl.FrontTorque = HW_STEER_TORQUE_MOVING;

				if(pInfoSet->Steer.PathSteer == PATH_STEERING_LEFT)
				{
					AUTO_RECOV_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,RETRY STEER FRONT LEFT,Start,%s,%06d,%06d,%06d,%d,%3.3lf,Next Node Dist,%6.1lf,OHT Detect Output Status,%d,OBS Output Status,%d",
								m_defualtparam->VHLName,m_mccparam.cCarrierType,
								m_mccparam.uSourceNode,
								m_mccparam.uTargetNode,
								m_pExecuteInfo->ExecutePositionInfo.CurrNode,
								m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
								pInfoSet->HwInfo.Axis1.dSpeed,
								pPathInfo->dLength - m_pOHTMainStatus->StatusCommon.CurNodeOffset,
								m_pOHTDetect->GetUbgAreaStatus(),
								m_pObstacle->GetObsAreaStatus());
				}
				else
				{
					AUTO_RECOV_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,RETRY STEER FRONT RIGHT,Start,%s,%06d,%06d,%06d,%d,%3.3lf,Next Node Dist,%6.1lf,OHT Detect Output Status,%d,OBS Output Status,%d",
								m_defualtparam->VHLName,m_mccparam.cCarrierType,
								m_mccparam.uSourceNode,
								m_mccparam.uTargetNode,
								m_pExecuteInfo->ExecutePositionInfo.CurrNode,
								m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
								pInfoSet->HwInfo.Axis1.dSpeed,
								pPathInfo->dLength - m_pOHTMainStatus->StatusCommon.CurNodeOffset,
								m_pOHTDetect->GetUbgAreaStatus(),
								m_pObstacle->GetObsAreaStatus());
				}
			}
			if((pInfoSet->Steer.PathSteer == PATH_STEERING_LEFT && m_pSteer->IsRearLeftOn() == 0)
				|| (pInfoSet->Steer.PathSteer == PATH_STEERING_RIGHT && m_pSteer->IsRearRightOn() == 0))   //Rear가 안움직인 경우
			{
				ADD_LOG("Rear Dir=%d", pInfoSet->HwInfo.IO.SteerRearDirCmd);
				pSteerCtrl.RearCmdOn = true;
				pSteerCtrl.RearDirection = pInfoSet->HwInfo.IO.SteerRearDirCmd;
				pSteerCtrl.RearTorque = HW_STEER_TORQUE_MOVING;

				if(pInfoSet->Steer.PathSteer == PATH_STEERING_LEFT)
				{
					AUTO_RECOV_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,RETRY STEER REAR LEFT,Start,%s,%06d,%06d,%06d,%d,%3.3lf,Next Node Dist,%6.1lf,OHT Detect Output Status,%d,OBS Output Status,%d",
								m_defualtparam->VHLName,m_mccparam.cCarrierType,
								m_mccparam.uSourceNode,
								m_mccparam.uTargetNode,
								m_pExecuteInfo->ExecutePositionInfo.CurrNode,
								m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
								pInfoSet->HwInfo.Axis1.dSpeed,
								pPathInfo->dLength - m_pOHTMainStatus->StatusCommon.CurNodeOffset,
								m_pOHTDetect->GetUbgAreaStatus(),
								m_pObstacle->GetObsAreaStatus());
				}
				else
				{
					AUTO_RECOV_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,RETRY STEER REAR RIGHT,Start,%s,%06d,%06d,%06d,%d,%3.3lf,Next Node Dist,%6.1lf,OHT Detect Output Status,%d,OBS Output Status,%d",
								m_defualtparam->VHLName,m_mccparam.cCarrierType,
								m_mccparam.uSourceNode,
								m_mccparam.uTargetNode,
								m_pExecuteInfo->ExecutePositionInfo.CurrNode,
								m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
								pInfoSet->HwInfo.Axis1.dSpeed,
								pPathInfo->dLength - m_pOHTMainStatus->StatusCommon.CurNodeOffset,
								m_pOHTDetect->GetUbgAreaStatus(),
								m_pObstacle->GetObsAreaStatus());
				}
			}

			if(pSteerCtrl.FrontTorque == HW_STEER_TORQUE_MOVING || pSteerCtrl.RearTorque == HW_STEER_TORQUE_MOVING)   //조향 명령을 주는 경우에만
			{
				ADD_LOG("AutoRecovery 동작 시작");

				while(OHTUTILITY::PreventOverflowGetTimeMs(RecoveryStartTime) < 500)
				{
					if(pInfoSet->HwInfo.Axis1.dSpeed != 0.0 || tmpError != NO_ERR)     //속도가 0이 아니거나 조향 명령 중 에러가 발생한 경우 정지 토크 명령 후 break
					{
						pSteerCtrl.FrontTorque = HW_STEER_TORQUE_STOP;
						pSteerCtrl.RearTorque = HW_STEER_TORQUE_STOP;
						controlSteer(pSteerCtrl);
						Sleep(50);

						break;
					}

					tmpError = controlSteer(pSteerCtrl);
					Sleep(50);

					if(OHTUTILITY::PreventOverflowGetTimeMs(RecoveryStartTime) >= 250)
					{
						//명령 전송 완료 후 Stop명령 필요
						pSteerCtrl.FrontTorque = HW_STEER_TORQUE_STOP;
						pSteerCtrl.RearTorque = HW_STEER_TORQUE_STOP;
					}
				}
			}

			if(pInfoSet->Steer.PathSteer == PATH_STEERING_LEFT)
			{
				if(pSteerCtrl.FrontCmdOn == true)
				{
		//			AUTO_RECOV_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,RETRY STEER FRONT LEFT,End,%s,%06d,%06d,%06d,%d,%3.3lf,Next Node Dist,%6.1lf,Steer Front Left Time,%d,Steer Front Left Hunting Count,%d,OHT Detect Output Status,%d,OBS Output Status,%d,Steer Front Right Off Time,%d,Steer Front Left On Time,%d,Steer Front Trq0 On Time,%d,Steer Front Trq0 Off Time,%d,Steer Front DIR Off Time,%d,Max UBG Level,%d,Min UBG Level,%d,Max OBS Level,%d,Min OBS Level,%d,Left Front Recovery Time,%d",
					AUTO_RECOV_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,RETRY STEER FRONT LEFT,End,%s,%06d,%06d,%06d,%d,%3.3lf,Next Node Dist,%6.1lf,OHT Detect Output Status,%d,OBS Output Status,%d,Max UBG Level,%d,Min UBG Level,%d,Max OBS Level,%d,Min OBS Level,%d,Left Front Steer On,%d,Left Front Recovery Time,%d",

								m_defualtparam->VHLName,m_mccparam.cCarrierType,
								m_mccparam.uSourceNode,
								m_mccparam.uTargetNode,
								m_pExecuteInfo->ExecutePositionInfo.CurrNode,
								m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
								pInfoSet->HwInfo.Axis1.dSpeed,
								pPathInfo->dLength - m_pOHTMainStatus->StatusCommon.CurNodeOffset,
//								OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwSteerFrontTime),
//								m_mccparam.nSteerFrontHauntingCount,
								m_pOHTDetect->GetUbgAreaStatus(),
								m_pObstacle->GetObsAreaStatus(),
//								m_mccparam.dwSteerFRightOffTime,
//								m_mccparam.dwSteerFLeftOnTime,
//								m_mccparam.dwSteerFTRQ0OnTime,
//								m_mccparam.dwSteerFTRQ0OffTime,
//								m_mccparam.dwSteerFTDIROffTime,
								m_mccparam.nUBGMaxOnSteering,
								m_mccparam.nUBGMinOnSteering,
								m_mccparam.nOBSMaxOnSteering,
								m_mccparam.nOBSMinOnSteering,
								m_pSteer->IsFrontLeftOn(),
								OHTUTILITY::PreventOverflowGetTimeMs(m_nLFrontSteerRecovery_Time));
				}
				if(pSteerCtrl.RearCmdOn == true)
				{
					AUTO_RECOV_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,RETRY STEER REAR LEFT,End,%s,%06d,%06d,%06d,%d,%3.3lf,Next Node Dist,%6.1lf,OHT Detect Output Status,%d,OBS Output Status,%d,Max UBG Level,%d,Min UBG Level,%d,Max OBS Level,%d,Min OBS Level,%d,Left Rear Steer On,%d,Left Rear Recovery Time,%d",

								m_defualtparam->VHLName,m_mccparam.cCarrierType,
								m_mccparam.uSourceNode,
								m_mccparam.uTargetNode,
								m_pExecuteInfo->ExecutePositionInfo.CurrNode,
								m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
								pInfoSet->HwInfo.Axis1.dSpeed,
								pPathInfo->dLength - m_pOHTMainStatus->StatusCommon.CurNodeOffset,
//								OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwSteerFrontTime),
//								m_mccparam.nSteerFrontHauntingCount,
								m_pOHTDetect->GetUbgAreaStatus(),
								m_pObstacle->GetObsAreaStatus(),
//								m_mccparam.dwSteerFRightOffTime,
//								m_mccparam.dwSteerFLeftOnTime,
//								m_mccparam.dwSteerFTRQ0OnTime,
//								m_mccparam.dwSteerFTRQ0OffTime,
//								m_mccparam.dwSteerFTDIROffTime,
								m_mccparam.nUBGMaxOnSteering,
								m_mccparam.nUBGMinOnSteering,
								m_mccparam.nOBSMaxOnSteering,
								m_mccparam.nOBSMinOnSteering,
								m_pSteer->IsRearLeftOn(),
								OHTUTILITY::PreventOverflowGetTimeMs(m_nLRearSteerRecovery_Time));
				}

				m_nLFrontSteerRecovery_Time = 0;
				m_nLRearSteerRecovery_Time = 0;
				m_nLeftSteerRecovery_Cnt = false;
			}
			else
			{
				if(pSteerCtrl.FrontCmdOn == true)
				{
					AUTO_RECOV_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,RETRY STEER FRONT RIGHT,End,%s,%06d,%06d,%06d,%d,%3.3lf,Next Node Dist,%6.1lf,OHT Detect Output Status,%d,OBS Output Status,%d,Max UBG Level,%d,Min UBG Level,%d,Max OBS Level,%d,Min OBS Level,%d,Right Front Steer On,%d,Right Front Recovery Time,%d",

								m_defualtparam->VHLName,m_mccparam.cCarrierType,
								m_mccparam.uSourceNode,
								m_mccparam.uTargetNode,
								m_pExecuteInfo->ExecutePositionInfo.CurrNode,
								m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
								pInfoSet->HwInfo.Axis1.dSpeed,
								pPathInfo->dLength - m_pOHTMainStatus->StatusCommon.CurNodeOffset,
//								OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwSteerFrontTime),
//								m_mccparam.nSteerFrontHauntingCount,
								m_pOHTDetect->GetUbgAreaStatus(),
								m_pObstacle->GetObsAreaStatus(),
//								m_mccparam.dwSteerFRightOffTime,
//								m_mccparam.dwSteerFLeftOnTime,
//								m_mccparam.dwSteerFTRQ0OnTime,
//								m_mccparam.dwSteerFTRQ0OffTime,
//								m_mccparam.dwSteerFTDIROffTime,
								m_mccparam.nUBGMaxOnSteering,
								m_mccparam.nUBGMinOnSteering,
								m_mccparam.nOBSMaxOnSteering,
								m_mccparam.nOBSMinOnSteering,
								m_pSteer->IsFrontRightOn(),
								OHTUTILITY::PreventOverflowGetTimeMs(m_nRFrontSteerRecovery_Time));
				}
				if(pSteerCtrl.RearCmdOn == true)
				{
					AUTO_RECOV_LOG(m_pExecuteInfo->ExecuteMode,",%s,DRV,RETRY STEER REAR RIGHT,End,%s,%06d,%06d,%06d,%d,%3.3lf,Next Node Dist,%6.1lf,OHT Detect Output Status,%d,OBS Output Status,%d,Max UBG Level,%d,Min UBG Level,%d,Max OBS Level,%d,Min OBS Level,%d,Right Rear Steer On,%d,Right Rear Recovery Time,%d",

								m_defualtparam->VHLName,m_mccparam.cCarrierType,
								m_mccparam.uSourceNode,
								m_mccparam.uTargetNode,
								m_pExecuteInfo->ExecutePositionInfo.CurrNode,
								m_pExecuteInfo->ExecutePositionInfo.CurrNodeOffset,
								pInfoSet->HwInfo.Axis1.dSpeed,
								pPathInfo->dLength - m_pOHTMainStatus->StatusCommon.CurNodeOffset,
//								OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwSteerFrontTime),
//								m_mccparam.nSteerFrontHauntingCount,
								m_pOHTDetect->GetUbgAreaStatus(),
								m_pObstacle->GetObsAreaStatus(),
//								m_mccparam.dwSteerFRightOffTime,
//								m_mccparam.dwSteerFLeftOnTime,
//								m_mccparam.dwSteerFTRQ0OnTime,
//								m_mccparam.dwSteerFTRQ0OffTime,
//								m_mccparam.dwSteerFTDIROffTime,
								m_mccparam.nUBGMaxOnSteering,
								m_mccparam.nUBGMinOnSteering,
								m_mccparam.nOBSMaxOnSteering,
								m_mccparam.nOBSMinOnSteering,
								m_pSteer->IsRearRightOn(),
								OHTUTILITY::PreventOverflowGetTimeMs(m_nRRearSteerRecovery_Time));

				}

				m_nRFrontSteerRecovery_Time = 0;
				m_nRRearSteerRecovery_Time = 0;
				m_nRightSteerRecovery_Cnt = false;
			}
		}
		else
			return nErrorNum;

		ADD_LOG("After Steer---%d/%d/%d/%d", m_pSteer->IsFrontLeftOn(), m_pSteer->IsRearLeftOn(), m_pSteer->IsFrontRightOn(), m_pSteer->IsRearRightOn());

		//AutoRecovery 동작중 에러가 발생했으면 원래 Error 출력
		if((tmpError != NO_ERR)
		|| (m_pSteer->IsFrontLeftOn()!= m_pSteer->IsRearLeftOn()) || (m_pSteer->IsFrontRightOn() != m_pSteer->IsRearRightOn())
		||((pInfoSet->Steer.PathSteer == PATH_STEERING_LEFT) && ((!m_pSteer->IsFrontLeftOn() && !m_pSteer->IsRearLeftOn())|| m_pSteer->IsFrontRightOn() || m_pSteer->IsRearRightOn()))
		||((pInfoSet->Steer.PathSteer == PATH_STEERING_RIGHT) && ((!m_pSteer->IsFrontRightOn() && !m_pSteer->IsRearRightOn())|| m_pSteer->IsFrontLeftOn() || m_pSteer->IsRearLeftOn()))
		)
		{
			ADD_LOG("Return ErrorNum-1");
			return nErrorNum;
		}

		pInfoSet->Time.Stop.OnAbnormalStop.bFlag = false;
		if(pInfoSet->Time.Steer.SteeringChangeCmded.bFlag == true) pInfoSet->Time.Steer.SteeringChangeCmded.bFlag = false;
		else if(pInfoSet->Time.Steer.SteeringNotMatch.bFlag == true) pInfoSet->Time.Steer.SteeringNotMatch.bFlag = false;
		return NO_ERR;
	}
	ADD_LOG("Return ErrorNum-2");

	return nErrorNum;
}
