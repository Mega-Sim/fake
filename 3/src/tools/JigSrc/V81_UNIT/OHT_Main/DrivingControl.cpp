// ---------------------------------------------------------------------------
/**
@file    DrivingControl.cpp
@version OHT 7.0
@brief   DrivingControl Class CPP File
*/
#include <stdlib.h> // _fullpath
#include <string.h>// memcmp
#include <time.h>
#include <math.h>
#include "OHTMain.h"
#include "DrivingControl.h"
//#include "LIniFile.h"
//#include "Utility.h"



#define NO_ERR 0
#define NODE_NONE 0


#define DEFAULT_ACCEL           0.0020  // 0.0025 mm/msec2 = 2.0 m/s2
#define DEFAULT_DECEL           0.0030  // 0.0028 mm/msec2 = 3.0 m/s2
#if(OHT_NAME == OHT_NAME_STD_V81S)
#define DEFAULT_EMERGENCY_DECEL 0.0032  // 0.0035 mm/msec2 = 3.0 m/s2
#else
#define DEFAULT_EMERGENCY_DECEL 0.0035  // 0.0035 mm/msec2 = 3.0 m/s2
#endif
#define DEFAULT_TURNOFF_DECEL	0.0030  // 0.0020mm/msec2  = 3.0 m/s2
#define DEFAULT_CURVE_DECEL		0.0025  // 0.0035 mm/msec2 = 3.0 m/s2

#define QRR_MARK_ACCEL          0.0001  // 0.0001 mm/msec2 = 0.1 m/s2
#define QRR_MARK_FIRST_DECEL    0.0020  // 0.0020 mm/msec2 = 2.0 m/s2
#define QRR_MARK_FIRST_SPEED    0.1     // 0.051mm/msec = 0.05 m/s

#define DRIVING_MIN_ACCEL       0.00005 // 0.0035 mm/msec2 = 0.05 m/s2
#define DRIVING_MAX_ACCEL       0.0035  // 0.0035 mm/msec2 = 3.5 m/s2
#define DRIVING_MIN_DECEL       0.00005 // 0.0035 mm/msec2 = 0.05 m/s2
#define DRIVING_MAX_DECEL       0.0035  // 0.0035 mm/msec2 = 3.5 m/s2

#define DRIVING_OUT_IN_NODE_AREA_SPEED  0.3     // 0.1mm/msec = 0.1 m/s
#define DRIVING_MIN_SPEED               0.05        // 0.051mm/msec = 0.05 m/s
#define DRIVING_MAX_SPEED               3.3     // 3.3mm/msec = 3.3 m/s
#define DRIVING_SPEED_SMOOTHING_FACTOR  0.85

#define MIN_DRIVING_DISTANCE    -50000   // -5000mm: 뒤로 너무 이동하는 것 방지
#define MAX_DRIVING_DISTANCE    1300000 // 1.3km    - S1에서 1.7km 이상 주행 시 오버 플로우에 의해 이상 주행 발생 : 안정적으로 1Km로 제한
                                        // 추후 AMC 단에서 인자의 오버플로 범위에 입각한 갑 설정및 처리 방안 고민 필요

#define OFFSET_TO_CHECK_FIRST_NODE          10.0    // Station에서 출발하여 처음 Node 만날 때 이상 Node Count 방지를 위해 Node Count Reset 해야 하는 Station 의 기준 Offset Max
#define POSITION_TO_CHECK_FIRST_NODE        20.0    // Offset이 -10~10mm인 Station 처음 Node 만날 때 이상 Node Count 방지를 위해 Node Count Reset 하는 위치
#define DIST_TO_CHECK_FIRST_NODE_MARGIN     80.0    // Offset이 -10~10mm인 Station 처음 Node 만날 때 이상 Node Count 방지를 위해 Node Count Reset 하는 종안 보내는 목적 거리
#define DIST_TO_CHECK_FIRST_NODE_POSITION   50.0
#define DIST_TO_CHECK_MARK_NODE_MARGIN      200.0   // Offset이 300mm인 Tag로 이동할 경우, 급가속하는 현상을 방지하기 위해 Mark동작으로 빠지게하는 거리

#define DIST_MARGIN_FOR_SMALL_ADD_START     450 // 500mm
#define SPEED_MARGIN_FOR_SMALL_ADD_START    1.0 // 1.0mm/msec

#define SPEED_MARGIN_FOR_CURVE_STOP 1250.0 // 1.25m/s

#define ACCEPTABLE_QR_MARK_POSITION_ERROR               0.5 //0.5       // 허용 오차범위    mm
#define ACCEPTABLE_DRIVING_POSITION_ERROR               0.5 //0.5       // 허용 오차범위    mm
#define ACCEPTABLE_DRIVING_POSITION_ERROR_HIGH          50.0    //50.0  // 허용 오차범위    mm
#define ACCEPTABLE_DRIVING_POSITION_ERROR_ON_QR_WAIT    5.0 //0.5   // 허용 오차범위    mm

#define ACCEPTABLE_DRIVING_FRISTNODE_POSITION_ERROR     5.0 //0.5       // 허용 오차범위    mm

#define ACCEPTABLE_DRIVING_SPEED_ERROR                  0.2 // 허용 오차범위    mm/msec

#define DRIVING_START_MARGIN                    50      // 주행 시작을 위한 마진 거리 : 시작점을 지났음을 확인하기 위한 마진
#define NODE_MARK_MARGIN                        150     // 주행 TAG Stop 할 경우 오차 보정을 위한 사전 마진 거리 : 이거리 전부터 이거리+350mm 정도까지 오차 보정이 가능하다.

#define TIME_STEER                              1000        // msec
#define TIME_INTERVAL_OF_STEER_COMPLETED        100     // 조향이 완전히 바뀌었다고 판단할 수 있는 시간 간격        // 16

#define DIST_BETWEEN_NODE_CHECK_AND_PRECHECK    	 350     // 350mm
#define DIST_MARGIN_TO_NODE_TO_CONPENSATE_SLIP  	 180     // 200mm
#define DIST_MARGIN_TO_NODE_TO_CONPENSATE_SLIP_200   200     // 200mm
#define SPEED_OF_OUT_IN_NODE                    0.05        // 0.1mm/msec
#define DIST_MARGIN_TO_NODE_SPEED_STANARD           3.3     // 3.3mm/msec = 3.3 m/s


#define MIN_DIST_BETWEEN_NODE                   350     // 주행 노드간의 최소 거리 350mm
#define DIST_MARGIN_TO_OUTNODE                  500     // 500mm Out Node 작업을 기다리기 위한 마진
#define DIST_MARGIN_TO_N_BRANCH_MOVING_CHECK    700     // 700mm N분기에 조향이 충분히 들어갔다고 판단하는 마진
#define DIST_MARGIN_OF_NODE                     400.0   // 400mm Node 감지가 map 위치에서 ±400 mm 를 벗어나서 나타날 경우 에러 발생
#define DIST_MARGIN_OF_NODE_FDC                 200.0   // 200mm Node 감지가 map 위치에서 ±200 mm 를 벗어나서 나타날 경우 FDC 전송
#define DIST_MARGIN_BETWEEN_TRANS_STATION       150     // 150mm 이적재 Node 간의 최소 간격
#define DIST_BETWEEN_TRANS_TAG_FRONT_AND_REAR   150     // 150mm 이적재 Node 간의 최소 간격
#define DIST_MARGIN_OF_TRANS_TAG                60      // 45mm 이적재 Station 명령 마진(이 거리 만큼 정위치 전으로 1차 명령을 보낸다)
#define DIST_MARGIN_OF_FINAL_MARK_RETRY     60      // 20mm 마지막 마크 안된 상태에서 정지 시 정위치 잡는 추가 마진 거리
#define DIST_MARGIN_OF_OVERRUN                  100     // 100mm Mark 시 Tag 검출 양의 방향 오차 범위

#define DRIVING1_ABNOMARL_MOVE_SPEED_LIMIT      0.3     // mm/msec
#define DRIVING2_ABNOMARL_MOVE_SPEED_LIMIT      0.3     // mm/msec

#define DRIVING1_ABNOMARL_MOVE_SPEED_LIMIT_BACK      -0.3     // mm/msec


//2 TimeOut
#define CHECK_TIME_OF_DETECT_FAIL_ERR           200     // ms
#define CHECK_TIME_OF_OBS_FAIL_ERR              200     // ms
#define TIMEOVER_OF_OBS_DETECT                  30000   // ms
#define TIMEOVER_OF_STEERING_CHANGE             15000        // ms
#define TIMEOVER_OF_DRIVING_ABNORMAL_STOP       15000        // ms

// Steering 재시도 시간
#define TIME_STEERING_RETRY                     2000    // 2 sec
//2 Jog
#define MAX_ADD_DIST_OF_JOG_DRIVING_CMD         1000.0  // 1000mm : 3.5m/s로 조그 이동시 1m 경우 285ms 주기의 업데이트 필요
#define MAX_DIST_OF_JOG_MARK_CMD                1000.0  // 1000mm : OHT의 길이만큼 이동, 그 이상 이동하지 않음
#define MAX_SPEED_OF_DRIVING_JOG                3.5     // mm/msec
#define TIMEOUT_DRIVING_JOG_COMMAND             1000        // msec : 이 시간 이상 통신 두절시 멈춤

#define DIST_FRONT_ON_MOVE_BACK_OF_TRANS_MARK   (-50.0)
#define DIST_REAR_ON_MOVE_BACK_OF_TRANS_MARK    (-10.0)
#define DIST_MARGIN_OF_MARK                     5.0
#define DIST_Of_ONE_QR_MARK_MOVE                50.0

#define EVENT_ON    true
#define EVENT_OFF   false
#define STATE_ON    true
#define STATE_OFF   false

#define WATING_TIME_OF_ID_READ              300     // msec //100: Keyence, 300: OPTICON
#define WATING_TIME_OF_ID_READER_REENABLE   300     // msec

#define RUN_TO_MARK_MINDIST   				400.0     // msec
#define RUN_TO_MARK_MINSPEED   				0.17     // msec

#define DIST_LIMIT_OF_FRONT_ON_WAIT     10      // mm
#define DIST_LIMIT_OF_REAR_ON_WAIT      10      // mm

#define STATUS_NORMAL					0
#define STATUS_OBS_STOP					1
#define STATUS_PBS_STOP					2
#define STATUS_OHT_PAUSED    			3

#define SETSLOPE    1
#define RELSLOPE    2

#define MAX_BYTE_SIZE_OF_DRIVING_LOG    1024*10
#define PATH_DIS_OFFSET					10

#define MAX(a,b)    ((a>b)?a:b)
#define MIN(a,b)    ((a<b)?a:b)

#define GET_DRIVING_DIST_IN_TIMEOUT(speed_mm_per_msec)  (speed_mm_per_msec)*TIMEOUT_DRIVING_JOG_COMMAND     // TimeOut 내 추가 명령이 없으면 정지하는 거리
#define GET_DRIVING_SPEED_IN_LIMIT(speed_mm_per_msec)   ((speed_mm_per_msec)<MAX_SPEED_OF_DRIVING_JOG)?(speed_mm_per_msec):MAX_SPEED_OF_DRIVING_JOG

#define OBS_REST_DISTANCE_1000mm		1000
#define OBS_REST_DISTANCE_900mm			900
#define OBS_REST_DISTANCE_800mm			800
#define OBS_REST_DISTANCE_700mm			700
#define OBS_REST_DISTANCE_600mm			600
#define OBS_REST_DISTANCE_500mm			500
#define OBS_REST_DISTANCE_400mm			400
#define OBS_REST_DISTANCE_300mm			300
#define OBS_REST_DISTANCE_200mm			200
#define OBS_REST_DISTANCE_100mm			100
#define OBS_REST_DISTANCE_0mm			0

#define	OHT_DETECT_CMD_PATH_DIRECTION_NO_USE 	0	// 미사용: 예전 없음
#define	OHT_DETECT_CMD_PATH_DIRECTION_NORMAL	1	// 직진 구간: 예전 N
#define	OHT_DETECT_CMD_PATH_DIRECTION_LEFT		2	// 왼쪽: 예전 L
#define	OHT_DETECT_CMD_PATH_DIRECTION_RIGHT 	3	// 오른쪽: 예전 R
#define	OHT_DETECT_CMD_PATH_DIRECTION_SHORT	    4	// N분기 사용: 예전 S
#define	OHT_DETECT_CMD_PATH_DIRECTION_BOTH		5	// 짧은 S자형 곡선: 예전 B
#define	OHT_DETECT_CMD_PATH_DIRECTION_NARROW	6	// 레일 간격이 900mm 이하일때의 짧은 S자형 곡선: 예전 V

#define SICK_OBS_AREA_0					0
#define SICK_OBS_AREA_4					4
#define SICK_OBS_AREA_5					5
#define SICK_OBS_AREA_6					6
#define SICK_OBS_AREA_7					7

#define HO_OBS_AREA_TEST					1
#define HO_OBS_AREA_SET						14


// 로그 작성 함수
#define USE_DRIVING_LOG 1
#define ADD_LOG(...)    WRITE_LOG_UNIT(pLogUnit, __VA_ARGS__)
#define RESET_LOG       CLEAR_LOG(pLogUnit)

//#define ERR_LOG(...)    WRITE_LOG_ON_THIS_FILE("D:\\log\\DrivingError.log", __VA_ARGS__);\
//						ADD_LOG(__VA_ARGS__)
//#define BCR_LOG(...)    WRITE_LOG_ON_THIS_FILE("D:\\log\\BCR.log", __VA_ARGS__)
//#define DETECT_LOG(...)    WRITE_LOG_ON_THIS_FILE("D:\\log\\OHTDETECTWarnning.log", __VA_ARGS__)
//#define CID_MONITOR_LOG(...)    WRITE_LOG_ON_THIS_FILE("D:\\log\\CID_MONITORING.log", __VA_ARGS__)


// 로그 작성 함수 수정
#define ERR_LOG(...)    WRITE_LOG_UNIT(pLogDrivingError, __VA_ARGS__)
#define BCR_LOG(...)    WRITE_LOG_UNIT(pLogBCR, __VA_ARGS__)
#define DETECT_LOG(...)    WRITE_LOG_UNIT(pLogDetect, __VA_ARGS__)
#define CID_MONITOR_LOG(...)    WRITE_LOG_UNIT(pLogCIDMonitor, __VA_ARGS__)
#define ADD_MCC_LOG(...)      WRITE_LOG_UNIT(pLogMCC, __VA_ARGS__)
#define ADD_MD_LOG(...)    WRITE_LOG_ON_THIS_FILE("D:\\log\\MonitoringDetail.log", __VA_ARGS__)  //AOHC-253 Monitoring 항목 추가 2


#define ADD_FDC_LOG(...)			writeFDCUnit(pFDCUnit, __VA_ARGS__)
#define SEND_WARN(...)				writeFDCUnit_WARN(pFDCUnit, __VA_ARGS__)
/**
@brief   pList 의 상태를 확인하고 nNodeCount 값 이전 정보를 삭제
@author  ehoto
@date    2013.7.19
@param pList: Command 리스트
@param nNodeCount: 기준 NodeCount 시작하는 위치
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
template <typename T>
bool    clearListLessThan(List<T*> *pList, int nNodeCount);

/**
@brief   pList 의 상태를 확인하고 nNodeCount 값 이전 정보를 삭제
@author  ehoto
@date    2013.7.19
@param pList: Command 리스트
@param nNodeCount: 기준 NodeCount 시작하는 위치
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
template <typename T>
bool    clearListLessAfter(List<T*> *pList, int nNodeCount);


/**
@brief   pList 의 상태를 확인하고 Index의 값 이후 의 정보를 삭제
@author  ehoto
@date    2013.7.19
@param pList: Command 리스트
@param Index: 찾기 시작하는 위치
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
template <typename T>
bool    clearListFrom(List<T*> *pList, int nIndex);

/**
@brief   pList 의 상태를 확인하고 모든 정보를 삭제
@author  ehoto
@date    2013.7.19
@param pList: Command 리스트
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
template <typename T>
bool    clearList(List<T*> *pList);


/**
@brief   DrivingControl Class 생성자 함수
@author  ehoto
@date    2012.11.07
@param   pHWSet : HWSet 클래스 포인터
*/
DrivingControl::DrivingControl():VirtualDrivingControl()
{
#if USE_DRIVING_LOG
    pLogUnit = getLogUnit("D:\\log\\DrivingCtrl.log", MAX_BYTE_SIZE_OF_DRIVING_LOG);
#else
    pLogUnit = NULL;
#endif

	pLogDrivingError = getLogUnit("D:\\log\\DrivingError.log",MAX_BYTE_SIZE_OF_MAIN_LOG);
	pLogBCR = getLogUnit("D:\\log\\BCR.log", MAX_BYTE_SIZE_OF_MAIN_LOG);
	pLogDetect = getLogUnit("D:\\log\\OHTDETECTWarnning.log", MAX_BYTE_SIZE_OF_MAIN_LOG);
	pLogCIDMonitor = getLogUnit("D:\\log\\CID_MONITORING.log", MAX_BYTE_SIZE_OF_MAIN_LOG);
    pLogMCC = getLogUnit("D:\\log\\MCC.log", MAX_BYTE_SIZE_OF_MAIN_LOG);
	pFDCUnit = getFDCUnit("D:\\log\\FDC.log", MAX_BYTE_SIZE_OF_MAIN_LOG);

    m_pTransBCR     = NULL;
    m_pDrivingBCR   = NULL;
    m_pDrivingAxis  = NULL;
    m_pDrivingTag   = NULL;
    m_pObstacle     = NULL;
    m_pOHTDetect    = NULL;
    m_pLeftQRR      = NULL;
    m_pRightQRR     = NULL;
    m_pSteer        = NULL;
    m_pTransStopTag = NULL;
	m_pPassBoxPIO   = NULL;
	m_pMTLPIO       = NULL;
	m_pServoControl = NULL;

	m_pTmpParamSet = NULL;   //17라인 버그로인하여 추가

	m_strOhtName = "OHT001";	// lifter send param

	m_iLifterPrePass = VHL_ELEVETOR_PREPASS_STEP_NONE;
	m_IsLifterCheck = false;
	m_IsMTLCheck = false;




	pHWSet = OHTMainForm->GetHWSet();
	m_pExecuteInfo = OHTMainForm->GetExecuteInfo();
	m_defualtparam = OHTMainForm->GetDefaultParam();
	m_pOHTMainStatus = OHTMainForm->GetOHTStatus();
	
    if(pHWSet!=NULL)
    {
        m_pTransBCR     = pHWSet->m_pTransBCR;
        m_pDrivingBCR   = pHWSet->m_pDrivingBCR;
        m_pDrivingAxis  = pHWSet->m_pDrivingAxis;
        m_pDrivingTag   = pHWSet->m_pDrivingTag;
        m_pObstacle     = pHWSet->m_pObstacle;
        m_pOHTDetect    = pHWSet->m_pOHTDetect;
		m_pLeftQRR      = pHWSet->m_pLeftQRR;
        m_pRightQRR     = pHWSet->m_pRightQRR;
        m_pSteer        = pHWSet->m_pSteer;
        m_pTransStopTag = pHWSet->m_pTransStopTag;
		m_pPassBoxPIO   = pHWSet->m_pPassBoxPIO;
		m_pMTLPIO       = pHWSet->m_pMTLPIO;
		m_pServoControl = pHWSet->m_pServoMonitoring;
	}

	m_ParamChehckError = NO_ERR;

	m_pParamSet = new DRIVING_PARAM_SET();
	memset(m_pParamSet, 0x00, sizeof(DRIVING_PARAM_SET));
	loadParameterRecovery("DataFiles\\Driving.ini", m_pParamSet);

	m_pDrivingAxis->SetGearRatio(m_defualtparam->DrivingDefault);

    m_pDrivingAxis->SetNegativeSWLimit(-1*MAX_DRIVING_DISTANCE);
    m_pDrivingAxis->SetPositiveSWLimit(MAX_DRIVING_DISTANCE);

//	m_pDrivingAxis->SetBrakeRelease(ON);
	m_pDrivingAxis->SetBrakeRelease(false);    //브레이 잡는거

	m_pDrivingAxis->SetAMPEnable(true);          //서버 On
	m_pDrivingAxis->SetSlaveAMPEnable(true);     //서버 On

	m_cSlopeNodeInfo = INIT_NTYPE;
	m_pServoControl->SetInnerLimitTorque_90();
	m_pServoControl->SetInnerLimitTorque_800_Trans();


	m_bOnMapMake = false;
	m_bOnBackMove = false;
//	m_bJobChange = false;
	memset(&m_bMapMakeType, 0x00, sizeof(MAP_MAKER_TYPE));

	m_DiagManager = DiagManager::getInstance();
    //1 NEW
    initCommandSet();
	initInfoSet();
    initPreviousArrivalInfo();
    memset(&m_PositionInfo, 0, sizeof(EXECUTE_POSITION_INFO));

	init();

	m_nCidControlStep = CID_STEP_CONNECTING;
	m_Continue_CID_MODE = false;
	m_Continue_CID_MODE_StopNode=0;
	m_Continue_CID_MODE_ResetNode=0;
	m_Continue_CID_MODE_ResetNodeType=0;
//	m_OverRunCount_E2313 = 0;
//	m_OverRunCount_E2314 = 0;
//	m_OverRunCount_E250 = 0;
	m_OverRunCount = 0;
	bReqLifterCounterReset = false;

	m_nMarkFailRetryCheckID = 0;
	b_ReadBcr = false;
	b_WaitTrg = false;
	memset(&CID_Save_Node, 0, sizeof(CID_Save_Node));

	CheckReadyToRunTime_ExcuteGo = timeGetTime();
	CheckReadyToRunTime_ManualMark = timeGetTime();
	CheckComplete_ExcuteGo = timeGetTime();
	CheckComplete_ManualMark = timeGetTime();

	m_MoniCFNode=0;

	m_dCheckAMCDecelPosition = 0.0;
	m_dPreTargetPosition = 0.0;
}

/**
@brief   DrivingControl Class 소멸자 함수
@author  ehoto
@date    2012.11.07
*/
DrivingControl::~DrivingControl()
{
//    saveParameter("DataFiles\\Driving.ini", m_pParamSet);

	m_pDrivingAxis->MoveStop(DEFAULT_EMERGENCY_DECEL);
    m_pDrivingAxis->SetBrakeRelease(false);

    // 정보 초기화
    initStatusSet();
    initCommandSet();
	initInfoSet();
    initPreviousArrivalInfo();

    init();

    delete m_pParamSet;
}
//---------------------------------------------------------------------------

/**
@brief   DrivingControl Class 초기화 함수
@author  ehoto
@date    2012.11.27
*/
void DrivingControl::init(void)
{
	m_QuickCmd = EXECUTE_QUICK_CMD_NONE;

    memset(&m_Detect,       0, sizeof(m_Detect));

    //1 NEW
	//2 마크 되어 있을 경우 현재 위치 정보가 그 후에도 계속 업데이트 되어 Data 양식과 달라질 수 있음
	//오버런과 기동off는 처리하지않는것롤 확인한다.

	POSITION_STATUS CurrPositionStatus  =   (m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.bMarked==true)
                                            ?   m_PreviousArrivalInfo
											:   m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus;


    initCommandSet();
	initInfoSet();
    initPreviousArrivalInfo();
    m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus = CurrPositionStatus;    //1 함수화 필요
    m_PreviousArrivalInfo = CurrPositionStatus;
    //1

    // 상태 정보 초기화
    m_StatusSet.byStatus    = STS_INIT;
    m_StatusSet.uError      = NO_ERR;
    m_StatusSet.uStep       = 0;

    // 받은 명령에 대한 초기화
    m_Detect.UseFollowControlFlag   = false;
    m_Detect.NodeCount              =0;
	m_pDrivingAxis->SetDetectInfo(m_Detect);
//	ADD_LOG("Pre:  Init");

	m_pDrivingBCR->ReStart();
    m_pTransBCR->ReStart();

	m_pPassBoxPIO->PIODisable(true);
	m_nPassBoxPIOStep = PASSBOX_CTRL_STEP_NONE;
	m_RunOffsetDistance = 0.0;
	m_nMarkFailRetryCheckID = 0;
	//TG추가
	m_pMTLPIO->PIODisable(true);
	m_nMTLTakeOutPIOStep = MTL_TakeOut_CTRL_STEP_NONE;
	m_nMTLTakeInPIOStep = MTL_TakeIn_CTRL_STEP_NONE;


	// VHL 엘리베이터 구현 관련 추가
	m_nElevetorRideStep = VHL_ELEVETOR_RIDE_CTRL_STEP_CID_INIT;		// 상태값을 초기화 한다
	m_nElevetorOffStep = VHL_ELEVETOR_OFF_CTRL_STEP_INIT;
	m_nElevetorDirection = PASS_DIRECTION_REQUEST_ALL;

	//m_nCidControlStep = CID_STEP_CONNECTING;

	m_Dectect_Dir = PATH_DIRECTION_NO_USE;
	m_Dectect_OBS_Dir =PATH_OBS_DIRECTION_NO_USE;

	m_bShutterCloseFlag = false;
	m_bShutterOpenFlag = false;
	m_bShutterCloseMovingFlag = false;

	m_pDrivingAxis->SetCurveEstop(false);
	// CID Reading Buffer
	// memset(&SEREAL_READING_BUFFER, CID_SERIAL_WORK_NONE, (SEREAL_READING_BUFFER_SIZE + 1));
}



/**
@brief   제어기 정지 시키는 명령(내부 사용)
@author  ehoto
@date    2013.04.13
*/
void DrivingControl::stop()
{
   //	m_Detect.UseFollowControlFlag = false;    //HJH
  //	m_Detect.NodeCount=0;                //HJH
  //	m_pDrivingAxis->SetDetectInfo(m_Detect);  //HJH
	m_nMarkFailRetryCheckID = 0;
//	ADD_LOG("Pre:  Stop");

	m_StatusSet.bIsOnProcess = false;
	m_pExecuteInfo->bPopListOfCmd = false;
	m_StatusSet.uStep = DRIVING_CTRL_STEP_NONE;
	m_pExecuteInfo->ExecuteDrivingStep = DRIVING_CTRL_STEP_NONE;

	ERR_LOG("Driving Stop");

	if(((m_Dectect_Dir == PATH_DIRECTION_LEFT)||(m_Dectect_Dir == PATH_DIRECTION_RIGHT))
		&& m_pDrivingAxis->GetCurrentVelocity() < SPEED_MARGIN_FOR_CURVE_STOP)
	{
		m_pDrivingAxis->SetCurveEstop(true);
		m_pDrivingAxis->MoveStop(DEFAULT_CURVE_DECEL);
		ERR_LOG("DEFAULT_CURVE_DECEL ");
	}
	else
	{
		m_pDrivingAxis->MoveStop(DEFAULT_EMERGENCY_DECEL);
		ERR_LOG("DEFAULT_EMERGENCY_DECEL ");
    }
	m_pSteer->Stop();

//	if((m_iLifterPrePass != VHL_ELEVETOR_PREPASS_STEP_NONE) ||  (m_nElevetorRideStep != VHL_ELEVETOR_RIDE_CTRL_STEP_CID_INIT)  ||(m_nElevetorOffStep != VHL_ELEVETOR_OFF_CTRL_STEP_INIT))
//		CID_SELECT_ALL_OFF();

	m_iLifterPrePass = VHL_ELEVETOR_PREPASS_STEP_NONE;
	m_nElevetorRideStep = VHL_ELEVETOR_RIDE_CTRL_STEP_CID_INIT;		// 상태값을 초기화 한다
	m_nElevetorOffStep = VHL_ELEVETOR_OFF_CTRL_STEP_INIT;


	m_nMTLTakeOutPIOStep = MTL_TakeOut_CTRL_STEP_NONE;
	m_nMTLTakeInPIOStep  = MTL_TakeIn_CTRL_STEP_NONE;

	if(m_pExecuteInfo->FlagMTLInfo.bTakeInCycle ==true)
	{
		EnterCriticalSection(&OHTMainForm->m_CS);
		m_pExecuteInfo->FlagMTLInfo.bTakeInCycle = false;
		m_pExecuteInfo->FlagMTLInfo.nTakeInOrder = INIT;
		LeaveCriticalSection(&OHTMainForm->m_CS);
    }

	m_bOnMapMake = false;
	m_bOnBackMove = false;

	m_IsLifterCheck = false;
	m_IsMTLCheck = false;

	m_bIsFirstNodeCountAdd = false;
	m_bIsAMCVHLDetectIgnore = false;

	DrivingCMDExuteFunc(false);

	pHWSet->m_pCID->CID_Manual_Mode_On();

	//MapMaker 쓰레기 Data 삭제
	EXECUTE_RESPONSE_MAPMAKING_INFO *pStationInfo=NULL; //저장할 Map 구조체
	int nCountOfList = m_ListOfTmpStationData.getCount();

	for(int n=0; n<nCountOfList; n++)
	{
		pStationInfo = m_ListOfTmpStationData.popFront();
		delete pStationInfo;
	}

	nCountOfList = m_ListOfMapData.getCount();

	for(int n=0; n<nCountOfList; n++)
	{
		pStationInfo = m_ListOfMapData.popFront();
		delete pStationInfo;
	}
	//MapMaker 쓰레기 Data 삭제

//	m_bJobChange = false;
}

/**
@brief   제어기 정지 시키는 명령(내부 사용)
@author  puting
@date    2015.12.30
*/
void DrivingControl::turnoff()
{

//    m_Detect.UseFollowControlFlag = false;
//    m_Detect.NodeCount=0;
//    m_pDrivingAxis->SetDetectInfo(m_Detect);

	ERR_LOG("Driving Turn Off");
	m_StatusSet.bIsOnProcess = false;
	m_StatusSet.uStep = DRIVING_CTRL_STEP_NONE;
	m_pExecuteInfo->ExecuteDrivingStep = DRIVING_CTRL_STEP_NONE;

	m_pDrivingAxis->MoveStop(DEFAULT_TURNOFF_DECEL);
	m_pSteer->Stop();


	m_iLifterPrePass = VHL_ELEVETOR_PREPASS_STEP_NONE;
	m_nElevetorRideStep = VHL_ELEVETOR_RIDE_CTRL_STEP_CID_INIT;		// 상태값을 초기화 한다
	m_nElevetorOffStep = VHL_ELEVETOR_OFF_CTRL_STEP_INIT;

	m_nMTLTakeOutPIOStep = MTL_TakeOut_CTRL_STEP_NONE;
	m_nMTLTakeInPIOStep  = MTL_TakeIn_CTRL_STEP_NONE;

	if(m_pExecuteInfo->FlagMTLInfo.bTakeInCycle ==true)
	{
		EnterCriticalSection(&OHTMainForm->m_CS);
		m_pExecuteInfo->FlagMTLInfo.bTakeInCycle = false;
		m_pExecuteInfo->FlagMTLInfo.nTakeInOrder = INIT;
		LeaveCriticalSection(&OHTMainForm->m_CS);
    }

	//기동 off시 조향명령 초기화 : 다시 출발시킬때 조향확인후 출발 테스트 확인 필요
	m_InfoSet.Time.Steer.SteeringChangeCmded.bFlag =false;
//	m_InfoSet.Steer.FrontMoving = false;
//	m_InfoSet.Steer.RearMoving = false;
//	m_InfoSet.Time.Steer.FrontSteeringArrived.bFlag = true;
//	m_InfoSet.Time.Steer.RearSteeringArrived.bFlag = true;


	m_bOnMapMake = false;
	m_bOnBackMove = false;

	m_IsLifterCheck = false;
	m_IsMTLCheck = false;

	m_bIsFirstNodeCountAdd = false;
	m_bIsAMCVHLDetectIgnore = false;

	DrivingCMDExuteFunc(false);

//	m_bJobChange = false;
}


/**
@brief   대기 중 이상 상태 확인
@author  ehoto
@date    2013.02.07
@return  문제 있을 경우 에러 반환, 그 외에는 NO_ERR(0) 반환
*/
UINT DrivingControl::CheckAbnormalOnWait(void)
{
    UINT        nTmpError   = NO_ERR;

	if( m_StatusSet.bIsOnProcess    == true) return NO_ERR;

    DRIVING_HW_INFO_SET TmpHwInfo = getHWInfo();

    // [ DRIVING ] //
    // Driving 가 서보 오프 되었을 때 에러 발생
    // Driving 가 움직일 경우 에러 발생
    // Driving 가 Limit를 벗어날 경우 에러 발생: 30mm
    bool    bFrontAMPEnable = TmpHwInfo.IO.Axis1AmpOn;
    bool    bFrontIsRunning = TmpHwInfo.IO.Axis1Running;
    bool    bRearAMPEnable      = TmpHwInfo.IO.Axis2AmpOn;
    bool    bRearIsRunning      = TmpHwInfo.IO.Axis2Running;

    //2 원점 틀어짐 확인

//  if( nTmpError==NO_ERR   &&  bFrontAMPEnable         == false    )   nTmpError   = ERR_DRIVING_NOTORIGIN+1000;   //@todo: 서보 오프 에러 추가 필요
//  if( nTmpError==NO_ERR   &&  bFrontIsRunning         == true     )   nTmpError   = ERR_DRIVING_NOTORIGIN+2000;   //@todo: 서보 오프 에러 추가 필요
//
//  if( nTmpError==NO_ERR   &&  m_pDrivingAxis->IsSyncControl() == true )   // 전후륜 구동일 경우
//  {
//      if( nTmpError==NO_ERR   &&  bRearAMPEnable      == true     )   nTmpError   = ERR_DRIVING_NOTORIGIN+4000;   //@todo: 서보 오프 에러 추가 필요
//      if( nTmpError==NO_ERR   &&  bRearIsRunning      == true     )   nTmpError   = ERR_DRIVING_NOTORIGIN+5000;   //@todo: 서보 오프 에러 추가 필요
//  }

     //Slope에서 모터관련 에러일 경우 브레이크 동작
//	if((TmpHwInfo.Axis1.nError !=NO_ERR) ||  (TmpHwInfo.Axis2.nError !=NO_ERR))
//	{
//		if(m_pDrivingAxis->IsBrakeReleased()==true)
//		{
//			ADD_LOG("SetBrakeRelease Amp Fault");
//			m_pDrivingAxis->SetBrakeRelease(false);
//		}
//	}
//	//슬로프에서 일반적인 에러일 경우 or 기동 Off일 경우, 내부제한 토크 설정.
//	else
//	{
//		if((bFrontIsRunning ==false) && (bRearIsRunning==false))
//		{
//			if(m_pServoControl->IsSetInnerLimitTorque_90() ==false)
//			{
//				m_pServoControl->SetInnerLimitTorque_90();
//				ADD_LOG("SetInnerLimitTorque_90 Amp Fault");
//			}
//		}
//	}


    if(nTmpError    != NO_ERR)
    {
        setMarkStatusFalse();
        return nTmpError;
    }

    return nTmpError;
}


/**
@brief   항시 이상 상태 확인
@author  ehoto
@date    2013.02.07
@return  문제 있을 경우 에러 반환, 그 외에는 NO_ERR(0) 반환
*/
UINT DrivingControl::CheckAlways(void)
{

	DRIVING_HW_INFO_SET TmpHwInfo;

#if((OHT_NAME == OHT_NAME_STD_V81S) ||(OHT_NAME == OHT_NAME_STD_V80)||(OHT_NAME == OHT_NAME_STD_V81))
	static DWORD dwLastTimeOfFoupCoverOpenDetect = timeGetTime();
	static DWORD dwLastTimeOfFoupDetectWarnning = timeGetTime();
	DWORD dwFoupCoverOpenDetectCheckTime = 200;
	bool bFoupCoverOpenDetect = pHWSet->m_pFoupCoverOpenDetect->IsDetect();
	static bool bPreFoupCoverOpenDetect = pHWSet->m_pFoupCoverOpenDetect->IsDetect();
	static PATH_DIRECTION_INFO TempPreFoupCoverDectect = PATH_DIRECTION_NO_USE;

	static DWORD dwLastTimeOfDrivingDetectWarnning = timeGetTime();
	static int nLastTimeOfDrivingDetectWarnning = 0;

	bool bShiftHome = pHWSet->m_pShiftAxis->IsShiftHome();
	static bool bPreShiftHome = pHWSet->m_pShiftAxis->IsShiftHome();
	bool bHoistHome = pHWSet->m_pHoistAxis->IsHoistHome();
	static bool bPreHoistHome = pHWSet->m_pHoistAxis->IsHoistHome();

	bool bFOUPDetect = pHWSet->m_pInnerFoup->IsFoupDetect();
	static bool bPreFOUPDetect = pHWSet->m_pInnerFoup->IsFoupDetect();
#endif

    if( m_StatusSet.bIsOnProcess==true)
	{
		TmpHwInfo = m_InfoSet.HwInfo;
    }
    else
	{
        TmpHwInfo = getHWInfo();
    }

    // Mark //
	MARK_TYPE   MarkType        = m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.MarkType;
	int         nCurrNodeID  	= m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode;
    int         nCurrStationID  = m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uStation;

    bool bNodeOn                = TmpHwInfo.IO.NodeOn;
    bool bTagStationFrontOn = TmpHwInfo.IO.TagStationFrontOn;
    bool bTagStationRearOn  = TmpHwInfo.IO.TagStationRearOn;


    // QR Sensor 확인 //
	static  bool    bQROnTriger = false;
    static  int     bCountOfQRNG    = 0;
	static  DWORD   dwQRTrigerTime  = timeGetTime();

    DWORD       dwCurrTime  = timeGetTime();
	UINT        nTmpError   = NO_ERR;

    QR_Reader   *pQRR;
    int         nID     = 0x00;
    double      dOffset = 0.0;

    bool        bFrontOnMarkPosition    = false;
    bool        bRearOnMarkPosition 	= false;

    // [ STEERING ] //
    bool    bSteerFrontLeft = TmpHwInfo.IO.SteerFrontLeftInOn;
    bool    bSteerFrontRight    = TmpHwInfo.IO.SteerFrontRightInOn;
    bool    bSteerRearLeft      = TmpHwInfo.IO.SteerRearLeftInOn;
    bool    bSteerRearRight = TmpHwInfo.IO.SteerRearRightInOn;

    // [ DRIVING ] //
    bool    bFrontAMPEnable = TmpHwInfo.IO.Axis1AmpOn;
    bool    bFrontIsRunning = TmpHwInfo.IO.Axis1Running;
    bool    bRearAMPEnable      = TmpHwInfo.IO.Axis2AmpOn;
    bool    bRearIsRunning      = TmpHwInfo.IO.Axis2Running;

    double dFrontAxisCurrPos    = TmpHwInfo.Axis1.dCurrPos;
    double dRearAxisCurrPos = TmpHwInfo.Axis2.dCurrPos;
    double dFrontAxisMarkPos    = m_InfoSet.Position.Mark.dFrontPosition;
    double dRearAxisMarkPos = m_InfoSet.Position.Mark.dRearPosition;

	double dFrontAxisSpeed  = TmpHwInfo.Axis1.dSpeed;
	double dRearAxisSpeed       = TmpHwInfo.Axis2.dSpeed;

	// [ SHUTTER ] //
	bool bShutterFrontOpen = pHWSet->m_pShutter->IsOpen(FRONT);
	bool bShutterFrontClose = pHWSet->m_pShutter->IsClose(FRONT);
	bool bShutterRearOpen = pHWSet->m_pShutter->IsOpen(REAR);
	bool bShutterRearClose = pHWSet->m_pShutter->IsClose(REAR);
	bool bShutterBothOpen = bShutterFrontOpen & bShutterRearOpen;
	bool bShutterBothClose = bShutterFrontClose & bShutterRearClose;

    static bool bPreFrontIsRunning = false;
	int     nOBSStatus = TmpHwInfo.IO.ObsStatus;
	int     nDetectStatus = TmpHwInfo.IO.DetectStatus;
    static  DWORD   dwStartOnDetectTime = timeGetTime();
    static bool bStartOnDetect = false;

	static int nMarkCheckCount = 0;

	static  DWORD   dwRearServoOffTime = timeGetTime();

	static  DWORD   dwTurnoffTime = timeGetTime();
	static   DWORD   dwLastTimeOfTriggerOn = timeGetTime();

	static DWORD dwCheckMoveAbnormalBack = timeGetTime();

//	int tmpCurrenrtNodeID;  //김태균
//	static  DWORD   dwCIDMonitoringTrigerTime  = timeGetTime();
//	static  int     bCountOfCID    = 0;
//	static  int     bCountOfCIDLink    = 0;
//	static  int     bCountOfCIDDualOccup    = 0;

	static double nPreOffset = 0.0	;


//사전동작 기능


	if(m_defualtparam->PreShutter)
	{
		static int nCountOfShutterDiff		= 0;
		static int nCountOfShutterNotClose	= 0;
		static int nCountOfShutterNotOpen	= 0;

		static DWORD dwLastTimeOfShutterClose = timeGetTime();
		static DWORD dwLastTimeOfShutterOpen = timeGetTime();


		// 2 [ SHUTTER ]
		// SHUTTER 열림 닫힘 센서가 둘다 On 이면 에러 발생
		// SHUTTER 열림 닫힘 센서가 둘다 Off 이면 에러 발생
		// FOUP 있을 때 닫혀 있지 않으면 에러 발생
		// FOUP 없을 때 열려 있지 않으면 에러 발생

		//사전 동작 및 Close 동작중이 아닐 경우만 항시 Check할것.
		if((m_StatusSet.bIsOnProcess==true) && (m_StatusSet.byStatus==STS_GOING) && (m_StatusSet.uStep > DRIVING_CTRL_STEP_GO_PREPARE))
		{
			if((m_bShutterOpenFlag ==false) && (m_bShutterCloseFlag == false))
			{

				if(bShutterFrontOpen == bShutterFrontClose || bShutterRearOpen == bShutterRearClose)
				{
					nCountOfShutterDiff++;
					if(nCountOfShutterDiff > 30)
					{
						nCountOfShutterDiff = 0;
						ERR_LOG("CheckAbnormal : ERR_SHUTTER_DIFFSTATUS");
						return ERR_SHUTTER_DIFFSTATUS;
					}
				}
				else
					nCountOfShutterDiff = 0;
			}


			//////Close 무시 구간.
			if(m_bShutterCloseFlag == true)
			{

				if(OHTUTILITY::PreventOverflowGetTimeMs(dwLastTimeOfShutterClose) < 3000)
				{
					if(m_bShutterCloseMovingFlag == true)
					{
					   if(pHWSet->m_pShutter->IsInposition(BOTH))
					   {
                          	pHWSet->m_pShutter->SendCloseCmd();
							ADD_LOG("[PreTrans-m_bShutterCloseMovingFlag] Shutter Close");
							m_bShutterCloseMovingFlag = false;
					   }
					}
					else
                   		CheckShutterClose(dFrontAxisSpeed);
				}
				else
					m_bShutterCloseFlag = false;

			}
			else  // Close 명령관련된 부분이 아닐때만 확인.
			{
				dwLastTimeOfShutterClose = timeGetTime();
				m_bShutterCloseMovingFlag = false;

				if(m_bShutterOpenFlag ==false)
				{
					if(IsInnerFoup() == true && bShutterBothClose == false)
					{
						nCountOfShutterNotClose++;
						if(nCountOfShutterNotClose > 40)   //inner Foup 에러 발생 채터링과 동기화처리
						{
							nCountOfShutterNotClose = 0;
							ERR_LOG("CheckAbnormal: ERR_SHUTTER_NOT_CLOSE");
							ADD_FDC_LOG("ERR/%d/2/9/%06d/%06d/%d/%d/%06d/%d/%d/%d/%d",
										ERR_SHUTTER_NOT_CLOSE,
										m_pOHTMainStatus->StatusCommon.CurNodeID,
										m_pExecuteInfo->ExecutePositionInfo.NextNode,
										m_pOHTMainStatus->StatusCommon.CurNodeOffset,
										m_pOHTMainStatus->StatusCommon.ExistFoup,
										m_pOHTMainStatus->StatusCommon.StopStationID,
										bShutterFrontOpen,
										bShutterFrontClose,
										bShutterRearOpen,
										bShutterRearClose);
							return ERR_SHUTTER_NOT_CLOSE;
						}
					}
					else
						nCountOfShutterNotClose = 0;
				}
			}

		   //사전 동작 시는 무시함...
			if(m_bShutterOpenFlag ==false)  //사전 동작. Open관련 명령이 없을 경우만  Check
			{
				dwLastTimeOfShutterOpen  = timeGetTime();

				if(IsInnerFoup() == false && bShutterBothOpen == false)
				{
					nCountOfShutterNotOpen++;
					if(nCountOfShutterNotOpen > 40)   //inner Foup 에러 발생 채터링과 동기화처리
					{
						nCountOfShutterNotOpen = 0;
						ERR_LOG("CheckAbnormal: ERR_SHUTTER_NOTORIGIN");
						ADD_FDC_LOG("ERR/%d/8/9/%06d/%06d/%d/%d/%06d/%d/%d/%d/%d",
									ERR_SHUTTER_NOTORIGIN,
									m_pOHTMainStatus->StatusCommon.CurNodeID,
									m_pExecuteInfo->ExecutePositionInfo.NextNode,
									m_pOHTMainStatus->StatusCommon.CurNodeOffset,
									m_pOHTMainStatus->StatusCommon.ExistFoup,
									m_pOHTMainStatus->StatusCommon.StopStationID,
									bShutterFrontOpen,
									bShutterFrontClose,
									bShutterRearOpen,
									bShutterRearClose);
						return ERR_SHUTTER_NOTORIGIN;
					}
				}
				else
					nCountOfShutterNotOpen = 0;
			}

			nTmpError =CheckShutterAlarm();
			if(nTmpError!=NO_ERR)return nTmpError;

		}
		else
		{
			dwLastTimeOfShutterClose = timeGetTime();
			m_bShutterCloseMovingFlag = false;
		}
	 }


	CID_Monitor_Status(&Info);

    // 정위치 아닐 경우 에러 발생: 주행 Tag / 이적재 Tag / QR Tag 별 처리 필요 - 정위치 Type 상태 정보 필요
    // 정지 위치에서 특정 거리만큼 차이 발생 시 에러 발생: 엔코더 값을 이용한 확인
    // 정지 후 리미트 초과 시 에러 발생: 추가 논의 필요 - 리미트 설정 하고 싶지 않음

    //1 파라미터 정보 확인 및 업데이트
    if(m_StatusSet.bIsOnProcess==false)
    {
        updateParameter();
    }


	//대차감지시 감속도 설정 부분 puting 20190421
	if((m_StatusSet.bIsOnProcess==false)||(m_InfoSet.EventAndState.State.MarkArea==true))  // 마크단계 3.5m/s^2 적용해야되는 시점
	{
		if(pHWSet->GetAMCDetectStopDecelDownStatus() == 1) // 0.5m/s^2 일 경우,
		{
			m_pDrivingAxis->SetDetectStopDecelDown();   //3.5m/s^2로 설정 -> 0으로
		}
	}
	else  //주행단계 0.5 적용해야되는 시점.
	{
		if(pHWSet->GetAMCDetectStopDecelDownStatus() == 0) //3.5m/s^2 일 경우
		{
			m_pDrivingAxis->SetDetectStopDecelDownRelease();   //0.5m/s^2로 설정 -> 1로
		}
	}

    //1 0. 위치 정보 Update
	  if(m_StatusSet.bIsOnProcess==false && m_PositionInfo.Marked==false && m_StatusSet.byStatus!=STS_INIT)
	  {
			if(fabs(dFrontAxisSpeed) > DRIVING1_ABNOMARL_MOVE_SPEED_LIMIT)
			{
				  if(OHTUTILITY::PreventOverflowGetTimeMs(dwLastTimeOfTriggerOn) > 100)
				  {
						ERR_LOG("DrivingFrontSpeed :%f",dFrontAxisSpeed);
						m_InfoSet.Control.IdReader[0] = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;  // Stop Tag
						dwLastTimeOfTriggerOn = timeGetTime();
						nTmpError = controlAll(m_InfoSet.Control);
				  }
			}

		getPostionInfoOnManual(TmpHwInfo,&m_PositionInfo);
	  }

		//빼냄과 투입은 항시 감시해야됨.
	nTmpError =checMTLTakeIn(TmpHwInfo);
	if(nTmpError!=NO_ERR)return nTmpError;

	nTmpError =checMTLTakeOut(TmpHwInfo);
	if(nTmpError!=NO_ERR)return nTmpError;


	if(m_StatusSet.byStatus!=STS_TURN_OFF) dwTurnoffTime = timeGetTime();

	//1 1. 자동 복구
	//2     Rear OFF  기동 off에 관련된 부분
	if((((m_StatusSet.byStatus==STS_TURN_OFF) || (m_StatusSet.byStatus==STS_INIT)|| (m_StatusSet.byStatus==STS_AUTORECOVERY_OVERRUN) ||(m_StatusSet.byStatus==STS_AUTORECOVERY) ||(m_StatusSet.byStatus==STS_AUTORECOVERY_BLANKTRANS)||(m_StatusSet.byStatus==STS_AUTORECOVERY_DOUBLETRANS)) ||   //기동 상태
		((m_StatusSet.bIsOnProcess==true) && (m_StatusSet.byStatus==STS_GOING) &&
		((TmpHwInfo.IO.DetectStatus==DETECT_AND_STOP) || (TmpHwInfo.IO.ObsStatus==DETECT_AND_STOP) ||
		(m_pExecuteInfo->bTpPause != false) || (m_pExecuteInfo->bOcsPause != false) || (pHWSet->m_pCID->GetCIDPause() != false))))   //대차감지 상태일때
	&&	(m_pExecuteInfo->ExecuteMode == EXECUTE_MODE_AUTO)
	&&  m_pDrivingAxis->IsSyncControl() == true
	&&  bFrontAMPEnable == true
	&&  bFrontIsRunning == false
	&&  bRearAMPEnable  == true
	&&  bRearIsRunning  == false
	&&  m_cSlopeNodeInfo !=SLOPE_NTYPE
	)
	{

		if(OHTUTILITY::PreventOverflowGetTimeMs(dwRearServoOffTime) > 10000)
		{
			ERR_LOG("SetSlaveAMPEnable Auto Off");
			m_pDrivingAxis->SetSlaveAMPEnable(false);
		}
	}
	else
	{
		//MTL Lifter 고려할것.
		if(((m_StatusSet.bIsOnProcess==true) && (m_StatusSet.byStatus==STS_GOING) &&
		   (TmpHwInfo.IO.DetectStatus!=DETECT_AND_STOP) &&(TmpHwInfo.IO.ObsStatus!=DETECT_AND_STOP) &&
		   (m_pExecuteInfo->bTpPause == false) && (m_pExecuteInfo->bOcsPause == false) && (pHWSet->m_pCID->GetCIDPause() == false))   //대차감지 상태일때
		&&  m_pDrivingAxis->IsSyncControl() == true
		&&  bRearAMPEnable  == false
		&&  bRearIsRunning  == false
		&&  ((m_StatusSet.uStep > DRIVING_CTRL_STEP_GO_FIRST_NODE) &&  (m_StatusSet.uStep < DRIVING_CTRL_STEP_GO_CHECK_STOP))
		)
		{

			if(OHTUTILITY::PreventOverflowGetTimeMs(dwRearServoOffTime)> 1000)
			{
				ERR_LOG("SetSlaveAMPEnable Auto ON");
				m_pDrivingAxis->SetSlaveAMPEnable(true);
			}
		}
		else
		{
			dwRearServoOffTime = timeGetTime();
		}
	}


     // 1. 주행 중 Break 상태 확인하는 부분
//	if(m_StatusSet.byStatus==STS_GOING)
//	{
//		if(m_pDrivingAxis->IsBrakeReleased()==false)
//		{
//           if((bFrontIsRunning ==true) || (bRearIsRunning==true))
//		   {
//				m_pDrivingAxis->SetBrakeRelease(true);
//		   }
//		}
//	}
//	  // 2. 에러 Or 기동 Off시  break 사용/ 내부제한토크 선택적으로 사용할것.
	if((m_StatusSet.byStatus==STS_ERROR) || (m_StatusSet.byStatus==STS_TURN_OFF))
	{
//		if((cSlopeNodeInfo ==NODE_SLOPE)  || (m_StatusSet.bIsOnProcess==false))
		if((m_cSlopeNodeInfo ==SLOPE_NTYPE) || (m_cSlopeNodeInfo ==INIT_NTYPE) ||
		   (m_pExecuteInfo->bJogInterlockIgnore == true))
		{
			//Slope에서 모터관련 에러일 경우 브레이크 동작
			if((TmpHwInfo.Axis1.nError !=NO_ERR) ||  (TmpHwInfo.Axis2.nError !=NO_ERR))
			{
				if(m_pDrivingAxis->IsBrakeReleased()==true)
				{
					ADD_LOG("SetBrakeRelease Amp Fault");
					m_pDrivingAxis->SetBrakeRelease(false);
				}
			}
			//슬로프에서 일반적인 에러일 경우 or 기동 Off일 경우, 내부제한 토크 설정.
			else
			{
				if((bFrontIsRunning ==false) && (bRearIsRunning==false))
				{
					DWORD dwCurrTime  = timeGetTime();
					//SetInnerLimitTorque_90 자체 800ms Sleep있으므로 2회 Retry 가능하도록 500ms->1000ms로 변경  #Jrespect.im
					while(OHTUTILITY::PreventOverflowGetTimeMs( dwCurrTime)<1000)             //20191104 KDS
					{
						if(m_pServoControl->IsSetInnerLimitTorque_90() == true)
							break;

						m_pServoControl->SetInnerLimitTorque_90();   //DrivingControl::CheckAlways Retry Error 처리 0
						ADD_LOG("SetInnerLimitTorque_90 Amp Fault");
						Sleep(5);
					}

					if(m_pServoControl->IsSetInnerLimitTorque_90() == false)
					{
					  // nTmpError = ERR_SERVO_DRIVING_ALARM;
					   ADD_LOG("[CheckAlways] Fail SetInnerLimitTorque_90");
					}
					else
					{
						//ERR_LOG("[CheckAlways] Success SetInnerLimitTorque_90");
					}
				}
			}
		}
//		else
//		{
//			if((bFrontIsRunning ==false) && (bRearIsRunning==false))
//			{
//				if(m_pServoControl->IsSetInnerLimitTorque_90() ==false)
//				{
//					m_pServoControl->SetInnerLimitTorque_90();
//					ADD_LOG("SetInnerLimitTorque_90 Amp Fault");
//				}
//			}
//		}

	}
    // 축 에러 확인
    nTmpError = TmpHwInfo.Axis1.nError;
    if(nTmpError!=NO_ERR)return nTmpError;

    if( m_pDrivingAxis->IsSyncControl() == true )
    {
        nTmpError = TmpHwInfo.Axis2.nError;
        if(nTmpError!=NO_ERR)return nTmpError;
    }


	if((m_pExecuteInfo->ExecuteMode == EXECUTE_MODE_MANUAL) && (m_pExecuteInfo->bJogInterlockIgnore == true))
	{
		return NO_ERR;
	}
	if((m_pExecuteInfo->ExecuteMode == EXECUTE_MODE_MANUAL) && (m_pOHTMainStatus->DataUseFlag.fUBGLoad == false))
	{
		m_pOHTMainStatus->DataUseFlag.fUBGLoad = 0xff;
		return ERR_UBG_NO_DATA;
	}

    //1 2. Mark 해제
    //2     Marked 해제: 센서 가 들어오지 않을 경우
    if( getMarkStatus() == true
//  &&  m_StatusSet.bIsOnProcess==false
	&&  (m_StatusSet.byStatus!=STS_GOING)
    )
	{
        switch(MarkType)
        {
		case MARK_TYPE_NODE:
            if(bNodeOn == OFF)
            {
				ERR_LOG("[ERR_MARK_FAIL:Node]MarkType: %d, Status:%d, OnProcess:%d [%d:%d:%d]"
                    , MarkType, m_StatusSet.byStatus, m_StatusSet.bIsOnProcess
                    , bNodeOn, m_InfoSet.HwInfo.IO.NodeOn, m_pDrivingTag->IsOn());
				ADD_FDC_LOG("ERR/%d/2/8/%06d/%06d/%d/%d/%06d/%d/%d/%d",
							ERR_MARK_FAIL,
							m_pOHTMainStatus->StatusCommon.CurNodeID,
							m_pExecuteInfo->ExecutePositionInfo.NextNode,
							m_pOHTMainStatus->StatusCommon.CurNodeOffset,
							m_pOHTMainStatus->StatusCommon.ExistFoup,
							m_pOHTMainStatus->StatusCommon.StopStationID,
							MarkType,
							m_StatusSet.byStatus,
							m_StatusSet.bIsOnProcess);

				nMarkCheckCount++;
				//에러는 미처리하며 로그만 찍음. (엔코더는 정상이고, BCR데이터는 읽힌 이후이나 반사판이 미인식된경우)

//				if(nMarkCheckCount == 3)
//					setMarkStatusFalse();
				if(m_bFDCMarkFailFlag == true)
				{
					SEND_WARN("WARN/52/1/8/%06d/%06d/%d/%d/%06d/%d/%d/%d",
							m_pOHTMainStatus->StatusCommon.CurNodeID,
							m_pExecuteInfo->ExecutePositionInfo.NextNode,
							m_pOHTMainStatus->StatusCommon.CurNodeOffset,
							m_pOHTMainStatus->StatusCommon.ExistFoup,
							m_pOHTMainStatus->StatusCommon.StopStationID,
							MarkType,
							m_StatusSet.byStatus,
							m_StatusSet.bIsOnProcess);
					m_bFDCMarkFailFlag = false;
				}

            }
            break;

		case MARK_TYPE_TAG_STATION:
		case MARK_TYPE_TAG_STATION_BACK:
//			if( bTagStationFrontOn  == OFF  ||
//				bTagStationRearOn   == OFF      )
			if( bTagStationFrontOn  == OFF  ||
			   ((bTagStationRearOn   == OFF)  &&   //리커버리 동작하지 않을떄는 거리값도 같이봄, 리커버리 동작했을때는 센서만 체크함.
				(((m_bIsRecovery==false) && (fabs(dFrontAxisCurrPos - m_dStationMarkInpos) > m_pParamSet->StationMarkInPos))||
				 (m_bIsRecovery==true)))
				)
			{
				ERR_LOG("[ERR_MARK_FAIL:Tag]MarkType: %d, Status:%d, OnProcess:%d F[%d:%d:%d]R[%d:%d:%d][%f,%f,%f]"
                    , MarkType, m_StatusSet.byStatus, m_StatusSet.bIsOnProcess
                    , bTagStationFrontOn, m_InfoSet.HwInfo.IO.TagStationFrontOn, m_pTransStopTag->IsOnFrontSensor()
					, bTagStationRearOn, m_InfoSet.HwInfo.IO.TagStationRearOn, m_pTransStopTag->IsOnRearSensor(),
					(dFrontAxisCurrPos - m_dStationMarkInpos),dFrontAxisCurrPos,m_dStationMarkInpos);

				nMarkCheckCount++;

				if(nMarkCheckCount == 50)
				{
					setMarkStatusFalse();
					ADD_FDC_LOG("ERR/%d/3/8/%06d/%06d/%d/%d/%06d/%d/%d/%d",
								ERR_MARK_FAIL,
								m_pOHTMainStatus->StatusCommon.CurNodeID,
								m_pExecuteInfo->ExecutePositionInfo.NextNode,
								m_pOHTMainStatus->StatusCommon.CurNodeOffset,
								m_pOHTMainStatus->StatusCommon.ExistFoup,
								m_pOHTMainStatus->StatusCommon.StopStationID,
								MarkType,
								m_StatusSet.byStatus,
								m_StatusSet.bIsOnProcess);
				}

				if((m_bFDCMarkFailFlag == true) && (nMarkCheckCount == 30))
				{
					SEND_WARN("WARN/52/2/8/%06d/%06d/%d/%d/%06d/%d/%d/%d",
							m_pOHTMainStatus->StatusCommon.CurNodeID,
							m_pExecuteInfo->ExecutePositionInfo.NextNode,
							m_pOHTMainStatus->StatusCommon.CurNodeOffset,
							m_pOHTMainStatus->StatusCommon.ExistFoup,
							m_pOHTMainStatus->StatusCommon.StopStationID,
							MarkType,
							m_StatusSet.byStatus,
							m_StatusSet.bIsOnProcess);
					m_bFDCMarkFailFlag = false;
				}
			}
			else
				nMarkCheckCount = 0;

            break;

        }

        if(getMarkStatus()==false)
        {
            ERR_LOG("[ERR_MARK_FAIL]MarkType: %d, Status:%d, OnProcess:%d",MarkType, m_StatusSet.byStatus, m_StatusSet.bIsOnProcess);
			bCountOfQRNG = 0;

			if(MarkType == MARK_TYPE_NODE)
				nTmpError   = ERR_MARK_FAIL_DRIVING;
			if((m_StatusSet.byStatus==STS_ARRIVED) || (m_StatusSet.byStatus==STS_UNLOADED) || (m_StatusSet.byStatus==STS_LOADED))
               	nTmpError   = ERR_MARK_FAIL;
			else
				nTmpError   = ERR_MARK_FAIL_TRANS;

			ADD_FDC_LOG("ERR/%d/1/8/%06d/%06d/%d/%d/%06d/%d/%d/%d",
						nTmpError,
						m_pOHTMainStatus->StatusCommon.CurNodeID,
						m_pExecuteInfo->ExecutePositionInfo.NextNode,
						m_pOHTMainStatus->StatusCommon.CurNodeOffset,
						m_pOHTMainStatus->StatusCommon.ExistFoup,
						m_pOHTMainStatus->StatusCommon.StopStationID,
						MarkType,
						m_StatusSet.byStatus,
						m_StatusSet.bIsOnProcess);

            return  nTmpError;  //@todo: 마크가 틀어진 에러
        }
    }
	else
    {
        bQROnTriger=false;
		nMarkCheckCount = 0;
    }

    //2 Mark 해제: 정위치에서 오차 범위 이상 벗어날 경우
    if(getMarkStatus()==true
//  && m_StatusSet.bIsOnProcess==false
	&&  (m_StatusSet.byStatus!=STS_GOING)
    )
    {
        bFrontOnMarkPosition    = (fabs(dFrontAxisCurrPos-dFrontAxisMarkPos)
                                < DIST_LIMIT_OF_FRONT_ON_WAIT)?true:false;
        if( m_pDrivingAxis->IsSyncControl() == true )
		{
            bRearOnMarkPosition = (fabs(dRearAxisCurrPos-dRearAxisMarkPos)
                                < DIST_LIMIT_OF_REAR_ON_WAIT)?true:false;
        }
        else
        {
            bRearOnMarkPosition = true;
        }

        if(bFrontOnMarkPosition==false  ||  bRearOnMarkPosition==false)
        {
            setMarkStatusFalse();
            nTmpError               = ERR_DRIVING_NOTORIGIN;
            ERR_LOG("MarkType: %d, F(%d:%6.1lf:%6.1lf)R(%d:%6.1lf:%6.1lf)"
                , MarkType
                , bFrontOnMarkPosition, dFrontAxisCurrPos, dFrontAxisMarkPos
                , bRearOnMarkPosition, dRearAxisCurrPos, dRearAxisMarkPos
                );
			ADD_FDC_LOG("ERR/%d/1/5/%06d/%06d/%d/%d/%06d",
						ERR_DRIVING_NOTORIGIN,
						m_pOHTMainStatus->StatusCommon.CurNodeID,
						m_pExecuteInfo->ExecutePositionInfo.NextNode,
						m_pOHTMainStatus->StatusCommon.CurNodeOffset,
						m_pOHTMainStatus->StatusCommon.ExistFoup,
						m_pOHTMainStatus->StatusCommon.StopStationID);
            return nTmpError;
        }
    }

	//2 축이 외력에 의해 움직일 경우 에러 발생


	if( m_StatusSet.bIsOnProcess==false )
	{
		if(fabs(dFrontAxisSpeed)>DRIVING1_ABNOMARL_MOVE_SPEED_LIMIT  && bFrontIsRunning==false  )
		{
			if(m_StatusSet.byStatus!=STS_TURN_OFF)
			{
				ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d",
						ERR_DRIVING1_ABNORMAL_MOVING,
						m_pOHTMainStatus->StatusCommon.CurNodeID,
						m_pExecuteInfo->ExecutePositionInfo.NextNode,
						m_pOHTMainStatus->StatusCommon.CurNodeOffset,
						m_pOHTMainStatus->StatusCommon.ExistFoup,
						m_pOHTMainStatus->StatusCommon.StopStationID,
						fabs(dFrontAxisSpeed));
				return ERR_DRIVING1_ABNORMAL_MOVING;
			}
			else
			{

			   if(OHTUTILITY::PreventOverflowGetTimeMs(dwTurnoffTime) > 5000)
			   {
					ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d",
						ERR_DRIVING1_ABNORMAL_MOVING,
						m_pOHTMainStatus->StatusCommon.CurNodeID,
						m_pExecuteInfo->ExecutePositionInfo.NextNode,
						m_pOHTMainStatus->StatusCommon.CurNodeOffset,
						m_pOHTMainStatus->StatusCommon.ExistFoup,
						m_pOHTMainStatus->StatusCommon.StopStationID,
						fabs(dFrontAxisSpeed));
                	return ERR_DRIVING1_ABNORMAL_MOVING;
			   }
			}
		}
	}

    if( m_StatusSet.bIsOnProcess==false &&  m_pDrivingAxis->IsSyncControl() ==true )
    {
		if( (fabs(dRearAxisSpeed)>DRIVING2_ABNOMARL_MOVE_SPEED_LIMIT) &&  (bRearIsRunning==false) && (bFrontIsRunning ==false) )
        {
			if(m_StatusSet.byStatus!=STS_TURN_OFF)
			{
				ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d",
						ERR_DRIVING2_ABNORMAL_MOVING,
						m_pOHTMainStatus->StatusCommon.CurNodeID,
						m_pExecuteInfo->ExecutePositionInfo.NextNode,
						m_pOHTMainStatus->StatusCommon.CurNodeOffset,
						m_pOHTMainStatus->StatusCommon.ExistFoup,
						m_pOHTMainStatus->StatusCommon.StopStationID,
						fabs(dRearAxisSpeed));
				return ERR_DRIVING2_ABNORMAL_MOVING;
			}
			else
			{

			   if(OHTUTILITY::PreventOverflowGetTimeMs(dwTurnoffTime) > 5000)
			   {
					ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d",
						ERR_DRIVING2_ABNORMAL_MOVING,
						m_pOHTMainStatus->StatusCommon.CurNodeID,
						m_pExecuteInfo->ExecutePositionInfo.NextNode,
						m_pOHTMainStatus->StatusCommon.CurNodeOffset,
						m_pOHTMainStatus->StatusCommon.ExistFoup,
						m_pOHTMainStatus->StatusCommon.StopStationID,
						fabs(dRearAxisSpeed));
					return ERR_DRIVING2_ABNORMAL_MOVING;
			   }
			}

        }
    }

 	if(( m_StatusSet.bIsOnProcess==true )  && (m_StatusSet.byStatus==STS_GOING) && (m_bOnBackMove ==false)
 	 &&( dFrontAxisSpeed < DRIVING1_ABNOMARL_MOVE_SPEED_LIMIT_BACK))
	{

		ADD_LOG("Ab Move Back Cnt:%f",dFrontAxisSpeed);
		if(OHTUTILITY::PreventOverflowGetTimeMs(dwCheckMoveAbnormalBack) > 100)
		{
			ADD_FDC_LOG("ERR/%d/1/5/%06d/%06d/%d/%d/%06d",
								ERR_DRIVING_CAN_NOT_BECAME_HOME,
								m_pOHTMainStatus->StatusCommon.CurNodeID,
								m_pExecuteInfo->ExecutePositionInfo.NextNode,
								m_pOHTMainStatus->StatusCommon.CurNodeOffset,
								m_pOHTMainStatus->StatusCommon.ExistFoup,
								m_pOHTMainStatus->StatusCommon.StopStationID);
			return ERR_DRIVING_CAN_NOT_BECAME_HOME;
	}
	}
	else
		dwCheckMoveAbnormalBack = timeGetTime();

    //1 4. 센서 이상 확인
    //2 STEERING 이 좌우 2개가 들어왔을 때 에러 발생

	if( (bSteerFrontLeft==true)   && (bSteerFrontRight==true))
	{
		ADD_LOG("SteeringIO:%d%d",bSteerRearLeft,bSteerRearRight);
		ADD_FDC_LOG("ERR/%d/1/9/%06d/%06d/%d/%d/%06d/%d/%d/%d/%d",
					ERR_SEN_ABNORMAL_STEERING_FRONT,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pExecuteInfo->ExecutePositionInfo.NextNode,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					m_pOHTMainStatus->StatusCommon.ExistFoup,
					m_pOHTMainStatus->StatusCommon.StopStationID,
					bSteerRearLeft,bSteerRearRight,bSteerRearLeft,bSteerRearRight);
	    return ERR_SEN_ABNORMAL_STEERING_FRONT;
    }
	if( (bSteerRearLeft==true)    && (bSteerRearRight==true))
	{
		ADD_LOG("SteeringIO:%d%d",bSteerRearLeft,bSteerRearRight);
		ADD_FDC_LOG("ERR/%d/1/9/%06d/%06d/%d/%d/%06d/%d/%d/%d/%d",
					ERR_SEN_ABNORMAL_STEERING_REAR,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pExecuteInfo->ExecutePositionInfo.NextNode,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					m_pOHTMainStatus->StatusCommon.ExistFoup,
					m_pOHTMainStatus->StatusCommon.StopStationID,
					bSteerRearLeft,bSteerRearRight,bSteerRearLeft,bSteerRearRight);
	    return ERR_SEN_ABNORMAL_STEERING_REAR;
	}

	if((m_StatusSet.bIsOnProcess==true) && (m_StatusSet.byStatus==STS_GOING))
	{
		if(m_cSlopeNodeInfo ==SLOPE_NTYPE)
		  m_pExecuteInfo->nHIDPathInfo = EXECUTE_HIDPATH_SLOOP;
		else
		{
			if((m_Dectect_Dir == PATH_DIRECTION_NO_USE) ||(m_Dectect_Dir == PATH_DIRECTION_NORMAL))
				m_pExecuteInfo->nHIDPathInfo = EXECUTE_HIDPATH_LINE;
			else
				m_pExecuteInfo->nHIDPathInfo = EXECUTE_HIDPATH_CURVE;
		}

	}else
	{
		//메뉴얼이 아닐 경우 이전상태 유지.
		if(m_pExecuteInfo->ExecuteMode == EXECUTE_MODE_MANUAL)
			m_pExecuteInfo->nHIDPathInfo = EXECUTE_HIDPATH_NONE;
	}

#if(((OHT_NAME == OHT_NAME_STD_V81S) ||(OHT_NAME == OHT_NAME_STD_V80)||(OHT_NAME == OHT_NAME_STD_V81)) && (SAMSUNG_COMMON_SPEC==ON))
//   ERR_FOUP_COVER_OPEN_DETECT 에러관련 주행시만 감시하도록 변경됨. (센서 위치 변경으로)

	if(TempPreFoupCoverDectect != m_Dectect_Dir)
	{
		TempPreFoupCoverDectect =  m_Dectect_Dir;
		dwLastTimeOfFoupCoverOpenDetect = timeGetTime();
	}

   	if((m_StatusSet.bIsOnProcess==true) && (m_StatusSet.byStatus==STS_GOING) && ( bFoupCoverOpenDetect == true) && (m_bShutterOpenFlag == false) && (m_bShutterCloseFlag ==false))
	{
		if(bPreFoupCoverOpenDetect != bFoupCoverOpenDetect)
		{
			m_DiagManager->IncreasePreviosDiagCount(PREVIOS_DIAG_FC);  //사전로그
			m_mccparam.nFoupCoverDetectCount++;
		}

		if((m_Dectect_Dir == PATH_DIRECTION_NO_USE) ||(m_Dectect_Dir == PATH_DIRECTION_NORMAL))
		{
			dwFoupCoverOpenDetectCheckTime = m_pParamSet->FoupCover.nLineFoupChattering;
			ADD_LOG("[FoupCover] %d %d",dwFoupCoverOpenDetectCheckTime,OHTUTILITY::PreventOverflowGetTimeMs( dwLastTimeOfFoupCoverOpenDetect));     //20191104 KDS
		}
		else
		{
			if((m_Dectect_OBS_Dir ==PATH_OBS_DIRECTION_UTrun_L) || (m_Dectect_OBS_Dir ==PATH_OBS_DIRECTION_UTrun_R))
			{
               dwFoupCoverOpenDetectCheckTime= m_pParamSet->FoupCover.nSPCurveFoupChattering;
			}
			else
			{
				dwFoupCoverOpenDetectCheckTime= m_pParamSet->FoupCover.nCurveFoupChattering;
			}

			ADD_LOG("[FoupCover] %d %d %d",dwFoupCoverOpenDetectCheckTime,OHTUTILITY::PreventOverflowGetTimeMs( dwLastTimeOfFoupCoverOpenDetect),m_Dectect_OBS_Dir);   //20191104 KDS
		}

		if(OHTUTILITY::PreventOverflowGetTimeMs(dwLastTimeOfFoupCoverOpenDetect) > dwFoupCoverOpenDetectCheckTime)
		{
			ADD_LOG("[Err FoupCover] IsDetect : %d, nFoupCoverOpenDetectCount : %d", bFoupCoverOpenDetect, OHTUTILITY::PreventOverflowGetTimeMs( dwLastTimeOfFoupCoverOpenDetect));  //20191104 KDS

			ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d/%d",
						ERR_FOUP_COVER_OPEN_DETECT,
						m_pOHTMainStatus->StatusCommon.CurNodeID,
						m_pExecuteInfo->ExecutePositionInfo.NextNode,
						m_pOHTMainStatus->StatusCommon.CurNodeOffset,
						m_pOHTMainStatus->StatusCommon.ExistFoup,
						m_pOHTMainStatus->StatusCommon.StopStationID,
						bFoupCoverOpenDetect);
			return ERR_FOUP_COVER_OPEN_DETECT;
		}
	}
	else
	{
		dwLastTimeOfFoupCoverOpenDetect = timeGetTime();
	}

	bPreFoupCoverOpenDetect = bFoupCoverOpenDetect;

	if((m_StatusSet.bIsOnProcess==true) && (m_StatusSet.byStatus==STS_GOING) && (bShiftHome == false) && (m_bShutterOpenFlag == false) && (m_bShutterCloseFlag ==false))
	{
		if( bPreShiftHome != bShiftHome)
		{
			m_mccparam.nShiftHomeSenOffCount++;
		}
	}

	bPreShiftHome = bShiftHome;

	if((m_StatusSet.bIsOnProcess==true) && (m_StatusSet.byStatus==STS_GOING) && (bHoistHome == false) && (m_bShutterOpenFlag == false) && (m_bShutterCloseFlag ==false))
	{
		if( bPreHoistHome != bHoistHome)
		{
			m_mccparam.nHoistHomeSenOffCount++;
		}
	}

	bPreHoistHome = bHoistHome;

	if((m_StatusSet.bIsOnProcess==true) && (m_StatusSet.byStatus==STS_GOING) && (bFOUPDetect == true) && (bShutterBothClose == false) && (m_bShutterOpenFlag == false) && (m_bShutterCloseFlag ==false))
	{
		if( bPreFOUPDetect != bFOUPDetect)
		{
			m_mccparam.nInnerFOUPDetectCount++;
		}
	}

	if((m_StatusSet.bIsOnProcess==true) && (m_StatusSet.byStatus==STS_GOING) && (bFOUPDetect == false) && (bShutterBothClose == true) && (m_bShutterOpenFlag == false) && (m_bShutterCloseFlag ==false))
	{
		if( bPreFOUPDetect != bFOUPDetect)
		{
			m_mccparam.nInnerFOUPNotDetectCount++;
		}
	}

	bPreFOUPDetect = bFOUPDetect;

	if((m_StatusSet.bIsOnProcess==true) && (m_StatusSet.byStatus==STS_GOING))
	{
		//주행중 직선패턴일 경우, 장애물/대차감지 센서 감지유무에 따라 로그 추가.
		if(m_Dectect_Dir == PATH_DIRECTION_NORMAL)
		{
			if(!((TmpHwInfo.IO.DetectStatus==DETECT_NONE)&&(TmpHwInfo.IO.ObsStatus!=DETECT_NONE)))
			 	dwLastTimeOfFoupDetectWarnning = timeGetTime();
		}
		else
			dwLastTimeOfFoupDetectWarnning = timeGetTime();

		if(OHTUTILITY::PreventOverflowGetTimeMs(dwLastTimeOfFoupDetectWarnning) > 2000)
		{
			m_DiagManager->IncreasePreviosDiagCount(PREVIOS_DIAG_PS); //사전 로그
			DETECT_LOG("Detect Warnning! Time:%d, Detect:%d, OBS %d",OHTUTILITY::PreventOverflowGetTimeMs(dwLastTimeOfFoupDetectWarnning),TmpHwInfo.IO.DetectStatus,TmpHwInfo.IO.ObsStatus);
			dwLastTimeOfFoupDetectWarnning = timeGetTime();
		}

	}else
		dwLastTimeOfFoupDetectWarnning = timeGetTime();


	 //S1B 이슈내용 관련 적용
	if((m_StatusSet.bIsOnProcess==true) && (m_StatusSet.byStatus==STS_GOING))
	{
		 if((nDetectStatus == DETECT_AND_STOP) &&
		  ((pHWSet->GetAMCStopStatus() != Move_None) && (pHWSet->GetAMCStopStatus() != Move_Stop)) &&
		  (m_StatusSet.uStep ==DRIVING_CTRL_STEP_GO_RUN))
		 {
		 	nLastTimeOfDrivingDetectWarnning++;
			ADD_LOG("[ERR_OHT_DETECT] Abnormal %d %d",pHWSet->GetAMCStopStatus(),nLastTimeOfDrivingDetectWarnning);

		 }
		 else
			nLastTimeOfDrivingDetectWarnning = 0;


		 if(nLastTimeOfDrivingDetectWarnning > 15)
		 {
			ADD_FDC_LOG("ERR/%d/1/5/%06d/%06d/%d/%d/%06d",
						ERR_DRV_MOVE_IN_PBS_UBG_DETECT,
						m_pOHTMainStatus->StatusCommon.CurNodeID,
						m_pExecuteInfo->ExecutePositionInfo.NextNode,
						m_pOHTMainStatus->StatusCommon.CurNodeOffset,
						m_pOHTMainStatus->StatusCommon.ExistFoup,
						m_pOHTMainStatus->StatusCommon.StopStationID);
		 	return ERR_DRV_MOVE_IN_PBS_UBG_DETECT;
		 }
//		 if(OHTUTILITY::PreventOverflowGetTimeMs(dwLastTimeOfDrivingDetectWarnning) > 200)
//		 {
//			return ERR_DRV_MOVE_IN_PBS_UBG_DETECT;
//		 }
	}
	else
		nLastTimeOfDrivingDetectWarnning = 0;

#endif


    // 2014.02.11 By LSJ 장애물이 감지되어 있는데 멈춰 있다가 출발하는 경우 에러 발생
#if(UBG_SENSOR_ENABLE == ON)
	if((bPreFrontIsRunning == false) && (bFrontIsRunning == true)
		&& (((nOBSStatus == DETECT_AND_STOP)&&(m_pOHTDetect->GetStatusLevel() !=7)) || (nDetectStatus == DETECT_AND_STOP)))
#else
	if((bPreFrontIsRunning == false) && (bFrontIsRunning == true) && (nOBSStatus == DETECT_AND_STOP))
#endif
	{

		if(bStartOnDetect == false)
        {
			dwStartOnDetectTime = timeGetTime();
            bStartOnDetect = true;
		}

		if((bStartOnDetect == true) && (m_StatusSet.uStep !=DRIVING_CTRL_STEP_GO_FIRST_NODE) && (OHTUTILITY::PreventOverflowGetTimeMs(dwStartOnDetectTime)>100))
        {
            bStartOnDetect = false;
			ADD_FDC_LOG("ERR/%d/2/5/%06d/%06d/%d/%d/%06d",
						ERR_DRV_MOVE_IN_PBS_UBG_DETECT,
						m_pOHTMainStatus->StatusCommon.CurNodeID,
						m_pExecuteInfo->ExecutePositionInfo.NextNode,
						m_pOHTMainStatus->StatusCommon.CurNodeOffset,
						m_pOHTMainStatus->StatusCommon.ExistFoup,
						m_pOHTMainStatus->StatusCommon.StopStationID);
			return ERR_DRV_MOVE_IN_PBS_UBG_DETECT;
		}
    }
	else
	{
		dwStartOnDetectTime= timeGetTime();
		bStartOnDetect = false;
	}
	bPreFrontIsRunning = bFrontIsRunning;

	return NO_ERR;


}




bool DrivingControl::DeleteCmd(void *pCmd)
{
    bool bReturn = true;
    try
    {
        EXECUTE_DRIVING_INFO    *sTmpDrivingControlInfo = (EXECUTE_DRIVING_INFO *)pCmd;
		ADD_LOG("DeleteCmd(%06d~%06d)"
            , sTmpDrivingControlInfo->BasicInfo.StartNID
            , sTmpDrivingControlInfo->BasicInfo.EndNID
			);

        delete sTmpDrivingControlInfo;
    }
    catch(...)
    {
        bReturn = false;
    }
    return bReturn;
}


/**
@brief   파라미터 로드
@author  임태웅
@date    2013.05.30
@return  성공 하면 파라미터 포인터 리턴, 실패하면 NULL 리턴
*/
void* DrivingControl::LoadParam(char* NewFileNameAndDirectory, char* BackUpFileNameAndDirectory)
{
    bool bSuccess = false;
    DRIVING_PARAM_SET* pTmpParamSet = new DRIVING_PARAM_SET();

    //2 Back Up
    saveParameter(BackUpFileNameAndDirectory ,m_pParamSet);

	//2 Load
    bSuccess = loadParameter(NewFileNameAndDirectory, pTmpParamSet);

    //2 성공 실패 여부 확인
    if( bSuccess == true)
	{
		Reload_QR_Data();
    }
    else
    {
        delete pTmpParamSet;
        pTmpParamSet = NULL;
    }

    return (void*)pTmpParamSet;

}


/**
@brief   파라미터 업데이트 요청
@author  임태웅
@date    2013.05.30
@return  성공 하면 파라미터 포인터 리턴, 실패하면 NULL 리턴
*/
bool DrivingControl::RequestParamUpdate(void* pParameter)
{
    if(pParameter!=NULL)
    {
        m_pTmpParamSet = (DRIVING_PARAM_SET* )pParameter;
        return true;
    }
    else
    {
        return false;
    }
}

/**
@brief   파라미터 업데이트 요청
@author  임태웅
@date    2013.05.30
@return  파라미터가 포인터 리턴, 실패하면 NULL 리턴
*/
bool DrivingControl::IsParamUpdated()
{
    if(m_pTmpParamSet==NULL)
    {
        return true;
    }
    else
    {
        return false;
    }
}

/**
@brief   긴급 정지
@author  ehoto
@date    2012.11.27
@return  EXECUTE_ACK_NO_ERR     // 명령 실행 완료 응답
*/
EXECUTE_ACK DrivingControl::Stop(void)
{
    ERR_LOG("Stop Status:%X, Err:%d, Pos:%7.1lf(%d)"
        , m_StatusSet.byStatus, m_StatusSet.uError
        , m_pDrivingAxis->GetCurrentPosition()
        , m_pDrivingAxis->IsRunning());

	m_StatusSet.byStatus = STS_ERROR;

	m_bOnMapMake = false;
	m_bOnBackMove = false;


	if(m_pExecuteInfo->QuickCmdEStopCommander == ESTOP_BY_TP)
	{
		m_StatusSet.uError = ERR_TP_ESTOP;  // - E_Stop 호출은 OCS 도 가능하므로 내용 추가 필요
	}
	else
	{
		if(m_pExecuteInfo->QuickCmdEStopType == EXIT_ROUTE_OCS_PATH)		    	m_StatusSet.uError = ERR_OCS_ESTOP1;
		else if(m_pExecuteInfo->QuickCmdEStopType == OHT_EXIST_IN_COLLISON_AREA)	m_StatusSet.uError = ERR_OCS_ESTOP2;
		else if(m_pExecuteInfo->QuickCmdEStopType == CARRIER_EXIST_4_UNLOADING)	    m_StatusSet.uError = ERR_OCS_ESTOP3;
		else if(m_pExecuteInfo->QuickCmdEStopType == NOT_CARRIER_4_LOADING)		    m_StatusSet.uError = ERR_OCS_ESTOP4;
		else if(m_pExecuteInfo->QuickCmdEStopType == TRUNOFF_STOP)					m_StatusSet.uError = NO_ERR;
		else if(m_pExecuteInfo->QuickCmdEStopType == TRUNON)						m_StatusSet.uError = NO_ERR;
		else																		m_StatusSet.uError = ERR_OCS_ESTOP5;

		ADD_FDC_LOG("ERR/%d/1/5/%06d/%06d/%d/%d/%06d",
					m_StatusSet.uError,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pExecuteInfo->ExecutePositionInfo.NextNode,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					m_pOHTMainStatus->StatusCommon.ExistFoup,
					m_pOHTMainStatus->StatusCommon.StopStationID);
	}

    stop();

    return EXECUTE_ACK_NO_ERR;
}

/**
@brief   기동 Off
@author  ehoto
@date    2012.11.27
@return  EXECUTE_ACK_NO_ERR     // 명령 실행 완료 응답
*/
EXECUTE_ACK DrivingControl::TurnON(void)
{
    // 상태 정보 초기화
    m_StatusSet.byStatus    = STS_INIT;
    m_StatusSet.uError      = NO_ERR;
    m_StatusSet.uStep       = 0;
}
/**
@brief   기동 Off
@author  ehoto
@date    2012.11.27
@return  EXECUTE_ACK_NO_ERR     // 명령 실행 완료 응답
*/
EXECUTE_ACK DrivingControl::TurnOff(void)
{
    ERR_LOG("Stop Status:%X, Err:%d, Pos:%7.1lf(%d)"
        , m_StatusSet.byStatus, m_StatusSet.uError
        , m_pDrivingAxis->GetCurrentPosition()
        , m_pDrivingAxis->IsRunning());

	m_StatusSet.byStatus = STS_TURN_OFF;//STS_AUTOPOSITION;
	m_pExecuteInfo->bPopListOfCmd = false;

	m_bOnMapMake = false;
	m_bOnBackMove = false;

	if(m_pExecuteInfo->QuickCmdEStopCommander == ESTOP_BY_TP)
	{
		m_StatusSet.uError = ERR_TP_ESTOP;  // - E_Stop 호출은 OCS 도 가능하므로 내용 추가 필요
	}
	else
	{
		if(m_pExecuteInfo->QuickCmdEStopType == EXIT_ROUTE_OCS_PATH)		    	m_StatusSet.uError = ERR_OCS_ESTOP1;
		else if(m_pExecuteInfo->QuickCmdEStopType == OHT_EXIST_IN_COLLISON_AREA)	m_StatusSet.uError = ERR_OCS_ESTOP2;
		else if(m_pExecuteInfo->QuickCmdEStopType == CARRIER_EXIST_4_UNLOADING)	    m_StatusSet.uError = ERR_OCS_ESTOP3;
		else if(m_pExecuteInfo->QuickCmdEStopType == NOT_CARRIER_4_LOADING)		    m_StatusSet.uError = ERR_OCS_ESTOP4;
		else if(m_pExecuteInfo->QuickCmdEStopType == TRUNOFF_STOP)					m_StatusSet.uError = NO_ERR;
		else if(m_pExecuteInfo->QuickCmdEStopType == TRUNON)						m_StatusSet.uError = NO_ERR;
		else																		m_StatusSet.uError = ERR_OCS_ESTOP5;

		ADD_FDC_LOG("ERR/%d/1/5/%06d/%06d/%d/%d/%06d",
					m_StatusSet.uError,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pExecuteInfo->ExecutePositionInfo.NextNode,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					m_pOHTMainStatus->StatusCommon.ExistFoup,
					m_pOHTMainStatus->StatusCommon.StopStationID);
	}

    turnoff();

    return EXECUTE_ACK_NO_ERR;
}

/**
@brief   초기화
@author  ehoto
@date    2012.11.27
@return  EXECUTE_ACK_NO_ERR     // 명령 실행 완료 응답
*/
EXECUTE_ACK DrivingControl::Reset(void)
{
	DWORD   dwCurrTime  = timeGetTime();

	int nNodeIndex = 0;
	NODE_INFO	*pNODE_INFO		= NULL;	// Node 정보
	bool bSlopeCheck = false;
	bool bCheckNode = false;
	
	// 메뉴얼 조치시에만 초기화해 줄 것.
	if((m_StatusSet.byStatus!=STS_AUTORECOVERY) &&
	   (m_StatusSet.byStatus!=STS_AUTORECOVERY_BLANKTRANS) &&
	   (m_StatusSet.byStatus!=STS_AUTORECOVERY_DOUBLETRANS) &&
	   (m_StatusSet.byStatus!=STS_AUTORECOVERY_OVERRUN) &&
	   (m_StatusSet.byStatus!=STS_TURN_OFF) &&
	   (m_pExecuteInfo->ExecuteMode != EXECUTE_MODE_AUTO))
	   {
	   		m_bsecond = false;
			m_CID_Pause = false;
			m_CIDComptFlag = false;  // cid 완료 처리 Flag
			m_CIDComptTryFlag = false;  // cid 완료 처리 시도 Flag
			m_CID_COMMON_bit_off_need = false;
			m_CIDMonitoringFlag = false;
			m_CIDLinkFlag = false;
			m_CIDStatusFlag = false;
			m_CIDStatusPauseFlag = false;
			m_CIDPauseTime = 0;
			m_CID_Status_Pause = false;
			m_Igro_CIDStatusPuaseFlag = false;
			m_bLinkFail = false;
			m_bLinkDisconnected = false;
			m_bInitialLink = false;
			m_CIDDirection = CID_DIRECTION_NOT_LINK;
			m_bCIDNotUse = false;
			m_CIDOperationStarted = false;  // 2016. 12. 23 추가
			m_job_change_flag_no_cid_area = false; //0: not change 1 : change
			m_job_change_flag_exception_CommonTag = false;
			m_CurrCIDStartnode = 0;
			m_sCIDStatus[0]=0;
			m_sCIDStatus[1]=0;
			m_sCIDStatus[2]=0;

			bCountOfCID_Delay    = 0;
			bCountOfCIDLink    = 0; 	   //링크 연결 관련
			m_job_change_without_link_complete = false;
			bCountOfCIDDualOccup	= 0;  //동시진입 관련
			bCountOfCIDComptACK    = 0;  //완료처리 응답 관련

			bDirCIDChage = false;		// 방향전환 전에 완료처리를 함을 나타내는 변수
			tmpStopID = 0;
			memset(&Info, 0, sizeof(CID_CTRL_INFO));
			memset(&CID_4WAY_CONTROL_INFO, 0, sizeof(CID_4WAY_INFO));

			m_CIDNameReadFlag = false;
			m_tmpCurrentResetNode = 0;
			m_tmpCurrentStopNode = 0;
			m_nCIDTerminateCount = 0;
			
			m_Diag_CID_index = 0;
			memset(&m_Diag_CID_R_ID[0][0],'0',sizeof(m_Diag_CID_R_ID));
			memset(&m_Diag_ResetNode[0],0,sizeof(m_Diag_ResetNode));
			memset(&m_Diag_StopNode[0],0,sizeof(m_Diag_StopNode));

			m_nCidControlStep = CID_STEP_CONNECTING;
			pHWSet->m_pCID->CID_Occup_Resume(&m_CID_Pause); //Resume CID Status 
			m_pExecuteInfo->FlagCIDReport.bCIDInterlock= false; //Resume CID Status
			m_pExecuteInfo->FlagCIDReport.bCIDStop= false; //Resume CID Status

  			ADD_LOG("[CID] Reset!!");
			
	   }

    //2 주행  중에는 먹지 않는다.
//#if 0
//  if(m_StatusSet.bIsOnProcess==true)
//  {
//      return EXECUTE_ACK_BUSY;
//  }
//#else
//  if(m_StatusSet.bIsOnProcess==true)
//  {
//      if(m_StatusSet.byStatus==STS_GOING || m_StatusSet.byStatus==STS_ARRIVED)
//      {
//          return EXECUTE_ACK_BUSY;
//      }
//      else
//      {
//          stop();
//      }
//  }
//#endif

	m_bOnMapMake = false;
	m_bOnBackMove = false;

	   //2 Reset Process 시작
    m_StatusSet.bIsOnProcess = true;

    //2 Node 정보 초기화
    if(m_PositionInfo.Marked==false)
    {
		initCommandSet();
		initInfoSet();
		initPreviousArrivalInfo();

		if((m_StatusSet.byStatus!=STS_AUTORECOVERY) &&
	   (m_StatusSet.byStatus!=STS_AUTORECOVERY_BLANKTRANS) &&
	   (m_StatusSet.byStatus!=STS_AUTORECOVERY_DOUBLETRANS) &&
	   (m_StatusSet.byStatus!=STS_AUTORECOVERY_OVERRUN) &&
	   (m_StatusSet.byStatus!=STS_TURN_OFF) &&
	   (m_pExecuteInfo->ExecuteMode != EXECUTE_MODE_AUTO))
	   {
        	memset(&m_PositionInfo, 0x00, sizeof(EXECUTE_POSITION_INFO));
	   }

        //      setCompensationInfo(m_PreviousArrivalInfo);
    }
    else if(    (m_PositionInfo.CurrStation!=0x00)
            &&  (m_PositionInfo.StationType==MARK_TYPE_NODE)
    )
    {
        m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uStation = 0x00;
        m_PositionInfo.CurrStation=0x00;
    }

    //2 조향 초기화
    m_pSteer->Adjust();

	//정위치 경사로 정보 확인
	 if((getMarkStatus() ==true) && (m_PositionInfo.Marked ==true))
	 {
		nNodeIndex =	OHTMainForm->GetMap()->FindNodeIndex(m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode);
		if(nNodeIndex!=INDEX_NONE) pNODE_INFO = &(OHTMainForm->GetMap()->m_NodeArray[nNodeIndex]);		// Node 정보

		if(pNODE_INFO !=NULL)
		{
			if(pNODE_INFO->InOutInfo ==SLOPE_NTYPE)
				bSlopeCheck = true;
			else
				bSlopeCheck = false;
		}
		else
		{
		   bSlopeCheck = true;
		}

		bCheckNode = true;

	 }
	 else if(m_pExecuteInfo->ExecuteMode == EXECUTE_MODE_AUTO)
     {
        if(m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode!=0)
        {
            nNodeIndex =    OHTMainForm->GetMap()->FindNodeIndex(m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode);
            if(nNodeIndex!=INDEX_NONE) pNODE_INFO = &(OHTMainForm->GetMap()->m_NodeArray[nNodeIndex]);        // Node 정보

            if(pNODE_INFO !=NULL)
            {
                if(pNODE_INFO->InOutInfo ==SLOPE_NTYPE)
					bSlopeCheck = true;
                else
                    bSlopeCheck = false;
            }
			else
			{
			   bSlopeCheck = true;
			}
            bCheckNode = true;
        }
     }


    //2 축 초기화
    // 주행 축 서보 오프 및 Reset
   //정위치 상태 구분
   //AOHC-191 Reset시 AMP 초기화 동시 제어 -> 차등 제어로 변경 #JRespect.im 2019.08.06
   if((((getMarkStatus() == false) || (m_PositionInfo.Marked == false)) && (bCheckNode ==false)) ||
      (bSlopeCheck ==true))
	{

	   ADD_LOG("bSlopeCheck Reset");

		if((m_StatusSet.byStatus != STS_INIT) || fabs(m_pDrivingAxis->GetCurrentPosition())>2.0)
		{

				m_pDrivingAxis->SetBrakeRelease(false);
				ADD_LOG("SetBrakeRelease false");

				Sleep(50);   // brake release false 될때까지 대기

				if( fabs(m_pDrivingAxis->GetCurrentPosition())>0.1 || m_pDrivingAxis->GetError()!=NO_ERR)
				{
					 m_pDrivingAxis->SetAMPEnable(false);
					 ADD_LOG("SetAMPEnable false");
					 ADD_LOG("F:%d, R:%d",m_pDrivingAxis->IsAMPEnable(),m_pDrivingAxis->IsSlaveAMPEnable() );

					Sleep(150);   //brake 잡히는데 최소 100mmsec

					if(m_pDrivingAxis->IsSyncControl())
					{

						 m_pDrivingAxis->SetSlaveAMPEnable(false);
						 ADD_LOG("m_pDrivingAxis SetSlaveAMPEnable false");
						 ADD_LOG("F:%d, R:%d",m_pDrivingAxis->IsAMPEnable(),m_pDrivingAxis->IsSlaveAMPEnable() );

						 Sleep(50); //slave amp off 되는데 대기  시간

						 m_pDrivingAxis->Reset();
						 ADD_LOG("m_pDrivingAxis Reset");
						 ADD_LOG("F:%d, R:%d",m_pDrivingAxis->IsAMPEnable(),m_pDrivingAxis->IsSlaveAMPEnable() );


						 m_pDrivingAxis->ResetSlave();
						 ADD_LOG("m_pDrivingAxis ResetSlave");
						 ADD_LOG("F:%d, R:%d",m_pDrivingAxis->IsAMPEnable(),m_pDrivingAxis->IsSlaveAMPEnable() );


						 m_pDrivingAxis->SetHome();
						 ADD_LOG("m_pDrivingAxis SetHome");
						 ADD_LOG("F:%d, R:%d",m_pDrivingAxis->IsAMPEnable(),m_pDrivingAxis->IsSlaveAMPEnable() );


						 m_pDrivingAxis->SetSlaveHome();
						 ADD_LOG("m_pDrivingAxis SetSlaveHome");
						 ADD_LOG("F:%d, R:%d",m_pDrivingAxis->IsAMPEnable(),m_pDrivingAxis->IsSlaveAMPEnable() );
					}
				}
				dwCurrTime  = timeGetTime();
				while(OHTUTILITY::PreventOverflowGetTimeMs(dwCurrTime)<200)       // master, slave reset 완료 판단
				{
					if( fabs(m_pDrivingAxis->GetCurrentPosition())<0.1      &&
						fabs(m_pDrivingAxis->GetSlaveCurrentPosition())<0.1     )
						break;
					Sleep(5);
				}
				if(m_pDrivingAxis->IsSyncControl())
				{
					if(m_pDrivingAxis->IsSlaveAMPEnable()==false)
					{
							m_pDrivingAxis->SetSlaveAMPEnable(true);
							ADD_LOG("SetSlaveAMPEnable true");
							 ADD_LOG("F:%d, R:%d",m_pDrivingAxis->IsAMPEnable(),m_pDrivingAxis->IsSlaveAMPEnable() );
					}
				}
				Sleep(50);   //brake 개방 시간 100mmsec 이하
				if(m_pDrivingAxis->IsAMPEnable()==false)
				{
					m_pDrivingAxis->SetAMPEnable(true);
					ADD_LOG("SetAMPEnable true");
					 ADD_LOG("F:%d, R:%d",m_pDrivingAxis->IsAMPEnable(),m_pDrivingAxis->IsSlaveAMPEnable() );
				}

				dwCurrTime  = timeGetTime();
				while(OHTUTILITY::PreventOverflowGetTimeMs(dwCurrTime)<500)
				{
					if((m_pDrivingAxis->IsAMPEnable() == true)&&(m_pDrivingAxis->IsSlaveAMPEnable() == true))
					{
						m_pDrivingAxis->SetBrakeRelease(true);
						ADD_LOG("SetBrakeRelease & SetSyncControl true");
						 ADD_LOG("F:%d, R:%d",m_pDrivingAxis->IsAMPEnable(),m_pDrivingAxis->IsSlaveAMPEnable() );
						break;
					}
					Sleep(5);
				}
		}
        //SetInnerLimitTorque_90 자체 800ms Sleep있으므로 2회 Retry 가능하도록 1s로 변경  #Jrespect.im
		dwCurrTime  = timeGetTime();
		while(OHTUTILITY::PreventOverflowGetTimeMs(dwCurrTime)<1000)                        //20191104 KDS
		{
			if(m_pServoControl->IsSetInnerLimitTorque_90() == true)
				break;

			m_pServoControl->SetInnerLimitTorque_90(); //DrivingControl::Reset Retry 존재 Error 처리 0
			Sleep(5);
		}
		//Reset 시도 중 Torque Limit설정 Fail했을 경우 Error Clear가 되지 않아 Error처리하지않고 로그만 남김
		if(m_pServoControl->IsSetInnerLimitTorque_90() == false)
		{
			//nTmpError = ERR_SERVO_DRIVING_ALARM;
			//return EXECUTE_ACK_ON_ERR;
			ADD_LOG("[Reset] Fail SetInnerLimitTorque_90");
		}
		else
		{
			//ERR_LOG("[Reset] Success SetInnerLimitTorque_90");
		}


	}
	else
	{
            ADD_LOG("No Reset");
			if( fabs(m_pDrivingAxis->GetCurrentPosition())>0.1 || m_pDrivingAxis->GetError()!=NO_ERR)
			{
				m_pDrivingAxis->SetAMPEnable(false);
			}
			if(m_pDrivingAxis->IsSyncControl())
			{
				if(fabs(m_pDrivingAxis->GetSlaveCurrentPosition())>0.1 || m_pDrivingAxis->GetSlaveError()!=NO_ERR)
					m_pDrivingAxis->SetSlaveAMPEnable(false);
			}

			if( fabs(m_pDrivingAxis->GetCurrentPosition())>0.1 || m_pDrivingAxis->GetError()!=NO_ERR)
				m_pDrivingAxis->Reset();
			if(m_pDrivingAxis->IsSyncControl())
			{
				if(fabs(m_pDrivingAxis->GetSlaveCurrentPosition())>0.1 || m_pDrivingAxis->GetSlaveError()!=NO_ERR)
					m_pDrivingAxis->ResetSlave();
			}

			// 주행 축 원점
			if(fabs(m_pDrivingAxis->GetCurrentPosition())>0.1)
				m_pDrivingAxis->SetHome();
			if(m_pDrivingAxis->IsSyncControl())
			{
				if(fabs(m_pDrivingAxis->GetSlaveCurrentPosition())>0.1)
				m_pDrivingAxis->SetSlaveHome();
			}
			dwCurrTime  = timeGetTime();
			while(OHTUTILITY::PreventOverflowGetTimeMs(dwCurrTime)<200)
			{
				if( fabs(m_pDrivingAxis->GetCurrentPosition())<0.1      &&
					fabs(m_pDrivingAxis->GetSlaveCurrentPosition())<0.1     )
					break;
				Sleep(5);
			}

			// 주행 축 서보 온
			if(m_pDrivingAxis->IsAMPEnable()==false)
			{
				m_pDrivingAxis->SetAMPEnable(true);

			}
    }
	//2 명령 초기화

	//AMC의 경사로 처리 부분 초기화(주행시 재설정됨)
	if(pHWSet->GetAMCTorqueStatus()==RELSLOPE)
	{
     	if(m_pServoControl->IsSetInnerLimitTorque_800() ==true)
			m_pDrivingAxis->SetTorqueLimitRelease();
	}

	m_pDrivingAxis->SetSlopeTimeRelease();
    ////
	//2 Node Count Reset
	m_pDrivingAxis->ClearNodeCountInfo();
//  NODE_CHECK_DATA NodeCheckData;
//  m_pDrivingAxis->GetNodeCountInfo(NodeCheckData);

	//2 근젭제어 Off
	m_Detect.UseFollowControlFlag = false;
	m_Detect.NodeCount = 0;
	m_pDrivingAxis->SetDetectInfo(m_Detect);
//	ADD_LOG("Pre:  Reset");

    init();
	m_StatusSet.uError =    NO_ERR;
	m_StatusSet.bIsOnProcess = false;

	DrivingCMDExuteFunc(false);

    return EXECUTE_ACK_NO_ERR;
}

#define OBS_SENSOR_FAIL_TIMEOVER		3000
#define STEER_IO_CHECK_TIMEOVER			500
#define STEER_IO_CHECK_TIMEOVER2		1000


/**
@brief   Driving 이상여부  확인

    1. 주행 축 알람 확인
      : 주행 축 알람 발생 시 에러 처리

    2. 조향 이상 확인
      ① Map 기준 조향이 왼쪽이나 오른쪽일 때, 현재의 조향 방향과 같지 않고
      ② 조향이 움직이지 않는 상태가 아닌 상태가 10번 이상일 경우 에러 처리함
        (진입 전 조향 변경, 나오면서 사전 조향 변경을 위한 예외 사항)

    3. 주행 TAG 간격 이상 확인
      : 다음 TAG가 Map 기준 대비 400mm 초과될 때가지 나오지 않을 경우 에러 처리

    4. 과속 시 에러 처리
      : 주행 속도가 기준 속도 대비, 0.5m/s 초과될 경우 에러 처리 (V기준 + 0.5m/s)

    5. 레일 Support Home 위치 확인
      : 레일 Support 가 Home 위치가 아닐 경우 에러 처리

@todo 내용 추가 필요 - 기존 코드 참조
@author  ehoto
@date    2012.11.07
@return     nTmpError 를 ㄹ리턴함 (0이면 정상, 아니면 에러)
*/
int DrivingControl::checkError(DRIVING_INFO_SET *pInfoSet)
{
    int     nTmpError   = NO_ERR;

	DWORD   dwCurrTime  = timeGetTime();
	static DWORD dwStaticObsPowerResetTime = 0;
	static bool bObsPowerReset = false;

	UINT    uCurrNode       = pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.uNode;
    double  dCurrOffset = pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset;

    UINT    uLimitNode  = (pInfoSet->Position.CurrentAndTarget.TargetPosition.MarkType==MARK_TYPE_NODE)
						? pInfoSet->Position.CurrentAndTarget.TargetPosition.uNode
                        : pInfoSet->Position.CurrentAndTarget.TargetPosition.uNextNode;

    UINT    uNodeBCR = (UINT)pInfoSet->HwInfo.Node.nBcrId;
	UINT    uStationBCR = (UINT)pInfoSet->HwInfo.TagStaion.nBcrId;

    MARK_TYPE   MarkType    = pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.MarkType;

    static bool bObsCheckArea = false;// AOHC-152 센서 데이터 로그 저장
	double  dSpeedOfNow                 = pInfoSet->HwInfo.Axis1.dSpeed;

    // -----------------------------------------------------------------------------------------------------------
    //1 0.  Mark 시 OverRun 감지
    // -----------------------------------------------------------------------------------------------------------
    if( (nTmpError==NO_ERR)
    &&  (uCurrNode==uLimitNode)
    &&  (pInfoSet->EventAndState.State.MarkArea==true)
    &&  (dCurrOffset>100.0) //1 기준 거리 확정 필요
    )
	{
		MarkType =  m_ClassifiedCmd.TargetInfo.Type;

        switch(MarkType)
        {
            case MARK_TYPE_NODE:
				nTmpError = ERR_NOTMATCH_TAGLENGTH_FINALNODE_MET_LATE;
				break;
            case MARK_TYPE_TAG_STATION:
				nTmpError = ERR_NOTMATCH_TAGLENGTH_FINALSTATION_TAG_MET_LATE;
				break;
            case MARK_TYPE_QR_STATION_LEFT:
				nTmpError = ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_LEFT_MET_LATE;
                break;
            case MARK_TYPE_QR_STATION_RIGHT:
				nTmpError = ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_RIGHT_MET_LATE;
                break;
            default:
				nTmpError = ERR_NOTMATCH_TAGLENGTH_FINALNODE;
				break;
		}
		ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d/%6.1lf",
					nTmpError,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pExecuteInfo->ExecutePositionInfo.NextNode,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					m_pOHTMainStatus->StatusCommon.ExistFoup,
					m_pOHTMainStatus->StatusCommon.StopStationID,
					dCurrOffset);
		m_PositionInfo.CurrNode = uCurrNode;
		m_PositionInfo.CurrPreCheckNode = uCurrNode;  //
		m_PositionInfo.CurrNodeOffset = dCurrOffset;
		ERR_LOG("[checkError] E%d Node(C:%6X/L:%6X) Offset:%6.1lf"
			, nTmpError, uCurrNode, uLimitNode, dCurrOffset);
    }

    if( (nTmpError==NO_ERR)
    &&  (pInfoSet->Position.CurrentAndTarget.TargetPosition.MarkType!=MARK_TYPE_NODE)
    &&  (uCurrNode==uLimitNode)
    &&  (pInfoSet->EventAndState.MarkState.Arrived==true)
    &&  ((pInfoSet->HwInfo.IO.NodeOn==true) ||(dCurrOffset>-5.0))   //1 기준 거리 확정 필요
    )
    {
        switch(MarkType)
        {
            case MARK_TYPE_NODE:
                nTmpError = ERR_NOTMATCH_TAGLENGTH_FINALNODE_MET_EARLY;
                break;
            case MARK_TYPE_TAG_STATION:
                nTmpError = ERR_NOTMATCH_TAGLENGTH_FINALSTATION_TAG_MET_EARLY;
                break;
            case MARK_TYPE_QR_STATION_LEFT:
				nTmpError = ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_LEFT_MET_EARLY;
                break;
            case MARK_TYPE_QR_STATION_RIGHT:
				nTmpError = ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_RIGHT_MET_EARLY;
                break;
            default:
                nTmpError = ERR_NOTMATCH_TAGLENGTH_FINALNODE;
                break;
        }
		ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d/%6.1lf",
					nTmpError,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pExecuteInfo->ExecutePositionInfo.NextNode,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					m_pOHTMainStatus->StatusCommon.ExistFoup,
					m_pOHTMainStatus->StatusCommon.StopStationID,
					dCurrOffset);
		m_PositionInfo.CurrNode = uCurrNode;
		m_PositionInfo.CurrPreCheckNode = uCurrNode;
        m_PositionInfo.CurrNodeOffset = MAX(0.0, dCurrOffset);//dCurrOffset;
        ERR_LOG("[checkError] After Mark: E%d Node(C:%6X/L:%6X) Offset:%6.1lf"
            , nTmpError, uCurrNode, uLimitNode, dCurrOffset);
    }



    // -----------------------------------------------------------------------------------------------------------
    //1 0.  전방 감지 센서 Fail 확인
    // -----------------------------------------------------------------------------------------------------------
#if(UBG_SENSOR_ENABLE == ON)
	//2 OHT Detect 센서 에러
	if(nTmpError==NO_ERR && pInfoSet->HwInfo.IO.DetectStatus==DETECT_UNIT_FAIL)
	{
		if(pInfoSet->Time.FrontObserve.OHTDetectFail.bFlag==true)
		{
			if(OHTUTILITY::PreventOverflowGetTimeMs(pInfoSet->Time.FrontObserve.OHTDetectFail.dwTime) >m_pParamSet->FrontDetect.dwDetectFailChatteringTime)
			{
				nTmpError = ERR_DETECT_SENSOR_FAIL;
				ADD_FDC_LOG("ERR/%d/1/5/%06d/%06d/%d/%d/%06d",
							ERR_DETECT_SENSOR_FAIL,
							m_pOHTMainStatus->StatusCommon.CurNodeID,
							m_pExecuteInfo->ExecutePositionInfo.NextNode,
							m_pOHTMainStatus->StatusCommon.CurNodeOffset,
							m_pOHTMainStatus->StatusCommon.ExistFoup,
							m_pOHTMainStatus->StatusCommon.StopStationID);
			}
		}
	}
#endif
	//2 전방 장애물 감지 센서 에러
	if(nTmpError==NO_ERR && pInfoSet->HwInfo.IO.ObsStatus==DETECT_UNIT_FAIL)
	{
		if(pInfoSet->Time.FrontObserve.OBSDetectFail.bFlag==true)
		{
			if(OHTUTILITY::PreventOverflowGetTimeMs(pInfoSet->Time.FrontObserve.OBSDetectFail.dwTime) >m_pParamSet->FrontDetect.dwObsFailChatteringTime)
			{
				//nTmpError = ERR_OBS_SENSOR_FAIL;
				if(bObsPowerReset == false)
				{
					m_pObstacle->PowerControl(PWR_OFF);
					ADD_LOG("[Obstacle Sensor Fail] Sensor Power Start");
					dwStaticObsPowerResetTime = timeGetTime();
					bObsPowerReset = true;
				}
			}
			if((OHTUTILITY::PreventOverflowGetTimeMs(dwStaticObsPowerResetTime)>500) && (bObsPowerReset == true))
			{
				m_pObstacle->PowerControl(PWR_ON);
				ADD_LOG("[Obstacle Sensor Fail] Sensor Power End");
				bObsPowerReset = false;
			}

			if(OHTUTILITY::PreventOverflowGetTimeMs(-pInfoSet->Time.FrontObserve.OBSDetectFail.dwTime) > (m_pParamSet->FrontDetect.dwObsFailChatteringTime+OBS_SENSOR_FAIL_TIMEOVER))
			{
				nTmpError = ERR_OBS_SENSOR_FAIL;
				ERR_LOG("ERR_OBS_SENSOR_FAIL");
				ADD_FDC_LOG("ERR/%d/1/5/%06d/%06d/%d/%d/%06d",
							ERR_OBS_SENSOR_FAIL,
							m_pOHTMainStatus->StatusCommon.CurNodeID,
							m_pExecuteInfo->ExecutePositionInfo.NextNode,
							m_pOHTMainStatus->StatusCommon.CurNodeOffset,
							m_pOHTMainStatus->StatusCommon.ExistFoup,
							m_pOHTMainStatus->StatusCommon.StopStationID);
			}
		}
	}

    // -----------------------------------------------------------------------------------------------------------
    //1 1. 주행 축 알람 확인
    // -----------------------------------------------------------------------------------------------------------
    if(nTmpError==NO_ERR)
    {
        nTmpError = pInfoSet->HwInfo.Axis1.nError;
    }

    if(nTmpError==NO_ERR && m_pDrivingAxis->IsSlaveRunning()==true)
    {
        nTmpError = pInfoSet->HwInfo.Axis2.nError;
    }


    // -----------------------------------------------------------------------------------------------------------
    //1 2. Steering check
    // -----------------------------------------------------------------------------------------------------------

    PATH_STEERING_INFO PathSteerInfo = pInfoSet->Steer.PathSteer;
    bool    bSteerFrontLeft = pInfoSet->HwInfo.IO.SteerFrontLeftInOn;
    bool    bSteerFrontRight    = pInfoSet->HwInfo.IO.SteerFrontRightInOn;
    bool    bSteerRearLeft      = pInfoSet->HwInfo.IO.SteerRearLeftInOn;
    bool    bSteerRearRight = pInfoSet->HwInfo.IO.SteerRearRightInOn;


    if( nTmpError==NO_ERR )
    if( (bSteerFrontLeft==true && bSteerFrontRight==true)
    &&  (bSteerRearLeft==true && bSteerRearRight==true)
    )   // 센서가 좌우에 다 들어온 경우 에러 발생
    {
        nTmpError = ERR_STEER_NOTSAMESTATUS;
		ADD_FDC_LOG("ERR/%d/2/9/%06d/%06d/%d/%d/%06d/%d/%d/%d/%d",
					ERR_STEER_NOTSAMESTATUS,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pExecuteInfo->ExecutePositionInfo.NextNode,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					m_pOHTMainStatus->StatusCommon.ExistFoup,
					m_pOHTMainStatus->StatusCommon.StopStationID,
					bSteerFrontLeft,
					bSteerFrontRight,
					bSteerRearLeft,
					bSteerRearRight);
    }


    if(nTmpError==NO_ERR)
    {
		if(pInfoSet->Time.Steer.SteeringNotMatch.bFlag==true)
        {
			if(OHTUTILITY::PreventOverflowGetTimeMs(pInfoSet->Time.Steer.SteeringNotMatch.dwTime) > (m_pParamSet->Steer.dwChangeTime*3))     // 3.3mm/msec * (30 + a) -->99+(3.3*a)mm : 샘플링 타임 만큼 더 갈 수 있음
			{
				switch(PathSteerInfo)
				{
				case PATH_STEERING_LEFT:
					nTmpError = ERR_STEER_FR_LEFTNOTON;
					break;
				case PATH_STEERING_RIGHT:
					nTmpError = ERR_STEER_FR_RIGHTNOTON;
					break;
				case PATH_STEERING_NONE:
					nTmpError = ERR_STEER_NOTSAMESTATUS;
					break;
				case PATH_STEERING_N_BRANCH_L2R:
				case PATH_STEERING_N_BRANCH_R2L:
					if(OHTUTILITY::PreventOverflowGetTimeMs(pInfoSet->Time.Steer.SteeringNotMatch.dwTime) > (m_pParamSet->Steer.dwChangeTime*10))     // 3.3mm/msec * (30 + a) -->99+(3.3*a)mm : 샘플링 타임 만큼 더 갈 수 있음
					{
						nTmpError = ERR_STEER_NOTSAMESTATUS;
					}
					break;
                }
				ADD_FDC_LOG("ERR/%d/1/9/%06d/%06d/%d/%d/%06d/%d/%d/%d/%d",
					nTmpError,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pExecuteInfo->ExecutePositionInfo.NextNode,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					m_pOHTMainStatus->StatusCommon.ExistFoup,
					m_pOHTMainStatus->StatusCommon.StopStationID,
					bSteerFrontLeft,
					bSteerFrontRight,
					bSteerRearLeft,
					bSteerRearRight);
			}

        }
	}


    if(nTmpError!=NO_ERR)
    {
		ERR_LOG("[%d]ERR_STEER PathType[%d] Front[%d:%d] Rear[%d:%d]"
            , uCurrNode
            , PathSteerInfo
            , bSteerFrontLeft
            , bSteerFrontRight
            , bSteerRearLeft
            , bSteerRearRight
        )

        return nTmpError;
    }

    DRIVING_CMD_INFO_OF_PATH* pPathInfo = getPathInfo(pInfoSet->HwInfo.Node.nNodeCount);
    // -----------------------------------------------------------------------------------------------------------
    //1 3. 일정 범위 오차 내에 TAG가 감지되지 않을 경우
    // -----------------------------------------------------------------------------------------------------------
    if( (nTmpError==NO_ERR)
    &&  (fabs(pInfoSet->Position.Compensation.dLinkDistError)>DIST_MARGIN_OF_NODE) //너무 일찍 나타나거나
    )
    {
        nTmpError = ERR_NOTMATCH_TAGLENGTH;

        ERR_LOG("ERR_NOTMATCH_TAGLENGTH-Meet Node Too Fast: |%7.1lf| > %7.1lf"
            ,pInfoSet->Position.Compensation.dLinkDistError ,DIST_MARGIN_OF_NODE);
		ADD_FDC_LOG("ERR/%d/1/7/%06d/%06d/%d/%d/%06d/%6.1lf/%6.1lf",
						ERR_NOTMATCH_TAGLENGTH,
						m_pOHTMainStatus->StatusCommon.CurNodeID,
						m_pExecuteInfo->ExecutePositionInfo.NextNode,
						m_pOHTMainStatus->StatusCommon.CurNodeOffset,
						m_pOHTMainStatus->StatusCommon.ExistFoup,
						m_pOHTMainStatus->StatusCommon.StopStationID,
						fabs(pInfoSet->Position.Compensation.dLinkDistError),
						DIST_MARGIN_OF_NODE);
    }

    if( (nTmpError==NO_ERR)
    &&  (pPathInfo!=NULL)
    )
    {
        if((pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset-pPathInfo->dLength)>DIST_MARGIN_OF_NODE)// 너무 늦게 나타나는 것 방지
        {
			nTmpError = ERR_NOTMATCH_TAGLENGTH;

			ERR_LOG("ERR_NOTMATCH_TAGLENGTH-Meet Node Too Late: %7.1lf(%7.1lf-%7.1lf[%d~%d(%d)]) > %7.1lf"
				, pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset - pPathInfo->dLength
                , pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset
				, pPathInfo->dLength
                , pPathInfo->StartNID
				, pPathInfo->EndNID
				, pInfoSet->HwInfo.Node.nNodeCount
				, DIST_MARGIN_OF_NODE);
			ADD_FDC_LOG("ERR/%d/2/7/%06d/%06d/%d/%d/%06d/%6.1lf/%6.1lf",
						ERR_NOTMATCH_TAGLENGTH,
						m_pOHTMainStatus->StatusCommon.CurNodeID,
						m_pExecuteInfo->ExecutePositionInfo.NextNode,
						m_pOHTMainStatus->StatusCommon.CurNodeOffset,
						m_pOHTMainStatus->StatusCommon.ExistFoup,
						m_pOHTMainStatus->StatusCommon.StopStationID,
						pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset-pPathInfo->dLength,
						DIST_MARGIN_OF_NODE);
		}
	}

	if( (nTmpError==NO_ERR)
	&&  (fabs(pInfoSet->Position.Compensation.dLinkDistError)>DIST_MARGIN_OF_NODE_FDC)) //너무 일찍 나타나거나
	{
		if(m_bFDCEarlyPathFlag == true)
		{
			SEND_WARN("WARN/4/1/6/%06d/%06d/%d/%d/%06d/%6.1lf",
						m_pOHTMainStatus->StatusCommon.CurNodeID,
						m_pExecuteInfo->ExecutePositionInfo.NextNode,
						m_pOHTMainStatus->StatusCommon.CurNodeOffset,
						m_pOHTMainStatus->StatusCommon.ExistFoup,
						m_pOHTMainStatus->StatusCommon.StopStationID,
						pInfoSet->Position.Compensation.dLinkDistError);
			m_bFDCEarlyPathFlag = false;
		}
	}
	else
	{
		m_bFDCEarlyPathFlag = true;
    }

	if((nTmpError==NO_ERR)&&(pPathInfo!=NULL))
	{
		if((pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset-pPathInfo->dLength)>DIST_MARGIN_OF_NODE_FDC)// 너무 늦게 나타나는 것 방지
		{
			if(m_bFDCLatePathFlag == true)
			{
				SEND_WARN("WARN/4/2/6/%06d/%06d/%d/%d/%06d/%6.1lf",
						m_pOHTMainStatus->StatusCommon.CurNodeID,
						m_pExecuteInfo->ExecutePositionInfo.NextNode,
						m_pOHTMainStatus->StatusCommon.CurNodeOffset,
						m_pOHTMainStatus->StatusCommon.ExistFoup,
						m_pOHTMainStatus->StatusCommon.StopStationID,
						pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset-pPathInfo->dLength);
				m_bFDCLatePathFlag = false;
			}
		}
		else
		{
        	m_bFDCLatePathFlag = true;
        }
	}

	//AOHC-196 사전 로그 추가
	if(pPathInfo!=NULL)
	{
		if(fabs(pInfoSet->Position.Compensation.dLinkDistError)>100.0) //너무 일찍 나타나거나
		{
			   /*//	  ERR_LOG("일찍 LinkDistError : %7.1f, 차이 : %7.1f, 마크 지점 :%7.1f, 맵 거리 : %7.1f, "
				  ,fabs(pInfoSet->Position.Compensation.dLinkDistError)
				  ,pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset - pPathInfo->dLength
				  , pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset
				  , pPathInfo->dLength);     */
			m_DiagManager->IncreasePreviosDiagCount(PREVIOS_DIAG_MAP_DGAP);   //사전로그
			ERR_LOG("[MNE]N:&6X, Diff:%7.1lf",uCurrNode,fabs(pInfoSet->Position.Compensation.dLinkDistError));
		}
		else if((pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset-pPathInfo->dLength)>100.0)// 너무 늦게 나타나는 것 방지
		{    /*
			ERR_LOG("늦게 차이 : %7..1lf, 마크 지점 :%7..1lf, 맵 거리 : %7..1lf, "
				,pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset - pPathInfo->dLength
				, pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset
				, pPathInfo->dLength);*/
			m_DiagManager->IncreasePreviosDiagCount(PREVIOS_DIAG_MAP_DGAP);   //사전로그
			ERR_LOG("[MNL]N:&6X, Offset:%7.1lf",uCurrNode,pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset - pPathInfo->dLength);
		}
	}


	if( (nTmpError==NO_ERR)
    &&  (pPathInfo!=NULL))
	{
		if(fabs(m_dCheckPrecheckNodecountPosition) > DIST_MARGIN_OF_NODE)
		{
		  //nTmpError = ERR_CURRNODE_INVALID;

			ERR_LOG("ERR_CURRNODE_INVALID-Meet Node MissMatch: %7.1lf([%d~%d(%d)]) > %7.1lf"
				, m_dCheckPrecheckNodecountPosition
                , pPathInfo->StartNID
				, pPathInfo->EndNID
				, pInfoSet->HwInfo.Node.nNodeCount
				, DIST_MARGIN_OF_NODE);
        }
    }
    //2 BCR 이상 확인
	if( (nTmpError==NO_ERR) &&(pPathInfo!=NULL) && (uNodeBCR!=0))// && (pInfoSet->HwInfo.Node.nNodeCount>0))
    {
        /* // [BEGIN] by zzang9un 2014.03.12 : BCR 인식 불량 인터락 제거
        if( (uNodeBCR==pPathInfo->StartNID)
        &&  (fabs(pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset)>200)
        )
		{
            nTmpError = ERR_NOTMATCHTGNODE; // 시작 노드인데 위치가 이상
            ERR_LOG("BCR:%6X/%6X Offset:%6.1lf", uNodeBCR, pPathInfo->StartNID, pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset);
        }
        else if( (uNodeBCR==pPathInfo->EndNID)
            &&  (fabs(pPathInfo->dLength-pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset)>MAX(200, pPathInfo->dLength*0.4))
        )
        {
            nTmpError = ERR_NOTMATCHTGNODE; // 끝 노드인데 위치가 이상
            ERR_LOG("BCR:%6X/%6X Offset:%6.1lf/%6.1lf", uNodeBCR, pPathInfo->EndNID, pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset, pPathInfo->dLength);
        }
        else
        */ // [END] by zzang9un 2014.03.12 : BCR 인식 불량 인터락 제거
//        if((uNodeBCR != pPathInfo->StartNID) && (uNodeBCR != pPathInfo->EndNID))
//		{
//			nTmpError = ERR_NOTMATCHTGNODE; // 이상한 노드가 읽힌 경우
//			ERR_LOG("BCR:%6d/%6d:%6d", uNodeBCR, pPathInfo->StartNID, pPathInfo->EndNID);
//		}
    }

    //1 4. Timeout Error
    //2 전방 장애물 감지 센서
	//2 전방 장애물 감지 센서 에러
    if(nTmpError==NO_ERR && pInfoSet->HwInfo.IO.ObsStatus==DETECT_AND_STOP)
    {
        if(pInfoSet->Time.FrontObserve.OBSDetect.bFlag==true)
		{
            /*
			if((dwCurrTime-pInfoSet->Time.FrontObserve.OBSDetect.dwTime)
				>(m_pParamSet->FrontDetect.dwObsTimeout)) // 삽체/정체로 대체사용유무 확인 필요.
			{
				nTmpError = ERR_OBS_TIMEOVER;
			}
            */
            // test 필요
			if(OHTUTILITY::PreventOverflowGetTimeMs(pInfoSet->Time.FrontObserve.OBSDetect.dwTime) //Overflow 방지
				>(m_pParamSet->FrontDetect.dwObsTimeout)) // 삽체/정체로 대체사용유무 확인 필요.
			{
                //ADD_LOG("TESTING1");
				int nObsResult = m_pObstacle->CheckObsSensorData();
                ERR_LOG("Check OBS Sensor Data : %d", nObsResult);
				nTmpError = ERR_OBS_TIMEOVER;
                bObsCheckArea = false;

				ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d/%d",
							ERR_OBS_TIMEOVER,
							m_pOHTMainStatus->StatusCommon.CurNodeID,
							m_pExecuteInfo->ExecutePositionInfo.NextNode,
							m_pOHTMainStatus->StatusCommon.CurNodeOffset,
							m_pOHTMainStatus->StatusCommon.ExistFoup,
							m_pOHTMainStatus->StatusCommon.StopStationID,
							OHTUTILITY::PreventOverflowGetTimeMs(pInfoSet->Time.FrontObserve.OBSDetect.dwTime));
				ADD_MCC_LOG(",%s,DRV,OHT DETECT AND STOP,End,FOUP,%06d,%06d,%06d,%d,%6.1lf,OHT Detect Stop Time,%d,OBS Detect Stop Time,%d",
							m_defualtparam->VHLName,
							m_mccparam.uSourceNode,
							m_mccparam.uTargetNode,
							m_pOHTMainStatus->StatusCommon.CurNodeID,
							m_pOHTMainStatus->StatusCommon.CurNodeOffset,
							dSpeedOfNow,
							OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwUBGDetectTime),
							OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwOBSDetectTime));
				m_mccparam.bDetectStatus = false;
				m_mccparam.dwOBSDetectTime = 0;
				m_mccparam.dwUBGDetectTime = 0;
			}
			else if(OHTUTILITY::PreventOverflowGetTimeMs(pInfoSet->Time.FrontObserve.OBSDetect.dwTime)   //Overflow 방지
				>(m_pParamSet->FrontDetect.dwObsTimeout - OBSLOGTIME)) // 삽체/정체로 대체사용유무 확인 필요.
			{
				if(bObsCheckArea == false)
                {
					m_pObstacle->RequestData();
                    //ERR_LOG("Request OBS Sensor Data!");
                    bObsCheckArea = true;
                }

			}
			else if(OHTUTILITY::PreventOverflowGetTimeMs(pInfoSet->Time.FrontObserve.OBSDetect.dwTime)  //Overflow 방지
				>(m_pParamSet->FrontDetect.dwObsChangeTime)) // 삽체/정체로 대체사용유무 확인 필요.
			{

				int nNowOBSAreaSelect = m_pObstacle->GetObsAreaStatus();

				//대차 패턴 모양에 의해 장애물 변경유무 결정 //직선이 아닐경우는 모두 변경
				if((m_Dectect_Dir != PATH_DIRECTION_NO_USE) &&
				(m_Dectect_Dir != PATH_DIRECTION_NORMAL))
				{
					//변경된 경우는 그대로 유지
					if(nNowOBSAreaSelect !=HO_OBS_AREA_TEST)
					{
						 ERR_LOG("OBS Data Set: %d %d",nNowOBSAreaSelect,m_Dectect_Dir);
						 m_pObstacle->AreaSelect(HO_OBS_AREA_SET);


					}
				}

			}
        }

        }
    else
    {
        if(bObsCheckArea ==true)
        {
			m_pObstacle->CloseCom();
            //ERR_LOG("[2325]driving reset OBS CloseCom : %d", );
        }
        bObsCheckArea = false;
    }

    STEER_HW_INFO_CMD SteerCmdDirection = pInfoSet->Steer.FrontCmdDirection;    // 전후방이 항상 같은 방향으로 명령을 주기 때문에

    //2 Steering 변경
    if(nTmpError==NO_ERR)
    {
        if(pInfoSet->Time.Steer.SteeringChangeCmded.bFlag==true)
        {
			if(OHTUTILITY::PreventOverflowGetTimeMs(pInfoSet->Time.Steer.SteeringChangeCmded.dwTime)>m_pParamSet->Steer.dwCompleteLimitTime)
            {
				switch(SteerCmdDirection)
                {
				case STEER_HW_INFO_CMD_LEFT:
                    nTmpError   = ERR_STEER_LEFT_EXEC_TIMEOVER;
					ADD_FDC_LOG("ERR/%d/1/9/%06d/%06d/%d/%d/%06d/%d/%d/%d/%d",
								ERR_STEER_LEFT_EXEC_TIMEOVER,
								m_pOHTMainStatus->StatusCommon.CurNodeID,
								m_pExecuteInfo->ExecutePositionInfo.NextNode,
								m_pOHTMainStatus->StatusCommon.CurNodeOffset,
								m_pOHTMainStatus->StatusCommon.ExistFoup,
								m_pOHTMainStatus->StatusCommon.StopStationID,
								bSteerFrontLeft,
								bSteerFrontRight,
								bSteerRearLeft,
								bSteerRearRight);
                    break;
                case STEER_HW_INFO_CMD_RIGHT:
                    nTmpError   = ERR_STEER_RIGHT_EXEC_TIMEOVER;
					ADD_FDC_LOG("ERR/%d/1/9/%06d/%06d/%d/%d/%06d/%d/%d/%d/%d",
								ERR_STEER_RIGHT_EXEC_TIMEOVER,
								m_pOHTMainStatus->StatusCommon.CurNodeID,
								m_pExecuteInfo->ExecutePositionInfo.NextNode,
								m_pOHTMainStatus->StatusCommon.CurNodeOffset,
								m_pOHTMainStatus->StatusCommon.ExistFoup,
								m_pOHTMainStatus->StatusCommon.StopStationID,
								bSteerFrontLeft,
								bSteerFrontRight,
								bSteerRearLeft,
								bSteerRearRight);
                    break;
                }
            }
        }
    }

    //2 무언 정지 에러(Abonormal Error)
    if(nTmpError==NO_ERR)
    {
        if(pInfoSet->Time.Stop.OnAbnormalStop.bFlag==true)
        {
            if((dwCurrTime-pInfoSet->Time.Stop.OnAbnormalStop.dwTime)
                >TIMEOVER_OF_DRIVING_ABNORMAL_STOP
            )
            {
                if((bSteerFrontLeft != bSteerRearLeft) || (bSteerFrontRight != bSteerRearRight))
                {
                    // Front와 Rear Steering 방향이 다른 경우
                    nTmpError = ERR_DRV_ABNORMAL_STOP_STEER_CROSS;
                    ADD_LOG("[ERR_DRV_ABNORMAL_STOP_STEER_CROSS] bSteerFrontLeft: %d, bSteerRearLeft: %d, bSteerFrontRight: %d bSteerRearRight: %d",
                            bSteerFrontLeft, bSteerRearLeft, bSteerFrontRight, bSteerRearRight);
					ADD_FDC_LOG("ERR/%d/1/9/%06d/%06d/%d/%d/%06d/%d/%d/%d/%d",
								ERR_DRV_ABNORMAL_STOP_STEER_CROSS,
								m_pOHTMainStatus->StatusCommon.CurNodeID,
								m_pExecuteInfo->ExecutePositionInfo.NextNode,
								m_pOHTMainStatus->StatusCommon.CurNodeOffset,
								m_pOHTMainStatus->StatusCommon.ExistFoup,
								m_pOHTMainStatus->StatusCommon.StopStationID,
								bSteerFrontLeft, bSteerRearLeft, bSteerFrontRight, bSteerRearRight);
                }
                else
                {
                    // 그 외 무언 정지 상황
                    nTmpError   = ERR_DRV_ABNORMAL_STOP;
					ADD_LOG("[ERR_DRV_ABNORMAL_STOP] ObsStatus: %d, DetectStatus: %d, bSteerFrontLeft: %d bSteerRearLeft: %d, bSteerFrontRight: %d, bSteerRearRight: %d, Time: %d\n\tPos:%6.1lf(Node:P%6.1lf,N%6.1lf,P%3d,N%3d)(Tag:F%6.1lf,R%6.1lf)",
                            pInfoSet->HwInfo.IO.ObsStatus, pInfoSet->HwInfo.IO.DetectStatus
                            , bSteerFrontLeft, bSteerRearLeft, bSteerFrontRight, bSteerRearRight
                            , (dwCurrTime-pInfoSet->Time.Stop.OnAbnormalStop.dwTime)
                            , pInfoSet->HwInfo.Axis1.dCurrPos
                            , pInfoSet->HwInfo.Node.dPreCheckPosition
                            , pInfoSet->HwInfo.Node.dNodePosition
                            , pInfoSet->HwInfo.Node.nPreCheckCount
                            , pInfoSet->HwInfo.Node.nNodeCount
                            , pInfoSet->HwInfo.TagStaion.dFrontPosition
                            , pInfoSet->HwInfo.TagStaion.dRearPosition);
					ADD_FDC_LOG("ERR/%d/1/12/%06d/%06d/%d/%d/%06d/%d/%d/%d/%d/%d/%d/%d",
								ERR_DRV_ABNORMAL_STOP,
								m_pOHTMainStatus->StatusCommon.CurNodeID,
								m_pExecuteInfo->ExecutePositionInfo.NextNode,
								m_pOHTMainStatus->StatusCommon.CurNodeOffset,
								m_pOHTMainStatus->StatusCommon.ExistFoup,
								m_pOHTMainStatus->StatusCommon.StopStationID,
								pInfoSet->HwInfo.IO.DetectStatus,
								pInfoSet->HwInfo.IO.ObsStatus,
								bSteerFrontLeft, bSteerRearLeft, bSteerFrontRight, bSteerRearRight,
								OHTUTILITY::PreventOverflowGetTimeMs(pInfoSet->Time.Stop.OnAbnormalStop.dwTime));
				}
				if(m_mccparam.bAbnormalStopFlag == true)
				{
					ADD_MCC_LOG(",%s,DRV,ABNORMAL STOP,End,FOUP,%06d,%06d,%06d,%d,%6.1lf,Abnormal Stop Time,%d",
								m_defualtparam->VHLName,
								m_mccparam.uSourceNode,
								m_mccparam.uTargetNode,
								m_pOHTMainStatus->StatusCommon.CurNodeID,
								m_pOHTMainStatus->StatusCommon.CurNodeOffset,
								dSpeedOfNow,
								OHTUTILITY::PreventOverflowGetTimeMs(pInfoSet->Time.Stop.OnAbnormalStop.dwTime));
					m_mccparam.bAbnormalStopFlag = false;
                }
			}
			if(m_mccparam.bAbnormalStopFlag == false)
			{
				if(OHTUTILITY::PreventOverflowGetTimeMs(pInfoSet->Time.Stop.OnAbnormalStop.dwTime) > 5000)
				{
					ADD_MCC_LOG(",%s,DRV,ABNORMAL STOP,Start,FOUP,%06d,%06d,%06d,%d,%6.1lf",
								m_defualtparam->VHLName,
								m_mccparam.uSourceNode,
								m_mccparam.uTargetNode,
								m_pOHTMainStatus->StatusCommon.CurNodeID,
								m_pOHTMainStatus->StatusCommon.CurNodeOffset,
								dSpeedOfNow);
					m_mccparam.bAbnormalStopFlag = true;
				}
                }
            }
		else
		{
			if(m_mccparam.bAbnormalStopFlag == true)
			{
				ADD_MCC_LOG(",%s,DRV,ABNORMAL STOP,End,FOUP,%06d,%06d,%06d,%d,%6.1lf,Abnormal Stop Time,%d",
							m_defualtparam->VHLName,
							m_mccparam.uSourceNode,
							m_mccparam.uTargetNode,
							m_pOHTMainStatus->StatusCommon.CurNodeID,
							m_pOHTMainStatus->StatusCommon.CurNodeOffset,
							dSpeedOfNow,
							OHTUTILITY::PreventOverflowGetTimeMs(pInfoSet->Time.Stop.OnAbnormalStop.dwTime));
            	m_mccparam.bAbnormalStopFlag = false;
			}
		}
    }

	if(nTmpError==NO_ERR)
	{
		if((pInfoSet->HwInfo.Node.nNodeCount <= pInfoSet->HwInfo.Node.nPreCheckCount-2)
		|| (pInfoSet->HwInfo.Node.nNodeCount > pInfoSet->HwInfo.Node.nPreCheckCount))
		{
            ADD_LOG("[ERR_NODE_COUNT_RESET_NOT_AVAILABLE] Node count : [%d], Pre-check count : [%d]",
				pInfoSet->HwInfo.Node.nNodeCount,
				pInfoSet->HwInfo.Node.nPreCheckCount);

			nTmpError = ERR_NODE_COUNT_RESET_NOT_AVAILABLE;
			ADD_FDC_LOG("ERR/%d/1/7/%06d/%06d/%d/%d/%06d/%d/%d",
								ERR_NODE_COUNT_RESET_NOT_AVAILABLE,
								m_pOHTMainStatus->StatusCommon.CurNodeID,
								m_pExecuteInfo->ExecutePositionInfo.NextNode,
								m_pOHTMainStatus->StatusCommon.CurNodeOffset,
								m_pOHTMainStatus->StatusCommon.ExistFoup,
								m_pOHTMainStatus->StatusCommon.StopStationID,
								pInfoSet->HwInfo.Node.nPreCheckCount,
								pInfoSet->HwInfo.Node.nNodeCount);
		}
//		else if(((double)(pInfoSet->HwInfo.Node.dPreCheckPosition - pInfoSet->HwInfo.Node.dNodePosition) > 0.0) &&
//				((pInfoSet->HwInfo.Node.dPreCheckPosition - pInfoSet->HwInfo.Node.dNodePosition) < 250.0) &&
//				 (pInfoSet->HwInfo.Node.nNodeCount > 1))
//				 {
//					ADD_LOG("[ERR_CURRNODE_INVALID] Node count : [%f], Pre-check count : [%f] Count [%d]",
//					pInfoSet->HwInfo.Node.dNodePosition,
//					pInfoSet->HwInfo.Node.dPreCheckPosition,
//					pInfoSet->HwInfo.Node.nNodeCount);
//					nTmpError = ERR_CURRNODE_INVALID;
//				 }
	}

    // -------------------------------------------
    // [BEGIN] by zzang9un 2014.02.24 : BCR 로그 추가(BCR ID Read Time 측정용, Debug)
    static AnsiString strPreBCRLog = "";
    AnsiString strBCRLog = "";
	strBCRLog.sprintf("%6d%d%5.1lf, %6d", uNodeBCR, pInfoSet->HwInfo.Node.nNodeCount, pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset, uStationBCR);
	if((strPreBCRLog != strBCRLog) && (uNodeBCR != 0))
	{
		BCR_LOG("/%6d/%d/%5.1lf, %6d", uNodeBCR, pInfoSet->HwInfo.Node.nNodeCount, pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset, uStationBCR);
		strPreBCRLog = strBCRLog;
	}
    // [END] by zzang9un 2014.02.24 : BCR 로그 추가(BCR ID Read Time 측정용, Debug)
    // -------------------------------------------

    return nTmpError;
}

/**
@brief  최적 속도를 산출 하는 함수

    삼각형 프로파일을 UniformSpeedRatio의 비율의 사다리꼴 프로파일로 만들기 위한 속도를 산출하는 함수
@author  ehoto
@date    2012.11.07
@param ListOfCmd: Command 리스트
@param CurrRefDrivingData: 찾기 시작하는 위치
@param UniformSpeedRatio: 현재가 감속 지점 초과 여부 반환하는 함수
@return GetOptimalSpeed 반환
*/
double DrivingControl::getOptimalSpeed( double Distance, double SpeedIn, double AccelIn, double AccelOut, double SpeedOut, double UniformSpeedRatio)    // 전부 양수 값
{
    // 임시 속도 최적화
#if 1
    if      (UniformSpeedRatio>1.0) UniformSpeedRatio=1.0;
    else if (UniformSpeedRatio<0.0) UniformSpeedRatio=0.0;
    // 속도가 0에서 출발하여 가감속을 하여 정지하였을 때 최대 속도를 등속비율 비율만큼 감소한 속도
    return MAX(((1.0-UniformSpeedRatio)*sqrt(fabs(2*Distance*((AccelOut*AccelIn)/(AccelOut+AccelIn))))),DRIVING_MIN_SPEED); //0.5 Defaul 속도
#else

	double dA = 0.0, dB = 0.0, dC = 0.0;
	double dOptimalSpeed = 0.0;

    if(SpeedOut<0.1)
    {
        SpeedOut=0.1;
    }

	if(Distance<(SpeedIn*SpeedIn/(2*DEFAULT_EMERGENCY_DECEL)))
    {
		return SpeedIn;
    }

    if(UniformSpeedRatio>0.9)
    {
		UniformSpeedRatio = 0.9;
    }
    else if(UniformSpeedRatio<0.1)
    {
        UniformSpeedRatio = 0.1;
    }

	if(AccelIn>DEFAULT_EMERGENCY_DECEL)
    {
		AccelIn = DEFAULT_EMERGENCY_DECEL;
    }
    if(AccelOut>DEFAULT_EMERGENCY_DECEL)
    {
		AccelOut = DEFAULT_EMERGENCY_DECEL;
	}

    dA = (UniformSpeedRatio+1)*(1/AccelIn+1/AccelOut) / (2*(1-UniformSpeedRatio));          // 항상 양수
    dB = (SpeedOut/AccelOut+SpeedIn/AccelIn)*UniformSpeedRatio/(UniformSpeedRatio-1);       // 항상 음수
    dC = ((SpeedOut*SpeedOut)/AccelOut+(SpeedIn*SpeedIn)/AccelIn+2*Distance)/(-2);                              // 항상 음수

    dOptimalSpeed = (((-1)*dB)+ sqrt(((dB*dB)-(4*dA*dC))))/(2*dA);      // 근의 공식 중 이값만 양수임 --> 선택

    return dOptimalSpeed;
#endif

}

/**
@brief   현재 위치 정보를 전달하는 함수
@author  임태웅
@date    2013.07.29
*/
EXECUTE_POSITION_INFO DrivingControl::GetPositionInfo()
{

	return m_PositionInfo;

}

/**
@brief   DrivingControl Class GetMapData 함수 : 축척된 MapData를 받아가는 함수
@author  임태웅
@date    2013.04.08
@return 받아오는 MapData의 개수
*/
int DrivingControl::GetMapData(List<EXECUTE_RESPONSE_MAPMAKING_INFO*> *pListOfMapData, volatile MAP_INFO_ON_ADDING_UNION *pMapInfoOnAdding)
{
    int nCount = m_ListOfMapData.getCount();
    int nOverCount = pListOfMapData->getCount()+nCount-100;
    EXECUTE_RESPONSE_MAPMAKING_INFO *pMapMakingInfo;
    EXECUTE_RESPONSE_MAPMAKING_INFO *pMapData;

    MAP_INFO_ON_ADDING_UNION MapInfoOnAdding;

    if(nOverCount>0)
	{
        for(int n=0; n<nOverCount; n++)
        {
            pMapMakingInfo = m_ListOfMapData.popFront();
            if(pMapMakingInfo!=NULL)
            {
                delete pMapMakingInfo;
            }
        }
    }

    if(nCount!=0)
    {
        pMapInfoOnAdding->Info.FlagExecuteThreadUsing = true;


		for(int n=0; n<nCount; n++)
        {
            pMapData = m_ListOfMapData.popFront();
            if(pMapData!=NULL)
            {
                pListOfMapData->insertBack(pMapData);
            }
        }

        MapInfoOnAdding.Info.FlagExecuteThreadUsing = true;
        MapInfoOnAdding.Info.CountOfResult = pListOfMapData->getCount();

		pMapInfoOnAdding->Data = MapInfoOnAdding.Data;

		ADD_LOG("[MapMake] GetMapData true %d ",nCount);

    }
    else
	{
//		ADD_LOG("[MapMake] GetMapData false");
        pMapInfoOnAdding->Info.FlagExecuteThreadUsing = false;
    }

    pMapInfoOnAdding->Info.FlagOnMapMaking = m_bOnMapMake;

    return nCount;
}

/**
@brief   DrivingControl Class Manual_Mark 함수
@author  임태웅
@date    2013.02.27
*/
int DrivingControl::Manual_Mark(MANUAL_MARK_CMD_TYPE pType)
{
    int nReturn = NO_ERR;

    MARK_TYPE MarkType;

    switch(pType)
    {
    case MANUAL_MARK_CMD_DEFAULT:
    case MANUAL_MARK_CMD_NODE:
        MarkType = MARK_TYPE_NODE;
        break;

    case MANUAL_MARK_CMD_STATION_STOP:
        MarkType = MARK_TYPE_TAG_STATION;
        break;

    case MANUAL_MARK_CMD_STATION_QR_LEFT:
        MarkType = MARK_TYPE_QR_STATION_LEFT;
        break;

    case MANUAL_MARK_CMD_STATION_QR_RIGHT:
        MarkType = MARK_TYPE_QR_STATION_RIGHT;
		break;
   //추가
	case MANUAL_MARK_CMD_STATION_STOP_BACK:
		MarkType = MARK_TYPE_TAG_STATION_BACK;
		break;

    }

    try
    {
		nReturn = manual_Mark(MarkType);
    }
    catch(...)
    {
        ERR_LOG("[Exception] ERR_MARK_FAIL - manual_Mark Type:%d", MarkType);
        nReturn = ERR_MARK_FAIL;
    }

    return nReturn;

}

/**
@brief   MarkFail에 대한 Recovert 동작하는 함수
@author  puting
@date    2017.10.19
*/
bool DrivingControl::MarkFail_Recovery_Driving()
{
	bool breturn =false; //true는 리커버리 수행, false는 리커버리 미수행
	int     nTmpError       = NO_ERR;
	DWORD   dwATTrigerTime  = timeGetTime();

	DRIVING_HW_INFO_SET HwInfo = getHWInfo();

	double  dAccel = 0.0;         ///< 가속도: mm/msec2
	double  dDecel = 0.0;         ///< 감속도: mm/msec2
	double  dSpeed = 0.0;         ///< 속도: mm/msec
	double  dPosition = 0.0;      ///< 거리: mm


	//이적재 Tag가 아니거나, 슬로프이거나, Station Rear가 On일 경우 시도 안함.
	if((m_pDrivingAxis->IsBrakeReleased()==false) ||
	   (m_cSlopeNodeInfo ==SLOPE_NTYPE) ||
	   (m_ClassifiedCmd.TargetInfo.Type != MARK_TYPE_TAG_STATION) ||
	   ((HwInfo.IO.TagStationRearOn == true) && (fabs(m_pDrivingAxis->GetCurrentPosition() - m_dStationMarkInpos) > m_pParamSet->StationMarkInPos)))
			return breturn;


	//정합성 확인 : 특정거리 이상일 경우 에러처리를 위해
	if(fabs(m_pDrivingAxis->GetCurrentPosition() - m_dStationMarkInpos) > 10.0)
		return breturn;

	//1 2. 명령 분류
	dAccel          = 0.0001;
	dDecel          = 0.0001;
	dSpeed          = 0.05;

	//1 3. 주행 명령 인가 시 확인 하는 절차

	breturn = true;
   	nTmpError = m_pDrivingAxis->SetAMPEnable(true);
	if(nTmpError == NO_ERR && m_pDrivingAxis->IsSyncControl())
	{
		nTmpError = m_pDrivingAxis->SetSlaveAMPEnable(true);
	}

	if(nTmpError==NO_ERR)
	{
		while (1)
		{
			 if(OHTUTILITY::PreventOverflowGetTimeMs(dwATTrigerTime) > 3000)
			 {
				nTmpError = -1;
				ERR_LOG("[MarkFail_Recovery_Driving] Fail");
				break;
			 }

			if(m_pDrivingAxis->IsAMPEnable()==true  &&  m_pDrivingAxis->IsSlaveAMPEnable()==true)
				break;

			Sleep(10);
		}
	}

	//1 4 실제 이동하는 부분
	if(nTmpError==NO_ERR)
	{

		if(m_pDrivingAxis->IsAMPEnable()==true  &&  m_pDrivingAxis->IsSlaveAMPEnable()==true)
		{
			nTmpError = m_pDrivingAxis->MoveDistance(dAccel, dDecel, dSpeed, m_dStationMarkInpos);

			ERR_LOG("[MarkFail_Recovery_Driving]MoveDistance %f",m_pDrivingAxis->GetCurrentPosition());
			dwATTrigerTime  = timeGetTime();
		}
		//적당량 필요
		Sleep(500);

		if(nTmpError==NO_ERR)
		{
			while (1)
			{
				 HwInfo = getHWInfo();   //HW 정보 갱신

				 if(OHTUTILITY::PreventOverflowGetTimeMs(dwATTrigerTime) > 3000)
				 {
					nTmpError = -1;
					ERR_LOG("[MarkFail_Recovery_Driving] Fail1");
					break;
				 }

				if(m_pDrivingAxis->IsRunning()==false  &&  m_pDrivingAxis->IsSlaveRunning()==false)
					break;

				Sleep(50);
			}
		}

		HwInfo = getHWInfo();
		//Rear sensor On 유무 확인
		if(HwInfo.IO.TagStationRearOn == true)
		{
			ERR_LOG("[MarkFail_Recovery_Driving] Rear ON");
		}

		Sleep(10);

	}

	if(nTmpError==NO_ERR)
	{
		DWORD dwCurrTime  = timeGetTime();

		if(m_pDrivingAxis->IsSlaveAMPEnable() ==true)
		{
			nTmpError = m_pDrivingAxis->SetSlaveAMPEnable(false);
		}

		ERR_LOG("[MarkFail_Recovery_Driving] Complete");

	}

	//1 4. 에러 처리
	if(nTmpError!=NO_ERR)
	{
		breturn = false; //에러발생으로 에러처리
		m_pDrivingAxis->MoveStop(0.001);
		ERR_LOG("[MarkFail_Recovery_Driving] Fail!");
	}

	return breturn;
}

/**
@brief   DrivingControl Class Manual_DRIVING 함수
@author  puting
@date    2017.01.10
*/
int DrivingControl::AutoTaeching_Driving(MANUAL_DRIVING_CMD_INFO Info)
{
//		DRIVING_HW_INFO_SET TmpHwInfo;

		static  DWORD   dwATTrigerTime  = timeGetTime();
//		DWORD       dwCurrTime  = timeGetTime();

		int     nTmpError       = NO_ERR;
		bool    bMoveDistCmd    = false;
		double  dCurrPosition   = m_pDrivingAxis->GetCurrentPosition(); ///< 거리: mm

		double  dAccel = 0.0;         ///< 가속도: mm/msec2
		double  dDecel = 0.0;         ///< 감속도: mm/msec2
		double  dSpeed = 0.0;         ///< 속도: mm/msec
		double  dPosition = 0.0;      ///< 거리: mm

			//조향
//		bool    bSteerFrontLeft = TmpHwInfo.IO.SteerFrontLeftInOn;
//		bool    bSteerFrontRight    = TmpHwInfo.IO.SteerFrontRightInOn;

		getPostionInfoOnManual(getHWInfo(),&m_PositionInfo);


        if(m_pServoControl->IsSetInnerLimitTorque_800() ==false)
			m_pServoControl->SetInnerLimitTorque_800();

		if(m_pServoControl->IsSetInnerLimitTorque_800() == false)
		{
			nTmpError = ERR_SERVO_DRIVING_ALARM;
			ERR_LOG("[AutoTaeching_Driving] Fail SetInnerLimitTorque_800");
		}
		else
		{
            //ERR_LOG("[AutoTaeching_Driving] Success SetInnerLimitTorque_800");
        }

		//1 2. 명령 분류
		m_pDrivingAxis->SetBrakeRelease(true);

		setMarkStatusFalse_AutoTeahcing();

		dAccel          = Info.dAccel;
		dDecel          = Info.dDecel;
		dSpeed          = Info.dSpeed;
		dPosition       = dCurrPosition + Info.dDist;

		ERR_LOG("[AutoTaeching_Driving]dPosition:%f + Offset:%f",dCurrPosition,Info.dDist);

		//1 3. 주행 명령 인가 시 확인 하는 절차

		if( dAccel>DRIVING_MAX_ACCEL        )   nTmpError = ERR_DRIVING_ACCEL_MAX_LIMIT;
		if( dAccel<DRIVING_MIN_ACCEL        )   nTmpError = ERR_DRIVING_ACCEL_MIN_LIMIT;
		if( dDecel>DRIVING_MAX_DECEL        )   nTmpError = ERR_DRIVING_DECEL_MAX_LIMIT;
		if( dDecel<DRIVING_MIN_DECEL        )   nTmpError = ERR_DRIVING_DECEL_MIN_LIMIT;
		if( dSpeed>DRIVING_MAX_SPEED        )   nTmpError = ERR_DRIVING_SPEED_MAX_LIMIT;
		if( dSpeed<0.0                      )   nTmpError = ERR_DRIVING_SPEED_MIN_LIMIT;
		if( dPosition>MAX_DRIVING_DISTANCE  )   nTmpError = ERR_DRIVING_DIST_P_LIMIT;
		if( dPosition<MIN_DRIVING_DISTANCE  )   nTmpError = ERR_DRIVING_DIST_N_LIMIT;

		nTmpError = m_pDrivingAxis->SetAMPEnable(true);
		if(nTmpError == NO_ERR && m_pDrivingAxis->IsSyncControl())
			nTmpError = m_pDrivingAxis->SetSlaveAMPEnable(true);

		Sleep(500);
		//
		if(nTmpError==NO_ERR)
		{
			if(m_pDrivingAxis->IsAMPEnable()==true  &&  m_pDrivingAxis->IsSlaveAMPEnable()==true)
			{
				nTmpError = m_pDrivingAxis->MoveDistance(dAccel, dDecel, dSpeed, dPosition);
				ERR_LOG("[AutoTaeching_Driving]MoveDistance %d",nTmpError);
				dwATTrigerTime  = timeGetTime();
			}
			Sleep(1000);
    	}

		if(nTmpError==NO_ERR)
		{
			while (1)
			{

				 if(OHTUTILITY::PreventOverflowGetTimeMs(dwATTrigerTime)  > 7777)
				 {
					nTmpError = ERR_AUTOTEACHING_DRIVING_AB;
					break;
				 }

				if(m_pDrivingAxis->IsRunning()==false  &&  m_pDrivingAxis->IsSlaveRunning()==false)
					break;

				Sleep(50);
			}
		}

		if(nTmpError==NO_ERR)
		{
			DWORD dwCurrTime  = timeGetTime();
			//SetInnerLimitTorque_90 자체 800ms Sleep있으므로 2회 Retry 가능하도록 1s로 변경  #Jrespect.im
			while(OHTUTILITY::PreventOverflowGetTimeMs(dwCurrTime)<1000)                //20191104 KDS
			{
				if(m_pServoControl->IsSetInnerLimitTorque_90() ==true)
					break;

				m_pServoControl->SetInnerLimitTorque_90();
				ADD_LOG("[AT]SetInnerLimitTorque_90 Amp Fault");
				Sleep(5);
			}

//			if(m_pDrivingAxis->IsSlaveAMPEnable() ==true)
//				nTmpError = m_pDrivingAxis->SetSlaveAMPEnable(false);
			if(m_pServoControl->IsSetInnerLimitTorque_90() == false)
			{
			   nTmpError = ERR_SERVO_DRIVING_ALARM;
			   ERR_LOG("[AutoTaeching_Driving] Fail SetInnerLimitTorque_90");
			}
			else
			{
				//ERR_LOG("[AutoTaeching_Driving] Success SetInnerLimitTorque_90");
			}

			ERR_LOG("[AutoTaeching_Driving] Complete");

		}

    //1 4. 에러 처리
    if(nTmpError!=NO_ERR)
    {
        m_pDrivingAxis->MoveStop(0.001);
    }
    return nTmpError;

}

/**
@brief   DrivingControl Class Manual_DRIVING 함수
@author  임태웅
@date    2013.03.03
*/
int DrivingControl::Manual_Driving(MANUAL_DRIVING_CMD_INFO Info)
{
	DRIVING_HW_INFO_SET TmpHwInfo;

	int     nTmpError       = NO_ERR;
    bool    bMoveDistCmd    = false;
    double  dCurrPosition   = m_pDrivingAxis->GetCurrentPosition(); ///< 거리: mm

	double  dAccel = 0.0;         ///< 가속도: mm/msec2
	double  dDecel = 0.0;         ///< 감속도: mm/msec2
	double  dSpeed = 0.0;         ///< 속도: mm/msec
	double  dPosition = 0.0;      ///< 거리: mm

	//조향
	bool    bSteerFrontLeft = TmpHwInfo.IO.SteerFrontLeftInOn;
	bool    bSteerFrontRight    = TmpHwInfo.IO.SteerFrontRightInOn;

	//CID 관련
	static unsigned char CID_Confluence_Area = 0; // 0 : 합류 이외의 구간,  1 : 합류 구간 Stop 과 Reset 사이
	unsigned int CIDResetNode = 0;
	unsigned int CIDStopNode1 = 0;
	unsigned int CIDStopNode2 = 0;
	unsigned int CIDResetNode_arr = INDEX_NONE;
	unsigned int CIDStopNode1_arr = INDEX_NONE;
	unsigned int CIDStopNode2_arr = INDEX_NONE;

    try
    {

        if(Info.bNew==true)
        {
            m_StatusSet.uStep = DRIVING_CTRL_STEP_MANUAL_INIT;
            // 처음 시작이면 위치 정보 초기화
    //      initCommandSet();
			initInfoSet();
            initPreviousArrivalInfo();
			m_PositionInfo.Marked = false;
			m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uStation = 0x00;
			m_PositionInfo.CurrStation=0x00;

			//AOHC-258 SetInnerLimitTorque_800 실패한 경우 Error 처리 Jrespect.im 2019.08.06
			if(m_pServoControl->IsSetInnerLimitTorque_800() ==false) //DrivingControl::Manual_Driving Retry x Error 처리 0
					m_pServoControl->SetInnerLimitTorque_800();


			if(m_pServoControl->IsSetInnerLimitTorque_800() == false)
			{
				nTmpError = ERR_SERVO_DRIVING_ALARM;
				ERR_LOG("[Manual_Driving] Fail SetInnerLimitTorque_800");
			}
			else
			{
				//ERR_LOG("[Manual_Driving] Success SetInnerLimitTorque_800");
			}

            // Jog 시 근접제어 정보 초기화
            m_Detect.UseFollowControlFlag = false;
			m_pDrivingAxis->SetDetectInfo(m_Detect);
//			ADD_LOG("Pre:  MD");
		}
        else
        {
            getPostionInfoOnManual(getHWInfo(),&m_PositionInfo);
        }

		//Get CID info==========================================================================================
		CIDResetNode_arr = OHTMainForm->GetMap()->FindNodeIndexFromCIDReset(m_PositionInfo.CurrNode);
		CIDStopNode1_arr = OHTMainForm->GetMap()->FindNodeIndexFromCIDStop_1(m_PositionInfo.CurrNode);
		CIDStopNode2_arr = OHTMainForm->GetMap()->FindNodeIndexFromCIDStop_2(m_PositionInfo.CurrNode);

		if (CIDResetNode_arr != INDEX_NONE)
		{
		  CIDResetNode = OHTMainForm->GetCID_STD()->m_NodeArray[CIDResetNode_arr].ResetNode;
		  //CIDResetNodeType = OHTMainForm->GetCID_STD()->m_NodeArray[CIDResetNode_arr].ResetNodeType; //필요한가?
		}
		if (CIDStopNode1_arr != INDEX_NONE)
		{
		  CIDStopNode1 = OHTMainForm->GetCID_STD()->m_NodeArray[CIDStopNode1_arr].StopNode1;
		  //CIDResetNode1 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStopNode1_arr].ResetNode;
		}
		if (CIDStopNode2_arr != INDEX_NONE)
		{
		  CIDStopNode2 = OHTMainForm->GetCID_STD()->m_NodeArray[CIDStopNode2_arr].StopNode2;
		  //CIDResetNode2 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStopNode2_arr].ResetNode;
		}
		//==========================================================================================Get CID info

        //1 1. 초기화 및 동작 실행 상태
        if(m_StatusSet.uStep==DRIVING_CTRL_STEP_MANUAL_INIT)
        {
            m_StatusSet.bIsOnProcess    = true;
            m_StatusSet.byStatus        = STS_RUNNING;

            setMarkStatusFalse();   // Mark 해제
            if(pHWSet->m_pCID->ISCidOperatingMode() == false)
			{
				Manual_CID(MANUAL_CID_MODE);
				ADD_LOG("[CID Manual] DRIVING_CTRL_STEP_MANUAL_INIT Operation Mode 0 -> 1");
			}
			if(pHWSet->m_pCID->ISCidManualMode() == false)
			{
				Manual_CID(MANUAL_CID_ABNORMAL_MODE_ON);
				ADD_LOG("[CID Manual] DRIVING_CTRL_STEP_MANUAL_INIT Abnormal 0 -> 1");
			}
			if(pHWSet->m_pCID->IsLinkOK() == false)
			{
				Manual_CID(MANUAL_CID_DIRECTION_CHK);
				ADD_LOG("[CID Manual] DRIVING_CTRL_STEP_MANUAL_INIT Direction Check (Current Node: %d)", m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode);
			}
        }

    //  ADD_LOG("Manual명령 Type:%d New:%d a:d:v:s[%9.8lf:%9.8lf:%9.8lf:%8.1lf]",
    //      Info.CmdType, Info.bNew, Info.dAccel, Info.dDecel, Info.dSpeed, Info.dDist);

        //1 2. 명령 분류
        switch(Info.CmdType)
        {
        case MANUAL_DRIVING_CMD_STOP:
            m_pDrivingAxis->MoveStop(Info.dDecel);
            bMoveDistCmd    = true;
			m_StatusSet.uStep           = DRIVING_CTRL_STEP_MANUAL_CHECK_STOP;
            break;
		case MANUAL_DRIVING_CMD_FORWARD:
			m_pDrivingAxis->SetBrakeRelease(true);
			m_cSlopeNodeInfo = INIT_NTYPE;
            dAccel          = Info.dAccel;
            dDecel          = Info.dDecel;
            dSpeed          = GET_DRIVING_SPEED_IN_LIMIT(Info.dSpeed);
            dPosition       = dCurrPosition + GET_DRIVING_DIST_IN_TIMEOUT(dSpeed);
			bMoveDistCmd    = true;
			if( m_PositionInfo.CurrNode == CIDStopNode1 ||
				m_PositionInfo.CurrNode == CIDStopNode2)
			{
				CID_Confluence_Area = 1;
			}
			else
			{
				CID_Confluence_Area = 0;
			}
			//pHWSet->m_pCID->CID_Manual_Mode_On();
		 //	ADD_LOG("CID_Manual_On_1");
	//      m_StatusSet.byStatus        = STS_COMPLETE;
			break;
		case MANUAL_DRIVING_CMD_BACKWARD:
			m_pDrivingAxis->SetBrakeRelease(true);
			m_cSlopeNodeInfo = INIT_NTYPE;
			dAccel          = Info.dAccel;
			dDecel          = Info.dDecel;
			dSpeed          = GET_DRIVING_SPEED_IN_LIMIT(Info.dSpeed);
			dPosition       = dCurrPosition - GET_DRIVING_DIST_IN_TIMEOUT(dSpeed);
			bMoveDistCmd    = true;
			if( m_PositionInfo.CurrNode == CIDResetNode )
			{
				CID_Confluence_Area = 1;
			}
			else
			{
				CID_Confluence_Area = 0;
			}
			//pHWSet->m_pCID->CID_Manual_Mode_On();
		 //	ADD_LOG("CID_Manual_On_2");
	//      m_StatusSet.byStatus        = STS_COMPLETE;
            break;
		case MANUAL_DRIVING_CMD_DIST:
			m_pDrivingAxis->SetBrakeRelease(true);
            dAccel          = Info.dAccel;
            dDecel          = Info.dDecel;
            dSpeed          = GET_DRIVING_SPEED_IN_LIMIT(Info.dSpeed);
            dPosition       = Info.dDist;
            bMoveDistCmd    = true;
			if( m_PositionInfo.CurrNode == CIDStopNode1 ||
				m_PositionInfo.CurrNode == CIDStopNode2)
			{
				CID_Confluence_Area = 1;
			}
			else
			{
				CID_Confluence_Area = 0;
			}
    //      m_StatusSet.byStatus        = STS_COMPLETE;
            break;
        case MANUAL_DRIVING_CMD_FRONT_AMP_ON:
            break;
        case MANUAL_DRIVING_CMD_FRONT_AMP_OFF:
            break;
        case MANUAL_DRIVING_CMD_REAR_AMP_ON:
            break;
        case MANUAL_DRIVING_CMD_REAR_AMP_OFF:
            break;
        case MANUAL_DRIVING_CMD_BRAKE_RELEASE:
            break;
        case MANUAL_DRIVING_CMD_BRAKE_NO_REALSE:
            break;
        }

        //1 3. 주행 명령 인가 시 확인 하는 절차
        if(bMoveDistCmd==true)
        {
			switch(m_StatusSet.uStep)
            {
            case DRIVING_CTRL_STEP_MANUAL_INIT: // AMP Enable
                if( dAccel>DRIVING_MAX_ACCEL        )   nTmpError = ERR_DRIVING_ACCEL_MAX_LIMIT;
                if( dAccel<DRIVING_MIN_ACCEL        )   nTmpError = ERR_DRIVING_ACCEL_MIN_LIMIT;
                if( dDecel>DRIVING_MAX_DECEL        )   nTmpError = ERR_DRIVING_DECEL_MAX_LIMIT;
                if( dDecel<DRIVING_MIN_DECEL        )   nTmpError = ERR_DRIVING_DECEL_MIN_LIMIT;
                if( dSpeed>DRIVING_MAX_SPEED        )   nTmpError = ERR_DRIVING_SPEED_MAX_LIMIT;
                if( dSpeed<0.0                      )   nTmpError = ERR_DRIVING_SPEED_MIN_LIMIT;
                if( dPosition>MAX_DRIVING_DISTANCE  )   nTmpError = ERR_DRIVING_DIST_P_LIMIT;
                if( dPosition<MIN_DRIVING_DISTANCE  )   nTmpError = ERR_DRIVING_DIST_N_LIMIT;

                if( nTmpError                           ==NO_ERR    &&
                    m_pDrivingAxis->IsAMPEnable()       ==true      &&
					m_pDrivingAxis->IsSlaveAMPEnable()  ==true          )
                {
                    m_StatusSet.uStep=DRIVING_CTRL_STEP_MANUAL_MOVE_CMD;
                }
                else
                {
                    m_StatusSet.uStep = DRIVING_CTRL_STEP_MANUAL_AMP_ON;
                }
                break;

            case DRIVING_CTRL_STEP_MANUAL_AMP_ON:   // Check AMP Enable
                nTmpError = m_pDrivingAxis->SetAMPEnable(true);
                if(nTmpError == NO_ERR && m_pDrivingAxis->IsSyncControl())
                {
                    nTmpError = m_pDrivingAxis->SetSlaveAMPEnable(true);
                    m_StatusSet.uStep=DRIVING_CTRL_STEP_MANUAL_MOVE_CMD;
                }
                break;

            case DRIVING_CTRL_STEP_MANUAL_MOVE_CMD: // Move Cmd
                if(m_pDrivingAxis->IsAMPEnable()==true  &&  m_pDrivingAxis->IsSlaveAMPEnable()==true)
                {
					// Jog 시 근접제어 정보 초기화

					//AOHC-258 SetInnerLimitTorque_800 실패한 경우 Error 처리 Jrespect.im 2019.08.06
					if(m_pServoControl->IsSetInnerLimitTorque_800() ==false)  //DrivingControl::Manual_Driving retry x Error 처리 0
						m_pServoControl->SetInnerLimitTorque_800();

                    if(m_pServoControl->IsSetInnerLimitTorque_800() == false)
					{
						nTmpError = ERR_SERVO_DRIVING_ALARM;
						ERR_LOG("[Manual_Driving] Fail SetInnerLimitTorque_800");
					}
					else
					{
					    //ERR_LOG("[Manual_Driving] Success SetInnerLimitTorque_800");
					}

                    m_Detect.UseFollowControlFlag = false;
					m_pDrivingAxis->SetDetectInfo(m_Detect);
//					ADD_LOG("Pre:  MD Move");

					m_pDrivingAxis->MoveDistance(dAccel, dDecel, dSpeed, dPosition);

					/*
					  매뉴얼 동작시 시나리오
					  shkim. 2016.10.21
					1) CID MODE ON, Abnormal모드 ON 부터 한다 (step : DRIVING_CTRL_STEP_MANUAL_INIT 에 추가 )
					2) 링크가 되어 있지 않으면 조향정보를 보고, 해당 방향의 링크 시도
					3) 링크 성공했는지 보고(IsLinkOK), 성공인 경우
					   - 상대쪽 점유(Interlock)이 들어오지 않는다면 내가 점유한다
					   - 상대쪽이 이미 점유되어 있다면, 나는 점유하지 않는다.
					4) 링크가 끊어졌는데, 나는 점유 시도중인 경우
					   - CID통신구간 밖으로 나갔다고 생각하고, reserve off한다

					5) 링크가 끊어진 경우 재링크 과정을 통해 점유 여부를 재확인 한다.
					6) 조향 변경시 10ms 이상 차이를 주어야 함. 변경 시 Select Off, 점유 off, sleep(20) 후 select on 함..
					*/
					// Step 1. CID Mode Set, Abnormal Mode Set


					IO_INFO_CID();

					if(pHWSet->m_pCID->ISCidOperatingMode() == false)
					{
						Manual_CID(MANUAL_CID_MODE);
						ADD_LOG("[CID Manual] Operation Mode 0 -> 1");
					}
					if(pHWSet->m_pCID->ISCidManualMode() == false)
					{
						Manual_CID(MANUAL_CID_ABNORMAL_MODE_ON);
						ADD_LOG("[CID Manual] Abnormal 0 -> 1");
					}

					// Step 2. Direction Check & Link
					// if(pHWSet->m_pCID->IsLinkOK() == false)
					{
						Manual_CID(MANUAL_CID_DIRECTION_CHK);
						ADD_LOG("[CID Manual] Direction Check (Current Node: %d)", m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode);
					}

					// Step 3. Reserve On : Occupying control
					if(pHWSet->m_pCID->IsLinkOK() == true)
					{
						if(pHWSet->m_pCID->IsLinkOK() == true)	// chettering. 2회 체크해보자.
						{
							if(pHWSet->m_pCID->IsInterlock_ON() == false)
							{
								Manual_CID(MANUAL_CID_RESERVED_ON);
								ADD_LOG("[CID Manual] Occupying.. (Current Node: %d)", m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode);
							}
							else
							{
								Manual_CID(MANUAL_CID_RESERVED_OFF);
							}
						}
					}
					else
					{
						Manual_CID(MANUAL_CID_RESERVED_OFF);
					}

					// Step 4. common tag control

					// Step 4. Reserve Off
					// Abnormal 상태에서는 통과완료 처리를 하지 않는다 (2016.11.10)
					/*
					if((pHWSet->m_pCID->IsLinkOK() == false) && (pHWSet->m_pCID->IsOccupying()==true))
					{
						Manual_CID(MANUAL_CID_RESERVED_OFF);
					}
					*/


                }
                if(m_pDrivingAxis->IsRunning()==true    ||  m_pDrivingAxis->IsSlaveRunning()==true)
                {
                    m_StatusSet.uStep=DRIVING_CTRL_STEP_MANUAL_CHECK_STOP;
                }
                break;

            case DRIVING_CTRL_STEP_MANUAL_CHECK_STOP:   // Check Stop
                if(m_pDrivingAxis->IsRunning()==false   &&  m_pDrivingAxis->IsSlaveRunning()==false)
                {

                    if( m_pDrivingAxis->IsRunning()         ==false &&
                        m_pDrivingAxis->IsSlaveRunning()    ==false )
//                        m_pDrivingAxis->IsSlaveAMPEnable()  ==false     )
					{

						DWORD dwCurrTime  = timeGetTime();
                        //SetInnerLimitTorque_90 자체 800ms Sleep있으므로 2회 Retry 가능하도록 1s로 변경  #Jrespect.im
						while(OHTUTILITY::PreventOverflowGetTimeMs(dwCurrTime)<1000)      //20191104 KDS
						{
							if(m_pServoControl->IsSetInnerLimitTorque_90() ==true)
								break;

							m_pServoControl->SetInnerLimitTorque_90(); //DrivingControl::Manual_Driving Retry 존재  Error 처리 0
							Sleep(5);
						}
						

						if(m_pServoControl->IsSetInnerLimitTorque_90() == false)
						{
						   nTmpError = ERR_SERVO_DRIVING_ALARM;
						   ERR_LOG("[Manual_Driving] Fail SetInnerLimitTorque_90");
						}
						else
						{
							//ERR_LOG("[Manual_Driving] Success SetInnerLimitTorque_90");
						}

						m_StatusSet.byStatus        = STS_COMPLETE;
                        m_StatusSet.uError          = NO_ERR;
                        m_StatusSet.uStep           = DRIVING_CTRL_STEP_NONE;
                        m_StatusSet.bIsOnProcess    = false;

//                        if(m_pExecuteInfo->bJogInterlockIgnore == true)
//                        {
//        	                EnterCriticalSection(&OHTMainForm->m_CS);
//							m_pExecuteInfo->bJogInterlockIgnore = false;
//                            LeaveCriticalSection(&OHTMainForm->m_CS);
//                        }
						ADD_LOG("STS_COMPLETE");

						if(pHWSet->m_pCID->ISCidOperatingMode() == false)
						{
							Manual_CID(MANUAL_CID_MODE);
							ADD_LOG("[CID Manual] DRIVING_CTRL_STEP_MANUAL_CHECK_STOP Operation Mode 0 -> 1");
						}
						if(pHWSet->m_pCID->ISCidManualMode() == false)
						{
							Manual_CID(MANUAL_CID_ABNORMAL_MODE_ON);
							ADD_LOG("[CID Manual] DRIVING_CTRL_STEP_MANUAL_CHECK_STOP Abnormal 0 -> 1");
						}
						if(pHWSet->m_pCID->IsLinkOK() == false)
						{
							Manual_CID(MANUAL_CID_DIRECTION_CHK);
							ADD_LOG("[CID Manual] DRIVING_CTRL_STEP_MANUAL_CHECK_STOP Direction Check (Current Node: %d)", m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode);
						}
						if (pHWSet->m_pCID->ISCidManualMode() == true)
						{
							if(CID_Confluence_Area == 1)
							{// 합류 구간
								Manual_CID(MANUAL_CID_RESERVED_ON);
								ADD_LOG("[CID] Jog Stop Key - CID occup On");
							}
							else
							{
								Manual_CID(MANUAL_CID_RESERVED_OFF);
								ADD_LOG("[CID] Jog Stop Key - CID occup Off");
							}

						}

						/* 현재는 막아둠. 추후 적용 필요 20161017 김태균
						if (pHWSet->m_pCID->ISCidManualMode() == true)
						{
							pHWSet->m_pCID->CID_Manual_Mode_Off();
							ADD_LOG("CID_Manual_off");
						}
						//Abnormal Mode OFF
						*/

                    }
//                    else
//                    {
//                        m_pDrivingAxis->SetSlaveAMPEnable(false);
//
//                    }


                }
            break;
            }
        }

    }
    catch(...)
    {
        ERR_LOG("[Exception] Manual_Driving Type:%d [%6.1lf:%6.1lf:%6.1lf:%6.1lf] New:%d"
            , Info.CmdType, Info.dAccel, Info.dDecel, Info.dSpeed, Info.dDist, Info.bNew);
        nTmpError = ERR_DRV_ABNORMAL_STOP;
    }

    //1 4. 에러 처리
    if(nTmpError!=NO_ERR)
    {
        m_pDrivingAxis->MoveStop(0.001);

//        if(m_pExecuteInfo->bJogInterlockIgnore == true)
//        {
//            EnterCriticalSection(&OHTMainForm->m_CS);
//            m_pExecuteInfo->bJogInterlockIgnore = false;
//            LeaveCriticalSection(&OHTMainForm->m_CS);
//        }

//        m_pDrivingAxis->SetSlaveAMPEnable(false);

        m_StatusSet.byStatus        = STS_ERROR;
        m_StatusSet.uError          = nTmpError;
        m_StatusSet.uStep           = DRIVING_CTRL_STEP_NONE;//DRIVING_CTRL_STEP_MANUAL_INIT;
        m_StatusSet.bIsOnProcess    = false;
    }
    return nTmpError;

}



int DrivingControl::Manual_IdReader(DRIVING_MANUAL_CMD_MARK_VALUE MarkType
                                        , DRIVING_MANUAL_CMD_FRONT_ID_READER_VALUE CmdType
                                        , int* pnResultID, double* pdResultOffset)
{
    return controlIdReader(MarkType, CmdType, pnResultID, pdResultOffset);
}

int DrivingControl::Manual_FrontObservation(DRIVING_MANUAL_CMD_FRONT_OBSERVATION_VALUE Level)
{
    CTRL_INFO_OF_FRONT_DETECT DirectionCmd;
    DirectionCmd.bCmdOn = true;
	DirectionCmd.Info.UseFollowControlFlag = true;
#if(USE_CHANGENODE == 1)
    DirectionCmd.Info.OHTDetectType = (char)Level;
#else
    DirectionCmd.Info.Type = (char)Level;
#endif
    DirectionCmd.Info.NodeCount = 0;
    DirectionCmd.Info.DistSumOfStraightPath = 0;

    return controlFrontObservation(DirectionCmd);
}
//1 --- NEW WAY -----------------------------------

/**
@brief   DrivingControl Reset 함수

    1. 초기화 처리 (대기 상태 서 첫 명령 인가 시)
      1) 변수 초기화
      2) 초기 주행 기준 정보 획득

    2. 받은 명령에 대한 공통 처리
      1) 명령 추가 및 분류

@author  임태웅
@date    2012.07.28.
@return
*/
EXECUTE_ACK DrivingControl::InsertGeneralCmd(void *pDrivingInfo)    //EXECUTE_DRIVING_INFO
{
	//int     nTmpError = NO_ERR;
    EXECUTE_ACK TmpExecuteAck = EXECUTE_ACK_ON_ERR;

    //1 0. 명령의 정합성 확인
	//2 명령 Type Casting
	EXECUTE_DRIVING_INFO *pTmpDrivingInfo=(EXECUTE_DRIVING_INFO *)pDrivingInfo;

	// debug only

   if(m_StatusSet.byStatus == STS_TURN_OFF)  return EXECUTE_ACK_ON_ERR;

   //IO 강제 설정 상태 확인
   if(pHWSet->GetVHLDetectForceIOStatus() ==1)
		m_pDrivingAxis->SetVHLDetectIOSet(false);

try{
	//2 주행 거리가 최대 거리 값보다 큰 명령이 들어올 경우 정지 후 다시 주행 시작

	if(     (m_StatusSet.bIsOnProcess==true)    // 작업 중이고
		&&  (m_ClassifiedCmd.TargetInfo.SQNum!=pTmpDrivingInfo->SQNum) //시퀀스가 나눠지는 위치에서
		&&  (pTmpDrivingInfo->BasicInfo.StartType ==STOP_NTYPE) //정지노드일떄만 정지해줌.
		&&  (   (m_ClassifiedCmd.TargetInfo.dDistSumToNode + pTmpDrivingInfo->BasicInfo.dLength)
                > m_pParamSet->Axis.Limit.Position.MaxValue )// 거리의 합이 기준 초과 일 경우
    )
	{
		ADD_LOG("CmdOverDistLimit, %6.1lf + %6.1lf = %6.1lf > %6.1lf"
        , m_ClassifiedCmd.TargetInfo.dDistSumToNode
        , pTmpDrivingInfo->BasicInfo.dLength
        , (m_ClassifiedCmd.TargetInfo.dDistSumToNode + pTmpDrivingInfo->BasicInfo.dLength)
        , m_pParamSet->Axis.Limit.Position.MaxValue );

        //3 ※ Arived 이지만 잔여 명령이 남아 있을 경우, OCS로 보고시 Going으로 처리 필요
        return EXECUTE_ACK_BUSY;
	}


	if(!(pTmpDrivingInfo->AddInfo.StationType != MARK_TYPE_NODE)
		&& (m_ClassifiedCmd.TargetInfo.NextNode == pTmpDrivingInfo->AddInfo.FinalNode)
		//&& (m_InfoSet.EventAndState.State.SpeedDownPassed)
		&& (m_StatusSet.byStatus == STS_GOING)
		&& (m_StatusSet.bIsOnProcess == true) )
	{
		ADD_LOG("StationType : %d, TargetInfo.NextNode : %06d, AddInfo.FinalNode : %06d, byStatus[%d]",
				pTmpDrivingInfo->AddInfo.StationType,
				m_ClassifiedCmd.TargetInfo.NextNode,
				pTmpDrivingInfo->AddInfo.FinalNode,
				m_StatusSet.byStatus);

		return EXECUTE_ACK_BUSY;
	}

//---------------------------------------------------
    //3 VHL Lifter In/out Check
	if(((pTmpDrivingInfo->BasicInfo.NodeType >= LIFTIN_NTYPE_LEFT) && (pTmpDrivingInfo->BasicInfo.NodeType <= LIFTOUT_NTYPE)))
	{
		m_IsLifterCheck = true;

		if((m_StatusSet.byStatus == STS_GOING) &&(m_StatusSet.bIsOnProcess==true))
		{
			if(pTmpDrivingInfo->BasicInfo.NodeType == LIFTOUT_NTYPE)
			{
				//AOHC-217 VHLLifter 속도 개선
				// by jhoun.lim
				if(m_nElevetorDirection == PASS_DIRECTION_REQUEST_PASS && m_nElevetorRideStep == VHL_ELEVETOR_RIDE_CTRL_STEP_COMPLETE)
				{
					ADD_CID_LOG("[PREPASS] - Insert General Cmd : PREPASS COMPLETE! SAME DIRECTION!! Right Go.. ");
				}
				else
				{
					return EXECUTE_ACK_BUSY;
				}
			}
			else
			{
				if(m_iLifterPrePass == VHL_ELEVETOR_PREPASS_STEP_COMPLETE)
				{
					ADD_CID_LOG("[PREPASS] - Insert General Cmd : PREPASS COMPLETE! Right Go.. ");
					//m_iLifterPrePass = VHL_ELEVETOR_PREPASS_STEP_NONE;
				}else
				{
					//ADD_CID_LOG("[PREPASS] - Insert General Cmd : I'm busy ");
					return EXECUTE_ACK_BUSY;
				}				
			}
		}


	}else
		m_IsLifterCheck = false;
	// MTL
	//if((m_pExecuteInfo->FlagMTLInfo.bTakeoutCycle == true)&&((m_StatusSet.byStatus == STS_GOING)||(m_StatusSet.bIsOnProcess==true)
	//	||(m_nMTLTakeOutPIOStep != MTL_TakeOut_CTRL_STEP_OHT_MTL_Insert_Start)))
	//{
	//	//log
	//	return EXECUTE_ACK_BUSY;
	//}

	if(((pTmpDrivingInfo->BasicInfo.NodeType >= MTL_STOP_LEFT) && (pTmpDrivingInfo->BasicInfo.NodeType <= MTL_STOP_RIGTH)))
	{
		m_IsMTLCheck = true;

		if((m_StatusSet.byStatus == STS_GOING) &&(m_StatusSet.bIsOnProcess==true))
		{
			if(m_iLifterPrePass == VHL_ELEVETOR_PREPASS_STEP_COMPLETE)
			{
				ADD_CID_LOG("[PREPASS_MTL] - Insert General Cmd : PREPASS COMPLETE! Right Go.. ");
				//m_iLifterPrePass = VHL_ELEVETOR_PREPASS_STEP_NONE;
			}else
			{
				ADD_CID_LOG("[PREPASS_MTL] - Insert General Cmd : I'm busy ");

				return EXECUTE_ACK_BUSY;
			}
		}


	}else
		m_IsMTLCheck = false;

    //투입관련된 추가 인터락.
	if((m_pExecuteInfo->FlagMTLInfo.bTakeInCycle == true) &&(m_nMTLTakeInPIOStep < MTL_TakeIn_CTRL_STEP_OHT_MTL_TakeIn_Start))
	{
		ADD_CID_LOG("[bTakeInCycle_MTL] - busy ");
     	return EXECUTE_ACK_BUSY;
    }

	//김태균 선임한테 확인 필요......
//		if((pTmpDrivingInfo->BasicInfo.NodeType == MTL_NTYPE)&&((m_StatusSet.byStatus == STS_GOING)||(m_StatusSet.bIsOnProcess==true)
//		||(m_nMTLTakeInPIOStep != MTL_TakeIn_CTRL_STEP_OHT_MTL_TakeIn_Start)))
//	{
//		//log
//		return EXECUTE_ACK_BUSY;
//	}

    //Map Maker시 차이점.
	if((((pTmpDrivingInfo->AddInfo.CmdType == EXECUTE_DRIVING_CMD_MAPMAKE) && ( m_bOnMapMake == false)) ||
		((pTmpDrivingInfo->AddInfo.CmdType != EXECUTE_DRIVING_CMD_MAPMAKE) && ( m_bOnMapMake == true)))
		&&	((m_StatusSet.byStatus == STS_GOING)||(m_StatusSet.bIsOnProcess==true)))
	{
		//log
		return EXECUTE_ACK_BUSY;
	}

    //후진시 현재 주행중이 아니어야됨.
	if((((pTmpDrivingInfo->AddInfo.CmdType == EXECUTE_DRIVING_CMD_GOBACK) && ( m_bOnBackMove == false)) ||
		((pTmpDrivingInfo->AddInfo.CmdType != EXECUTE_DRIVING_CMD_GOBACK) && ( m_bOnBackMove == true)))
		&&	((m_StatusSet.byStatus == STS_GOING)||(m_StatusSet.bIsOnProcess==true)))
	{
		//log
		return EXECUTE_ACK_BUSY;
	}

//---------------------------------------------------
        //2 마크 루틴 경우 완료 후 다시 시작 : 오버런 상태일 수도 있음 / 서보 오프 중일 수 있음
	if(((m_InfoSet.EventAndState.State.MarkArea==true)  ||(m_StatusSet.uStep >= DRIVING_CTRL_STEP_GO_MARK))  &&
		(m_StatusSet.bIsOnProcess==true))
	{

		if(m_StatusSet.uStep==DRIVING_CTRL_STEP_GO_MARK)
		{
			if(((pTmpDrivingInfo->AddInfo.StationType == MARK_TYPE_TAG_STATION) ||
				(pTmpDrivingInfo->AddInfo.StationType == MARK_TYPE_QR_STATION_LEFT) ||
				(pTmpDrivingInfo->AddInfo.StationType == MARK_TYPE_QR_STATION_RIGHT))
				&&(pTmpDrivingInfo->AddInfo.DistToStation < 100))
			{
				static DWORD dwPrevTick2 = 0;
				if(OHTUTILITY::PreventOverflowGetTimeMs(dwPrevTick2) > 3000)           //20191104 KDS
				{
					ADD_LOG("CmdOn_MarkArea_Driving ->Station_Mark");
					dwPrevTick2 = timeGetTime();
				}


				return EXECUTE_ACK_BUSY;
			}
			else
			{
				//대차 센서가 Off일 경우에 마크동작 수행 후 다음 동작 처리.
				if((m_InfoSet.EventAndState.MarkState.FollowCtrlOffArea==true) || (m_pOHTDetect->CheckSensorOff() == true) || (pHWSet->GetAMCVHLDetectStatus() ==0) || (m_bIsAMCVHLDetectIgnore == true))
				{

						// 로그 중복 방지 코드
					static DWORD dwPrevTick = 0;
					if(OHTUTILITY::PreventOverflowGetTimeMs(dwPrevTick) > 3000)           //20191104 KDS
					{
						ADD_LOG("CmdOn_MarkArea_FollowCtrlOffArea");
						dwPrevTick = timeGetTime();
					}

					return EXECUTE_ACK_BUSY;
				}
				else
				{
					m_InfoSet.EventAndState.State.MarkArea=false;
					m_StatusSet.uStep = DRIVING_CTRL_STEP_GO_RUN;
					memset(&m_InfoSet.EventAndState.MarkState, 0x00, sizeof(DRIVING_MARK_STATE));
					ADD_LOG("CmdOn_MarkArea -> Run Step!!");
					ADD_MCC_LOG(",%s,DRV,NODE MARK,End,FOUP,%06d,%06d,%06d,%d,%6.1lf,Mark Type,0,Node Mark Dist,0,Node Sensor Dist,0,Node Mark Start Speed,0,Driving BCR Read Fail,0,Driving BCR Trigger Count,0",
								m_defualtparam->VHLName,
								m_mccparam.uSourceNode,
								m_mccparam.uTargetNode,
								m_pOHTMainStatus->StatusCommon.CurNodeID,
								m_pOHTMainStatus->StatusCommon.CurNodeOffset,
								m_InfoSet.HwInfo.Axis1.dSpeed);
					m_mccparam.bMarkStartFlag = false;
					m_mccparam.dMarkStartSpeed = 0.0;
					m_mccparam.dMarkStartDist = 0.0;
					m_mccparam.bBCRReadFail = false;
					m_mccparam.nBCRTriggerCount = 0;
                }
			}
		}
		else if(m_StatusSet.uStep==DRIVING_CTRL_STEP_GO_RUN)
		{
			m_InfoSet.EventAndState.State.MarkArea = false;
			memset(&m_InfoSet.EventAndState.MarkState, 0x00, sizeof(DRIVING_MARK_STATE));
		}
		else if(m_StatusSet.uStep > DRIVING_CTRL_STEP_GO_MARK)
		{
            ADD_LOG("CmdOn_MarkArea");
			return EXECUTE_ACK_BUSY;
		}
	}

		// -----------------------------------------------------------------------------
	// Lifter Pre Node Setting
	if(((pTmpDrivingInfo->BasicInfo.NodeType == LIFTPRE_NTYPE_RIGHT) || (pTmpDrivingInfo->BasicInfo.NodeType == LIFTPRE_NTYPE_LEFT))
	   ||((pTmpDrivingInfo->BasicInfo.NodeType == MTL_SEL_ON_LEFT) || (pTmpDrivingInfo->BasicInfo.NodeType == MTL_SEL_ON_RIGHT)))
//	if(Lifter_Prenode_Check(pTmpDrivingInfo->BasicInfo.StartNID))
	{
		// 리프터 진입전에는 반드시 해야 하는 값 초기화는 여기서 하자
		m_nElevetorRideStep = VHL_ELEVETOR_RIDE_CTRL_STEP_CID_INIT;
		m_iLifterPrePass = VHL_ELEVETOR_PREPASS_STEP_NONE;

		AnsiString strLogTmp;
		strLogTmp.sprintf("[LIFTER PRE] PRE IN NODE, Reset Run. node no : %d  m_nElevetorRideStep =STEP_CID_INIT  m_iLifterPrePass = VHL_ELEVETOR_PREPASS_STEP_NONE",
			pTmpDrivingInfo->BasicInfo.StartNID);
		ADD_CID_LOG(strLogTmp);
	}
	// -----------------------------------------------------------------------------
    //명령 처리 가능할 경우
//	ADD_LOG("InsertGen Step1");
	//1 1. 대기 상태에서 처음 명령이 들어온 경우
	if(m_StatusSet.bIsOnProcess==false)
	{

		if((m_pExecuteInfo->FlagInitPositon.dDrivingInitPosition !=0.0)  ||
			(m_pExecuteInfo->FlagInitPositon.bInitFlag ==true))
			{
				return EXECUTE_ACK_BUSY;
			}

//		m_pExecuteInfo->dCompensatedPosition   = 0.0;

		ADD_LOG("Cmd On Ready");


		if(setStationOffset(pDrivingInfo)==EXECUTE_ACK_NO_ERR)
        {
            m_StatusSet.bIsOnProcess = false;
            m_StatusSet.byStatus = STS_INIT;
			m_StatusSet.uStep = DRIVING_CTRL_STEP_NONE;
            m_StatusSet.uError = NO_ERR;

            ADD_LOG("set Station Offset");
			return EXECUTE_ACK_NO_ERR;
        }
        else
        {
            ADD_LOG("setStationOffset None");
		}

		//Offset 0인 경우로 주행에서 이적재로 온경우 오버런 처리.
		if((pTmpDrivingInfo->AddInfo.StationType == MARK_TYPE_TAG_STATION) ||
		 (pTmpDrivingInfo->AddInfo.StationType == MARK_TYPE_QR_STATION_LEFT) ||
		 (pTmpDrivingInfo->AddInfo.StationType == MARK_TYPE_QR_STATION_RIGHT))
		 {
				//오버런 처리
				if((m_PositionInfo.Marked ==true)&&
				  (pTmpDrivingInfo->AddInfo.DistToStation < 25))
				{
					ADD_LOG("[Driving]Overrun %d",pTmpDrivingInfo->BasicInfo.DivInfo);

					m_pExecuteInfo->FlagOverRunInfo.nFinalNode = pTmpDrivingInfo->AddInfo.StationID;
					m_pExecuteInfo->FlagOverRunInfo.bCheck = true;
					m_pExecuteInfo->FlagOverRunInfo.OverrunType = 0x02; //이적재
					m_pExecuteInfo->FlagOverRunInfo.dDrivingInitPosition = 0.0;


					m_pExecuteInfo->nCheckDivInfo =   pTmpDrivingInfo->BasicInfo.DivInfo;


					m_PositionInfo.Marked = false;
					m_PositionInfo.CurrNodeOffset =  0.0;
					m_PositionInfo.NextNode = pTmpDrivingInfo->AddInfo.ProcessingGoInfo.StartNodeID;
					m_PositionInfo.CurrStation = pTmpDrivingInfo->AddInfo.StationID;
					m_PositionInfo.StationType = pTmpDrivingInfo->AddInfo.StationType;
					m_PositionInfo.CurrCommandedStation = pTmpDrivingInfo->AddInfo.StationID;


					m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.bMarked = false;
					m_InfoSet.Position.Mark.PositionStatus.bMarked = false;
					m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.MarkType = pTmpDrivingInfo->AddInfo.StationType;
					m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uStation = pTmpDrivingInfo->AddInfo.StationID;
					m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode = pTmpDrivingInfo->AddInfo.ProcessingGoInfo.OriginStartNodeID;
					m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNextNode = pTmpDrivingInfo->AddInfo.ProcessingGoInfo.StartNodeID;
					m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset =  0.0;


					m_StatusSet.uError =  ERR_BCR_READTIMEOUT;
                    m_StatusSet.byStatus = STS_AUTORECOVERY_OVERRUN;
                    m_StatusSet.bIsOnProcess = false;
					m_StatusSet.uStep = DRIVING_CTRL_STEP_NONE;

					return EXECUTE_ACK_ON_ERR;
				}
		 }

		RESET_LOG;
		ADD_LOG("Driving Start %d",pTmpDrivingInfo->PathIndexNum);



        m_bOnBackMove=isBackMove(pDrivingInfo);

		if(m_bOnBackMove == true)
		{
		 //후진 기능에 대한 처리 할것.
			// uNiode 및 RealAriveNode는 현재 위치(MTL 진입 Node로 바꿔줄것)
			m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode       = pTmpDrivingInfo->BasicInfo.EndNID;
			m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uStation    = 0;
			m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNextNode   = 0;
			m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset     = 0;

			m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.MarkType = MARK_TYPE_TAG_STATION_BACK;

			m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.uRealArrivedNode = pTmpDrivingInfo->BasicInfo.EndNID;

			//현재 상태 갱신.
			m_InfoSet.Position.Mark.PositionStatus  = m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus;
          	setPreviousArrivalInfo(m_InfoSet.Position.Mark.PositionStatus);    ///< 이전 정보는 필요없음.
		}
		else
		{
			if(pTmpDrivingInfo->PathIndexNum ==0)
			{
				//2  현재 위치 정리
	//			if(m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.MarkType    != pTmpDrivingInfo->AddInfo.ProcessingGoInfo.)
	//					return EXECUTE_ACK_NOT_AVAILABLE_CMD;

				if(pTmpDrivingInfo->AddInfo.ProcessingGoInfo.IsStationStart == false)
				{

					m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode       = pTmpDrivingInfo->AddInfo.ProcessingGoInfo.OriginStartNodeID;
				  //	m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uStation    = =0;
				  //	m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNextNode   = pTmpDrivingInfo->BasicInfo.EndNID;
				  //	m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset     = pTmpDrivingInfo->AddInfo.DistToStation;

					m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.uRealArrivedNode = pTmpDrivingInfo->AddInfo.ProcessingGoInfo.OriginStartNodeID;


				//				m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.uRealArrivedNode = pTmpDrivingInfo->BasicInfo.StartNID;   ---실제 Mark or
				}
				else
				{
					 //			m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.bMarked          = true;    // 실제 마크된 정보를 이용. ------------------------실제 정보로 바꾸기.

					 m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode       = pTmpDrivingInfo->AddInfo.ProcessingGoInfo.OriginStartNodeID;
					 m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uStation    = pTmpDrivingInfo->AddInfo.StationID;
					 m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNextNode   = pTmpDrivingInfo->AddInfo.ProcessingGoInfo.StartNodeID;
					 m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset     = (double)pTmpDrivingInfo->AddInfo.ProcessingGoInfo.StationData_StartRunDist;

					 m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.uRealArrivedNode = pTmpDrivingInfo->AddInfo.ProcessingGoInfo.OriginStartNodeID;

					 if(m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.MarkType == MARK_TYPE_NODE)
						m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.MarkType = MARK_TYPE_OFFSET;

				}

				ADD_LOG("Driving PreviousInfo Node%06d NextNode%06d Station %06d offset %f",m_InfoSet.Position.Mark.PositionStatus.Info.uNode,m_InfoSet.Position.Mark.PositionStatus.Info.uNextNode, m_InfoSet.Position.Mark.PositionStatus.Info.uStation,m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset);
				//2 마크 정보로 정리


	//
				m_InfoSet.Position.Mark.PositionStatus  = m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus;
				//2 마크 정보를 멤버변수로 저장
				setPreviousArrivalInfo(m_InfoSet.Position.Mark.PositionStatus);    ///< 이전 정보는 필요없음.
	//			getPostionInfoOnMarked(m_InfoSet, &m_PositionInfo);       // 중요한 부분 ----------수정 필요 puting

			}
		}



		if(m_PreviousArrivalInfo.Info.uNode==0)
		{
			ERR_LOG("Error[%d] : Start Command without Mark", ERR_CURRNODE_ZERO);
			m_StatusSet.uError = ERR_CURRNODE_ZERO;
			m_StatusSet.byStatus = STS_ERROR;
			m_StatusSet.bIsOnProcess = false;
			ADD_FDC_LOG("ERR/%d/1/5/%06d/%06d/%d/%d/%06d",
						ERR_CURRNODE_ZERO,
						m_pOHTMainStatus->StatusCommon.CurNodeID,
						m_pExecuteInfo->ExecutePositionInfo.NextNode,
						m_pOHTMainStatus->StatusCommon.CurNodeOffset,
						m_pOHTMainStatus->StatusCommon.ExistFoup,
						m_pOHTMainStatus->StatusCommon.StopStationID);
			return EXECUTE_ACK_ON_ERR;
		}



		if((m_defualtparam->PreEQPIO)
		&& (m_pExecuteInfo->FlagMTLInfo.bTakeoutCycle == false)
		&& (m_pExecuteInfo->FlagMTLInfo.bTakeInCycle == false))
		{
			ExeCmdEQPIOClose();
		}


		// 1) 변수 초기화
		initStatusSet();
		initCommandSet();
		initInfoSet();
		// 2) 초기 주행 기준 정보 획득
		setCompensationInfo(m_PreviousArrivalInfo);
		initPreviousArrivalInfo();
        // 3) 보고용 Data : Mark 해제
		m_PositionInfo.Marked = false;
//		m_PositionInfo.CurrStation=0x00;
//		m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uStation = 0x00;
        // 4) MapMake 여부 확인
		m_bOnMapMake=isMapMake(pDrivingInfo);
        if(m_bOnMapMake==true)
		{
    		ADD_LOG("MapMake Start:%d %d", m_bOnMapMake,m_bMapMakeType);
		}

        // ------------------------------------------------------------------------------
        // 프로세스 진행 중으로 상태 변경.
		m_StatusSet.bIsOnProcess = true;
		m_StatusSet.byStatus = STS_GOING;
		m_pExecuteInfo->bPopListOfCmd = false;
//		DrivingCMDExuteFunc(false);

		if(pTmpDrivingInfo->AddInfo.FinalPortType == GO_FINAL_PORT_TYPE_PassBoxOut)
		{
	        m_StatusSet.uStep = DRIVING_CTRL_STEP_GO_PASSBOX;
			m_nPassBoxPIOStep = PASSBOX_CTRL_STEP_INIT;
		}
//-------------------------------------------------------------------------------------
		else if((pTmpDrivingInfo->BasicInfo.NodeType == LIFTIN_NTYPE_LEFT) ||
				(pTmpDrivingInfo->BasicInfo.NodeType == LIFTIN_NTYPE_RIGHT))
		{
			AnsiString strLogTmp;
			strLogTmp.sprintf("[LIFTER IN NODE FOUND - Node : %d PrePass : %d",
								pTmpDrivingInfo->BasicInfo.StartNID, m_iLifterPrePass);

			ADD_CID_LOG(strLogTmp);

			bReqLifterCounterReset = true;

			switch(m_iLifterPrePass)
			{
				case VHL_ELEVETOR_PREPASS_STEP_NONE:
					ADD_CID_LOG("[PREPASS] - NORMAL RIDE GO");

					m_StatusSet.uStep = DRIVING_CTRL_STEP_ELEVETOR_RIDE;
					m_nElevetorRideStep = VHL_ELEVETOR_RIDE_CTRL_STEP_CID_INIT;
				break;

				case VHL_ELEVETOR_PREPASS_STEP_TOUCH:
					ADD_CID_LOG("[PREPASS] - TOUCH RIDE GO - Current State Continue...");

					m_StatusSet.uStep = DRIVING_CTRL_STEP_ELEVETOR_RIDE;
				break;

				case VHL_ELEVETOR_PREPASS_STEP_COMPLETE:
					m_StatusSet.uStep = DRIVING_CTRL_STEP_GO_INIT;
					ADD_CID_LOG("[PREPASS] - PREPASS COMPLETE! Right Go.. ");
   				break;
            }
		}
		//MTL
		else if((pTmpDrivingInfo->BasicInfo.NodeType == MTL_STOP_LEFT) ||
				(pTmpDrivingInfo->BasicInfo.NodeType == MTL_STOP_RIGTH))
		{
			AnsiString strLogTmp;
			strLogTmp.sprintf("[LIFTER IN NODE FOUND - Node : %d PrePass : %d",
								pTmpDrivingInfo->BasicInfo.StartNID, m_iLifterPrePass);

			ADD_CID_LOG(strLogTmp);

			switch(m_iLifterPrePass)
			{
				case VHL_ELEVETOR_PREPASS_STEP_NONE:
					ADD_CID_LOG("[PREPASS] - NORMAL RIDE GO");

					m_StatusSet.uStep = DRIVING_CTRL_STEP_ELEVETOR_RIDE;
					m_nElevetorRideStep = VHL_ELEVETOR_RIDE_CTRL_STEP_CID_INIT;
				break;

				case VHL_ELEVETOR_PREPASS_STEP_TOUCH:
					ADD_CID_LOG("[PREPASS] - TOUCH RIDE GO - Current State Continue...");

					m_StatusSet.uStep = DRIVING_CTRL_STEP_ELEVETOR_RIDE;
				break;

				case VHL_ELEVETOR_PREPASS_STEP_COMPLETE:
					m_StatusSet.uStep = DRIVING_CTRL_STEP_GO_INIT;
					ADD_CID_LOG("[PREPASS] - PREPASS COMPLETE! Right Go.. ");
   				break;
            }
		}
		else if(pTmpDrivingInfo->BasicInfo.NodeType == LIFTOUT_NTYPE)
		{
			m_StatusSet.uStep = DRIVING_CTRL_STEP_ELEVETOR_OFF;
			m_nElevetorOffStep = VHL_ELEVETOR_OFF_CTRL_STEP_INIT;

			if(pTmpDrivingInfo->BasicInfo.DivInfo == PATH_DIVERGENCE_RIGHT)
				m_nElevetorDirection =PASS_DIRECTION_REQUEST_RIGHT;
			else if(pTmpDrivingInfo->BasicInfo.DivInfo == PATH_DIVERGENCE_LEFT)
				m_nElevetorDirection =PASS_DIRECTION_REQUEST_LEFT;

			ADD_LOG("[LIFTOUT_NTYPE] - Go.. %d",pTmpDrivingInfo->BasicInfo.Steering);
		}
//-------------------------------------------------------------------------------------
		else
		{
			m_StatusSet.uStep = DRIVING_CTRL_STEP_GO_INIT;
		}

		m_StatusSet.uError = NO_ERR;

        // 이전 명령이 Station 인 경우, 다음 명령이 Next Node 로의 명령이 아닌 경우
//		checkStartCmd(pTmpDrivingInfo);

		if(m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.MarkType==MARK_TYPE_NODE)
		{

				//주행인 경우 바로 들어감.
				TmpExecuteAck=  makeCmdInfoLists(pDrivingInfo);

		}
		/// 후진기능 관련 기능 적용 할 것.
		else if(m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.MarkType==MARK_TYPE_TAG_STATION_BACK)
		{

             	TmpExecuteAck = makeCmdInfoListsBack(pDrivingInfo);

        }
		else    // Station Marked
		{
			if(pTmpDrivingInfo->BasicInfo.EndNID==m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNextNode)
			{
				return EXECUTE_ACK_NOT_AVAILABLE_CMD;
			}
			else if(pTmpDrivingInfo->BasicInfo.StartNID==m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNextNode)
			{
			   // TmpDrivingInfo = m_LastDrivingCmdInfo;
			   //	memset(&(TmpDrivingInfo.AddInfo), 0x00, sizeof(EXECUTE_DRIVING_ADD_INFO));
				TmpExecuteAck=  makeCmdInfoLists(pDrivingInfo);

				ADD_LOG("[checkStartCmd] StartCmd Added TmpExecuteAck %d", TmpExecuteAck);
			}
			else
			{
				// 추후 에러 처리

			}
		}

		if(m_pOHTMainStatus->StatusCommon.StopStationID != 0)
		{
			m_mccparam.uSourceNode = m_pOHTMainStatus->StatusCommon.StopStationID;
		}
		else
		{
			m_mccparam.uSourceNode = m_pOHTMainStatus->StatusCommon.CurNodeID;
		}
	}
	else
	{
     //1 2. 명령이 추가된 경우
	//  ADD_LOG("InsertGeneralCmd_NEW #%d , %d", 3, TmpExecuteAck);
	//2 Target Node의 정보를 반영하여 응답한다.

//		DrivingCMDExuteFunc(false);   //동기화 부분

		if(m_bOnBackMove == false)
			TmpExecuteAck = makeCmdInfoLists(pDrivingInfo);
		else
			TmpExecuteAck = makeCmdInfoListsBack(pDrivingInfo);

		 m_pExecuteInfo->bPopListOfCmd = false;
    }
//  ADD_LOG("InsertGeneralCmd_NEW #%d , %d", 4, TmpExecuteAck);
	if(TmpExecuteAck==EXECUTE_ACK_NO_ERR)
	{
		delete pTmpDrivingInfo;
	}
}catch(...)
 	ADD_LOG("[InsertGen Exception!");
    //2 잘 받았다고 응답한다
    return TmpExecuteAck;
}


/**
@brief   주행 시 반복 호출되는 함수
@author  임태웅
@date    2013.08.09
@return
*/
UINT DrivingControl::ExecuteJob()
{
	static bool nPreError                   = NO_ERR;
    int             nTmpError                   = NO_ERR;

    DRIVING_HW_INFO_SET HwInfo = getHWInfo();

	static DWORD dwLastTimeOfMapMakerTriggerOn = timeGetTime();
	static DWORD dwLastTimeOfMapMakerTriggerOnQR = timeGetTime();
    // ================================================================================
    //1 0. 이상 혹은 완료 처리
	if((m_StatusSet.uError != NO_ERR) && nPreError==NO_ERR) //@ 불필요한 호출 응답
	{
		if(AutoRecovery_Driving(m_StatusSet.uError) !=NO_ERR)
		{
         	m_StatusSet.byStatus = STS_ERROR;
			stop();
		}

		return m_StatusSet.uError;
    }
    else if(m_StatusSet.uError==NO_ERR)
    {
        nPreError=NO_ERR;
    }


	if(m_StatusSet.byStatus ==  STS_GOING)
	{
		if(m_pExecuteInfo->FlagCmdExcute.bCmdDrivingCMDExcute == true)
			DrivingCMDExuteFunc(false);
    }
    // ================================================================================
    //1 1. 상태 확인 및 명령 생성
    if(nTmpError==NO_ERR)
    {

	try{
        switch(m_StatusSet.uStep)
        {
        case DRIVING_CTRL_STEP_GO_PASSBOX :
			if(nTmpError==NO_ERR)nTmpError = executeOpenPassBox(HwInfo, &m_InfoSet, &(m_StatusSet.uStep));
			break;

		case DRIVING_CTRL_STEP_ELEVETOR_RIDE:
			if(nTmpError==NO_ERR)nTmpError = executeRideEvevetor(HwInfo, &m_InfoSet, &(m_StatusSet.uStep));
			break;

		case DRIVING_CTRL_STEP_ELEVETOR_OFF:
			if(nTmpError==NO_ERR)nTmpError = executeOffEvevetor(HwInfo, &m_InfoSet, &(m_StatusSet.uStep));
			break;

        case DRIVING_CTRL_STEP_GO_INIT:
            if(nTmpError==NO_ERR)nTmpError = executeGoInit(HwInfo, &m_InfoSet, &(m_StatusSet.uStep));
            break;

        case DRIVING_CTRL_STEP_GO_PREPARE:
            if(nTmpError==NO_ERR)nTmpError = executeGoPrepare(HwInfo, &m_InfoSet, &(m_StatusSet.uStep));
            break;

        case DRIVING_CTRL_STEP_GO_FIRST_NODE:
			if(nTmpError==NO_ERR)nTmpError = executeGoFirstNode(HwInfo, &m_InfoSet, &(m_StatusSet.uStep));
            break;

		case DRIVING_CTRL_STEP_GO_RUN:
			if(nTmpError==NO_ERR)nTmpError = checkError(&m_InfoSet);
			if(nTmpError==NO_ERR)nTmpError = executeGoRun(HwInfo, &m_InfoSet, &(m_StatusSet.uStep));
            break;

        case DRIVING_CTRL_STEP_GO_MARK:
            if(nTmpError==NO_ERR)nTmpError = checkError(&m_InfoSet);
            if(nTmpError==NO_ERR)nTmpError = executeGoMark(HwInfo, &m_InfoSet, &(m_StatusSet.uStep));
            break;

		case DRIVING_CTRL_STEP_GO_CHECK_STOP:
            if(nTmpError==NO_ERR)nTmpError = checkError(&m_InfoSet);
            if(nTmpError==NO_ERR)nTmpError = executeGoCheckStop(HwInfo, &m_InfoSet, &(m_StatusSet.uStep));
            break;

		case DRIVING_CTRL_STEP_GO_COMPLETE:
            if(nTmpError==NO_ERR)nTmpError = checkError(&m_InfoSet);
            if(nTmpError==NO_ERR)
			{


				m_bIsRecovery = false;
                ////////
				DRIVING_HW_INFO_SET TempHwInfo = getHWInfo();
				//처음으로 온 위치일 경우만 리커버리 및 오보런 처리함.
				if(m_nMarkFailRetryCheckID != m_PositionInfo.CurrStation)   //동일 위치가 아닐경우만 시도함.
				{
					if(m_ClassifiedCmd.TargetInfo.Type == MARK_TYPE_TAG_STATION)
					{
						//1) 리커버리 동작 )

						DRIVING_HW_INFO_SET TempHwInfo = getHWInfo();

						if(((TempHwInfo.IO.TagStationRearOn == OFF)&& (fabs(m_pDrivingAxis->GetCurrentPosition() - m_dStationMarkInpos) > m_pParamSet->StationMarkInPos)) ||  //&&거리값 제한 추가로 둘지 고민할것.
						   (TempHwInfo.IO.TagStationFrontOn == OFF))
						{
//							m_bIsRecovery = MarkFail_Recovery_Driving();     //마지막 정지한 위치로 재이동.
							//오버런 처리.  Mark 상태 false로 만들것.
							ADD_LOG("MarkFail_S..%d %d", m_nMarkFailRetryCheckID,m_PositionInfo.CurrStation);
							m_pExecuteInfo->FlagOverRunInfo.bCheck = true;
							m_pExecuteInfo->FlagOverRunInfo.OverrunType = 0x02; //이적재
							m_pExecuteInfo->FlagOverRunInfo.nFinalNode = m_PositionInfo.CurrStation;    //주행은 주행, 이적재는 이적재
							m_pExecuteInfo->FlagOverRunInfo.dDrivingInitPosition =0.0;
							nTmpError   = ERR_BCR_READTIMEOUT;
							m_DiagManager->IncreasePreviosDiagCount(PREVIOS_DIAG_TBT);
							ADD_MD_LOG("TBT Cur Station 1 : %d",m_PositionInfo.CurrStation);
							m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.bMarked = false;
							m_InfoSet.Position.Mark.PositionStatus.bMarked = false;
						}

						/*
						TempHwInfo = getHWInfo();

						//2) 선회주행 동작(리커버리 동작했을떄만)
						if((TempHwInfo.IO.TagStationRearOn == OFF)&&
						(m_bIsRecovery == true)) //리커버리 동작을 수해한 경우만 오버런 처리할것.(오버런 처리시는 거리값은 참조안함 센서만으로 확인함)
						{
							//오버런 처리.  Mark 상태 false로 만들것.                                           /
							m_pExecuteInfo->FlagOverRunInfo.bCheck = true;
							m_pExecuteInfo->FlagOverRunInfo.OverrunType = 0x02; //이적재
							m_pExecuteInfo->FlagOverRunInfo.nFinalNode = m_PositionInfo.CurrStation;    //주행은 주행, 이적재는 이적재
							m_pExecuteInfo->FlagOverRunInfo.dDrivingInitPosition =0.0;
							nTmpError   = ERR_BCR_READTIMEOUT;

							m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.bMarked = false;
							m_InfoSet.Position.Mark.PositionStatus.bMarked = false;

						}
						*/

						m_nMarkFailRetryCheckID = m_PositionInfo.CurrStation;
					}

				}
				//soming E248 오버런 이후 리커버리 동작 추가
				else
				{
					if(m_ClassifiedCmd.TargetInfo.Type == MARK_TYPE_TAG_STATION)
					{
						DRIVING_HW_INFO_SET TempHwInfo = getHWInfo();

						if(((TempHwInfo.IO.TagStationRearOn == OFF)&& (fabs(m_pDrivingAxis->GetCurrentPosition() - m_dStationMarkInpos) > m_pParamSet->StationMarkInPos)) ||  //&&거리값 제한 추가로 둘지 고민할것.
							(TempHwInfo.IO.TagStationFrontOn == OFF))
							m_bIsRecovery = MarkFail_Recovery_Driving();
					}

				}
			}


			if(nTmpError==NO_ERR)
			{
				// Puting  만약에 통과허가 구간에서 정지할떄도 Going으로 표시해야될경우 해당구간에서 Target와 비교할것.
				EnterCriticalSection(&OHTMainForm->m_CS);
				m_pExecuteInfo->FlagInitPositon.bInitFlag = true;
				m_pExecuteInfo->FlagRunningPositon =false;
				LeaveCriticalSection(&OHTMainForm->m_CS);

				m_StatusSet.byStatus=STS_ARRIVED;
				m_StatusSet.bIsOnProcess=false;

				if(m_defualtparam->PreShutter)
				{
					m_bShutterCloseFlag = false;
					m_bShutterOpenFlag = false;

					pHWSet->m_pShutter->IO_Init();
				}

                nTmpError = executeGoComplete(HwInfo, &m_InfoSet, &(m_StatusSet.uStep));
			}

			m_bFDCMarkFailFlag = true;

			break;
		}
		}catch(...)
          ADD_LOG("[ExecuteJob Exception!");
	}

	//1 2. MapMake
    if(m_bOnMapMake==true)
	{
		if(OHTUTILITY::PreventOverflowGetTimeMs(dwLastTimeOfMapMakerTriggerOn) > 100)
		{
			m_InfoSet.Control.IdReader[0] = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;  // Stop Tag

			if(m_bMapMakeType.MapMake_StopTag ==ON)
				m_InfoSet.Control.IdReader[1] = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;  // Stop Tag

           dwLastTimeOfMapMakerTriggerOn = timeGetTime();
		}

		//QR Data 동기화 처리.
		if(m_bMapMakeType.MapMake_QR_Left_Tag ==ON)
		{
			if(m_pLeftQRR->IsQRDataSync()==false)
				m_pLeftQRR->SetQRDataSync(true);

			if( m_pLeftQRR->GetQRDataSync() == 0)
				m_InfoSet.Control.IdReader[2] = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;  // QR Left
			else if(m_pLeftQRR->GetQRDataSync() > 2)
				nTmpError = ERR_QRR_READTIMEOUT;
		}

		if(m_bMapMakeType.MapMake_QR_Right_Tag ==ON)
		{
			if(m_pRightQRR->IsQRDataSync()==false)
				m_pRightQRR->SetQRDataSync(true);

			if( m_pRightQRR->GetQRDataSync() == 0)
				m_InfoSet.Control.IdReader[3] = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON; // QR Right
			else if(m_pRightQRR->GetQRDataSync() > 2)
				nTmpError = ERR_QRR_READTIMEOUT;
		}

		// m_ListOfTmpStationData -> mapmkaer 진행중냉요이 담긴 임시  버퍼 puting
		// m_ListOfMapData -> Map Maker 관련된 내용이 담긴 버퍼            puting
		measureDist(m_InfoSet, &m_ListOfTmpStationData, &m_ListOfMapData);
	}
	else
	{
    	if(m_pLeftQRR->IsQRDataSync()==true)
			m_pLeftQRR->SetQRDataSync(false);

		if(m_pRightQRR->IsQRDataSync()==true)
			m_pRightQRR->SetQRDataSync(false);
	}


    //1 3. 명령 실행
    if(nTmpError==NO_ERR)
	{

#if 0
        if( (m_InfoSet.EventAndState.Event.StopWithNoReason==true)
        &&  (m_InfoSet.Control.Axis.byType==AXIS_CTRL_CMD_NONE)
        &&  (m_InfoSet.EventAndState.MarkState.Arrived==false)
        )
        {
            m_InfoSet.Control.Axis.byType = AXIS_CTRL_CMD_MOVE_DS;
//          m_InfoSet.Control.Axis.Dynamic.dAccel = 0;
//          m_InfoSet.Control.Axis.Dynamic.dDecel = 0;
//          m_InfoSet.Control.Axis.Dynamic.dSpeed = 0;
//          m_InfoSet.Control.Axis.Dynamic.dDist = 0;
//          m_InfoSet.Control.Axis.Dynamic.AdditionalInfo = 0;
        }
#endif

		nTmpError = controlAll(m_InfoSet.Control);
        clearDrivingCtrlInfoSet();
    }

    //1 5. 에러 처리 및 정지
	if(m_StatusSet.uError==NO_ERR && nTmpError!=NO_ERR)
	{
		if(AutoRecovery_Driving(nTmpError) !=NO_ERR)
		{
			m_StatusSet.byStatus = STS_ERROR;
			m_StatusSet.uError = nTmpError;
			m_StatusSet.bIsOnProcess=false;
			m_StatusSet.uStep = DRIVING_CTRL_STEP_NONE;

			stop();
		}


	}
		EnterCriticalSection(&OHTMainForm->m_CS);
		m_pExecuteInfo->ExecuteDrivingStep =  m_StatusSet.uStep;
		LeaveCriticalSection(&OHTMainForm->m_CS);

    // 잔여 명령 리스트 삭제
//  clearCmdInfoListsLessThan(m_InfoSet.HwInfo.Node.nNodeCount);

    return nTmpError;
}


/**
@brief   DrivingControl Class Manual_DRIVING 함수
@author  임태웅
@date    2013.07.01
*/
int DrivingControl::ExecuteManual(DRIVING_MANUAL_CMD_INFO Info)
{


}


bool DrivingControl::loadParameter(char* szFilePath, DRIVING_PARAM_SET* pParamSet)
{
    bool bRetrun = false;
    int nTmpValue = 0;
    //int nResult = 0;
	double dTmpValue = 0.0;
	bool bTmpValue = false;
	//double dResult = 0.0;
	char szSection[1024];
	memset(szSection, 0, sizeof(szSection));
	char strTempValue[8]= {0,};

    LIniFile *pIniFile;
    pIniFile = NULL;
    pIniFile = new LIniFile(szFilePath);

    if(!pIniFile->GetIniFileExist())
    {
        delete pIniFile;
        pIniFile = NULL;
    }

    if(pIniFile != NULL)
    {
        //2 (1)DRIVING_AXIS_PARAM
        //1.IniFile Read

		memset(&pParamSet->Version,0x00, sizeof(pParamSet->Version));
		pIniFile->ReadString("Version","IniVersion", "00", strTempValue);
		memmove(&pParamSet->Version, strTempValue, strlen(strTempValue)); //Return Value
		memset(strTempValue, 0, sizeof(strTempValue));


        pIniFile->ReadDoubleMinMaxCheck("AXIS","AccelMin", 0.0005, 0.0005, 0.0010, &dTmpValue);
        pParamSet->Axis.Limit.Accel.MinValue = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("AXIS","AccelMax", 0.0035, 0.0005, 0.0035, &dTmpValue);
        pParamSet->Axis.Limit.Accel.MaxValue = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("AXIS","DecelMin", 0.0005, 0.0005, 0.0010, &dTmpValue);
        pParamSet->Axis.Limit.Decel.MinValue = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("AXIS","DecelMax", 0.0035, 0.0005, 0.0035, &dTmpValue);
        pParamSet->Axis.Limit.Decel.MaxValue = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("AXIS","SpeedMin", 0.05, 0.05, 0.10, &dTmpValue);
        pParamSet->Axis.Limit.Speed.MinValue = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("AXIS","SpeedMax", 3.5, 0.1, 7.0, &dTmpValue);
        pParamSet->Axis.Limit.Speed.MaxValue = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("AXIS","AbnormalMoveSpeedMargin", 0.3, 0.05, 3.5, &dTmpValue);
        pParamSet->Axis.Limit.dAbnormalMoveSpeedMargin = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("AXIS","PositionMin", -5000, -100, -5000, &dTmpValue);
        pParamSet->Axis.Limit.Position.MinValue = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("AXIS","PositionMax", 1200000, 10000, 1200000, &dTmpValue);
        pParamSet->Axis.Limit.Position.MaxValue = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("AXIS","JogPositionMin", -1000, -10000, 0, &dTmpValue);
        pParamSet->Axis.Limit.JogPosition.MinValue = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("AXIS","JogPositionMax", 1000, 0, 10000, &dTmpValue);
        pParamSet->Axis.Limit.JogPosition.MaxValue = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("AXIS","DefaultAccel", 0.002, pParamSet->Axis.Limit.Accel.MinValue, pParamSet->Axis.Limit.Accel.MaxValue, &dTmpValue);
        pParamSet->Axis.Default.dDefaultAccel = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("AXIS","DefaultDecel", 0.003, pParamSet->Axis.Limit.Decel.MinValue, pParamSet->Axis.Limit.Decel.MaxValue, &dTmpValue);
        pParamSet->Axis.Default.dDefaultDecel = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("AXIS","EmergencyDecel", 0.0035, pParamSet->Axis.Limit.Decel.MinValue, pParamSet->Axis.Limit.Decel.MaxValue, &dTmpValue);
        pParamSet->Axis.Default.dEmergencyDecel = dTmpValue;

        //2 (2)DRIVING_MARK_PARAM

        // Node Type
        pIniFile->ReadIntegerMinMaxCheck("MARK0","Type", 0, 0, 3, &nTmpValue);
        pParamSet->Mark[0].Type = nTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("MARK0","MarginToTarget", 100, 0, 500, &dTmpValue);
        pParamSet->Mark[0].Dist.dMarginToTarget = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("MARK0","DistFromFirstToSecond", 340, 0, 500, &dTmpValue);
        pParamSet->Mark[0].Dist.dDistFromFirstToSecond = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("MARK0","LengthOfSecond", 20, 0, 500, &dTmpValue);
        pParamSet->Mark[0].Dist.dLengthOfSecond = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("MARK0","AddDistAfterFirstMet", 310, 0, 500, &dTmpValue);
		pParamSet->Mark[0].Dist.dAddDistAfetrFirstMet = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("MARK0","AddDistAfterSecondMet", 10, 0, 500, &dTmpValue);
        pParamSet->Mark[0].Dist.dAddDistAfterSecondMet = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("MARK0","ForwardMoveDistLimit", 300, 0, 500, &dTmpValue);
        pParamSet->Mark[0].Dist.dForwardMoveDistLimit = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("MARK0","BackMoveDistLimit", 100, 0, 500, &dTmpValue);
        pParamSet->Mark[0].Dist.dBackMoveDistLimit = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("MARK0","MarkInPosLimit", 0.5, 0, 500, &dTmpValue);
        pParamSet->Mark[0].Dist.dMarkInPosLimit = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("MARK0","MinLengthToNext", 400, 0, 500, &dTmpValue);
        pParamSet->Mark[0].Dist.dMinLengthToNext = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("MARK0","IgnoreTagDist", 100, 0, 200, &dTmpValue);
		pParamSet->Mark[0].Dist.dIgnoreTagDist = dTmpValue;


        pIniFile->ReadDoubleMinMaxCheck("MARK0","SpeedInFirstMet", 0.80, pParamSet->Axis.Limit.Speed.MinValue, pParamSet->Axis.Limit.Speed.MaxValue, &dTmpValue);
        pParamSet->Mark[0].Speed.dOfFirstMet = dTmpValue;//dSpeedInFirstMet = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("MARK0","SpeedInSecondMet", 0.10, pParamSet->Axis.Limit.Speed.MinValue, pParamSet->Axis.Limit.Speed.MaxValue, &dTmpValue);
        pParamSet->Mark[0].Speed.dOfSecondMet = dTmpValue;//dSpeedInSecondMet = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("MARK0","AccelInFirstMet", 0.0010, pParamSet->Axis.Limit.Decel.MinValue, pParamSet->Axis.Limit.Decel.MaxValue, &dTmpValue);
        pParamSet->Mark[0].Accel.dOfFirstMet = dTmpValue;//.dAccelInFirstMet = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("MARK0","AccelInSecondMet", 0.0005, pParamSet->Axis.Limit.Decel.MinValue, pParamSet->Axis.Limit.Decel.MaxValue, &dTmpValue);
        pParamSet->Mark[0].Accel.dOfSecondMet = dTmpValue;//.dAccelInSecondMet = dTmpValue;


        // Tag Station
        pIniFile->ReadIntegerMinMaxCheck("MARK1","Type", 1, 0, 3, &nTmpValue);
        pParamSet->Mark[1].Type = nTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("MARK1","MarginToTarget", 100, 0, 500, &dTmpValue);
        pParamSet->Mark[1].Dist.dMarginToTarget = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("MARK1","DistFromFirstToSecond", 140, 0, 500, &dTmpValue);
        pParamSet->Mark[1].Dist.dDistFromFirstToSecond = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("MARK1","LengthOfSecond", 5, 0, 500, &dTmpValue);
        pParamSet->Mark[1].Dist.dLengthOfSecond = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("MARK1","AddDistAfterFirstMet", 125, 0, 500, &dTmpValue);
        pParamSet->Mark[1].Dist.dAddDistAfetrFirstMet = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("MARK1","AddDistAfterSecondMet", 0.5, 0, 500, &dTmpValue);
        pParamSet->Mark[1].Dist.dAddDistAfterSecondMet = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("MARK1","ForwardMoveDistLimit", 300, 0, 500, &dTmpValue);
        pParamSet->Mark[1].Dist.dForwardMoveDistLimit = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("MARK1","BackMoveDistLimit", 100, 0, 500, &dTmpValue);
        pParamSet->Mark[1].Dist.dBackMoveDistLimit = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("MARK1","MarkInPosLimit", 0.5, 0, 500, &dTmpValue);
        pParamSet->Mark[1].Dist.dMarkInPosLimit = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("MARK1","MinLengthToNext", 400, 0, 500, &dTmpValue);
        pParamSet->Mark[1].Dist.dMinLengthToNext = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("MARK1","IgnoreTagDist", 180, 0, 200, &dTmpValue);
		pParamSet->Mark[1].Dist.dIgnoreTagDist = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("MARK1","SpeedInFirstMet", 0.50, pParamSet->Axis.Limit.Speed.MinValue, pParamSet->Axis.Limit.Speed.MaxValue, &dTmpValue);
        pParamSet->Mark[1].Speed.dOfFirstMet = dTmpValue;//dSpeedInFirstMet = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("MARK1","SpeedInSecondMet", 0.05, pParamSet->Axis.Limit.Speed.MinValue, pParamSet->Axis.Limit.Speed.MaxValue, &dTmpValue);
        pParamSet->Mark[1].Speed.dOfSecondMet = dTmpValue;//dSpeedInSecondMet = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("MARK1","AccelInFirstMet", 0.0010, pParamSet->Axis.Limit.Decel.MinValue, pParamSet->Axis.Limit.Decel.MaxValue, &dTmpValue);
        pParamSet->Mark[1].Accel.dOfFirstMet = dTmpValue;//.dAccelInFirstMet = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("MARK1","AccelInSecondMet", 0.0005, pParamSet->Axis.Limit.Decel.MinValue, pParamSet->Axis.Limit.Decel.MaxValue, &dTmpValue);
        pParamSet->Mark[1].Accel.dOfSecondMet = dTmpValue;//.dAccelInSecondMet = dTmpValue;


        // QR Left
        pIniFile->ReadIntegerMinMaxCheck("MARK2","Type", 2, 0, 3, &nTmpValue);
		pParamSet->Mark[2].Type = nTmpValue;

		pIniFile->ReadIntegerMinMaxCheck("MARK2","MakerType", MAKER_TYPE_KEYENCE, 0, 3, &nTmpValue);
		pParamSet->Mark[2].MakerType = nTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("MARK2","MarginToTarget", 100, 0, 500, &dTmpValue);
        pParamSet->Mark[2].Dist.dMarginToTarget = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("MARK2","DistFromFirstToSecond", 70, 0, 500, &dTmpValue);
        pParamSet->Mark[2].Dist.dDistFromFirstToSecond = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("MARK2","LengthOfSecond", 0, 0, 500, &dTmpValue);
        pParamSet->Mark[2].Dist.dLengthOfSecond = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("MARK2","AddDistAfterFirstMet", 50, 0, 500, &dTmpValue);
        pParamSet->Mark[2].Dist.dAddDistAfetrFirstMet = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("MARK2","AddDistAfterSecondMet", 0, 0, 500, &dTmpValue);
        pParamSet->Mark[2].Dist.dAddDistAfterSecondMet = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("MARK2","ForwardMoveDistLimit", 300, 0, 500, &dTmpValue);
        pParamSet->Mark[2].Dist.dForwardMoveDistLimit = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("MARK2","BackMoveDistLimit", 100, 0, 500, &dTmpValue);
        pParamSet->Mark[2].Dist.dBackMoveDistLimit = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("MARK2","MarkInPosLimit", 50, 0, 500, &dTmpValue);
        pParamSet->Mark[2].Dist.dMarkInPosLimit = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("MARK2","MinLengthToNext", 400, 0, 500, &dTmpValue);
        pParamSet->Mark[2].Dist.dMinLengthToNext = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("MARK2","IgnoreTagDist", 0, 0, 200, &dTmpValue);
		pParamSet->Mark[2].Dist.dIgnoreTagDist = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("MARK2","SpeedInFirstMet", 0.05, pParamSet->Axis.Limit.Speed.MinValue, pParamSet->Axis.Limit.Speed.MaxValue, &dTmpValue);
        pParamSet->Mark[2].Speed.dOfFirstMet = dTmpValue;//dSpeedInFirstMet = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("MARK2","SpeedInSecondMet", 0.05, pParamSet->Axis.Limit.Speed.MinValue, pParamSet->Axis.Limit.Speed.MaxValue, &dTmpValue);
        pParamSet->Mark[2].Speed.dOfSecondMet = dTmpValue;//dSpeedInSecondMet = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("MARK2","AccelInFirstMet", 0.0010, pParamSet->Axis.Limit.Decel.MinValue, pParamSet->Axis.Limit.Decel.MaxValue, &dTmpValue);
        pParamSet->Mark[2].Accel.dOfFirstMet = dTmpValue;//.dAccelInFirstMet = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("MARK2","AccelInSecondMet", 0.0005, pParamSet->Axis.Limit.Decel.MinValue, pParamSet->Axis.Limit.Decel.MaxValue, &dTmpValue);
        pParamSet->Mark[2].Accel.dOfSecondMet = dTmpValue;//.dAccelInSecondMet = dTmpValue;


        // QR Right
        pIniFile->ReadIntegerMinMaxCheck("MARK3","Type", 3, 0, 3, &nTmpValue);
		pParamSet->Mark[3].Type = nTmpValue;

		pIniFile->ReadIntegerMinMaxCheck("MARK3","MakerType", MAKER_TYPE_KEYENCE, 0, 3, &nTmpValue);
		pParamSet->Mark[3].MakerType = nTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("MARK3","MarginToTarget", 100, 0, 500, &dTmpValue);
        pParamSet->Mark[3].Dist.dMarginToTarget = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("MARK3","DistFromFirstToSecond", 70, 0, 500, &dTmpValue);
        pParamSet->Mark[3].Dist.dDistFromFirstToSecond = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("MARK3","LengthOfSecond", 0, 0, 500, &dTmpValue);
        pParamSet->Mark[3].Dist.dLengthOfSecond = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("MARK3","AddDistAfterFirstMet", 50, 0, 500, &dTmpValue);
        pParamSet->Mark[3].Dist.dAddDistAfetrFirstMet = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("MARK3","AddDistAfterSecondMet", 0, 0, 500, &dTmpValue);
        pParamSet->Mark[3].Dist.dAddDistAfterSecondMet = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("MARK3","ForwardMoveDistLimit", 300, 0, 500, &dTmpValue);
        pParamSet->Mark[3].Dist.dForwardMoveDistLimit = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("MARK3","BackMoveDistLimit", 100, 0, 500, &dTmpValue);
        pParamSet->Mark[3].Dist.dBackMoveDistLimit = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("MARK3","MarkInPosLimit", 50, 0, 500, &dTmpValue);
        pParamSet->Mark[3].Dist.dMarkInPosLimit = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("MARK3","MinLengthToNext", 400, 0, 500, &dTmpValue);
        pParamSet->Mark[3].Dist.dMinLengthToNext = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("MARK3","IgnoreTagDist", 0, 0, 200, &dTmpValue);
		pParamSet->Mark[3].Dist.dIgnoreTagDist = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("MARK3","SpeedInFirstMet", 0.05, pParamSet->Axis.Limit.Speed.MinValue, pParamSet->Axis.Limit.Speed.MaxValue, &dTmpValue);
        pParamSet->Mark[3].Speed.dOfFirstMet = dTmpValue;//dSpeedInFirstMet = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("MARK3","SpeedInSecondMet", 0.05, pParamSet->Axis.Limit.Speed.MinValue, pParamSet->Axis.Limit.Speed.MaxValue, &dTmpValue);
        pParamSet->Mark[3].Speed.dOfSecondMet = dTmpValue;//dSpeedInSecondMet = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("MARK3","AccelInFirstMet", 0.0010, pParamSet->Axis.Limit.Decel.MinValue, pParamSet->Axis.Limit.Decel.MaxValue, &dTmpValue);
        pParamSet->Mark[3].Accel.dOfFirstMet = dTmpValue;//.dAccelInFirstMet = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("MARK3","AccelInSecondMet", 0.0005, pParamSet->Axis.Limit.Decel.MinValue, pParamSet->Axis.Limit.Decel.MaxValue, &dTmpValue);
        pParamSet->Mark[3].Accel.dOfSecondMet = dTmpValue;//.dAccelInSecondMet = dTmpValue;



        //2 (3)DRIVING_STEER_PARAM
        pIniFile->ReadIntegerMinMaxCheck("STEER","ChangeTime", 1000, 500, 1000, &nTmpValue);
        pParamSet->Steer.dwChangeTime = nTmpValue;

        pIniFile->ReadIntegerMinMaxCheck("STEER","MovingTorqueTime", 100, 0, 1000, &nTmpValue);
        pParamSet->Steer.dwMovingTorqueTime = nTmpValue;

        pIniFile->ReadIntegerMinMaxCheck("STEER","CompleteCheckTime", 100, 0, 1000, &nTmpValue);
        pParamSet->Steer.dwCompleteCheckTime = nTmpValue;

        pIniFile->ReadIntegerMinMaxCheck("STEER","CompleteLimitTime", 5000, 500, 60000, &nTmpValue);
        pParamSet->Steer.dwCompleteLimitTime = nTmpValue;


        //2 (4)DRIVING_LINK_PARAM
        pIniFile->ReadDoubleMinMaxCheck("LINK","OutNodeAreaMargin", 500, 400, 600, &dTmpValue);
        pParamSet->Link.dOutNodeAreaMargin = dTmpValue;

        pIniFile->ReadDoubleMinMaxCheck("LINK","NBranchMiddleAreaInMargin", 700, 500, 1000, &dTmpValue);
        pParamSet->Link.dNBranchMiddleAreaInMargin = dTmpValue;


        //2 (5)DRIVING_FRONT_DETECT_PARAM
        pIniFile->ReadIntegerMinMaxCheck("DETECT","DetectFailChatteringTime", 200, 0, 60000, &nTmpValue);
        pParamSet->FrontDetect.dwDetectFailChatteringTime = nTmpValue;

        pIniFile->ReadIntegerMinMaxCheck("DETECT","ObsFailChatteringTime", 200, 0, 60000, &nTmpValue);
        pParamSet->FrontDetect.dwObsFailChatteringTime = nTmpValue;

        pIniFile->ReadIntegerMinMaxCheck("DETECT","ObsTimeout", 30000, 0, 60000, &nTmpValue);
		pParamSet->FrontDetect.dwObsTimeout = nTmpValue;


        pIniFile->ReadIntegerMinMaxCheck("DETECT","ObsChangeTime", 2000, 0, 15000, &nTmpValue);
        pParamSet->FrontDetect.dwObsChangeTime = nTmpValue;


        pIniFile->ReadDoubleMinMaxCheck("DETECT","ObsStraightDetectMargin",500.0, 0.0, 1000.0 , &dTmpValue);
        pParamSet->FrontDetect.dObsStraightDetectMargin = dTmpValue;

		//2 (5)Foup Cover PARAM //KYH FoupCoverChattering Test 위하여 수정
		//pIniFile->ReadIntegerMinMaxCheck("FOUPCOVER","LineFoupChattering", 1000, 1000, 1500, &nTmpValue);
		pIniFile->ReadIntegerMinMaxCheck("FOUPCOVER","LineFoupChattering", 1000, 100, 1500, &nTmpValue);
		pParamSet->FoupCover.nLineFoupChattering = nTmpValue;

		//pIniFile->ReadIntegerMinMaxCheck("FOUPCOVER","CurveFoupChattering", 3000, 3000, 3500, &nTmpValue);
		pIniFile->ReadIntegerMinMaxCheck("FOUPCOVER","CurveFoupChattering", 3000, 100, 3500, &nTmpValue);
		pParamSet->FoupCover.nCurveFoupChattering = nTmpValue;

		//pIniFile->ReadIntegerMinMaxCheck("FOUPCOVER","SPCurveFoupChattering", 3000, 3000, 5000, &nTmpValue);
		pIniFile->ReadIntegerMinMaxCheck("FOUPCOVER","SPCurveFoupChattering", 3000, 100, 5000, &nTmpValue);
		pParamSet->FoupCover.nSPCurveFoupChattering = nTmpValue;

		//2 (6)CID PARAM
		pIniFile->ReadIntegerMinMaxCheck("CID","CID_PAUSE_TIMEOVER", 30000, 1000, 60000, &nTmpValue);
		pParamSet->CID_PAUSE_TIMEOVER = nTmpValue;

		//2 (6)이적재 Tag 정위치 InPos
		pIniFile->ReadDoubleMinMaxCheck("STATION","StationMarkInPos", 2.0, 0.0, 3.0, &dTmpValue);
		pParamSet->StationMarkInPos = dTmpValue;


		//2 (6)이적재 Tag 정위치 InPos
		pIniFile->ReadIntegerMinMaxCheck("STATION","MapMakerCount_Driving", 50, 0, 500, &nTmpValue);
		pParamSet->MapMakerCount_Driving = nTmpValue;

	   //2 (6)이적재 Tag 정위치 InPos
		pIniFile->ReadIntegerMinMaxCheck("STATION","MapMakerCount_Trans", 3, 0, 100, &nTmpValue);
		pParamSet->MapMakerCount_Trans = nTmpValue;

		//2 (6)이적재 Tag 정위치 InPos
		pIniFile->ReadDoubleMinMaxCheck("STATION","MapMakerMargin_Gap", 40.0, 0.0, 70.0, &dTmpValue);
		pParamSet->MapMakerMargin_Gap = dTmpValue;


		pIniFile->ReadDoubleMinMaxCheck("STATION","ScatteredReflection", 120.0, 120.0, 150.0, &dTmpValue);
		pParamSet->ScatteredReflection = dTmpValue;

		pIniFile->ReadDoubleMinMaxCheck("STATION","ScatteredReflectionMax", 600.0, 180.0, 700.0, &dTmpValue);
		pParamSet->ScatteredReflectionMax = dTmpValue;

		pIniFile->ReadBool("VHLLIFTER", "OutPosDir", false, &bTmpValue);
		pParamSet->bVHLLifterDir = bTmpValue;

		pIniFile->ReadIntegerMinMaxCheck("CID","CIDWaitingTimeout", 10, 0, 100, &nTmpValue);
		pParamSet->CIDWaitingTimeout = nTmpValue;

		delete pIniFile;

		Reload_QR_Data();


        bRetrun = true;
    }
	else
	{
        //2 (1)DRIVING_AXIS_PARAM
		strcpy(pParamSet->Version, "00");

        pParamSet->Axis.Limit.Accel.MinValue = 0.0005;
        pParamSet->Axis.Limit.Accel.MaxValue = 0.0035;
        pParamSet->Axis.Limit.Decel.MinValue = 0.0005;
        pParamSet->Axis.Limit.Decel.MaxValue = 0.0035;
        pParamSet->Axis.Limit.Speed.MinValue = 0.05;
        pParamSet->Axis.Limit.Speed.MaxValue = 3.5;
		pParamSet->Axis.Limit.dAbnormalMoveSpeedMargin = 0.3;
        pParamSet->Axis.Limit.Position.MinValue = -5000;
        pParamSet->Axis.Limit.Position.MaxValue = 1200000;
        pParamSet->Axis.Limit.JogPosition.MinValue = -1000;
        pParamSet->Axis.Limit.JogPosition.MaxValue = 1000;
        pParamSet->Axis.Default.dDefaultAccel = 0.002;
        pParamSet->Axis.Default.dDefaultDecel = 0.003;
        pParamSet->Axis.Default.dEmergencyDecel = 0.0035;

        //2 (2)DRIVING_MARK_PARAM
        pParamSet->Mark[0].Type = 0;
        pParamSet->Mark[0].Dist.dMarginToTarget = 100;
        pParamSet->Mark[0].Dist.dDistFromFirstToSecond = 350;
        pParamSet->Mark[0].Dist.dLengthOfSecond = 40;
        pParamSet->Mark[0].Dist.dAddDistAfetrFirstMet = 320;
        pParamSet->Mark[0].Dist.dAddDistAfterSecondMet = 20;
        pParamSet->Mark[0].Dist.dForwardMoveDistLimit = 300;
        pParamSet->Mark[0].Dist.dBackMoveDistLimit = 100;
        pParamSet->Mark[0].Dist.dMarkInPosLimit = 0.5;//50;
        pParamSet->Mark[0].Dist.dMinLengthToNext = 400;
		pParamSet->Mark[0].Dist.dIgnoreTagDist = 0;
        pParamSet->Mark[0].Speed.dOfFirstMet = 0.80;//dSpeedInFirstMet = 0.80;
        pParamSet->Mark[0].Speed.dOfSecondMet= 0.10;//dSpeedInSecondMet = 0.10;
        pParamSet->Mark[0].Accel.dOfFirstMet = 0.0015;//dAccelInFirstMet = 0.0010;
        pParamSet->Mark[0].Accel.dOfSecondMet = 0.0005;//dAccelInSecondMet = 0.0005;

        pParamSet->Mark[1].Type = 1;
        pParamSet->Mark[1].Dist.dMarginToTarget = 100;
        pParamSet->Mark[1].Dist.dDistFromFirstToSecond = 140;
        pParamSet->Mark[1].Dist.dLengthOfSecond = 5;
        pParamSet->Mark[1].Dist.dAddDistAfetrFirstMet = 125;
        pParamSet->Mark[1].Dist.dAddDistAfterSecondMet = 2.5;
        pParamSet->Mark[1].Dist.dForwardMoveDistLimit = 300;
        pParamSet->Mark[1].Dist.dBackMoveDistLimit = 100;
        pParamSet->Mark[1].Dist.dMarkInPosLimit = 0.5;//50;
        pParamSet->Mark[1].Dist.dMinLengthToNext = 400;
		pParamSet->Mark[1].Dist.dIgnoreTagDist = 180;
        pParamSet->Mark[1].Speed.dOfFirstMet = 0.50;//dSpeedInFirstMet = 0.50;
        pParamSet->Mark[1].Speed.dOfSecondMet = 0.05;//dSpeedInSecondMet = 0.05;
        pParamSet->Mark[1].Accel.dOfFirstMet = 0.0015;//dAccelInFirstMet = 0.0010;
        pParamSet->Mark[1].Accel.dOfSecondMet = 0.0005;//dAccelInSecondMet = 0.0005;

		pParamSet->Mark[2].Type = 2;
		pParamSet->Mark[2].MakerType = MAKER_TYPE_KEYENCE;
        pParamSet->Mark[2].Dist.dMarginToTarget = 100;
        pParamSet->Mark[2].Dist.dDistFromFirstToSecond = 70;
        pParamSet->Mark[2].Dist.dLengthOfSecond = 0;
        pParamSet->Mark[2].Dist.dAddDistAfetrFirstMet = 50;
        pParamSet->Mark[2].Dist.dAddDistAfterSecondMet = 0;
        pParamSet->Mark[2].Dist.dForwardMoveDistLimit = 300;
        pParamSet->Mark[2].Dist.dBackMoveDistLimit = 100;
        pParamSet->Mark[2].Dist.dMarkInPosLimit = 0.5;//50;
        pParamSet->Mark[2].Dist.dMinLengthToNext = 400;
		pParamSet->Mark[2].Dist.dIgnoreTagDist = 0;
        pParamSet->Mark[2].Speed.dOfFirstMet = 0.10;//0.05;//dSpeedInFirstMet = 0.05;
        pParamSet->Mark[2].Speed.dOfSecondMet = 0.10;//0.05;//dSpeedInSecondMet = 0.05;
        pParamSet->Mark[2].Accel.dOfFirstMet = 0.0010;//dAccelInFirstMet = 0.0010;
        pParamSet->Mark[2].Accel.dOfSecondMet = 0.0005;//dAccelInSecondMet = 0.0005;

		pParamSet->Mark[3].Type = 3;
		pParamSet->Mark[3].MakerType = MAKER_TYPE_KEYENCE;
        pParamSet->Mark[3].Dist.dMarginToTarget = 100;
        pParamSet->Mark[3].Dist.dDistFromFirstToSecond = 70;
        pParamSet->Mark[3].Dist.dLengthOfSecond = 0;
        pParamSet->Mark[3].Dist.dAddDistAfetrFirstMet = 50;
        pParamSet->Mark[3].Dist.dAddDistAfterSecondMet = 0;
        pParamSet->Mark[3].Dist.dForwardMoveDistLimit = 300;
        pParamSet->Mark[3].Dist.dBackMoveDistLimit = 100;
        pParamSet->Mark[3].Dist.dMarkInPosLimit = 0.5;//50;
        pParamSet->Mark[3].Dist.dMinLengthToNext = 400;
		pParamSet->Mark[3].Dist.dIgnoreTagDist = 0;
        pParamSet->Mark[3].Speed.dOfFirstMet = 0.10;//0.05;//dSpeedInFirstMet = 0.05;
        pParamSet->Mark[3].Speed.dOfSecondMet = 0.10;//0.05;//dSpeedInSecondMet = 0.05;
        pParamSet->Mark[3].Accel.dOfFirstMet = 0.0010;//dAccelInFirstMet = 0.0010;
        pParamSet->Mark[3].Accel.dOfSecondMet = 0.0005;//dAccelInSecondMet = 0.0005;

        //2 (3)DRIVING_STEER_PARAM
        pParamSet->Steer.dwChangeTime = 1000;
        pParamSet->Steer.dwMovingTorqueTime = 100;
        pParamSet->Steer.dwCompleteCheckTime = 100;
        pParamSet->Steer.dwCompleteLimitTime = 5000;

        //2 (4)DRIVING_LINK_PARAM
        pParamSet->Link.dOutNodeAreaMargin = 500;
        pParamSet->Link.dNBranchMiddleAreaInMargin = 700;

        //2 (5)DRIVING_FRONT_DETECT_PARAM
        pParamSet->FrontDetect.dwDetectFailChatteringTime = 200;
        pParamSet->FrontDetect.dwObsFailChatteringTime = 200;
		pParamSet->FrontDetect.dwObsTimeout = 30000;
		pParamSet->FrontDetect.dwObsChangeTime = 2000;
        pParamSet->FrontDetect.dObsStraightDetectMargin = 500.0;

		//2 (5)Foup Cover PARAM
		pParamSet->FoupCover.nLineFoupChattering = 200;
		pParamSet->FoupCover.nCurveFoupChattering = 900;
		pParamSet->FoupCover.nSPCurveFoupChattering = 3000;

		//2 (6)CID PARAM
		pParamSet->CID_PAUSE_TIMEOVER = 30000;

		pParamSet->StationMarkInPos = 2.0;
		pParamSet->MapMakerCount_Driving = 50;
		pParamSet->MapMakerCount_Trans = 3;
		pParamSet->MapMakerMargin_Gap = 40.0;
		pParamSet->ScatteredReflection = 120;
		pParamSet->ScatteredReflectionMax = 600;
		pParamSet->bVHLLifterDir  = false;
		pParamSet->CIDWaitingTimeout = 10;
    }



    return bRetrun;
}



bool DrivingControl::loadParameterRecovery(char* szFilePath, DRIVING_PARAM_SET* pParamSet)
{
	bool bSuccess = true;
    int nTmpValue = 0;
    //int nResult = 0;
	double dTmpValue = 0.0;
	bool bTmpValue = false;
	//double dResult = 0.0;
	char szSection[1024];
	memset(szSection, 0, sizeof(szSection));
	char strTempValue[8]= {0,};
	bool bCheckParam = false;

    LIniFile *pIniFile;
    pIniFile = NULL;
    pIniFile = new LIniFile(szFilePath);

    if(!pIniFile->GetIniFileExist())
    {
        delete pIniFile;
		pIniFile = NULL;
		bSuccess = false;
    }

    if(pIniFile != NULL)
    {
        //2 (1)DRIVING_AXIS_PARAM
        //1.IniFile Read
		pIniFile->ReadString("Version","IniVersion", "00", strTempValue);
		if(StrToIntA(strTempValue) <= StrToIntA(pParamSet->Version))
			bSuccess = false;
		else
		{
			memmove(&pParamSet->Version, strTempValue, strlen(strTempValue)); //Return Value
			memset(strTempValue, 0, sizeof(strTempValue));
		}


		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("AXIS","AccelMin", 0.0005, 0.0005, 0.0010, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Axis.Limit.Accel.MinValue = dTmpValue;
			}
			else
			{
            	bSuccess = false;
            }

		}

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("AXIS","AccelMax", 0.0035, 0.0005, 0.0035, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Axis.Limit.Accel.MaxValue = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("AXIS","DecelMin", 0.0005, 0.0005, 0.0010, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Axis.Limit.Decel.MinValue = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("AXIS","DecelMax", 0.0035, 0.0005, 0.0035, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Axis.Limit.Decel.MaxValue = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("AXIS","SpeedMin", 0.05, 0.05, 0.10, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Axis.Limit.Speed.MinValue = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("AXIS","SpeedMax", 3.5, 0.1, 7.0, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Axis.Limit.Speed.MaxValue = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("AXIS","AbnormalMoveSpeedMargin", 0.3, 0.05, 3.5, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Axis.Limit.dAbnormalMoveSpeedMargin = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("AXIS","PositionMin", -50000, -100000, -5000, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Axis.Limit.Position.MinValue = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}


		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("AXIS","PositionMax", 1200000, 10000, 1500000, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Axis.Limit.Position.MaxValue = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("AXIS","JogPositionMin", -1000, -10000, 0, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Axis.Limit.JogPosition.MinValue = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("AXIS","JogPositionMax", 1000, 0, 10000, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Axis.Limit.JogPosition.MaxValue = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("AXIS","DefaultAccel", 0.002, pParamSet->Axis.Limit.Accel.MinValue, pParamSet->Axis.Limit.Accel.MaxValue, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Axis.Default.dDefaultAccel = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("AXIS","DefaultDecel", 0.003, pParamSet->Axis.Limit.Decel.MinValue, pParamSet->Axis.Limit.Decel.MaxValue, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Axis.Default.dDefaultDecel = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("AXIS","EmergencyDecel", 0.0035, pParamSet->Axis.Limit.Decel.MinValue, pParamSet->Axis.Limit.Decel.MaxValue, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Axis.Default.dEmergencyDecel = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

        //2 (2)DRIVING_MARK_PARAM

		// Node Type

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadIntegerMinMaxVerification("MARK0","Type", 0, 0, 3, &nTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[0].Type = nTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("MARK0","MarginToTarget", 100, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[0].Dist.dMarginToTarget = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("MARK0","DistFromFirstToSecond", 340, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[0].Dist.dDistFromFirstToSecond = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("MARK0","LengthOfSecond", 20, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[0].Dist.dLengthOfSecond = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("MARK0","AddDistAfterFirstMet", 310, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[0].Dist.dAddDistAfetrFirstMet = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("MARK0","AddDistAfterSecondMet", 10, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[0].Dist.dAddDistAfterSecondMet = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("MARK0","ForwardMoveDistLimit", 300, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[0].Dist.dForwardMoveDistLimit = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("MARK0","BackMoveDistLimit", 100, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[0].Dist.dBackMoveDistLimit = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("MARK0","MarkInPosLimit", 0.5, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[0].Dist.dMarkInPosLimit = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("MARK0","MinLengthToNext", 400, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[0].Dist.dMinLengthToNext = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("MARK0","IgnoreTagDist", 100, 0, 200, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[0].Dist.dIgnoreTagDist = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("MARK0","SpeedInFirstMet", 0.80, pParamSet->Axis.Limit.Speed.MinValue, pParamSet->Axis.Limit.Speed.MaxValue, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[0].Speed.dOfFirstMet = dTmpValue;//dSpeedInFirstMet = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("MARK0","SpeedInSecondMet", 0.10, pParamSet->Axis.Limit.Speed.MinValue, pParamSet->Axis.Limit.Speed.MaxValue, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[0].Speed.dOfSecondMet = dTmpValue;//dSpeedInSecondMet = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("MARK0","AccelInFirstMet", 0.0010, pParamSet->Axis.Limit.Decel.MinValue, pParamSet->Axis.Limit.Decel.MaxValue, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[0].Accel.dOfFirstMet = dTmpValue;//.dAccelInFirstMet = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("MARK0","AccelInSecondMet", 0.0005, pParamSet->Axis.Limit.Decel.MinValue, pParamSet->Axis.Limit.Decel.MaxValue, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[0].Accel.dOfSecondMet = dTmpValue;//.dAccelInSecondMet = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}


		// Tag Station

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadIntegerMinMaxVerification("MARK1","Type", 1, 0, 3, &nTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[1].Type = nTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK1","MarginToTarget", 100, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[1].Dist.dMarginToTarget = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK1","DistFromFirstToSecond", 140, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[1].Dist.dDistFromFirstToSecond = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK1","LengthOfSecond", 5, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[1].Dist.dLengthOfSecond = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK1","AddDistAfterFirstMet", 125, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[1].Dist.dAddDistAfetrFirstMet = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK1","AddDistAfterSecondMet", 0.5, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[1].Dist.dAddDistAfterSecondMet = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK1","ForwardMoveDistLimit", 300, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[1].Dist.dForwardMoveDistLimit = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK1","BackMoveDistLimit", 100, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[1].Dist.dBackMoveDistLimit = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK1","MarkInPosLimit", 0.5, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[1].Dist.dMarkInPosLimit = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK1","MinLengthToNext", 400, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[1].Dist.dMinLengthToNext = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK1","IgnoreTagDist", 180, 0, 200, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[1].Dist.dIgnoreTagDist = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK1","SpeedInFirstMet", 0.50, pParamSet->Axis.Limit.Speed.MinValue, pParamSet->Axis.Limit.Speed.MaxValue, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[1].Speed.dOfFirstMet = dTmpValue;//dSpeedInFirstMet = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK1","SpeedInSecondMet", 0.05, pParamSet->Axis.Limit.Speed.MinValue, pParamSet->Axis.Limit.Speed.MaxValue, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[1].Speed.dOfSecondMet = dTmpValue;//dSpeedInSecondMet = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK1","AccelInFirstMet", 0.0010, pParamSet->Axis.Limit.Decel.MinValue, pParamSet->Axis.Limit.Decel.MaxValue, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[1].Accel.dOfFirstMet = dTmpValue;//.dAccelInFirstMet = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK1","AccelInSecondMet", 0.0005, pParamSet->Axis.Limit.Decel.MinValue, pParamSet->Axis.Limit.Decel.MaxValue, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[1].Accel.dOfSecondMet = dTmpValue;//.dAccelInSecondMet = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}


		// QR Left

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadIntegerMinMaxVerification("MARK2","Type", 2, 0, 3, &nTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[2].Type = nTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadIntegerMinMaxVerification("MARK2","MakerType", MAKER_TYPE_KEYENCE, 0, 3, &nTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[2].MakerType = nTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK2","MarginToTarget", 100, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[2].Dist.dMarginToTarget = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK2","DistFromFirstToSecond", 70, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[2].Dist.dDistFromFirstToSecond = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK2","LengthOfSecond", 0, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[2].Dist.dLengthOfSecond = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

 		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK2","AddDistAfterFirstMet", 50, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[2].Dist.dAddDistAfetrFirstMet = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

 		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK2","AddDistAfterSecondMet", 0, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[2].Dist.dAddDistAfterSecondMet = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK2","ForwardMoveDistLimit", 300, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[2].Dist.dForwardMoveDistLimit = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK2","BackMoveDistLimit", 100, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[2].Dist.dBackMoveDistLimit = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK2","MarkInPosLimit", 50, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[2].Dist.dMarkInPosLimit = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK2","MinLengthToNext", 400, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[2].Dist.dMinLengthToNext = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK2","IgnoreTagDist", 0, 0, 200, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[2].Dist.dIgnoreTagDist = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK2","SpeedInFirstMet", 0.05, pParamSet->Axis.Limit.Speed.MinValue, pParamSet->Axis.Limit.Speed.MaxValue, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[2].Speed.dOfFirstMet = dTmpValue;//dSpeedInFirstMet = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK2","SpeedInSecondMet", 0.05, pParamSet->Axis.Limit.Speed.MinValue, pParamSet->Axis.Limit.Speed.MaxValue, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[2].Speed.dOfSecondMet = dTmpValue;//dSpeedInSecondMet = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK2","AccelInFirstMet", 0.0010, pParamSet->Axis.Limit.Decel.MinValue, pParamSet->Axis.Limit.Decel.MaxValue, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[2].Accel.dOfFirstMet = dTmpValue;//.dAccelInFirstMet = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK2","AccelInSecondMet", 0.0005, pParamSet->Axis.Limit.Decel.MinValue, pParamSet->Axis.Limit.Decel.MaxValue, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[2].Accel.dOfSecondMet = dTmpValue;//.dAccelInSecondMet = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}


		// QR Right
		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadIntegerMinMaxVerification("MARK3","Type", 3, 0, 3, &nTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[3].Type = nTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadIntegerMinMaxVerification("MARK3","MakerType", MAKER_TYPE_KEYENCE, 0, 3, &nTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[3].MakerType = nTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK3","MarginToTarget", 100, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[3].Dist.dMarginToTarget = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK3","DistFromFirstToSecond", 70, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[3].Dist.dDistFromFirstToSecond = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK3","LengthOfSecond", 0, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[3].Dist.dLengthOfSecond = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK3","AddDistAfterFirstMet", 50, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[3].Dist.dAddDistAfetrFirstMet = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK3","AddDistAfterSecondMet", 0, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[3].Dist.dAddDistAfterSecondMet = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK3","ForwardMoveDistLimit", 300, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[3].Dist.dForwardMoveDistLimit = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK3","BackMoveDistLimit", 100, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[3].Dist.dBackMoveDistLimit = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK3","MarkInPosLimit", 50, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[3].Dist.dMarkInPosLimit = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK3","MinLengthToNext", 400, 0, 500, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[3].Dist.dMinLengthToNext = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK3","IgnoreTagDist", 0, 0, 200, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[3].Dist.dIgnoreTagDist = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK3","SpeedInFirstMet", 0.05, pParamSet->Axis.Limit.Speed.MinValue, pParamSet->Axis.Limit.Speed.MaxValue, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[3].Speed.dOfFirstMet = dTmpValue;//dSpeedInFirstMet = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK3","SpeedInSecondMet", 0.05, pParamSet->Axis.Limit.Speed.MinValue, pParamSet->Axis.Limit.Speed.MaxValue, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[3].Speed.dOfSecondMet = dTmpValue;//dSpeedInSecondMet = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadDoubleMinMaxVerification("MARK3","AccelInFirstMet", 0.0010, pParamSet->Axis.Limit.Decel.MinValue, pParamSet->Axis.Limit.Decel.MaxValue, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[3].Accel.dOfFirstMet = dTmpValue;//.dAccelInFirstMet = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

 		if(bSuccess)
		{
			bCheckParam =   pIniFile->ReadDoubleMinMaxVerification("MARK3","AccelInSecondMet", 0.0005, pParamSet->Axis.Limit.Decel.MinValue, pParamSet->Axis.Limit.Decel.MaxValue, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Mark[3].Accel.dOfSecondMet = dTmpValue;//.dAccelInSecondMet = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}


		//2 (3)DRIVING_STEER_PARAM
 		if(bSuccess)
		{
			bCheckParam =   pIniFile->ReadIntegerMinMaxVerification("STEER","ChangeTime", 1000, 500, 1000, &nTmpValue);
			if(bCheckParam)
			{
				pParamSet->Steer.dwChangeTime = nTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

 		if(bSuccess)
		{
			bCheckParam =   pIniFile->ReadIntegerMinMaxVerification("STEER","MovingTorqueTime", 100, 0, 1000, &nTmpValue);
			if(bCheckParam)
			{
				pParamSet->Steer.dwMovingTorqueTime = nTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

 		if(bSuccess)
		{
			bCheckParam =   pIniFile->ReadIntegerMinMaxVerification("STEER","CompleteCheckTime", 100, 0, 1000, &nTmpValue);
			if(bCheckParam)
			{
				pParamSet->Steer.dwCompleteCheckTime = nTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

 		if(bSuccess)
		{
			bCheckParam =   pIniFile->ReadIntegerMinMaxVerification("STEER","CompleteLimitTime", 5000, 500, 60000, &nTmpValue);
			if(bCheckParam)
			{
				pParamSet->Steer.dwCompleteLimitTime = nTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		//2 (4)DRIVING_LINK_PARAM

 		if(bSuccess)
		{
			bCheckParam =   pIniFile->ReadDoubleMinMaxVerification("LINK","OutNodeAreaMargin", 500, 400, 600, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Link.dOutNodeAreaMargin = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

 		if(bSuccess)
		{
			bCheckParam =   pIniFile->ReadDoubleMinMaxVerification("LINK","NBranchMiddleAreaInMargin", 700, 500, 1000, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->Link.dNBranchMiddleAreaInMargin = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		//2 (5)DRIVING_FRONT_DETECT_PARAM
 		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadIntegerMinMaxVerification("DETECT","DetectFailChatteringTime", 200, 0, 60000, &nTmpValue);
			if(bCheckParam)
			{
				pParamSet->FrontDetect.dwDetectFailChatteringTime = nTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

 		if(bSuccess)
		{
			bCheckParam =  pIniFile->ReadIntegerMinMaxVerification("DETECT","ObsFailChatteringTime", 200, 0, 60000, &nTmpValue);
			if(bCheckParam)
			{
				pParamSet->FrontDetect.dwObsFailChatteringTime = nTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

 		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadIntegerMinMaxVerification("DETECT","ObsTimeout", 30000, 0, 60000, &nTmpValue);
			if(bCheckParam)
			{
				pParamSet->FrontDetect.dwObsTimeout = nTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

 		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadIntegerMinMaxVerification("DETECT","ObsChangeTime", 2000, 0, 15000, &nTmpValue);
			if(bCheckParam)
			{
				pParamSet->FrontDetect.dwObsChangeTime = nTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

 		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("DETECT","ObsStraightDetectMargin",500.0, 0.0, 1000.0 , &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->FrontDetect.dObsStraightDetectMargin = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}


		//2 (5)Foup Cover PARAM
 		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadIntegerMinMaxVerification("FOUPCOVER","LineFoupChattering", 1000, 100, 1500, &nTmpValue);
			if(bCheckParam)
			{
				pParamSet->FoupCover.nLineFoupChattering = nTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

 		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadIntegerMinMaxVerification("FOUPCOVER","CurveFoupChattering", 3000, 100, 3500, &nTmpValue);
			if(bCheckParam)
			{
				pParamSet->FoupCover.nCurveFoupChattering = nTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

 		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadIntegerMinMaxVerification("FOUPCOVER","SPCurveFoupChattering", 3000, 100, 5000, &nTmpValue);
			if(bCheckParam)
			{
				pParamSet->FoupCover.nSPCurveFoupChattering = nTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		//2 (6)CID PARAM
 		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadIntegerMinMaxVerification("CID","CID_PAUSE_TIMEOVER", 30000, 1000, 60000, &nTmpValue);
			if(bCheckParam)
			{
				pParamSet->CID_PAUSE_TIMEOVER = nTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}


		//2 (6)이적재 Tag 정위치 InPos
 		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("STATION","StationMarkInPos", 2.0, 0.0, 3.0, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->StationMarkInPos = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		//2 (6)이적재 Tag 정위치 InPos
		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadIntegerMinMaxVerification("STATION","MapMakerCount_Driving", 50, 0, 500, &nTmpValue);
			if(bCheckParam)
			{
				pParamSet->MapMakerCount_Driving = nTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}


	   //2 (6)이적재 Tag 정위치 InPos
 		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadIntegerMinMaxVerification("STATION","MapMakerCount_Trans", 3, 0, 100, &nTmpValue);
			if(bCheckParam)
			{
				pParamSet->MapMakerCount_Trans = nTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}


		//2 (6)이적재 Tag 정위치 InPos
 		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("STATION","MapMakerMargin_Gap", 40.0, 0.0, 70.0, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->MapMakerMargin_Gap = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

 		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("STATION","ScatteredReflection", 120.0, 120.0, 150.0, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->ScatteredReflection = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

 		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadDoubleMinMaxVerification("STATION","ScatteredReflectionMax", 600.0, 180.0, 700.0, &dTmpValue);
			if(bCheckParam)
			{
				pParamSet->ScatteredReflectionMax = dTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

 		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadBoolVerification("VHLLIFTER", "OutPosDir", false, &bTmpValue);
			if(bCheckParam)
			{
				pParamSet->bVHLLifterDir = bTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}

		if(bSuccess)
		{
			bCheckParam = pIniFile->ReadIntegerMinMaxVerification("CID","CIDWaitingTimeout", 10, 0, 100, &nTmpValue);
			if(bCheckParam)
			{
				pParamSet->CIDWaitingTimeout = nTmpValue;
			}
			else
			{
				bSuccess = false;
			}

		}



		delete pIniFile;

		if(bSuccess)
			Reload_QR_Data();

    }
	else
	{
       	bSuccess = false;
    }

	if(bSuccess ==false)
	{
		bCheckParam = loadParameter("DataFiles\\Driving.bgk", pParamSet);
		if(bCheckParam)
			saveParameter("DataFiles\\Driving.ini", pParamSet);
		else
           m_ParamChehckError = ERR_PARADATA_LOAD_FAIL;
	}
	else
	{
		saveParameter("DataFiles\\Driving.bgk", pParamSet);
		m_ParamChehckError = NO_ERR;
    }

    return bSuccess;
}


bool DrivingControl::saveParameter(char* szPath, DRIVING_PARAM_SET* pParamSet)
{
    bool bResult = false;

    LIniFile *m_lWriteIniFile;
    m_lWriteIniFile = NULL;
    m_lWriteIniFile = new LIniFile(szPath);


    if(!m_lWriteIniFile->GetIniFileExist())
    {
		delete m_lWriteIniFile;
		m_lWriteIniFile = NULL;
    }

    if(m_lWriteIniFile != NULL)
    {
        m_lWriteIniFile->DeleteIniFile();

        //1. [DRIVING_AXIS_PARAM]
//        m_lWriteIniFile->WriteDouble("AXIS","IdealGearRatio", pParamSet->Axis.GearRatio.dIdealGearRatio);
//        m_lWriteIniFile->WriteDouble("AXIS","Ideal2RealRatio", pParamSet->Axis.GearRatio.dIdeal2RealRatio);
		m_lWriteIniFile->WriteString("Version","IniVersion", pParamSet->Version);

        m_lWriteIniFile->WriteDouble("AXIS","AccelMin", pParamSet->Axis.Limit.Accel.MinValue);
        m_lWriteIniFile->WriteDouble("AXIS","AccelMax", pParamSet->Axis.Limit.Accel.MaxValue);
        m_lWriteIniFile->WriteDouble("AXIS","DecelMin", pParamSet->Axis.Limit.Decel.MinValue);
        m_lWriteIniFile->WriteDouble("AXIS","DecelMax", pParamSet->Axis.Limit.Decel.MaxValue);
        m_lWriteIniFile->WriteDouble("AXIS","SpeedMin", pParamSet->Axis.Limit.Speed.MinValue);
        m_lWriteIniFile->WriteDouble("AXIS","SpeedMax", pParamSet->Axis.Limit.Speed.MaxValue);
		m_lWriteIniFile->WriteDouble("AXIS","AbnormalMoveSpeedMargin", pParamSet->Axis.Limit.dAbnormalMoveSpeedMargin);
        m_lWriteIniFile->WriteDouble("AXIS","PositionMin", pParamSet->Axis.Limit.Position.MinValue);
        m_lWriteIniFile->WriteDouble("AXIS","PositionMax", pParamSet->Axis.Limit.Position.MaxValue);
        m_lWriteIniFile->WriteDouble("AXIS","JogPositionMin", pParamSet->Axis.Limit.JogPosition.MinValue);
        m_lWriteIniFile->WriteDouble("AXIS","JogPositionMax", pParamSet->Axis.Limit.JogPosition.MaxValue);
        m_lWriteIniFile->WriteDouble("AXIS","DefaultAccel", pParamSet->Axis.Default.dDefaultAccel);
        m_lWriteIniFile->WriteDouble("AXIS","DefaultDecel", pParamSet->Axis.Default.dDefaultDecel);
        m_lWriteIniFile->WriteDouble("AXIS","EmergencyDecel", pParamSet->Axis.Default.dEmergencyDecel);

        //2. [DRIVING_MARK_PARAM]

        //MARK0
        m_lWriteIniFile->WriteInteger("MARK0","Type", pParamSet->Mark[0].Type);
        m_lWriteIniFile->WriteDouble("MARK0","MarginToTarget", pParamSet->Mark[0].Dist.dMarginToTarget);
        m_lWriteIniFile->WriteDouble("MARK0","DistFromFirstToSecond", pParamSet->Mark[0].Dist.dDistFromFirstToSecond );
        m_lWriteIniFile->WriteDouble("MARK0","LengthOfSecond", pParamSet->Mark[0].Dist.dLengthOfSecond);
        m_lWriteIniFile->WriteDouble("MARK0","AddDistAfterFirstMet", pParamSet->Mark[0].Dist.dAddDistAfetrFirstMet);
        m_lWriteIniFile->WriteDouble("MARK0","AddDistAfterSecondMet", pParamSet->Mark[0].Dist.dAddDistAfterSecondMet);
        m_lWriteIniFile->WriteDouble("MARK0","ForwardMoveDistLimit", pParamSet->Mark[0].Dist.dForwardMoveDistLimit);
        m_lWriteIniFile->WriteDouble("MARK0","BackMoveDistLimit", pParamSet->Mark[0].Dist.dBackMoveDistLimit);
        m_lWriteIniFile->WriteDouble("MARK0","MarkInPosLimit", pParamSet->Mark[0].Dist.dMarkInPosLimit);
        m_lWriteIniFile->WriteDouble("MARK0","MinLengthToNext", pParamSet->Mark[0].Dist.dMinLengthToNext);
		m_lWriteIniFile->WriteDouble("MARK0","IgnoreTagDist", pParamSet->Mark[0].Dist.dIgnoreTagDist);
        m_lWriteIniFile->WriteDouble("MARK0","SpeedInFirstMet", pParamSet->Mark[0].Speed.dOfFirstMet);
        m_lWriteIniFile->WriteDouble("MARK0","SpeedInSecondMet",pParamSet->Mark[0].Speed.dOfSecondMet);
        m_lWriteIniFile->WriteDouble("MARK0","AccelInFirstMet", pParamSet->Mark[0].Accel.dOfFirstMet);
        m_lWriteIniFile->WriteDouble("MARK0","AccelInSecondMet", pParamSet->Mark[0].Accel.dOfSecondMet);

        //MARK1
        m_lWriteIniFile->WriteInteger("MARK1","Type", pParamSet->Mark[1].Type);
        m_lWriteIniFile->WriteDouble("MARK1","MarginToTarget", pParamSet->Mark[1].Dist.dMarginToTarget);
        m_lWriteIniFile->WriteDouble("MARK1","DistFromFirstToSecond", pParamSet->Mark[1].Dist.dDistFromFirstToSecond );
        m_lWriteIniFile->WriteDouble("MARK1","LengthOfSecond", pParamSet->Mark[1].Dist.dLengthOfSecond);
        m_lWriteIniFile->WriteDouble("MARK1","AddDistAfterFirstMet", pParamSet->Mark[1].Dist.dAddDistAfetrFirstMet);
        m_lWriteIniFile->WriteDouble("MARK1","AddDistAfterSecondMet", pParamSet->Mark[1].Dist.dAddDistAfterSecondMet);
        m_lWriteIniFile->WriteDouble("MARK1","ForwardMoveDistLimit", pParamSet->Mark[1].Dist.dForwardMoveDistLimit);
        m_lWriteIniFile->WriteDouble("MARK1","BackMoveDistLimit", pParamSet->Mark[1].Dist.dBackMoveDistLimit);
        m_lWriteIniFile->WriteDouble("MARK1","MarkInPosLimit", pParamSet->Mark[1].Dist.dMarkInPosLimit);
        m_lWriteIniFile->WriteDouble("MARK1","MinLengthToNext", pParamSet->Mark[1].Dist.dMinLengthToNext);
		m_lWriteIniFile->WriteDouble("MARK1","IgnoreTagDist", pParamSet->Mark[1].Dist.dIgnoreTagDist);
        m_lWriteIniFile->WriteDouble("MARK1","SpeedInFirstMet", pParamSet->Mark[1].Speed.dOfFirstMet);
        m_lWriteIniFile->WriteDouble("MARK1","SpeedInSecondMet",pParamSet->Mark[1].Speed.dOfSecondMet);
        m_lWriteIniFile->WriteDouble("MARK1","AccelInFirstMet", pParamSet->Mark[1].Accel.dOfFirstMet);
        m_lWriteIniFile->WriteDouble("MARK1","AccelInSecondMet", pParamSet->Mark[1].Accel.dOfSecondMet);

        //MARK2
		m_lWriteIniFile->WriteInteger("MARK2","Type", pParamSet->Mark[2].Type);
		m_lWriteIniFile->WriteInteger("MARK2","MakerType", pParamSet->Mark[2].MakerType);
        m_lWriteIniFile->WriteDouble("MARK2","MarginToTarget", pParamSet->Mark[2].Dist.dMarginToTarget);
        m_lWriteIniFile->WriteDouble("MARK2","DistFromFirstToSecond", pParamSet->Mark[2].Dist.dDistFromFirstToSecond );
        m_lWriteIniFile->WriteDouble("MARK2","LengthOfSecond", pParamSet->Mark[2].Dist.dLengthOfSecond);
        m_lWriteIniFile->WriteDouble("MARK2","AddDistAfterFirstMet", pParamSet->Mark[2].Dist.dAddDistAfetrFirstMet);
        m_lWriteIniFile->WriteDouble("MARK2","AddDistAfterSecondMet", pParamSet->Mark[2].Dist.dAddDistAfterSecondMet);
        m_lWriteIniFile->WriteDouble("MARK2","ForwardMoveDistLimit", pParamSet->Mark[2].Dist.dForwardMoveDistLimit);
        m_lWriteIniFile->WriteDouble("MARK2","BackMoveDistLimit", pParamSet->Mark[2].Dist.dBackMoveDistLimit);
        m_lWriteIniFile->WriteDouble("MARK2","MarkInPosLimit", pParamSet->Mark[2].Dist.dMarkInPosLimit);
        m_lWriteIniFile->WriteDouble("MARK2","MinLengthToNext", pParamSet->Mark[2].Dist.dMinLengthToNext);
		m_lWriteIniFile->WriteDouble("MARK2","IgnoreTagDist", pParamSet->Mark[2].Dist.dIgnoreTagDist);
        m_lWriteIniFile->WriteDouble("MARK2","SpeedInFirstMet", pParamSet->Mark[2].Speed.dOfFirstMet);
        m_lWriteIniFile->WriteDouble("MARK2","SpeedInSecondMet",pParamSet->Mark[2].Speed.dOfSecondMet);
        m_lWriteIniFile->WriteDouble("MARK2","AccelInFirstMet", pParamSet->Mark[2].Accel.dOfFirstMet);
        m_lWriteIniFile->WriteDouble("MARK2","AccelInSecondMet", pParamSet->Mark[2].Accel.dOfSecondMet);

        //MARK3
		m_lWriteIniFile->WriteInteger("MARK3","Type", pParamSet->Mark[3].Type);
		m_lWriteIniFile->WriteInteger("MARK3","MakerType", pParamSet->Mark[3].MakerType);
        m_lWriteIniFile->WriteDouble("MARK3","MarginToTarget", pParamSet->Mark[3].Dist.dMarginToTarget);
        m_lWriteIniFile->WriteDouble("MARK3","DistFromFirstToSecond", pParamSet->Mark[3].Dist.dDistFromFirstToSecond );
        m_lWriteIniFile->WriteDouble("MARK3","LengthOfSecond", pParamSet->Mark[3].Dist.dLengthOfSecond);
        m_lWriteIniFile->WriteDouble("MARK3","AddDistAfterFirstMet", pParamSet->Mark[3].Dist.dAddDistAfetrFirstMet);
        m_lWriteIniFile->WriteDouble("MARK3","AddDistAfterSecondMet", pParamSet->Mark[3].Dist.dAddDistAfterSecondMet);
        m_lWriteIniFile->WriteDouble("MARK3","ForwardMoveDistLimit", pParamSet->Mark[3].Dist.dForwardMoveDistLimit);
        m_lWriteIniFile->WriteDouble("MARK3","BackMoveDistLimit", pParamSet->Mark[3].Dist.dBackMoveDistLimit);
        m_lWriteIniFile->WriteDouble("MARK3","MarkInPosLimit", pParamSet->Mark[3].Dist.dMarkInPosLimit);
        m_lWriteIniFile->WriteDouble("MARK3","MinLengthToNext", pParamSet->Mark[3].Dist.dMinLengthToNext);
		m_lWriteIniFile->WriteDouble("MARK3","IgnoreTagDist", pParamSet->Mark[3].Dist.dIgnoreTagDist);
        m_lWriteIniFile->WriteDouble("MARK3","SpeedInFirstMet", pParamSet->Mark[3].Speed.dOfFirstMet);
        m_lWriteIniFile->WriteDouble("MARK3","SpeedInSecondMet",pParamSet->Mark[3].Speed.dOfSecondMet);
        m_lWriteIniFile->WriteDouble("MARK3","AccelInFirstMet", pParamSet->Mark[3].Accel.dOfFirstMet);
        m_lWriteIniFile->WriteDouble("MARK3","AccelInSecondMet", pParamSet->Mark[3].Accel.dOfSecondMet);

        //3. [DRIVING_STEER_PARAM]
        m_lWriteIniFile->WriteInteger("STEER","ChangeTime", pParamSet->Steer.dwChangeTime);
        m_lWriteIniFile->WriteInteger("STEER","MovingTorqueTime", pParamSet->Steer.dwMovingTorqueTime);
        m_lWriteIniFile->WriteInteger("STEER","CompleteCheckTime", pParamSet->Steer.dwCompleteCheckTime);
        m_lWriteIniFile->WriteInteger("STEER","CompleteLimitTime", pParamSet->Steer.dwCompleteLimitTime);

        //4. [DRIVING_LINK_PARAM]
        m_lWriteIniFile->WriteDouble("LINK","OutNodeAreaMargin", pParamSet->Link.dOutNodeAreaMargin);
        m_lWriteIniFile->WriteDouble("LINK","NBranchMiddleAreaInMargin", pParamSet->Link.dNBranchMiddleAreaInMargin);

        //5. [DRIVING_FRONT_DETECT_PARAM]
        m_lWriteIniFile->WriteInteger("DETECT","DetectFailChatteringTime", pParamSet->FrontDetect.dwDetectFailChatteringTime);
        m_lWriteIniFile->WriteInteger("DETECT","ObsFailChatteringTime", pParamSet->FrontDetect.dwObsFailChatteringTime);
		m_lWriteIniFile->WriteInteger("DETECT","ObsTimeout", pParamSet->FrontDetect.dwObsTimeout);
		m_lWriteIniFile->WriteInteger("DETECT","ObsChangeTime", pParamSet->FrontDetect.dwObsChangeTime);
        m_lWriteIniFile->WriteDouble("DETECT","ObsStraightDetectMargin", pParamSet->FrontDetect.dObsStraightDetectMargin);

		//2 (5)Foup Cover PARAM
		m_lWriteIniFile->WriteInteger("FOUPCOVER","LineFoupChattering", pParamSet->FoupCover.nLineFoupChattering);
		m_lWriteIniFile->WriteInteger("FOUPCOVER","CurveFoupChattering", pParamSet->FoupCover.nCurveFoupChattering);
		m_lWriteIniFile->WriteInteger("FOUPCOVER","SPCurveFoupChattering", pParamSet->FoupCover.nSPCurveFoupChattering);

		m_lWriteIniFile->WriteDouble("STATION","StationMarkInPos", pParamSet->StationMarkInPos);
		m_lWriteIniFile->WriteInteger("STATION","MapMakerCount_Driving", pParamSet->MapMakerCount_Driving);
		m_lWriteIniFile->WriteInteger("STATION","MapMakerCount_Trans", pParamSet->MapMakerCount_Trans);

		m_lWriteIniFile->WriteDouble("STATION","MapMakerMargin_Gap", pParamSet->MapMakerMargin_Gap);
		m_lWriteIniFile->WriteDouble("STATION","ScatteredReflection", pParamSet->ScatteredReflection);
		m_lWriteIniFile->WriteDouble("STATION","ScatteredReflectionMax", pParamSet->ScatteredReflectionMax);

		m_lWriteIniFile->WriteBool("VHLLIFTER","OutPosDir", pParamSet->bVHLLifterDir);

		m_lWriteIniFile->WriteInteger("CID","CIDWaitingTimeout", pParamSet->CIDWaitingTimeout);
		//2 (6)CID PARAM
		m_lWriteIniFile->WriteInteger("CID","CID_PAUSE_TIMEOVER", pParamSet->CID_PAUSE_TIMEOVER);//미적용으로 Write 부분은 주석 처리

		delete m_lWriteIniFile;
		bResult = true;
	}

	return bResult;
}


/**
@brief  주행 명령(pDrivingInfo)이 들어어오면 InfoList 에 정보 추가
@author  ehoto
@date    2013.7.19
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
EXECUTE_ACK DrivingControl::setStationOffset(void *pDrivingInfo)
{
    //bool bSuccess = true;
    EXECUTE_ACK TmpExecuteAck = EXECUTE_ACK_ON_ERR;

    EXECUTE_DRIVING_INFO *pTmpDrivingInfo=(EXECUTE_DRIVING_INFO *)pDrivingInfo;

    ADD_LOG("[setStationOffset] In: CmdType:%d, PreMark:%6d(%d)→%6X(%d:%6.1lf)[%6d~%6d]"
        , pTmpDrivingInfo->AddInfo.CmdType
        , m_PreviousArrivalInfo.Info.uStation
        , m_PreviousArrivalInfo.Info.MarkType
        , pTmpDrivingInfo->AddInfo.StationID
        , pTmpDrivingInfo->AddInfo.StationType
        , pTmpDrivingInfo->AddInfo.DistToStation
        , pTmpDrivingInfo->BasicInfo.StartNID
        , pTmpDrivingInfo->BasicInfo.EndNID
        );

    if( (pTmpDrivingInfo->AddInfo.CmdType==EXECUTE_DRIVING_CMD_SET_STATION_OFFSET) )
//	&&  (m_PreviousArrivalInfo.Info.MarkType!=MARK_TYPE_NODE)   )
	{

		//2  현재 위치 정리
		if (m_PreviousArrivalInfo.Info.MarkType!=MARK_TYPE_OFFSET)
		{
			m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.bMarked          = true;
			m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.MarkType    = pTmpDrivingInfo->AddInfo.StationType;
			m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode       = pTmpDrivingInfo->BasicInfo.StartNID;
			m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uStation    = pTmpDrivingInfo->AddInfo.StationID;
			m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNextNode   = pTmpDrivingInfo->BasicInfo.EndNID;
			m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset     = pTmpDrivingInfo->AddInfo.DistToStation;
			m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.uRealArrivedNode = pTmpDrivingInfo->BasicInfo.StartNID;
		}else
		{
			m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.bMarked          = false;
			m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.MarkType    = pTmpDrivingInfo->AddInfo.StationType;
			m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode       = pTmpDrivingInfo->BasicInfo.StartNID;
//			m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uStation    = pTmpDrivingInfo->AddInfo.StationID;
//			m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNextNode   = pTmpDrivingInfo->BasicInfo.EndNID;
			m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset     = pTmpDrivingInfo->AddInfo.DistToStation;
			m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.uRealArrivedNode = pTmpDrivingInfo->BasicInfo.StartNID;
        }

		//2 마크 정보로 정리
        m_InfoSet.Position.Mark.dFrontPosition  = m_pDrivingAxis->GetCurrentPosition();
        m_InfoSet.Position.Mark.dRearPosition   = m_pDrivingAxis->m_pSlaveAxis->GetCurrentPosition();
        m_InfoSet.Position.Mark.PositionStatus  = m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus;

        //2 마크 정보를 멤버변수로 저장
        setPreviousArrivalInfo(m_InfoSet.Position.Mark.PositionStatus);
        getPostionInfoOnMarked(m_InfoSet, &m_PositionInfo);

        ADD_LOG("[setStationOffset] Result:Marked:%d Type:%d S(%d)N(%6d~%6d,%6.1lf)N(%6d),Pos(F:%6.1lf,R:%6.1lf)"
            , m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.bMarked
            , m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.MarkType
            , m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uStation
            , m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode
            , m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNextNode
            , m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset
            , m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.uRealArrivedNode
            , m_InfoSet.Position.Mark.dFrontPosition
            , m_InfoSet.Position.Mark.dRearPosition
            );

        TmpExecuteAck = EXECUTE_ACK_NO_ERR;
    }
    else
    {
        TmpExecuteAck = EXECUTE_ACK_NOT_AVAILABLE_CMD;
        ADD_LOG("[setStationOffset] EXECUTE_ACK_NOT_AVAILABLE_CMD");
    }

    return TmpExecuteAck;
}


/**
@brief  주행 명령(pDrivingInfo)이 MapMake 인지 확인
@author  임태웅
@date    2013.9.1
@return MapMake면 true 반환, 아니면 false 반환
*/
bool DrivingControl::isMapMake(void *pDrivingInfo)
{
    bool bIsMapMake = false;
	EXECUTE_DRIVING_INFO *pTmpDrivingInfo=(EXECUTE_DRIVING_INFO *)pDrivingInfo;


	if(pTmpDrivingInfo->AddInfo.CmdType == EXECUTE_DRIVING_CMD_MAPMAKE)
    {
		bIsMapMake = true;

		memmove(&m_bMapMakeType, &(pTmpDrivingInfo->AddInfo.MapMakeType), 1);

    }

    return bIsMapMake;
}

/**
@brief  주행 명령(pDrivingInfo)이 MapMake 인지 확인
@author  임태웅
@date    2013.9.1
@return MapMake면 true 반환, 아니면 false 반환
*/
bool DrivingControl::isBackMove(void *pDrivingInfo)
{
    bool bIsBack = false;
	EXECUTE_DRIVING_INFO *pTmpDrivingInfo=(EXECUTE_DRIVING_INFO *)pDrivingInfo;


	if(pTmpDrivingInfo->AddInfo.CmdType == EXECUTE_DRIVING_CMD_GOBACK)
    {
		bIsBack = true;

	   //	memmove(&m_bMapMakeType, &(pTmpDrivingInfo->AddInfo.MapMakeType), 1);

    }

	return bIsBack;
}






/**
@brief  주행 명령(pDrivingInfo)이 들어어오면 InfoList 에 정보 추가
@author  ehoto
@date    2013.7.19
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
EXECUTE_ACK DrivingControl::makeCmdInfoLists(void *pDrivingInfo)
{
	const int nCount = 6;
    bool abSuccess[nCount] ={false,};
    bool bSuccess = true;
    EXECUTE_ACK TmpExecuteAck = EXECUTE_ACK_ON_ERR;

	EXECUTE_DRIVING_INFO *pTmpDrivingInfo=(EXECUTE_DRIVING_INFO *)pDrivingInfo;
    m_LastDrivingCmdInfo = *pTmpDrivingInfo;
    EXECUTE_DRIVING_ADD_INFO AddInfo = pTmpDrivingInfo->AddInfo;
	DRIVING_CMD_INFO_OF_PATH *pLastPathInfo = NULL;
	DRIVING_CMD_INFO_OF_PATH TmpPathInfo;
	DRIVING_CMD_INFO_OF_TARGET TmpTargetInfo;
	memset(&TmpTargetInfo, 0x00, sizeof(DRIVING_CMD_INFO_OF_TARGET));

//   ADD_LOG("makeCmdInfoLists puting #%d , %d", 1, pTmpDrivingInfo->PathIndexNum);

	//1 TmpPathInfo 획득
//	ADD_LOG("makeCmdInfoLists  Step1 %d",m_ClassifiedCmd.PathList.getCount());
	if(m_ClassifiedCmd.PathList.getCount()==0)
	{
		TmpPathInfo = pTmpDrivingInfo->BasicInfo;

//		if(m_PositionInfo.CurrNode != pTmpDrivingInfo->BasicInfo.StartNID)
//          	return EXECUTE_ACK_ON_ERR;


		if((pTmpDrivingInfo->PathIndexNum ==0) &&
		   (AddInfo.ProcessingGoInfo.IsStationStart ==true))
		{
			TmpPathInfo.dDistSumToEndNode = TmpPathInfo.dLength + AddInfo.ProcessingGoInfo.StationData_StartRunDistOfNextNode;
//			ADD_LOG("makeCmdInfoLists  dDist %d   %d",TmpPathInfo.dLength,AddInfo.ProcessingGoInfo.StationData_StartRunDistOfNextNode);
			if(AddInfo.ProcessingGoInfo.StationData_StartRunDistOfNextNode < POSITION_TO_CHECK_FIRST_NODE)
				TmpPathInfo.nCount = 1;
			else
				TmpPathInfo.nCount = 2;
		}
		else
		{
			TmpPathInfo.dDistSumToEndNode = TmpPathInfo.dLength;
			TmpPathInfo.nCount = 1;
		}

//		ADD_LOG("makeCmdInfoLists  dDistSumToEndNode %f, dLength %f, DistToStation %f", TmpPathInfo.dDistSumToEndNode,TmpPathInfo.dLength,AddInfo.DistToStation);


    }
    else
	{

//		ADD_LOG("makeCmdInfoLists  Step2 %d",m_ClassifiedCmd.PathList.getCount());
		pLastPathInfo = (DRIVING_CMD_INFO_OF_PATH*)m_ClassifiedCmd.PathList.referBack();

//      ADD_LOG("Before %X~%X : After %X~%X"
//          , pLastPathInfo->StartNID, pLastPathInfo->EndNID
//          , pTmpDrivingInfo->BasicInfo.StartNID, pTmpDrivingInfo->BasicInfo.EndNID);

        // 연속되는 Path
        if( pLastPathInfo->EndNID==pTmpDrivingInfo->BasicInfo.StartNID)
        {
            TmpPathInfo = pTmpDrivingInfo->BasicInfo;
			TmpPathInfo.dDistSumToEndNode = pLastPathInfo->dDistSumToEndNode + TmpPathInfo.dLength;
            TmpPathInfo.nCount = pLastPathInfo->nCount + 1;
		}
        // 동일 Path도 아닌 경우
        else if(    (pLastPathInfo->StartNID!=pTmpDrivingInfo->BasicInfo.StartNID)
		 ||         (pLastPathInfo->EndNID!=pTmpDrivingInfo->BasicInfo.EndNID)
         )
        {
			return EXECUTE_ACK_ON_ERR;  // 이상 명령: 연속되지도 않고, 동일 Path에서 Station 이 변경 되는 명령도 아님
		}
    }


//  ADD_LOG("makeCmdInfoLists #%d , %d", 2, TmpExecuteAck);


    //1 TmpTargetInfo 획득
	TmpTargetInfo.Type = AddInfo.StationType;


   //	ADD_LOG("makeCmdInfoLists  TmpTargetInfo.Type , %d", TmpTargetInfo.Type);
	if(TmpTargetInfo.Type==MARK_TYPE_NODE)
	{
		TmpTargetInfo.Node = TmpPathInfo.EndNID;
		TmpTargetInfo.dDistSumToNode = TmpPathInfo.dDistSumToEndNode;
		TmpTargetInfo.nCount = TmpPathInfo.nCount;
//		TmpTargetInfo.PassBoxIn = (AddInfo.FinalPortType == GO_FINAL_PORT_TYPE_PassBoxIn)?true:false;
	}
	else
	{
		TmpTargetInfo.Node = TmpPathInfo.StartNID;
		TmpTargetInfo.dDistSumToNode = TmpPathInfo.dDistSumToEndNode - TmpPathInfo.dLength;
		TmpTargetInfo.nCount = TmpPathInfo.nCount;
		TmpTargetInfo.Station = AddInfo.StationID;
		TmpTargetInfo.dOffset = AddInfo.DistToStation;
		TmpTargetInfo.StationSafetyLevel = AddInfo.StationSafetyLevel;
		TmpTargetInfo.bIgnolOverRun = AddInfo.bIgnolOverRun;
		TmpTargetInfo.NextNode= TmpPathInfo.EndNID;
		TmpTargetInfo.dLength = TmpPathInfo.dLength;
		TmpTargetInfo.Steering = TmpPathInfo.Steering;

		TmpTargetInfo.dSTBOffset = AddInfo.STBOffset;
	}

//  ADD_LOG("makeCmdInfoLists #%d , %d", 3, TmpExecuteAck);


	//1 명령 분류
	abSuccess[0] = makeList(&(m_ClassifiedCmd.NodeList), TmpPathInfo);
	abSuccess[1] = makeList(&(m_ClassifiedCmd.SteerList), TmpPathInfo);
	abSuccess[2] = makeList(&(m_ClassifiedCmd.DirectionList), TmpPathInfo);
	abSuccess[3] = makeList(&(m_ClassifiedCmd.SpeedlList), TmpPathInfo, TmpTargetInfo);
	abSuccess[4] = makeList(&(m_ClassifiedCmd.PathList), TmpPathInfo);
	abSuccess[5] = makeList(&(m_ClassifiedCmd.DivList), TmpPathInfo);

//  ADD_LOG("makeCmdInfoLists #%d , %d", 4, TmpExecuteAck);



	//1 성공 여부 확인
	for(int n=0; n<nCount; n++)
	{
		bSuccess = bSuccess & abSuccess[n];
	}



//  ADD_LOG("makeCmdInfoLists #%d , %d", 5, TmpExecuteAck);

	//1 최종 목적지 정보 입력
	if(bSuccess==true)
	{
		m_ClassifiedCmd.TargetInfo=TmpTargetInfo;
		TmpExecuteAck = EXECUTE_ACK_NO_ERR;
	}
	else
	{
		ADD_LOG("Success[%d] = [%d:%d:%d:%d:%d]", bSuccess, abSuccess[0], abSuccess[1], abSuccess[2], abSuccess[3], abSuccess[4]);
	}


//  ADD_LOG("makeCmdInfoLists #%d , %d", 6, TmpExecuteAck);

	ADD_LOG("[IGC]//N.Cnt:%d/Spd:%5.1lf/Str:%d/PreStr:%d/Dist:%5.1lf/End:%d/Target:%d/PassBoxIn:%d/dLength:%5.1lf Offset:%5.1lf/ListCnt %d/Type:%d/Offset(2Station:Start)[%5.1lf,%5.1lf], Saftey:%d"
		, TmpPathInfo.nCount
		, TmpPathInfo.dSpeed
		, TmpPathInfo.Steering
		, TmpPathInfo.PreSteering
		, TmpPathInfo.dDistSumToEndNode
		, TmpPathInfo.EndNID
		, TmpTargetInfo.Station
		, TmpTargetInfo.PassBoxIn
		, TmpPathInfo.dLength
		, TmpTargetInfo.dOffset
		, m_ClassifiedCmd.PathList.getCount()
		, AddInfo.StationType
		, AddInfo.DistToStation
		, AddInfo.DistOffsetForStartFromStation
		, AddInfo.StationSafetyLevel
        );

	if(TmpTargetInfo.Station != 0)
	{
		m_mccparam.uTargetNode = TmpTargetInfo.Station;
	}
	else
	{
		m_mccparam.uTargetNode = TmpPathInfo.EndNID;
    }

//  ADD_LOG("makeCmdInfoLists #%d , %d", 7, TmpExecuteAck);

	// CID 4분기 처리용 정보 get
	CID_4WAY_CONTROL_INFO.bLoadUnload = pTmpDrivingInfo->AddInfo.ProcessingGoInfo.IsStationEnd; // 이적재 유무. true : 이적재 한다. false : 이적재 하지 않음
	CID_4WAY_CONTROL_INFO.tmpLastCMDID = pTmpDrivingInfo->AddInfo.ProcessingGoInfo.EndNodeID;   // 최종 타겟

    return TmpExecuteAck;
}


/**
@brief  주행 명령(pDrivingInfo)이 들어어오면 InfoList 에 정보 추가
@author  ehoto
@date    2013.7.19
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
EXECUTE_ACK DrivingControl::makeCmdInfoListsBack(void *pDrivingInfo)
{
    const int nCount = 6;
    bool abSuccess[nCount] ={false,};
    bool bSuccess = true;
    EXECUTE_ACK TmpExecuteAck = EXECUTE_ACK_ON_ERR;

	EXECUTE_DRIVING_INFO *pTmpDrivingInfo=(EXECUTE_DRIVING_INFO *)pDrivingInfo;
    m_LastDrivingCmdInfo = *pTmpDrivingInfo;
    EXECUTE_DRIVING_ADD_INFO AddInfo = pTmpDrivingInfo->AddInfo;
	DRIVING_CMD_INFO_OF_PATH *pLastPathInfo = NULL;
	DRIVING_CMD_INFO_OF_PATH TmpPathInfo;
    DRIVING_CMD_INFO_OF_TARGET TmpTargetInfo;
	memset(&TmpTargetInfo, 0x00, sizeof(DRIVING_CMD_INFO_OF_TARGET));

//   ADD_LOG("makeCmdInfoLists puting #%d , %d", 1, pTmpDrivingInfo->PathIndexNum);

	//1 TmpPathInfo 획득
	ADD_LOG("makeCmdInfoLists  Step1 %d",m_ClassifiedCmd.PathList.getCount());
    if(m_ClassifiedCmd.PathList.getCount()==0)
	{
		TmpPathInfo = pTmpDrivingInfo->BasicInfo;
		TmpPathInfo.dDistSumToEndNode = -TmpPathInfo.dLength;
		TmpPathInfo.nCount = 1;

		ADD_LOG("makeCmdInfoLists  dDistSumToEndNode %f, dLength %f, DistToStation %f", TmpPathInfo.dDistSumToEndNode,TmpPathInfo.dLength,AddInfo.DistToStation);
     }
    else
	{

		ADD_LOG("makeCmdInfoLists  Step2 %d",m_ClassifiedCmd.PathList.getCount());
		pLastPathInfo = (DRIVING_CMD_INFO_OF_PATH*)m_ClassifiedCmd.PathList.referBack();

		// 연속되는 Path 기존 1-2, 2-3  3-4  ->  3-4 2-3 1-2   puting 2016 11 01
		if( pLastPathInfo->StartNID==pTmpDrivingInfo->BasicInfo.EndNID)
        {
            TmpPathInfo = pTmpDrivingInfo->BasicInfo;
			TmpPathInfo.dDistSumToEndNode = pLastPathInfo->dDistSumToEndNode - TmpPathInfo.dLength;
            TmpPathInfo.nCount = pLastPathInfo->nCount + 1;
		}
        // 동일 Path도 아닌 경우
        else if(    (pLastPathInfo->EndNID!=pTmpDrivingInfo->BasicInfo.EndNID)
		 ||         (pLastPathInfo->EndNID!=pTmpDrivingInfo->BasicInfo.StartNID)
         )
        {
            return EXECUTE_ACK_ON_ERR;  // 이상 명령: 연속되지도 않고, 동일 Path에서 Station 이 변경 되는 명령도 아님
        }
    }

    //1 TmpTargetInfo 획득
	TmpTargetInfo.Type = AddInfo.StationType;

//	ADD_LOG("makeCmdInfoLists  TmpTargetInfo.Type , %d", TmpTargetInfo.Type);
	if(TmpTargetInfo.Type==MARK_TYPE_NODE)
	{
//		TmpTargetInfo.Node = TmpPathInfo.EndNID;
//		TmpTargetInfo.dDistSumToNode = TmpPathInfo.dDistSumToEndNode;
//		TmpTargetInfo.nCount = TmpPathInfo.nCount;
  		return EXECUTE_ACK_ON_ERR;  // 이상 명령: 연속되지도 않고, 동일 Path에서 Station 이 변경 되는 명령도 아님

	}
	else
	{
		TmpTargetInfo.Node = TmpPathInfo.StartNID;
		TmpTargetInfo.dDistSumToNode = TmpPathInfo.dDistSumToEndNode;   //MTL 후진용
		TmpTargetInfo.nCount = TmpPathInfo.nCount;
		TmpTargetInfo.Station = AddInfo.StationID;
		TmpTargetInfo.dOffset = AddInfo.DistToStation;
		TmpTargetInfo.NextNode= TmpPathInfo.EndNID;
		TmpTargetInfo.dLength = TmpPathInfo.dLength;
		TmpTargetInfo.Steering = TmpPathInfo.Steering;

		TmpTargetInfo.dSTBOffset = AddInfo.STBOffset;
	}

	ADD_LOG("makeCmdInfoLists Station ID %d dDistSumToEndNode %f, dLength %f, DistToStation %f",
	TmpTargetInfo.Station, TmpPathInfo.dDistSumToEndNode,TmpPathInfo.dLength,TmpTargetInfo.dOffset);


//  ADD_LOG("makeCmdInfoLists #%d , %d", 3, TmpExecuteAck);


    //1 명령 분류
    abSuccess[0] = makeBackList(&(m_ClassifiedCmd.NodeList), TmpPathInfo);
    abSuccess[1] = makeList(&(m_ClassifiedCmd.SteerList), TmpPathInfo);
    abSuccess[2] = makeList(&(m_ClassifiedCmd.DirectionList), TmpPathInfo);
	abSuccess[3] = makeBackList(&(m_ClassifiedCmd.SpeedlList), TmpPathInfo, TmpTargetInfo);
	abSuccess[4] = makeBackList(&(m_ClassifiedCmd.PathList), TmpPathInfo);
	abSuccess[5] = makeList(&(m_ClassifiedCmd.DivList), TmpPathInfo);

//  ADD_LOG("makeCmdInfoLists #%d , %d", 4, TmpExecuteAck);



    //1 성공 여부 확인
    for(int n=0; n<nCount; n++)
    {
        bSuccess = bSuccess & abSuccess[n];
    }



//  ADD_LOG("makeCmdInfoLists #%d , %d", 5, TmpExecuteAck);

	//1 최종 목적지 정보 입력
    if(bSuccess==true)
    {
		m_ClassifiedCmd.TargetInfo=TmpTargetInfo;
		TmpExecuteAck = EXECUTE_ACK_NO_ERR;
    }
    else
    {
        ADD_LOG("Success[%d] = [%d:%d:%d:%d:%d]", bSuccess, abSuccess[0], abSuccess[1], abSuccess[2], abSuccess[3], abSuccess[4]);
    }


//  ADD_LOG("makeCmdInfoLists #%d , %d", 6, TmpExecuteAck);

	m_InfoSet.EventAndState.Event.CmdAdded = true;

	ADD_LOG("[IGC]//N.Cnt:%d/Spd:%5.1lf/Str:%d/PreStr:%d/Dist:%5.1lf/End:%d/Target:%d/PassBoxIn:%d/ListCnt %d/Type:%d/Offset(2Station:Start)[%5.1lf,%5.1lf]"
        , TmpPathInfo.nCount
        , TmpPathInfo.dSpeed
        , TmpPathInfo.Steering
        , TmpPathInfo.PreSteering
        , TmpPathInfo.dDistSumToEndNode
        , TmpPathInfo.EndNID
		, TmpTargetInfo.Station
        , TmpTargetInfo.PassBoxIn
        , m_ClassifiedCmd.PathList.getCount()
		, AddInfo.StationType
		, AddInfo.DistToStation
		, AddInfo.DistOffsetForStartFromStation
        );

//  ADD_LOG("makeCmdInfoLists #%d , %d", 7, TmpExecuteAck);



    return TmpExecuteAck;
}


/**
@brief   파라미터를 업데이트 하는 함수
@author  임태웅
@date    2013.7.19
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
bool DrivingControl::updateParameter()
{
    DRIVING_PARAM_SET* pTmpParamSet;

    if(m_pTmpParamSet!=NULL)
    {
        pTmpParamSet = m_pParamSet;
        m_pParamSet = m_pTmpParamSet;
        m_pTmpParamSet = NULL;
        delete pTmpParamSet;
        return true;
    }
    else
    {
        return false;
    }
}

/**
@brief   StatusSet 정보를 초기화하는 함수
@author  임태웅
@date    2013.7.29
*/
void DrivingControl::initStatusSet()
{
    m_StatusSet.byStatus = STS_INIT;
    m_StatusSet.uError = NO_ERR;
    m_StatusSet.bIsOnProcess = false;
    m_StatusSet.uStep = 0;
}

/**
@brief   명령 정보를 초기화하는 함수
@author  임태웅
@date    2013.7.29
*/
void DrivingControl::initCommandSet()
{
    int nTestNum = 0;
    try
    {
        m_QuickCmd = EXECUTE_QUICK_CMD_NONE;
        nTestNum = 0;
        clearCmdInfoLists();
        nTestNum = 1;
    }
    catch(...)
    {
        ERR_LOG("initCommandSet Err Step : %d", nTestNum);
    }
}

/**
@brief   주행 관련 HW 정보를 초기화하는 함수
@author  임태웅
@date    2013.7.29
*/
void DrivingControl::initInfoSet()
{
    memset(&m_InfoSet, 0, sizeof(DRIVING_INFO_SET));

    // 최초 명령이 적용되기 위해 설정하는 초기 값
    m_InfoSet.Position.CmdRefInfo.dCmdSpeed = m_pParamSet->Axis.Limit.Speed.MaxValue;
    m_InfoSet.Position.CmdRefInfo.dSpeedDownPos = -1000;

	m_dPreNodecount = 0;
	m_bFirstNodeStep = false;

	DRIVING_HW_INFO_SET HwInfo = getHWInfo();
	m_InfoSet.HwInfo.IO = HwInfo.IO;

    m_InfoSet.Steer.FrontCmdDirection   = m_InfoSet.HwInfo.IO.SteerFrontDirCmd;
	m_InfoSet.Steer.RearCmdDirection    = m_InfoSet.HwInfo.IO.SteerRearDirCmd;

	m_pExecuteInfo->FlagMTLInfo.nTakeOut =0x00;
	m_pExecuteInfo->FlagMTLInfo.bTakeoutCycle  =false;
	m_pExecuteInfo->dCompensatedPosition = 0.0;

	//MCC Parameter 초기화
	m_mccparam.nFoupCoverDetectCount = 0;
	m_mccparam.nInnerFOUPDetectCount = 0;
	m_mccparam.nInnerFOUPNotDetectCount = 0;
	m_mccparam.nShiftHomeSenOffCount = 0;
	m_mccparam.nHoistHomeSenOffCount = 0;

	m_mccparam.dwSteerFrontTime = 0;
	m_mccparam.dwSteerRearTime = 0;
	m_mccparam.dwShutterFrontTime = 0;
	m_mccparam.dwShutterRearTime = 0;

	m_mccparam.bSteerFrontFlag = false;
	m_mccparam.bSteerRearFlag = false;
	m_mccparam.bDetectStatus = false;
	m_mccparam.bMarkStartFlag = false;
	m_mccparam.bBCRReadFail = false;
	m_mccparam.bFrontShutterFlag = false;
	m_mccparam.bRearShutterFlag = false;
	m_mccparam.bAbnormalStopFlag = false;

	m_mccparam.dwOBSDetectTime = 0;
	m_mccparam.dwUBGDetectTime = 0;

	m_mccparam.nPreCount = 0;
	m_mccparam.nNodeCount = 0;
	m_mccparam.nBCRTriggerCount = 0;

	m_mccparam.uSourceNode = 0;
	m_mccparam.uTargetNode = 0;

	m_mccparam.bSteerTimeCheckFlag == false;
	m_mccparam.dwSteerFTRQ0OnTime = 0;
	m_mccparam.dwSteerFTRQ0OffTime = 0;
	m_mccparam.dwSteerRTRQ0OnTime = 0;
	m_mccparam.dwSteerRTRQ0OffTime = 0;
	m_mccparam.dwSteerFDIROnTime = 0;
	m_mccparam.dwSteerFTDIROffTime = 0;
	m_mccparam.dwSteerRDIROnTime = 0;
	m_mccparam.dwSteerRDIROffTime = 0;
	m_mccparam.dwSteerFLeftOnTime = 0;
	m_mccparam.dwSteerFLeftOffTime = 0;
	m_mccparam.dwSteerFRightOnTime = 0;
	m_mccparam.dwSteerFRightOffTime = 0;
	m_mccparam.dwSteerRLeftOnTime = 0;
	m_mccparam.dwSteerRLeftOffTime = 0;
	m_mccparam.dwSteerRRightOnTime = 0;
	m_mccparam.dwSteerRRightOffTime = 0;

	m_mccparam.nSteerFrontHuntingCount = 0;
	m_mccparam.nSteerRearHuntingCount = 0;

	m_bFDCMarkFailFlag = true;
	m_bFDCEarlyPathFlag = true;
	m_bFDCLatePathFlag = true;
}

/**
@brief   마지막 도착 정보(다음 출발의 기준점)를 초기화하는 함수
@author  임태웅
@date    2013.7.29
*/
void DrivingControl::initPreviousArrivalInfo()
{
    memset(&m_PreviousArrivalInfo, 0, sizeof(POSITION_STATUS));
}

/**
@brief   마지막 도착 정보(다음 출발의 기준점)를 설정하는 함수
@author  임태웅
@date    2013.7.29
*/
void DrivingControl::setPreviousArrivalInfo(POSITION_STATUS PositionStatus)
{
    m_PreviousArrivalInfo = PositionStatus;
}

/**
@brief   마지막 도착 정보를 초기화하는 함수
@author  임태웅
@date    2013.7.29
*/
void DrivingControl::setCompensationInfo(POSITION_STATUS PreviousArrivalInfo)
{
    double dPreArriveOffset = 0.0;  //default case: MARK_TYPE_NODE

    if(PreviousArrivalInfo.Info.MarkType!=MARK_TYPE_NODE)
    {
//      if(PreviousArrivalInfo.Info.uNode==PreviousArrivalInfo.uRealArrivedNode)
//      if(PreviousArrivalInfo.Info.uNextNode==PreviousArrivalInfo.uRealArrivedNode)
//      {
            dPreArriveOffset = PreviousArrivalInfo.Info.dOffset;      //puting 수정 할 것 ..... 빼기로 해서 .
//      }
    }
	//memset(&m_InfoSet.Position.Compensation,0x00, sizeof(DRIVING_COMPENSATION_INFO));

	m_InfoSet.Position.Compensation.dPreArriveOffset = dPreArriveOffset;
    m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus = PreviousArrivalInfo;
    m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.bMarked = false;

    ADD_LOG("setCompensationInfo: (%d)%5.1lf (%06d~%06d) --> %5.1lf (%06d~%06d)"
		, PreviousArrivalInfo.Info.MarkType
        , PreviousArrivalInfo.Info.dOffset
        , PreviousArrivalInfo.Info.uNode
        , PreviousArrivalInfo.Info.uNextNode
        , m_InfoSet.Position.Compensation.dPreArriveOffset
        , m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode
        , m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNextNode
        );
}

/**
@brief   마지막 도착 정보를 초기화하는 함수
@author  임태웅
@date    2013.7.29
*/
//DRIVING_MARK_INFO DrivingControl::getMarkInfo(DRIVING_HW_INFO_SET HwInfo, POSITION_STATUS PositionStatus)
//{
//  DRIVING_MARK_INFO TmpMarkInfo;
//
//  TmpMarkInfo.PositionStatus = PositionStatus;
//  TmpMarkInfo.dFrontPosition = HwInfo.Axis1.dCurrPos;
//  TmpMarkInfo.dRearPosition = HwInfo.Axis2.dCurrPos;
//  TmpMarkInfo.uRealArrivedNode = PositionStatus.
//
//  return TmpMarkInfo;
//}

/**
@brief   명령으로 부터 Node Info List 정보를 만들어 냄
@author  ehoto
@date    2013.7.19
@param pList: 정보를 저장하는 List의 포인터
@param pDrivingInfo: 명령 정보의 포인터
@return 성공하면  NodeCount 반환, List에 명령이 없어 추가 못하면 -1 반환
*/
bool DrivingControl::checkCmdInfoNodeList(List<DRIVING_CMD_INFO_OF_NODE*> *pList, int CheckNodeID, CLASSIFIED_DRIVING_CHANGE* ChagneInfo)
{
	bool bSuccess = false;
    DRIVING_CMD_INFO_OF_NODE* pItem = NULL;

	int nCount = pList->getCount();


	if((nCount==0) || (CheckNodeID ==0))
		return bSuccess;

//	ChagneInfo->TargetInfo =m_ClassifiedCmd.TargetInfo;

	for(int Index =0; Index<nCount; Index++)
	{
		pItem = pList->refer(nCount-Index -1);
		//최초값 저장

		if(pItem->ID==CheckNodeID)
		{

			ChagneInfo->dEncoderFinal = pItem->dDistSum;
			ChagneInfo->nCheckNodeCount = pItem->nCount;

			ChagneInfo->TargetInfo.dDistSumToNode =pItem->dDistSum;
            ChagneInfo->TargetInfo.Node =  pItem->ID;
			ChagneInfo->TargetInfo.Type =MARK_TYPE_NODE;
			ChagneInfo->TargetInfo.nCount = pItem->nCount;

			bSuccess= true;

			ADD_LOG("checkCmdInfoNodeList Success!%d",CheckNodeID);

			break;
		}else
		{
		 	m_pExecuteInfo->nNextNodeIDInfo =  pItem->ID;
        }

	}

    return bSuccess;
}


/**
@brief   명령으로 부터 Node Info List 정보를 만들어 냄
@author  ehoto
@date    2013.7.19
@param pList: 정보를 저장하는 List의 포인터
@param pDrivingInfo: 명령 정보의 포인터
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
bool DrivingControl::CancelList(List<DRIVING_CMD_INFO_OF_NODE*> *pList, CLASSIFIED_DRIVING_CHANGE DrivingInfo)
{
    int nListCount      = pList->getCount();
	bool bReturn = false;
	DRIVING_CMD_INFO_OF_NODE *pItem = NULL;
	DRIVING_CMD_INFO_OF_NODE *pTempItem = NULL;

	if(nListCount==0) return bReturn;

	pTempItem = new DRIVING_CMD_INFO_OF_NODE;

	for(int nTmpIndex = 0; nTmpIndex<nListCount; nTmpIndex++)
    {
        pItem   = pList->popBack();
        if(pItem!=NULL)
		{

            if(pItem->nCount < DrivingInfo.nCheckNodeCount)
			{
				pTempItem->nCount = DrivingInfo.nCheckNodeCount;
				pTempItem->dDistSum = DrivingInfo.dEncoderFinal;

				bReturn = true;

				pList->insertBack(pItem);
				pList->insertBack(pTempItem);

				ADD_LOG("CancelList NODE1 %d %d",pItem->nCount, DrivingInfo.nCheckNodeCount);
				return bReturn;
			}
			else if((pItem->nCount == DrivingInfo.nCheckNodeCount) || (nTmpIndex == (nListCount-1)))
			{
				pItem->nCount = DrivingInfo.nCheckNodeCount;
				pItem->dDistSum = DrivingInfo.dEncoderFinal;
				bReturn = true;

				pList->insertBack(pItem);
				ADD_LOG("CancelList NODE2 %d %d",pItem->nCount, DrivingInfo.nCheckNodeCount);
				delete pTempItem;
				return bReturn;
			}
			else
            {
//				pItem   = pList->popBack();
				pTempItem->ID = pItem->ID;
				pTempItem->Type = pItem->Type;
				pTempItem->dDistSum = pItem->dDistSum;
				pTempItem->nCount = pItem->nCount;
//				pTempItem->DivInfo = pItem->DivInfo;
//				memmove(pTempItem,pItem,sizeof(DRIVING_CMD_INFO_OF_PATH));
                delete pItem;
                pItem   = NULL;
			}

        }
	}

	delete pTempItem;
    return bReturn;

}
/**
@brief   명령으로 부터 Node Info List 정보를 만들어 냄
@author  ehoto
@date    2013.7.19
@param pList: 정보를 저장하는 List의 포인터
@param pDrivingInfo: 명령 정보의 포인터
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
bool DrivingControl::CancelList(List<DRIVING_CMD_INFO_OF_STEER*> *pList, CLASSIFIED_DRIVING_CHANGE DrivingInfo)
{
	int nListCount      = pList->getCount();
	bool bReturn = false;
	DRIVING_CMD_INFO_OF_STEER *pItem = NULL;
	DRIVING_CMD_INFO_OF_STEER *pTempItem = NULL;

	if(nListCount==0) return bReturn;

	pTempItem = new DRIVING_CMD_INFO_OF_STEER;

	for(int nTmpIndex = 0; nTmpIndex<nListCount; nTmpIndex++)
    {
		pItem   = pList->popBack();
        if(pItem!=NULL)
		{

		   if(pItem->nCount < DrivingInfo.nCheckNodeCount)
			{

				pTempItem->nCount = DrivingInfo.nCheckNodeCount;
				pTempItem->dDistSumToEndNode = DrivingInfo.dEncoderFinal;

				bReturn = true;

				pList->insertBack(pItem);
				pList->insertBack(pTempItem);
				ADD_LOG("CancelList STEER1 %d %d",pItem->nCount, DrivingInfo.nCheckNodeCount);
				return bReturn;
			}
			else if((pItem->nCount == DrivingInfo.nCheckNodeCount) || (nTmpIndex == (nListCount-1)))
			{
				pItem->nCount = DrivingInfo.nCheckNodeCount;
				pItem->dDistSumToEndNode = DrivingInfo.dEncoderFinal;
				bReturn = true;

				pList->insertBack(pItem);
				ADD_LOG("CancelList STEER2 %d %d",pItem->nCount, DrivingInfo.nCheckNodeCount);
				delete pTempItem;
				return bReturn;
			}
			else
            {
//				pItem   = pList->popBack();

				pTempItem->Type = pItem->Type;
				pTempItem->NextType = PATH_STEERING_NONE;
				pTempItem->dDistSumToEndNode = pItem->dDistSumToEndNode;
				pTempItem->nCount = pItem->nCount;

                delete pItem;
                pItem   = NULL;
            }
        }
	}


	delete pTempItem;
	return bReturn;


}
/**
@brief   명령으로 부터 Node Info List 정보를 만들어 냄
@author  ehoto
@date    2013.7.19
@param pList: 정보를 저장하는 List의 포인터
@param pDrivingInfo: 명령 정보의 포인터
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
bool DrivingControl::CancelList(List<DRIVING_CMD_INFO_OF_DIV*> *pList, CLASSIFIED_DRIVING_CHANGE DrivingInfo)
{
	int nListCount      = pList->getCount();
	bool bReturn = false;
	DRIVING_CMD_INFO_OF_DIV *pItem = NULL;
	DRIVING_CMD_INFO_OF_DIV *pTempItem = NULL;

	if(nListCount==0) return bReturn;

	pTempItem = new DRIVING_CMD_INFO_OF_DIV;

	for(int nTmpIndex = 0; nTmpIndex<nListCount; nTmpIndex++)
    {
		pItem   = pList->popBack();
        if(pItem!=NULL)
		{

		   if(pItem->nCount < DrivingInfo.nCheckNodeCount)
			{

				pTempItem->nCount = DrivingInfo.nCheckNodeCount;
				pTempItem->dDistSumToEndNode = DrivingInfo.dEncoderFinal;

				bReturn = true;

				pList->insertBack(pItem);
				pList->insertBack(pTempItem);
				ADD_LOG("CancelList1 Div %d %d",pItem->nCount, DrivingInfo.nCheckNodeCount);
				return bReturn;
			}
			else if((pItem->nCount == DrivingInfo.nCheckNodeCount) || (nTmpIndex == (nListCount-1)))
			{
				pItem->nCount = DrivingInfo.nCheckNodeCount;
				pItem->dDistSumToEndNode = DrivingInfo.dEncoderFinal;
				bReturn = true;

				pList->insertBack(pItem);
                ADD_LOG("CancelList Div2 %d %d",pItem->nCount, DrivingInfo.nCheckNodeCount);
				delete pTempItem;
				return bReturn;
			}
			else
            {
//				pItem   = pList->popBack();

				pTempItem->Type = pItem->Type;
				pTempItem->NextType = PATH_DIVERGENCE_NONE;
				pTempItem->dDistSumToEndNode = pItem->dDistSumToEndNode;
				pTempItem->nCount = pItem->nCount;

                delete pItem;
                pItem   = NULL;
            }
        }
    }

	delete pTempItem;
	return bReturn;


}

/**
@brief   명령으로 부터 Node Info List 정보를 만들어 냄
@author  ehoto
@date    2013.7.19
@param pList: 정보를 저장하는 List의 포인터
@param pDrivingInfo: 명령 정보의 포인터
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
bool DrivingControl::CancelList(List<DRIVING_CMD_INFO_OF_DIRECTION*> *pList, CLASSIFIED_DRIVING_CHANGE DrivingInfo)
{
	int nListCount      = pList->getCount();
	bool bReturn = false;
	DRIVING_CMD_INFO_OF_DIRECTION *pItem = NULL;
	DRIVING_CMD_INFO_OF_DIRECTION *pTempItem = NULL;

	if(nListCount==0) return bReturn;

	pTempItem = new DRIVING_CMD_INFO_OF_DIRECTION;

	for(int nTmpIndex = 0; nTmpIndex<nListCount; nTmpIndex++)
	{
		pItem   = pList->popBack();
		if(pItem!=NULL)
		{


			if(pItem->nCount < DrivingInfo.nCheckNodeCount)
			{
				pTempItem->nCount = DrivingInfo.nCheckNodeCount;
				pTempItem->dDistSumToEndNode = DrivingInfo.dEncoderFinal;

				bReturn = true;

				pList->insertBack(pItem);
				pList->insertBack(pTempItem);
				ADD_LOG("CancelList DIRECTION1 %d %d",pItem->nCount, DrivingInfo.nCheckNodeCount);
				return bReturn;
			}
			else if((pItem->nCount == DrivingInfo.nCheckNodeCount) || (nTmpIndex == (nListCount-1)))
			{
				pItem->nCount = DrivingInfo.nCheckNodeCount;
				pItem->dDistSumToEndNode = DrivingInfo.dEncoderFinal;
				bReturn = true;

				pList->insertBack(pItem);
				ADD_LOG("CancelList DIRECTION2 %d %d",pItem->nCount, DrivingInfo.nCheckNodeCount);
				delete pTempItem;
				return bReturn;
			}
			else
            {
//				pItem   = pList->popBack();
#if(USE_CHANGENODE == 1)
				pTempItem->UBGRegion = pItem->UBGRegion;
				pTempItem->ObstacleRegion = pItem->ObstacleRegion;
				pTempItem->nPBSIgnoreFlag = pItem->nPBSIgnoreFlag;
				pTempItem->nFollowsCommandType = pItem->nFollowsCommandType;
				pTempItem->dDistSumToEndNode = pItem->dDistSumToEndNode;
				pTempItem->nCount = pItem->nCount;

				//for change node
				pTempItem->NodeType = pItem->NodeType;
				pTempItem->OptDistance = pItem->OptDistance;
				pTempItem->OptDistanceAfter = pItem->OptDistanceAfter;
				pTempItem->OptUBGRegion = pItem->OptUBGRegion;
				pTempItem->OptObstacleRegion = pItem->OptObstacleRegion;
#else
				pTempItem->Type = pItem->Type;
				pTempItem->nPBSIgnoreFlag = pItem->nPBSIgnoreFlag;
				pTempItem->nFollowsCommandType = pItem->nFollowsCommandType;
				pTempItem->dDistSumToEndNode = pItem->dDistSumToEndNode;
				pTempItem->nCount = pItem->nCount;
#endif
                delete pItem;
                pItem   = NULL;
            }
		}
	}

	delete pTempItem;
	return bReturn;

}
/**
@brief   명령으로 부터 Node Info List 정보를 만들어 냄
@author  ehoto
@date    2013.7.19
@param pList: 정보를 저장하는 List의 포인터
@param pDrivingInfo: 명령 정보의 포인터
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
bool DrivingControl::CancelList(List<DRIVING_CMD_INFO_OF_SPEED*> *pList, CLASSIFIED_DRIVING_CHANGE DrivingInfo)
{
 	int nListCount      = pList->getCount();
	bool bReturn = false;
	DRIVING_CMD_INFO_OF_SPEED *pItem = NULL;
	DRIVING_CMD_INFO_OF_SPEED *pTempItem = NULL;

	if(nListCount==0) return bReturn;

	pTempItem = new DRIVING_CMD_INFO_OF_SPEED;

	for(int nTmpIndex = 0; nTmpIndex<nListCount; nTmpIndex++)
	{
		pItem   = pList->popBack();
		if(pItem!=NULL)
		{


			if(pItem->nCount < DrivingInfo.nCheckNodeCount)
			{
				pTempItem->nCount = DrivingInfo.nCheckNodeCount;
				pTempItem->dDistSumToFinalNode = DrivingInfo.dEncoderFinal;
				pTempItem->dDistSumToTarget = DrivingInfo.dEncoderFinal;

				bReturn = true;

				pList->insertBack(pItem);
				pList->insertBack(pTempItem);
				ADD_LOG("CancelList SPEED1 %d %d",pItem->nCount, DrivingInfo.nCheckNodeCount);
				return bReturn;
			}
			else if((pItem->nCount == DrivingInfo.nCheckNodeCount) || (nTmpIndex == (nListCount-1)))
			{
				pItem->nCount = DrivingInfo.nCheckNodeCount;
				pItem->dDistSumToFinalNode = DrivingInfo.dEncoderFinal;
				pItem->dDistSumToTarget = DrivingInfo.dEncoderFinal;
				bReturn = true;

				pList->insertBack(pItem);

				ADD_LOG("CancelList SPEED2 %d %d",pItem->nCount, DrivingInfo.nCheckNodeCount);
				delete pTempItem;
				return bReturn;
			}
			else
			{
//				pItem   = pList->popBack();

				pTempItem->dSpeed = pItem->dSpeed;
				pTempItem->dDistSumToFinalNode = pItem->dDistSumToFinalNode;
				pTempItem->nCount = pItem->nCount;
				pTempItem->MarkType = pItem->MarkType;
				pTempItem->dDistSumToTarget = pItem->dDistSumToTarget;
				pTempItem->dDecelDist = pItem->dDecelDist;

                delete pItem;
                pItem   = NULL;
			}

		}
	}

	delete pTempItem;
	return bReturn;

}
/**
@brief   명령으로 부터 Node Info List 정보를 만들어 냄
@author  ehoto
@date    2013.7.19
@param pList: 정보를 저장하는 List의 포인터
@param pDrivingInfo: 명령 정보의 포인터
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
bool DrivingControl::CancelList(List<DRIVING_CMD_INFO_OF_PATH*> *pList, CLASSIFIED_DRIVING_CHANGE DrivingInfo)
{
	int nListCount      = pList->getCount();
	bool bReturn = false;
	DRIVING_CMD_INFO_OF_PATH *pItem = NULL;
	DRIVING_CMD_INFO_OF_PATH *pTempItem = NULL;

	if(nListCount==0) return bReturn;

	pTempItem = new DRIVING_CMD_INFO_OF_PATH;

	for(int nTmpIndex = 0; nTmpIndex<nListCount; nTmpIndex++)
	{
		pItem   = pList->popBack();
		if(pItem!=NULL)
		{


			if(pItem->nCount < DrivingInfo.nCheckNodeCount)
			{
				pTempItem->nCount = DrivingInfo.nCheckNodeCount;
				pTempItem->dDistSumToEndNode = DrivingInfo.dEncoderFinal;

				bReturn = true;

				pList->insertBack(pItem);
				pList->insertBack(pTempItem);
				ADD_LOG("CancelList PATH1 %d %d",pItem->nCount, DrivingInfo.nCheckNodeCount);
				return bReturn;
			}
			else if((pItem->nCount == DrivingInfo.nCheckNodeCount) || (nTmpIndex == (nListCount-1)))
			{
				pItem->nCount = DrivingInfo.nCheckNodeCount;
				pItem->dDistSumToEndNode = DrivingInfo.dEncoderFinal;
				bReturn = true;

				pList->insertBack(pItem);
                ADD_LOG("CancelList PATH2 %d %d",pItem->nCount, DrivingInfo.nCheckNodeCount);
				delete pTempItem;
				return bReturn;
			}
			else
            {
//				pItem   = pList->popBack();

				pTempItem->StartNID = pItem->StartNID;
				pTempItem->EndNID = pItem->EndNID;
				pTempItem->StartNType = pItem->StartNType;
				pTempItem->EndNType = pItem->EndNType;
				pTempItem->StartType = pItem->StartType;
				pTempItem->NodeType = pItem->NodeType;
				pTempItem->dSpeed = pItem->dSpeed;
				pTempItem->dLength = pItem->dLength;
				pTempItem->dDistSumToEndNode = pItem->dDistSumToEndNode;
				pTempItem->nPBSIgnoreFlag = pItem->nPBSIgnoreFlag;
				pTempItem->nCount = pItem->nCount;
				pTempItem->Steering = pItem->Steering;
#if(USE_CHANGENODE == 1)
				pTempItem->UBGRegion = pItem->UBGRegion;
				pTempItem->ObstacleRegion = pItem->ObstacleRegion;
				pTempItem->PreSteering = pItem->PreSteering;
				pTempItem->DivInfo = pItem->DivInfo;

				//for change node
				pTempItem->NodeType = pItem->NodeType;
				pTempItem->OptDistance = pItem->OptDistance;
				pTempItem->OptDistanceAfter = pItem->OptDistanceAfter;
				pTempItem->OptUBGRegion = pItem->OptUBGRegion;
				pTempItem->OptObstacleRegion = pItem->OptObstacleRegion;
#else
				pTempItem->Direction = pItem->Direction;
				pTempItem->PreSteering = pItem->PreSteering;
				pTempItem->DivInfo = pItem->DivInfo;
#endif


//				memmove(pTempItem,pItem,sizeof(DRIVING_CMD_INFO_OF_PATH));
                delete pItem;
                pItem   = NULL;
            }
		}
	}

	delete pTempItem;
	return bReturn;

}

/**
@brief   명령으로 부터 Node Info List 정보를 만들어 냄
@author  ehoto
@date    2013.7.19
@param pList: 정보를 저장하는 List의 포인터
@param pDrivingInfo: 명령 정보의 포인터
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
bool DrivingControl::makeList(List<DRIVING_CMD_INFO_OF_NODE*> *pList, DRIVING_CMD_INFO_OF_PATH DrivingInfo)
{
    bool bSuccess = true;
    DRIVING_CMD_INFO_OF_NODE* pItem = NULL;

    int nCount = pList->getCount();

    if(nCount==0)
    {
        // 시작 Node 정보 입력
        pItem = NULL;
		pItem = new DRIVING_CMD_INFO_OF_NODE();
        pItem->ID = DrivingInfo.StartNID;
        pItem->Type = DrivingInfo.StartNType;
		pItem->dDistSum = 0;
		pItem->nCount = 0;
//		pItem->DivInfo = DrivingInfo.DivInfo;
//		if(DrivingInfo.NodeType ==SLOPE_NTYPE) pItem->SlopeInfo = NODE_SLOPE;
//		else	pItem->SlopeInfo = NODE_NORMAL;
        pItem->NodeType = DrivingInfo.NodeType;
		pList->insertBack(pItem);

        // 다음 Node 정보 입력
        pItem = NULL;
        pItem = new DRIVING_CMD_INFO_OF_NODE();
        pItem->ID = DrivingInfo.EndNID;
        pItem->Type = DrivingInfo.EndNType;
		pItem->dDistSum = DrivingInfo.dDistSumToEndNode;
		pItem->nCount = DrivingInfo.nCount;
//		pItem->DivInfo = PATH_DIVERGENCE_NONE;
//		if(DrivingInfo.NodeType ==SLOPE_NTYPE) pItem->SlopeInfo = NODE_SLOPE;
//		else	pItem->SlopeInfo = NODE_NORMAL;
		pItem->NodeType = DrivingInfo.NextNodeType;
        pList->insertBack(pItem);
    }
	else//if(nCount==0)
    {
        //2 1) 중복 명령 확인
		pItem = pList->referBack();
        if(pItem->ID==DrivingInfo.EndNID)
        {
        //2 마지막 Node는 같으나 이전 노드가 다른 경우
            if(nCount>1)
            {
                pItem = pList->refer(nCount-2);
                if(pItem->ID!=DrivingInfo.StartNID)
                {
                    bSuccess = false;
                    ERR_LOG("DrivingControl::makeList: 마지막 Node는 같으나 이전 노드가 다른 경우 [Curr(%d)!=StartNID%d]", pItem->ID, DrivingInfo.StartNID);
                }
            }
        //2 중복된 명령이면 Skip
            else//if(nCount>1)
            {
                // skip
            }//else of if(nCount>1)
		}
        //2 2) 중복이 아닐 경우
        else//if(pItem->ID==DrivingInfo->EndNID)
		{
        //2 비연속 명령 확인
            if(pItem->ID!=DrivingInfo.StartNID)
            {
                bSuccess = false;
                ERR_LOG("DrivingControl::makeList: 비연속 명령 [Curr(%X)!=StartNID%X]", pItem->ID, DrivingInfo.StartNID);
            }
        //2 정상 명령 (연속 명령 경우)
            else//if(pItem->ID!=DrivingInfo->StartNID)
			{

//				pItem->DivInfo = DrivingInfo.DivInfo;

                pItem = NULL;
                pItem = new DRIVING_CMD_INFO_OF_NODE();
                pItem->ID = DrivingInfo.EndNID;
                pItem->Type = DrivingInfo.EndNType;
                pItem->dDistSum = DrivingInfo.dDistSumToEndNode;
				pItem->nCount = DrivingInfo.nCount;
//				pItem->DivInfo = PATH_DIVERGENCE_NONE;
//				if(DrivingInfo.NodeType ==SLOPE_NTYPE) pItem->SlopeInfo = NODE_SLOPE;
//				else	pItem->SlopeInfo = NODE_NORMAL;
				pItem->NodeType = DrivingInfo.NextNodeType;
                pList->insertBack(pItem);
			}//else of if(pItem->ID!=DrivingInfo->StartNID)

        }//else of if(pItem->ID==DrivingInfo->EndNID)
    }//else of if(nCount==0)

    return bSuccess;
}
/**
@brief   명령으로 부터 Steer Info List 정보를 만들어 냄
@author  ehoto
@date    2013.7.19
@param pList: 정보를 저장하는 List의 포인터
@param pDrivingInfo: 명령 정보의 포인터
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
bool DrivingControl::makeList(List<DRIVING_CMD_INFO_OF_STEER*> *pList, DRIVING_CMD_INFO_OF_PATH DrivingInfo)
{
    bool bSuccess = true;
    DRIVING_CMD_INFO_OF_STEER* pItem;

    int nCount = pList->getCount();

    if(nCount==0)
    {
        // 시작 Node 정보 입력
        pItem = NULL;
        pItem = new DRIVING_CMD_INFO_OF_STEER();
        pItem->Type = DrivingInfo.Steering;
		pItem->NextType = DrivingInfo.PreSteering;
        pItem->dDistSumToEndNode = DrivingInfo.dDistSumToEndNode;
        pItem->nCount = DrivingInfo.nCount;
		pList->insertBack(pItem);
    }
    else//if(nCount==0)
    {
        //2 1) 중복 명령 확인
		pItem = pList->referBack();
        if(pItem->nCount==DrivingInfo.nCount)
        {
        //2 중복된 명령이면 Skip
            if(pItem->Type==DrivingInfo.Steering)
            {
				if(pItem->NextType!=DrivingInfo.PreSteering)
                {
					pItem->NextType=DrivingInfo.PreSteering;
                }
            }
            else
            {
                bSuccess = false;
            }
        }
        //2 2) 중복이 아닐 경우
        else//if(pItem->ID==DrivingInfo->EndNID)
        {
        //2 조향이 같을 경우
            if(pItem->Type==DrivingInfo.Steering)
            {
				pItem->NextType = DrivingInfo.PreSteering;
                pItem->dDistSumToEndNode = DrivingInfo.dDistSumToEndNode;
                pItem->nCount = DrivingInfo.nCount;
            }
        //2 조향이 다른 경우
            else
            {
                pItem = NULL;
                pItem = new DRIVING_CMD_INFO_OF_STEER();
                pItem->Type = DrivingInfo.Steering;
				pItem->NextType = DrivingInfo.PreSteering;
                pItem->dDistSumToEndNode = DrivingInfo.dDistSumToEndNode;
                pItem->nCount = DrivingInfo.nCount;
                pList->insertBack(pItem);
            }
        }//else of if(pItem->ID==DrivingInfo->EndNID)
    }//else of if(nCount==0)

    return bSuccess;
}

/**
@brief   명령으로 부터 Steer Info List 정보를 만들어 냄
@author  ehoto
@date    2013.7.19
@param pList: 정보를 저장하는 List의 포인터
@param pDrivingInfo: 명령 정보의 포인터
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
bool DrivingControl::makeList(List<DRIVING_CMD_INFO_OF_DIV*> *pList, DRIVING_CMD_INFO_OF_PATH DrivingInfo)
{
    bool bSuccess = true;
    DRIVING_CMD_INFO_OF_DIV* pItem;

    int nCount = pList->getCount();

//	ADD_LOG("makeList DIV %d %d %d:%d",DrivingInfo.StartNID, DrivingInfo.DivInfo,nCount,DrivingInfo.nCount);

    if(nCount==0)
    {
        // 시작 Node 정보 입력
        pItem = NULL;
        pItem = new DRIVING_CMD_INFO_OF_DIV();
		pItem->Type = DrivingInfo.DivInfo;
		pItem->NextType = DrivingInfo.PreDivInfo;
        pItem->dDistSumToEndNode = DrivingInfo.dDistSumToEndNode;
        pItem->nCount = DrivingInfo.nCount;
		pList->insertBack(pItem);
    }
    else//if(nCount==0)
    {
        //2 1) 중복 명령 확인
		pItem = pList->referBack();
        if(pItem->nCount==DrivingInfo.nCount)
        {
        //2 중복된 명령이면 Skip
			if(pItem->Type==DrivingInfo.DivInfo)
            {
				if(pItem->NextType!=DrivingInfo.PreDivInfo)
                {
					pItem->NextType=DrivingInfo.PreDivInfo;
                }
            }
            else
            {
                bSuccess = false;
            }
        }
        //2 2) 중복이 아닐 경우
        else//if(pItem->ID==DrivingInfo->EndNID)
        {
        //2 조향이 같을 경우
			if((pItem->Type==DrivingInfo.DivInfo)&&
			   (DrivingInfo.DivInfo ==PATH_DIVERGENCE_NONE))
            {
				pItem->NextType = DrivingInfo.DivInfo;
                pItem->dDistSumToEndNode = DrivingInfo.dDistSumToEndNode;
                pItem->nCount = DrivingInfo.nCount;
            }
        //2 조향이 다른 경우
            else
			{
				pItem->NextType = DrivingInfo.DivInfo;

                pItem = NULL;
                pItem = new DRIVING_CMD_INFO_OF_DIV();
				pItem->Type = DrivingInfo.DivInfo;
				pItem->NextType = DrivingInfo.DivInfo;
                pItem->dDistSumToEndNode = DrivingInfo.dDistSumToEndNode;
                pItem->nCount = DrivingInfo.nCount;
                pList->insertBack(pItem);
            }
        }//else of if(pItem->ID==DrivingInfo->EndNID)
    }//else of if(nCount==0)

    return bSuccess;
}

/**
@brief   명령으로 부터 Direction Info List 정보를 만들어 냄
@author  ehoto
@date    2013.7.19
@param pList: 정보를 저장하는 List의 포인터
@param pDrivingInfo: 명령 정보의 포인터
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
bool DrivingControl::makeList(List<DRIVING_CMD_INFO_OF_DIRECTION*> *pList, DRIVING_CMD_INFO_OF_PATH DrivingInfo)
{
    bool bSuccess = true;

    DRIVING_CMD_INFO_OF_DIRECTION *pItem = NULL;

    int nCount = pList->getCount();

    if(nCount==0)
    {
        // 시작 Node 정보 입력
        pItem = NULL;
		pItem = new DRIVING_CMD_INFO_OF_DIRECTION();
#if(USE_CHANGENODE == 1)
		pItem->UBGRegion = DrivingInfo.UBGRegion;
		pItem->ObstacleRegion = DrivingInfo.ObstacleRegion;
        pItem->dDistSumToEndNode = DrivingInfo.dDistSumToEndNode;
		pItem->nPBSIgnoreFlag = DrivingInfo.nPBSIgnoreFlag;
		pItem->nFollowsCommandType = DETECT_INFO_TYPE_BOTH;
        pItem->nCount = DrivingInfo.nCount;

		// for change node
		pItem->NodeType = DrivingInfo.NodeType;
		pItem->OptDistance = DrivingInfo.OptDistance;
		pItem->OptDistanceAfter = DrivingInfo.OptDistanceAfter;
		pItem->OptUBGRegion = DrivingInfo.OptUBGRegion;
		pItem->OptObstacleRegion = DrivingInfo.OptObstacleRegion;

		// edit change node information for station starting situtation!
		if(DrivingInfo.nCount == 1 &&
			(DrivingInfo.NodeType == OPT_TAG || DrivingInfo.NodeType == OPT_DISTANCE || DrivingInfo.NodeType == OPT_COMBO) &&
			m_LastDrivingCmdInfo.AddInfo.ProcessingGoInfo.IsStationStart == true)
		{
			double offset = m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset;
			if(offset < DrivingInfo.OptDistance)
			{
				pItem->OptDistance -= offset;
			}
			else
			{
				if(DrivingInfo.NodeType == OPT_TAG || DrivingInfo.NodeType == OPT_DISTANCE) // pattern already be changed
				{
					pItem->NodeType = NONE_TYPE;
					pItem->OptDistance = 0;
					pItem->OptDistanceAfter = 0;
					pItem->OptUBGRegion = PATH_DIRECTION_NO_USE;
					pItem->OptObstacleRegion = PATH_OBS_DIRECTION_NO_USE;

					pItem->UBGRegion = DrivingInfo.OptUBGRegion;
					pItem->ObstacleRegion = DrivingInfo.OptObstacleRegion;
				}
				else if(DrivingInfo.NodeType == OPT_COMBO)
				{
					double remainDistance = offset - DrivingInfo.OptDistance;
					if(remainDistance < DrivingInfo.OptDistanceAfter)
					{
						pItem->NodeType = OPT_DISTANCE;
						pItem->OptDistance = DrivingInfo.OptDistanceAfter - remainDistance;
						pItem->OptDistanceAfter = 0;
					}
					else  // pattern already be changed
					{
						pItem->NodeType = NONE_TYPE;
						pItem->OptDistance = 0;
						pItem->OptDistanceAfter = 0;
						pItem->OptUBGRegion = PATH_DIRECTION_NO_USE;
						pItem->OptObstacleRegion = PATH_OBS_DIRECTION_NO_USE;

						pItem->UBGRegion = DrivingInfo.OptUBGRegion;
						pItem->ObstacleRegion = DrivingInfo.OptObstacleRegion;
					}
				}
			}
			ADD_LOG("Edit ChangeNode : %d/%d/%d/%d/%d ->%d/%d/%d/%d/%d (%f)"
				, (int)DrivingInfo.NodeType, DrivingInfo.OptDistance, DrivingInfo.OptDistanceAfter, DrivingInfo.OptUBGRegion, DrivingInfo.OptObstacleRegion
				, (int)pItem->NodeType, pItem->OptDistance, pItem->OptDistanceAfter, pItem->OptUBGRegion, pItem->OptObstacleRegion,
				offset);
		}
#else
		pItem->Type = DrivingInfo.Direction;
		pItem->dDistSumToEndNode = DrivingInfo.dDistSumToEndNode;
		pItem->nPBSIgnoreFlag = DrivingInfo.nPBSIgnoreFlag;
		pItem->nFollowsCommandType = DETECT_INFO_TYPE_BOTH;
        pItem->nCount = DrivingInfo.nCount;
#endif


        pList->insertBack(pItem);
    }
    else//if(nCount==0)
    {
        //2 1) 중복 명령 확인
        pItem = pList->referBack();
        if(pItem->nCount==DrivingInfo.nCount)
        {
		//2 중복된 명령이면 Skip
#if(USE_CHANGENODE == 1)
             if(pItem->UBGRegion == DrivingInfo.UBGRegion && pItem->ObstacleRegion == DrivingInfo.ObstacleRegion &&
				pItem->OptUBGRegion == DrivingInfo.OptUBGRegion && pItem->OptObstacleRegion == DrivingInfo.OptObstacleRegion)
#else
            if(pItem->Type==DrivingInfo.Direction)
#endif
            {

            }
            else
            {
                bSuccess = false;
            }
        }
        //2 2) 중복이 아닐 경우
        else
        {
//        	ADD_LOG("MakeList.. pItem->nPBSIgnoreFlag: %d, pItem->Type: 0x%x, DrivingInfo.Direction: 0x%x",pItem->nPBSIgnoreFlag, pItem->Type, DrivingInfo.Direction);
#if(USE_CHANGENODE == 1)
            if(pItem->UBGRegion == DrivingInfo.UBGRegion && pItem->ObstacleRegion == DrivingInfo.ObstacleRegion &&
				pItem->OptUBGRegion == DrivingInfo.OptUBGRegion && pItem->OptObstacleRegion == DrivingInfo.OptObstacleRegion)
#else
			if(pItem->Type==DrivingInfo.Direction)
#endif
            {
            	if(pItem->nPBSIgnoreFlag == DrivingInfo.nPBSIgnoreFlag)
           		{
	                pItem->dDistSumToEndNode = DrivingInfo.dDistSumToEndNode;
    	            pItem->nCount = DrivingInfo.nCount;
           		}
				else
				{
	                pItem = NULL;
					pItem = new DRIVING_CMD_INFO_OF_DIRECTION();
#if(USE_CHANGENODE == 1)
					pItem->UBGRegion = DrivingInfo.UBGRegion;
					pItem->ObstacleRegion = DrivingInfo.ObstacleRegion;
	                pItem->dDistSumToEndNode = DrivingInfo.dDistSumToEndNode;
					pItem->nPBSIgnoreFlag = DrivingInfo.nPBSIgnoreFlag;
					pItem->nFollowsCommandType = DETECT_INFO_TYPE_ONLY_PBS;
	                pItem->nCount = DrivingInfo.nCount;

					// for change node
					pItem->NodeType = DrivingInfo.NodeType;
					pItem->OptDistance = DrivingInfo.OptDistance;
					pItem->OptDistanceAfter = DrivingInfo.OptDistanceAfter;
					pItem->OptUBGRegion = DrivingInfo.OptUBGRegion;
					pItem->OptObstacleRegion = DrivingInfo.OptObstacleRegion;
#else
	                pItem->Type = DrivingInfo.Direction;
	                pItem->dDistSumToEndNode = DrivingInfo.dDistSumToEndNode;
					pItem->nPBSIgnoreFlag = DrivingInfo.nPBSIgnoreFlag;
					pItem->nFollowsCommandType = DETECT_INFO_TYPE_ONLY_PBS;
	                pItem->nCount = DrivingInfo.nCount;
#endif

	                pList->insertBack(pItem);
				}
            }
            else
            {
            	if(pItem->nPBSIgnoreFlag == DrivingInfo.nPBSIgnoreFlag)
           		{
	                pItem = NULL;
					pItem = new DRIVING_CMD_INFO_OF_DIRECTION();
#if(USE_CHANGENODE == 1)
					pItem->UBGRegion = DrivingInfo.UBGRegion;
					pItem->ObstacleRegion = DrivingInfo.ObstacleRegion;
	                pItem->dDistSumToEndNode = DrivingInfo.dDistSumToEndNode;
					pItem->nPBSIgnoreFlag = DrivingInfo.nPBSIgnoreFlag;
					pItem->nFollowsCommandType = DETECT_INFO_TYPE_ONLY_UBG;
	                pItem->nCount = DrivingInfo.nCount;

					// for change node
					pItem->NodeType = DrivingInfo.NodeType;
					pItem->OptDistance = DrivingInfo.OptDistance;
					pItem->OptDistanceAfter = DrivingInfo.OptDistanceAfter;
					pItem->OptUBGRegion = DrivingInfo.OptUBGRegion;
					pItem->OptObstacleRegion = DrivingInfo.OptObstacleRegion;
#else
	                pItem->Type = DrivingInfo.Direction;
	                pItem->dDistSumToEndNode = DrivingInfo.dDistSumToEndNode;
					pItem->nPBSIgnoreFlag = DrivingInfo.nPBSIgnoreFlag;
					pItem->nFollowsCommandType = DETECT_INFO_TYPE_ONLY_UBG;
	                pItem->nCount = DrivingInfo.nCount;
#endif
					pList->insertBack(pItem);
           		}
				else
				{
					pItem = NULL;
					pItem = new DRIVING_CMD_INFO_OF_DIRECTION();
#if(USE_CHANGENODE == 1)
					pItem->UBGRegion = DrivingInfo.UBGRegion;
					pItem->ObstacleRegion = DrivingInfo.ObstacleRegion;
	                pItem->dDistSumToEndNode = DrivingInfo.dDistSumToEndNode;
					pItem->nPBSIgnoreFlag = DrivingInfo.nPBSIgnoreFlag;
					pItem->nFollowsCommandType = DETECT_INFO_TYPE_BOTH;
	                pItem->nCount = DrivingInfo.nCount;

					// for change node
					pItem->NodeType = DrivingInfo.NodeType;
					pItem->OptDistance = DrivingInfo.OptDistance;
					pItem->OptDistanceAfter = DrivingInfo.OptDistanceAfter;
					pItem->OptUBGRegion = DrivingInfo.OptUBGRegion;
					pItem->OptObstacleRegion = DrivingInfo.OptObstacleRegion;
#else
	                pItem->Type = DrivingInfo.Direction;
	                pItem->dDistSumToEndNode = DrivingInfo.dDistSumToEndNode;
					pItem->nPBSIgnoreFlag = DrivingInfo.nPBSIgnoreFlag;
					pItem->nFollowsCommandType = DETECT_INFO_TYPE_BOTH;
	                pItem->nCount = DrivingInfo.nCount;
#endif
	                pList->insertBack(pItem);
				}
            }
        }//else of if(pItem->ID==DrivingInfo->EndNID)
    }//else of if(nCount==0)

    return bSuccess;
}
/**
@brief   명령으로 부터 Speed Info List 정보를 만들어 냄
@author  ehoto
@date    2013.7.19
@param pList: 정보를 저장하는 List의 포인터
@param pDrivingInfo: 명령 정보의 포인터
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
bool DrivingControl::makeList(List<DRIVING_CMD_INFO_OF_SPEED*> *pList, DRIVING_CMD_INFO_OF_PATH DrivingInfo, DRIVING_CMD_INFO_OF_TARGET TargetInfo)
{
    bool bSuccess = true;

    DRIVING_CMD_INFO_OF_SPEED *pItem = NULL;
    double dDecel = m_pParamSet->Axis.Default.dDefaultDecel;

    int nCount = pList->getCount();

    if(nCount==0)
    {
        // 시작 Node 정보 입력
        pItem = NULL;
        pItem = new DRIVING_CMD_INFO_OF_SPEED();
        pItem->dSpeed = DrivingInfo.dSpeed;
        pItem->dDistSumToFinalNode = DrivingInfo.dDistSumToEndNode;
        pItem->nCount = DrivingInfo.nCount;
        pItem->MarkType = TargetInfo.Type;
        pItem->dDistSumToTarget = TargetInfo.dDistSumToNode + TargetInfo.dOffset;
        pItem->dDecelDist = (pItem->dSpeed*pItem->dSpeed)/(2*dDecel);   // 감속 거리 구하는 식 : S=(V^2)/(2*a)
        pList->insertBack(pItem);
    }
    else//if(nCount==0)
    {
        //2 1) 중복 명령 확인
        pItem = pList->referBack();
        if(pItem->nCount==DrivingInfo.nCount)
        {
        //2 중복된 명령이면 Skip (Target까지의 거리 확인)
            if(pItem->dDistSumToTarget==(TargetInfo.dDistSumToNode + TargetInfo.dOffset))
            {

            }
        //2 Target Station 거리가 가까워진 경우 에러 처리
            else if(pItem->dDistSumToTarget>(TargetInfo.dDistSumToNode + TargetInfo.dOffset))
            {
                bSuccess = false;
            }
        //2 Target Station 거리가 Next Node를 넘어간 경우 에러 처리
            else if(pItem->dDistSumToTarget>(TargetInfo.dDistSumToNode + TargetInfo.dLength))
            {
                bSuccess = false;
            }
        //2 Target Station 정보가 변경된 경우
            else
            {
                // 시작 Node 정보 입력
                pItem->dSpeed = DrivingInfo.dSpeed;
                pItem->dDistSumToFinalNode = DrivingInfo.dDistSumToEndNode;
                pItem->nCount = DrivingInfo.nCount;
                pItem->MarkType = TargetInfo.Type;
                pItem->dDistSumToTarget = TargetInfo.dDistSumToNode + TargetInfo.dOffset;
                pItem->dDecelDist = (pItem->dSpeed*pItem->dSpeed)/(2*dDecel);   // 감속 거리 구하는 식 : S=(V^2)/(2*a)
                pList->insertBack(pItem);
            }
        }
        //2 2) 중복이 아닐 경우
        else//if(pItem->ID==DrivingInfo->EndNID)
        {
        //2 속도가 같을 경우
            if(pItem->dSpeed==DrivingInfo.dSpeed)
            {
                pItem->dSpeed = DrivingInfo.dSpeed;
                pItem->dDistSumToFinalNode = DrivingInfo.dDistSumToEndNode;
                pItem->nCount = DrivingInfo.nCount;
                pItem->MarkType = TargetInfo.Type;
                pItem->dDistSumToTarget = TargetInfo.dDistSumToNode + TargetInfo.dOffset;
                pItem->dDecelDist = (pItem->dSpeed*pItem->dSpeed)/(2*dDecel);   // 감속 거리 구하는 식 : S=(V^2)/(2*a)
            }
        //2 속도가 다른 경우
            else
            {
                // 이전 명령 의 Type을 Node로 변경
                pItem->MarkType = MARK_TYPE_NODE;
                pItem->dDistSumToTarget = pItem->dDistSumToFinalNode;
                pItem->dDecelDist = (pItem->dSpeed*pItem->dSpeed)/(2*dDecel);   // 감속 거리 구하는 식 : S=(V^2)/(2*a)

                // 새 명령 정보 추가
                pItem = NULL;
                pItem = new DRIVING_CMD_INFO_OF_SPEED();
                pItem->dSpeed = DrivingInfo.dSpeed;
                pItem->dDistSumToFinalNode = DrivingInfo.dDistSumToEndNode;
                pItem->nCount = DrivingInfo.nCount;
                pItem->MarkType = TargetInfo.Type;
                pItem->dDistSumToTarget = TargetInfo.dDistSumToNode + TargetInfo.dOffset;
                pItem->dDecelDist = (pItem->dSpeed*pItem->dSpeed)/(2*dDecel);   // 감속 거리 구하는 식 : S=(V^2)/(2*a)
                pList->insertBack(pItem);
            }
        }//else of if(pItem->ID==DrivingInfo->EndNID)
    }//else of if(nCount==0)

    return bSuccess;
}
/**
@brief   명령으로 부터 Path Info List 정보를 만들어 냄
@author  ehoto
@date    2013.7.19
@param pList: 정보를 저장하는 List의 포인터
@param pDrivingInfo: 명령 정보의 포인터
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
bool DrivingControl::makeList(List<DRIVING_CMD_INFO_OF_PATH*> *pList, DRIVING_CMD_INFO_OF_PATH DrivingInfo)
{
    bool bSuccess = true;
    DRIVING_CMD_INFO_OF_PATH* pItem = NULL;

    int nCount = pList->getCount();

    if(nCount==0)
    {
		// 시작 Path 정보 입력
        pItem = NULL;
		pItem = new DRIVING_CMD_INFO_OF_PATH();
		*pItem = DrivingInfo;

		pList->insertBack(pItem);
	}
	else//if(nCount==0)
	{
		//2 1) 중복 명령 확인
		pItem = pList->referBack();
		if(pItem->EndNID==DrivingInfo.EndNID)
		{
		//2 마지막 Node는 같으나 이전 노드가 다른 경우
			if(pItem->StartNID!=DrivingInfo.StartNID)
			{
				bSuccess = false;
//              ERR_LOG("DrivingControl::makeList: 마지막 Node는 같으나 이전 노드가 다른 경우 [Curr(%X)!=StartNID%X]", pItem->ID, DrivingInfo.StartNID);
			}
		//2 중복된 명령이면 Skip
			else//if(nCount>1)
			{
				// skip
			}//else of if(nCount>1)
		}
		//2 2) 중복이 아닐 경우
		else//if(pItem->ID==DrivingInfo->EndNID)
		{
		//2 비연속 명령 확인
			if(pItem->EndNID!=DrivingInfo.StartNID)
			{
				bSuccess = false;
//              ERR_LOG("DrivingControl::makeList: 비연속 명령 [Curr(%X)!=StartNID%X]", pItem->ID, DrivingInfo.StartNID);
			}
		//2 정상 명령 (연속 명령 경우)
			else//if(pItem->ID!=DrivingInfo->StartNID)
			{
				pItem = NULL;
				pItem = new DRIVING_CMD_INFO_OF_PATH();
				*pItem = DrivingInfo;

				pList->insertBack(pItem);
			}//else of if(pItem->ID!=DrivingInfo->StartNID)

		}//else of if(pItem->ID==DrivingInfo->EndNID)
	}//else of if(nCount==0)

	return bSuccess;
}
////////후진기능을 위한 추가된 부분

/**
@brief   명령으로 부터 Node Info List 정보를 만들어 냄
@author  ehoto
@date    2013.7.19
@param pList: 정보를 저장하는 List의 포인터
@param pDrivingInfo: 명령 정보의 포인터
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
bool DrivingControl::makeBackList(List<DRIVING_CMD_INFO_OF_NODE*> *pList, DRIVING_CMD_INFO_OF_PATH DrivingInfo)
{
    bool bSuccess = true;
    DRIVING_CMD_INFO_OF_NODE* pItem = NULL;

    int nCount = pList->getCount();

    if(nCount==0)
    {
        // 시작 Node 정보 입력
        pItem = NULL;
		pItem = new DRIVING_CMD_INFO_OF_NODE();
		pItem->ID = DrivingInfo.EndNID;
		pItem->Type = DrivingInfo.EndNType;
		pItem->dDistSum = 0;
		pItem->nCount = 0;
//		pItem->DivInfo = DrivingInfo.DivInfo;
//		if(DrivingInfo.NodeType ==SLOPE_NTYPE) pItem->SlopeInfo = NODE_SLOPE;
//		else	pItem->SlopeInfo = NODE_NORMAL;
		pItem->NodeType = DrivingInfo.NodeType;
		pList->insertBack(pItem);

        // 다음 Node 정보 입력
        pItem = NULL;
        pItem = new DRIVING_CMD_INFO_OF_NODE();
		pItem->ID = DrivingInfo.StartNID;
		pItem->Type = DrivingInfo.StartNType;
		pItem->dDistSum = DrivingInfo.dDistSumToEndNode;
		pItem->nCount = DrivingInfo.nCount;
//		pItem->DivInfo = PATH_DIVERGENCE_NONE;
//		if(DrivingInfo.NodeType ==SLOPE_NTYPE) pItem->SlopeInfo = NODE_SLOPE;
//		else	pItem->SlopeInfo = NODE_NORMAL;
		pItem->NodeType = DrivingInfo.NodeType;
        pList->insertBack(pItem);
    }
	else//if(nCount==0)
    {
        //2 1) 중복 명령 확인
		pItem = pList->referBack();
//        if(pItem->ID==DrivingInfo.EndNID)
//        {
//        //2 마지막 Node는 같으나 이전 노드가 다른 경우
//            if(nCount>1)
//            {
//                pItem = pList->refer(nCount-2);
//                if(pItem->ID!=DrivingInfo.StartNID)
//                {
//                    bSuccess = false;
//                    ERR_LOG("DrivingControl::makeList: 마지막 Node는 같으나 이전 노드가 다른 경우 [Curr(%d)!=StartNID%d]", pItem->ID, DrivingInfo.StartNID);
//                }
//            }
//        //2 중복된 명령이면 Skip
//            else//if(nCount>1)
//            {
//                // skip
//            }//else of if(nCount>1)
//		}
		//2 2) 중복이 아닐 경우
		if(pItem->ID==DrivingInfo.EndNID)
		{
		//2 비연속 명령 확인
			if(pItem->ID!=DrivingInfo.EndNID)
			{
				bSuccess = false;
				ERR_LOG("DrivingControl::makeList: 비연속 명령 [Curr(%X)!=StartNID%X]", pItem->ID, DrivingInfo.StartNID);
			}
		//2 정상 명령 (연속 명령 경우)
			else//if(pItem->ID!=DrivingInfo->StartNID)
			{

//				pItem->DivInfo = DrivingInfo.DivInfo;

				pItem = NULL;
				pItem = new DRIVING_CMD_INFO_OF_NODE();
				pItem->ID = DrivingInfo.StartNID;
				pItem->Type = DrivingInfo.StartNType;
				pItem->dDistSum = DrivingInfo.dDistSumToEndNode;
				pItem->nCount = DrivingInfo.nCount;
//				pItem->DivInfo = PATH_DIVERGENCE_NONE;
//				if(DrivingInfo.NodeType ==SLOPE_NTYPE) pItem->SlopeInfo = NODE_SLOPE;
//				else	pItem->SlopeInfo = NODE_NORMAL;
				pItem->NodeType = DrivingInfo.NodeType;
				pList->insertBack(pItem);
			}//else of if(pItem->ID!=DrivingInfo->StartNID)

		}//else of if(pItem->ID==DrivingInfo->EndNID)
	}//else of if(nCount==0)

	return bSuccess;
}

/**
@brief   명령으로 부터 Speed Info List 정보를 만들어 냄
@author  수정 필요
@date    2013.7.19
@param pList: 정보를 저장하는 List의 포인터
@param pDrivingInfo: 명령 정보의 포인터
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
bool DrivingControl::makeBackList(List<DRIVING_CMD_INFO_OF_SPEED*> *pList, DRIVING_CMD_INFO_OF_PATH DrivingInfo, DRIVING_CMD_INFO_OF_TARGET TargetInfo)
{
	bool bSuccess = true;

	DRIVING_CMD_INFO_OF_SPEED *pItem = NULL;
	double dDecel = m_pParamSet->Axis.Default.dDefaultDecel;

	int nCount = pList->getCount();

	if(nCount==0)
	{
		// 시작 Node 정보 입력
		pItem = NULL;
		pItem = new DRIVING_CMD_INFO_OF_SPEED();
		pItem->dSpeed = DrivingInfo.dSpeed;
		pItem->dDistSumToFinalNode = DrivingInfo.dDistSumToEndNode;
		pItem->nCount = DrivingInfo.nCount;
		pItem->MarkType = TargetInfo.Type;
		pItem->dDistSumToTarget = TargetInfo.dDistSumToNode + TargetInfo.dOffset;
		pItem->dDecelDist = (pItem->dSpeed*pItem->dSpeed)/(2*dDecel);   // 감속 거리 구하는 식 : S=(V^2)/(2*a)
		pList->insertBack(pItem);
    }
    else//if(nCount==0)
    {
        //2 1) 중복 명령 확인
        pItem = pList->referBack();
        if(pItem->nCount==DrivingInfo.nCount)
        {
        //2 중복된 명령이면 Skip (Target까지의 거리 확인)
            if(pItem->dDistSumToTarget==(TargetInfo.dDistSumToNode + TargetInfo.dOffset))
            {

			}
		//2 Target Station 거리가 가까워진 경우 에러 처리 부호 반대
			else if(pItem->dDistSumToTarget < (TargetInfo.dDistSumToNode + TargetInfo.dOffset))
			{
				bSuccess = false;
			}
		//2 Target Station 거리가 Next Node를 넘어간 경우 에러 처리  부호 반대
            else if(pItem->dDistSumToTarget < (TargetInfo.dDistSumToNode + TargetInfo.dLength))
            {
                bSuccess = false;
            }
        //2 Target Station 정보가 변경된 경우
            else
            {
                // 시작 Node 정보 입력
                pItem->dSpeed = DrivingInfo.dSpeed;
                pItem->dDistSumToFinalNode = DrivingInfo.dDistSumToEndNode;
                pItem->nCount = DrivingInfo.nCount;
                pItem->MarkType = TargetInfo.Type;
                pItem->dDistSumToTarget = TargetInfo.dDistSumToNode + TargetInfo.dOffset;
                pItem->dDecelDist = (pItem->dSpeed*pItem->dSpeed)/(2*dDecel);   // 감속 거리 구하는 식 : S=(V^2)/(2*a)
                pList->insertBack(pItem);
            }
        }
        //2 2) 중복이 아닐 경우
        else//if(pItem->ID==DrivingInfo->EndNID)
        {
        //2 속도가 같을 경우
            if(pItem->dSpeed==DrivingInfo.dSpeed)
            {
                pItem->dSpeed = DrivingInfo.dSpeed;
                pItem->dDistSumToFinalNode = DrivingInfo.dDistSumToEndNode;
                pItem->nCount = DrivingInfo.nCount;
                pItem->MarkType = TargetInfo.Type;
                pItem->dDistSumToTarget = TargetInfo.dDistSumToNode + TargetInfo.dOffset;
                pItem->dDecelDist = (pItem->dSpeed*pItem->dSpeed)/(2*dDecel);   // 감속 거리 구하는 식 : S=(V^2)/(2*a)
            }
        //2 속도가 다른 경우
            else
            {
                // 이전 명령 의 Type을 Node로 변경
                pItem->MarkType = MARK_TYPE_NODE;
                pItem->dDistSumToTarget = pItem->dDistSumToFinalNode;
                pItem->dDecelDist = (pItem->dSpeed*pItem->dSpeed)/(2*dDecel);   // 감속 거리 구하는 식 : S=(V^2)/(2*a)

                // 새 명령 정보 추가
                pItem = NULL;
                pItem = new DRIVING_CMD_INFO_OF_SPEED();
                pItem->dSpeed = DrivingInfo.dSpeed;
                pItem->dDistSumToFinalNode = DrivingInfo.dDistSumToEndNode;
                pItem->nCount = DrivingInfo.nCount;
                pItem->MarkType = TargetInfo.Type;
                pItem->dDistSumToTarget = TargetInfo.dDistSumToNode + TargetInfo.dOffset;
                pItem->dDecelDist = (pItem->dSpeed*pItem->dSpeed)/(2*dDecel);   // 감속 거리 구하는 식 : S=(V^2)/(2*a)
                pList->insertBack(pItem);
            }
        }//else of if(pItem->ID==DrivingInfo->EndNID)
    }//else of if(nCount==0)

    return bSuccess;
}
/**
@brief   명령으로 부터 Path Info List 정보를 만들어 냄
@author  ehoto
@date    2013.7.19
@param pList: 정보를 저장하는 List의 포인터
@param pDrivingInfo: 명령 정보의 포인터
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
bool DrivingControl::makeBackList(List<DRIVING_CMD_INFO_OF_PATH*> *pList, DRIVING_CMD_INFO_OF_PATH DrivingInfo)
{
    bool bSuccess = true;
    DRIVING_CMD_INFO_OF_PATH* pItem = NULL;

    int nCount = pList->getCount();

    if(nCount==0)
    {
		// 시작 Path 정보 입력
        pItem = NULL;
		pItem = new DRIVING_CMD_INFO_OF_PATH();
		*pItem = DrivingInfo;

		pList->insertBack(pItem);
	}
	else//if(nCount==0)
	{
		//2 1) 중복 명령 확인
		pItem = pList->referBack();
		if(pItem->EndNID==DrivingInfo.EndNID)
		{
		//2 마지막 Node는 같으나 이전 노드가 다른 경우
			if(pItem->StartNID!=DrivingInfo.StartNID)
			{
				bSuccess = false;
//              ERR_LOG("DrivingControl::makeList: 마지막 Node는 같으나 이전 노드가 다른 경우 [Curr(%X)!=StartNID%X]", pItem->ID, DrivingInfo.StartNID);
			}
		//2 중복된 명령이면 Skip
			else//if(nCount>1)
			{
				// skip
			}//else of if(nCount>1)
		}
		//2 2) 중복이 아닐 경우
		else//if(pItem->ID==DrivingInfo->EndNID)
		{
		//2 비연속 명령 확인
			if(pItem->StartNID!=DrivingInfo.EndNID)
			{
				bSuccess = false;
//              ERR_LOG("DrivingControl::makeList: 비연속 명령 [Curr(%X)!=StartNID%X]", pItem->ID, DrivingInfo.StartNID);
			}
		//2 정상 명령 (연속 명령 경우)
			else//if(pItem->ID!=DrivingInfo->StartNID)
			{
				pItem = NULL;
				pItem = new DRIVING_CMD_INFO_OF_PATH();
				*pItem = DrivingInfo;

				pList->insertBack(pItem);
			}//else of if(pItem->ID!=DrivingInfo->StartNID)

		}//else of if(pItem->ID==DrivingInfo->EndNID)
	}//else of if(nCount==0)

	return bSuccess;
}




/**
@brief   위치 정보 확인 및 지나간 Classified List 정리
@author  임태웅
@date    2013.08.05
@param HwInfo 입력되는 HW 정보
@param pInfoSet 변경되는 상태 정보
@return 에러 없으면 0반환, 있으면 에러 코드 반환
*/
UINT DrivingControl::checkPosition(DRIVING_HW_INFO_SET HwInfo, DRIVING_INFO_SET *pInfoSet)
{

	//거리값 확인용
	static int nPrenodeInfo = 0;
  //	static double m_dPreNodecountPosition = 0.0;

    UINT nTmpError = NO_ERR;
    double dNodeDistOffset = 0.0;

//	//김태균 20151216
	int tmpCurrenrtNodeID = (int)m_PositionInfo.CurrNode;
//	int tmpCurrenrtNextID = 0;
//	int tmpCurrentCMDID = 0;

	double dSpeedDownPos    = pInfoSet->Position.CmdRefInfo.dSpeedDownPos;//getSpeedDownPos();

	int nDetectStatus = pHWSet->m_pOHTDetect->GetStatus(); //DETECT_AND_STOP

	DRIVING_CMD_INFO_OF_NODE* pPreNodeInfo = getNodeInfo(HwInfo.Node.nPreCheckCount);
	DRIVING_CMD_INFO_OF_PATH* pPrePathInfo = getPathInfo(HwInfo.Node.nPreCheckCount);
	DRIVING_CMD_INFO_OF_NODE* pNodeInfo = getNodeInfo(HwInfo.Node.nNodeCount);
	DRIVING_CMD_INFO_OF_PATH* pPathInfo = getPathInfo(HwInfo.Node.nNodeCount);

	PATH_DIVERGENCE_INFO NodeDivInfo = NULL;
	PATH_DIVERGENCE_INFO NextDivInfo = NULL;


	DRIVING_INFO_SET PreInfoSet = *pInfoSet;

	bool    bSteerFrontRight    = HwInfo.IO.SteerFrontRightInOn;
	bool    bSteerRearRight 	= HwInfo.IO.SteerRearRightInOn;

	if(pNodeInfo==NULL)
    {
        ADD_LOG("Cnt:%d/%d, ListCnt:%d"
            , HwInfo.Node.nNodeCount
            , pInfoSet->HwInfo.Node.nNodeCount
            , m_ClassifiedCmd.NodeList.getCount())
		ADD_FDC_LOG("ERR/%d/1/5/%06d/%06d/%d/%d/%06d",
					ERR_NOTFIND_NODE,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pExecuteInfo->ExecutePositionInfo.NextNode,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					m_pOHTMainStatus->StatusCommon.ExistFoup,
					m_pOHTMainStatus->StatusCommon.StopStationID);
        return ERR_NOTFIND_NODE;// 에러 처리 : 명령에 없는 노드 Count 실시
	}

    if( (m_PreviousArrivalInfo.Info.MarkType==MARK_TYPE_NODE)
    &&  (HwInfo.Node.nNodeCount==0)
    )
    {
		dNodeDistOffset = m_pParamSet->Mark[0].Dist.dAddDistAfterSecondMet;
    }

	//FirtNode에서 강제로 노드카운트 1개 Up 거리값 확인.(타겟노드가 바로 앞이 아닐 경우)
	if(m_bIsFirstNodeCountAdd ==false)
	{
		if((HwInfo.Node.nNodeCount==0)
		&& (HwInfo.IO.NodeOn ==ON)
		&& (HwInfo.Axis1.dCurrPos <100.0)//40.0)
		)
		{

			if((pNodeInfo->ID  != m_ClassifiedCmd.TargetInfo.Node)
			&&(pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.MarkType !=MARK_TYPE_NODE)
//			&& (m_PreviousArrivalInfo.Info.MarkType!=MARK_TYPE_NODE)
			&& (pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset > 300.0))
			{
				ADD_LOG("SetFirstNodeCountAdd:%d/%d MarkType:%d: Offset:%f",pNodeInfo->ID,m_ClassifiedCmd.TargetInfo.Node,pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.MarkType,pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset);
				m_pDrivingAxis->SetFirstNodeCountAdd();
				m_bIsFirstNodeCountAdd = true;
			}
		}
	}
    //1 HW
	pInfoSet->HwInfo = HwInfo;



//  if((pInfoSet->HwInfo.IO.ObsStatus!=DETECT_NONE)||(pInfoSet->HwInfo.IO.DetectStatus!=DETECT_NONE))
//  {
//      ADD_LOG("[checkPosition] OBS:%d, Detect:%d"
//          , pInfoSet->HwInfo.IO.ObsStatus
//          , pInfoSet->HwInfo.IO.DetectStatus);
//  }
    //1 Position
    //2 TargetPosition
    pInfoSet->Position.CurrentAndTarget.TargetPosition.MarkType     = m_ClassifiedCmd.TargetInfo.Type;
    pInfoSet->Position.CurrentAndTarget.TargetPosition.uNode        = m_ClassifiedCmd.TargetInfo.Node;
    pInfoSet->Position.CurrentAndTarget.TargetPosition.uNextNode    = m_ClassifiedCmd.TargetInfo.NextNode;
    pInfoSet->Position.CurrentAndTarget.TargetPosition.uStation     = m_ClassifiedCmd.TargetInfo.Station;
    pInfoSet->Position.CurrentAndTarget.TargetPosition.dOffset      = m_ClassifiedCmd.TargetInfo.dOffset;

	//AOHC-196 사전 로그 추가
	m_DiagManager->IncreasePreviosDiagMax(PREVIOS_DIAG_FOLOWF_MAX, abs(m_pDrivingAxis->GetFollowing_Axis1()));
	//ADD_LOG("<<Compensation>>FollowErr : %6..1lf  (%d)",HwInfo.Axis1.dFollowError,(DWORD)HwInfo.Axis1.dFollowError);
	//2 Compensation
	if(((m_bFirstNodeStep == true) && (HwInfo.Node.dNodePosition > 100.0)) || (m_bFirstNodeStep == false) || (HwInfo.Axis1.dCurrPos > 200.0))
	{
		if(m_bFirstNodeStep == true) m_bFirstNodeStep = false;     // FirstNodeStop과 타이밍 이슈 제거로 인해 추가 puting

		if((HwInfo.Node.nNodeCount!=m_dPreNodecount) && (m_dPreNodecountPosition != HwInfo.Node.dNodePosition))
		{

			getFrontObservationNodeCount(HwInfo.Node.nNodeCount);

			m_RunOffsetDistance = 0.0;
			pInfoSet->Position.Compensation.dDistErrorSum       = HwInfo.Node.dNodePosition - pNodeInfo->dDistSum
																+ m_InfoSet.Position.Compensation.dPreArriveOffset;
			pInfoSet->Position.Compensation.dLinkDistError      = pInfoSet->Position.Compensation.dDistErrorSum
																- PreInfoSet.Position.Compensation.dDistErrorSum;
			//pInfoSet->Position.Compensation.dPreArriveOffset = // 처음 명령 인가 시 설정
			pInfoSet->Position.Compensation.dWearRatio          = 1.0
																+ pInfoSet->Position.Compensation.dDistErrorSum/pNodeInfo->dDistSum;



			try{
				if(HwInfo.Node.nNodeCount > 1)
				{
					DRIVING_CMD_INFO_OF_PATH* pTestPathInfo = getPathInfo(HwInfo.Node.nNodeCount-1);
					if(pTestPathInfo!=NULL)
					{
							ADD_LOG("<<Compensation>>dDistSum:%06f,dPreArriveOffset:%06f dDistErrorSum:%06f, dNodePosition:%06f, dCurrPos%06f,OHTDetcet:%d,OBS:%d<<Debug>>%d/%d(%06f/%06f)/%06f/%06f",
							pNodeInfo->dDistSum,
							pInfoSet->Position.Compensation.dPreArriveOffset,
							pInfoSet->Position.Compensation.dDistErrorSum,
							HwInfo.Node.dNodePosition, HwInfo.Axis1.dCurrPos,
							m_Dectect_Dir,m_Dectect_OBS_Dir ,nPrenodeInfo,
							pNodeInfo->ID,m_dPreNodecountPosition, HwInfo.Node.dNodePosition,
							pTestPathInfo->dLength,(HwInfo.Node.dNodePosition-m_dPreNodecountPosition));

							//AOHC-253 모니터링 로그 주행 오차 발생 로깅
							if((HwInfo.Node.dNodePosition-m_dPreNodecountPosition)- pTestPathInfo->dLength  < -100.0) //너무 일찍 나타나거나
							{
								 m_DiagManager->IncreasePreviosDiagCount(PREVIOS_DIAG_MAP_DGAP);   //사전로그
								 ADD_MD_LOG("MAP_DGAP_EARLY N:%d~%d, Diff:%5.1lf, MapDist: %5.1lf , RealDist : %5.1lf, PreSpeed:%5.1lf, CurSpeed:%5.1lf",    nPrenodeInfo,pNodeInfo->ID,((HwInfo.Node.dNodePosition-m_dPreNodecountPosition)- pTestPathInfo->dLength),pTestPathInfo->dLength,(HwInfo.Node.dNodePosition-m_dPreNodecountPosition),m_dPreNodecountSpeed,pPathInfo->dSpeed);
							}
							else if((HwInfo.Node.dNodePosition-m_dPreNodecountPosition) - pTestPathInfo->dLength > 100.0)//너무 일찍 나타나거나
							{
								m_DiagManager->IncreasePreviosDiagCount(PREVIOS_DIAG_MAP_DGAP);   //사전로그
								ADD_MD_LOG("MAP_DGAP_LATE N:%d~%d, Diff:%5.1lf, MapDist: %5.1lf , RealDist : %5.1lf, PreSpeed:%5.1lf, CurSpeed:%5.1lf",    nPrenodeInfo,pNodeInfo->ID,(pTestPathInfo->dLength - (HwInfo.Node.dNodePosition-m_dPreNodecountPosition)),pTestPathInfo->dLength,(HwInfo.Node.dNodePosition-m_dPreNodecountPosition),m_dPreNodecountSpeed,pPathInfo->dSpeed);
							}

							SEND_WARN("MCC/12/1/6/%06d/%06d/%d/%d/%06d/%06f",
										m_pOHTMainStatus->StatusCommon.CurNodeID,
										m_pExecuteInfo->ExecutePositionInfo.NextNode,
										m_pOHTMainStatus->StatusCommon.CurNodeOffset,
										m_pOHTMainStatus->StatusCommon.ExistFoup,
										m_pOHTMainStatus->StatusCommon.StopStationID,
										pInfoSet->Position.Compensation.dLinkDistError);
					}
				}
				else
				{
					ADD_LOG("<<Compensation>>dDistSum:%06f,dPreArriveOffset:%06f dDistErrorSum:%06f, dNodePosition:%06f, dCurrPos%06f,OHTDetcet:%d,OBS:%d",
					pNodeInfo->dDistSum,
					pInfoSet->Position.Compensation.dPreArriveOffset,
					pInfoSet->Position.Compensation.dDistErrorSum,
					HwInfo.Node.dNodePosition, HwInfo.Axis1.dCurrPos,
					m_Dectect_Dir,m_Dectect_OBS_Dir);

					SEND_WARN("MCC/12/1/6/%06d/%06d/%d/%d/%06d/%06f",
								m_pOHTMainStatus->StatusCommon.CurNodeID,
								m_pExecuteInfo->ExecutePositionInfo.NextNode,
								m_pOHTMainStatus->StatusCommon.CurNodeOffset,
								m_pOHTMainStatus->StatusCommon.ExistFoup,
								m_pOHTMainStatus->StatusCommon.StopStationID,
								pInfoSet->Position.Compensation.dLinkDistError);
				}



			}catch(...)
			{

			}

			nPrenodeInfo = pNodeInfo->ID;
			m_dPreNodecountPosition  = HwInfo.Node.dNodePosition;
			m_dPreNodecountSpeed =HwInfo.Axis1.dSpeed;
			m_dPreNodecount = HwInfo.Node.nNodeCount;
		}
	}

	//3 PreCheck Sensor 난반사에 의한 에러 처리 추가.(일반 주행시만 확인)
	//if((HwInfo.Node.nPreCheckCount!=PreInfoSet.HwInfo.Node.nPreCheckCount) && (m_dPrePrecheckNodecountPosition != HwInfo.Node.dPreCheckPosition))
   if(m_dPrePrecheckNodecountPosition != HwInfo.Node.dPreCheckPosition)
	{
		try{
			if((HwInfo.Node.nPreCheckCount > 2) &&(HwInfo.Node.nPreCheckCount!=PreInfoSet.HwInfo.Node.nPreCheckCount))
			{
				DRIVING_CMD_INFO_OF_PATH* pTest2PathInfo = getPathInfo(HwInfo.Node.nPreCheckCount-1);
				if(pTest2PathInfo!=NULL)
				{
					ADD_LOG("<PreCheck>(%06f/%06f)/%06f/%06f"
					,m_dPrePrecheckNodecountPosition, HwInfo.Node.dPreCheckPosition, pTest2PathInfo->dLength,(HwInfo.Node.dPreCheckPosition-m_dPrePrecheckNodecountPosition));

                	m_dCheckPrecheckNodecountPosition =  pTest2PathInfo->dLength - (HwInfo.Node.dPreCheckPosition-m_dPrePrecheckNodecountPosition);
				}
			}
		}catch(...)
		{

        }

		m_dPrePrecheckNodecountPosition  = HwInfo.Node.dPreCheckPosition;
	}


	pInfoSet->Position.Compensation.dCompensatedPosition    = HwInfo.Axis1.dCurrPos
															- pInfoSet->Position.Compensation.dDistErrorSum;
//															- pInfoSet->Position.Compensation.dPreArriveOffset;


	//2 CurrPositionStatus
    //pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.bMarked; // Mark 마무리서 처리
    //pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.uRealArrivedNode = // Mark 마무리서 처리
    //pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.MarkType = // Mark 마무리서 처리
    pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.uNode       = pNodeInfo->ID;
    pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.uNextNode   = (pPathInfo!=NULL)?pPathInfo->EndNID:0;
    //pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.uStation = // Mark 마무리서 처리
	pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset     = pInfoSet->Position.Compensation.dCompensatedPosition
																			- pNodeInfo->dDistSum + dNodeDistOffset
																			+ pInfoSet->Position.Compensation.dPreArriveOffset;

//	m_RunOffsetDistance = dNodeDistOffset - pNodeInfo->dDistSum - pInfoSet->Position.Compensation.dDistErrorSum + HwInfo.Node.dNodePosition; //ㅋㅋㅋㅋ

//
//	ADD_LOG("<<Compensation>>dCompensatedPosition:%06f,dOffset:%06f",
//			pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset,
//			pInfoSet->Position.Compensation.dCompensatedPosition);


    //pInfoSet->Position.Mark.dFrontPosition = // Mark 마무리서 처리
    //pInfoSet->Position.Mark.dRearPosition = // Mark 마무리서 처리
    //pInfoSet->Position.Mark.PositionStatus = // Mark 마무리서 처리

    //pInfoSet->Position.CmdRefInfo.dCmdSpeed = // 명령 인가 시점 설정
    //pInfoSet->Position.CmdRefInfo.dRefSpeed = // 명령 인가 시점 설정
    //pInfoSet->Position.CmdRefInfo.nCount = // 명령 인가 시점 설정
    //pInfoSet->Position.CmdRefInfo.dDist = // 명령 인가 시점 설정
    //pInfoSet->Position.CmdRefInfo.dSpeedDownPos = // 명령 인가 시점 설정


    //1 임시
    if(m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uStation!=0)
    {
        if( (PreInfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode!=pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.uNode)
        ||  (pInfoSet->HwInfo.Node.nNodeCount>0)
        ||  (pInfoSet->HwInfo.Node.nPreCheckCount>0)
        )
        {
            if(m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uStation!=0)
            {
                m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uStation = 0;
            }
        }
    }

	//2 Steer
    // Steer
    //pInfoSet->Steer.PathSteer = (pPathInfo!=NULL)?pPathInfo->Steering:0;
    //pInfoSet->Steer.PathDirection = (pPathInfo!=NULL)?pPathInfo->Direction:0;
    //pInfoSet->Steer.FrontPosition = getSteerPosition(HwInfo.IO.SteerFrontLeftInOn, HwInfo.IO.SteerFrontRightInOn);
    //pInfoSet->Steer.FrontCmdDirection = // 명령 인가 시점 설정
    //pInfoSet->Steer.FrontMoving = // 명령 인가 시점 설정
    //pInfoSet->Steer.RearPosition = getSteerPosition(HwInfo.IO.SteerRearLeftInOn, HwInfo.IO.SteerRearLeftInOn);
    //pInfoSet->Steer.RearCmdDirection = // 명령 인가 시점 설정
    //pInfoSet->Steer.RearMoving = // 명령 인가 시점 설정

    //2 Time
    //pInfoSet->Time.Steer.SteeringChangeCmded.bFlag = // 명령 인가 시점 설정
    //pInfoSet->Time.Steer.SteeringChangeCmded.dwTime = // 명령 인가 시점 설정
    //pInfoSet->Time.Steer.SteeringNotMatch.bFlag = // 에러 확인 시점 설정
    //pInfoSet->Time.Steer.SteeringNotMatch.dwTime = // 에러 확인 시점 설정
    //
    //pInfoSet->Time.Steer.FrontSteeringArrived.bFlag =
    //pInfoSet->Time.Steer.FrontSteeringArrived.dwTime =
    //
    //pInfoSet->Time.Steer.RearSteeringArrived.bFlag =
    //pInfoSet->Time.Steer.RearSteeringArrived.dwTime =
    //
    //pInfoSet->Time.Steer.FrontSteeringDeparted.bFlag =
    //pInfoSet->Time.Steer.FrontSteeringDeparted.dwTime =
    //
    //pInfoSet->Time.Steer.RearSteeringDeparted.bFlag =
    //pInfoSet->Time.Steer.RearSteeringDeparted.dwTime =


    //pInfoSet->Time.FrontObserve.OHTDetectFail.bFlag =
    //pInfoSet->Time.FrontObserve.OHTDetectFail.dwTime =
    //pInfoSet->Time.FrontObserve.OBSDetectFail.bFlag =
    //pInfoSet->Time.FrontObserve.OBSDetectFail.dwTime =
    //pInfoSet->Time.FrontObserve.OBSDetect.bFlag =
    //pInfoSet->Time.FrontObserve.OBSDetect.dwTime =

    //pInfoSet->Time.Stop.OnAbnormalStop.bFlag =
    //pInfoSet->Time.Stop.OnAbnormalStop.dwTime =

    //2 Events & States
    // Event

	pInfoSet->EventAndState.Event.CmdAdded = ((memcmp(&(PreInfoSet.Position.CurrentAndTarget.TargetPosition)
                                                , &(pInfoSet->Position.CurrentAndTarget.TargetPosition)
												, sizeof(POSITION_INFO)))==0)   ?false:true;

//	pInfoSet->EventAndState.Event.TargetChanged = pInfoSet->EventAndState.Event.CmdAdded;
	pInfoSet->EventAndState.Event.PreCheck = (PreInfoSet.HwInfo.Node.nPreCheckCount<pInfoSet->HwInfo.Node.nPreCheckCount)?true:false;
	pInfoSet->EventAndState.Event.Check = (PreInfoSet.HwInfo.Node.nNodeCount<pInfoSet->HwInfo.Node.nNodeCount)?true:false;
	pInfoSet->EventAndState.Event.SpeedDownPassed = (   (pInfoSet->HwInfo.Axis1.dCurrPos>=pInfoSet->Position.CmdRefInfo.dSpeedDownPos)
//                                                  &&  (PreInfoSet.HwInfo.Axis1.dCurrPos<pInfoSet->Position.CmdRefInfo.dSpeedDownPos))
													&& (PreInfoSet.EventAndState.State.SpeedDownPassed==false))
													?true:false;

	//pInfoSet->EventAndState.Event.FrontSteerMoved
	//pInfoSet->EventAndState.Event.RearSteerMoved
	//pInfoSet->EventAndState.Event.FrontSteerCompleted
	//pInfoSet->EventAndState.Event.AllCompleted
	//pInfoSet->EventAndState.Event.PushedByGuide
	//pInfoSet->EventAndState.Event.StopWithNoReason
	//pInfoSet->EventAndState.Event.DistNotMatch

	pInfoSet->EventAndState.Event.MarkCmd = (   (isMarkArea()==true)
												&& (pInfoSet->EventAndState.State.MarkArea==false))
												?true:false;

	//State
	pInfoSet->EventAndState.State.NodePreChecked = (pInfoSet->HwInfo.Node.nNodeCount<pInfoSet->HwInfo.Node.nPreCheckCount)?true:false;
	//pInfoSet->EventAndState.State.OutInNodeDiffSteer  // Axis 명령 시
	//pInfoSet->EventAndState.State.SteerMoving
	//pInfoSet->EventAndState.State.SteerFrontCompleted
	//pInfoSet->EventAndState.State.SteerAllCompleted
	//pInfoSet->EventAndState.State.SteerChangeAreaByGuide
	//pInfoSet->EventAndState.State.StopByFrontDetect
	//pInfoSet->EventAndState.State.SpeedDownByFrontDetect
	pInfoSet->EventAndState.State.SpeedDownPassed   = (pInfoSet->HwInfo.Axis1.dCurrPos>=pInfoSet->Position.CmdRefInfo.dSpeedDownPos)
													?true:false;
	pInfoSet->EventAndState.State.MarkArea = (pInfoSet->EventAndState.State.MarkArea==true)?true:isMarkArea();
//	EnterCriticalSection(&OHTMainForm->m_CS);
	m_pExecuteInfo->dCompensatedPosition   = HwInfo.Axis1.dCurrPos
											- pInfoSet->Position.Compensation.dDistErrorSum;


	m_pExecuteInfo->FlagInitPositon.dDrivingInitPosition = pNodeInfo->dDistSum
														   - m_InfoSet.Position.Compensation.dPreArriveOffset;
	if(m_pExecuteInfo->FlagInitPositon.dDrivingInitPosition <0.0 )
		m_pExecuteInfo->FlagInitPositon.dDrivingInitPosition = 0.0;



	try
	{                                 //11(114node) , 현재 분기정보, 다음분기정보
		int TempNodeCount = 0;
		if(getDivergenceInfo(HwInfo.Node.nNodeCount, &NodeDivInfo, &NextDivInfo,&TempNodeCount)==true)
		{
			m_pExecuteInfo->nCheckDivInfo  =   NodeDivInfo;  //분기 정보 갱신
			cRunNextDivInfo = NextDivInfo;

			DRIVING_CMD_INFO_OF_NODE* pTempNodeInfo = getNodeInfo(TempNodeCount);
			if(pNodeInfo != NULL) nRunNextNodeID = pTempNodeInfo->ID;
//			ADD_LOG("=======NodeID %d NodeDivInfo : %d NextDivInfo:%d",pNodeInfo->ID,NodeDivInfo,NextDivInfo);
		}

//		DRIVING_CMD_INFO_OF_NODE* pNextNodeInfo = getNodeInfo(HwInfo.Node.nNodeCount+1);
//		if(pNextNodeInfo != NULL)
//		{
//			nRunNextNodeID = pNextNodeInfo->ID;
//		}

	}catch(...)
	{
		ADD_LOG("<<Exception7777>>");

	}

	m_pExecuteInfo->bSpeedDownFlag =  (pInfoSet->HwInfo.Axis1.dCurrPos>=pInfoSet->Position.CmdRefInfo.dSpeedDownPos)
									   ?true:false;

	m_pExecuteInfo->FlagRunningPositon =true;
//	LeaveCriticalSection(&OHTMainForm->m_CS);



	try
	{
		AnsiString strLogTmp;

		// 리프터 IN앞의 노드 (Pre Node) 이면서, 진입허가가 떨어지지 않은 경우
		// Status Machine 실행



		if(((pNodeInfo->NodeType == LIFTPRE_NTYPE_RIGHT) || (pNodeInfo->NodeType == LIFTPRE_NTYPE_LEFT)))
		{
			// strLogTmp.sprintf("[LIFTER-PRE] ==> PRE NODE!!  node id : %d",tmpCurrenrtNodeID);
			// ADD_CID_LOG(strLogTmp);
//			ADD_LOG("[LIFTER-PRE] ==> execute pre! %d %d %d",pNodeInfo->NodeType, m_IsLifterCheck, m_iLifterPrePass);

			if((m_iLifterPrePass != VHL_ELEVETOR_PREPASS_STEP_COMPLETE) && (m_IsLifterCheck == true))
			{
				// ADD_CID_LOG("[LIFTER-PRE] ==> execute pre!");
				executePreEvevetor(pNodeInfo->NodeType);
			}
			else
			{
				// ADD_CID_LOG("[LIFTER-PRE] ==> execute NONE!");
			}
		}
		//MTL 연동
		else if((pNodeInfo->NodeType == MTL_SEL_ON_LEFT) || (pNodeInfo->NodeType == MTL_SEL_ON_RIGHT))
//		&& (m_IsMTLCheck == true))
		{
        	if(m_iLifterPrePass != VHL_ELEVETOR_PREPASS_STEP_COMPLETE)
			{
//				ADD_LOG("[LIFTER-PRE] ==> execute pre! %d",pNodeInfo->NodeType);
				executePreEvevetor(pNodeInfo->NodeType);
			}
			else
			{
				// ADD_CID_LOG("[LIFTER-PRE] ==> execute NONE!");
			}
        }
	}
	catch(...)
	{
		ADD_LOG("[LIFTER-PRE] CheckPosition - Exception!!!!");
	}

	// ============================================================================

	//1 현재 위치 이전 명령 처리
	if(pInfoSet->HwInfo.Node.nNodeCount!=PreInfoSet.HwInfo.Node.nNodeCount)
	{
		clearCmdInfoListsLessThan(pInfoSet->HwInfo.Node.nNodeCount);
	}

	if(nTmpError == NO_ERR)  nTmpError = checkJobChange(pInfoSet);


	if((m_mccparam.nPreCount + 1) == HwInfo.Node.nPreCheckCount)
	{
		ADD_MCC_LOG(",%s,DRV,NODE DETECT PRE,-,FOUP,%06d,%06d,%06d,%d,%6.1lf",
					m_defualtparam->VHLName,
					m_mccparam.uSourceNode,
					m_mccparam.uTargetNode,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					HwInfo.Axis1.dSpeed);
	}

	if((m_mccparam.nNodeCount + 1) == HwInfo.Node.nNodeCount)
	{
		ADD_MCC_LOG(",%s,DRV,NODE DETECT,-,FOUP,%06d,%06d,%06d,%d,%6.1lf,DistSum,%6.1lf,PreCheckCount,%d,NodeCount,%d,Compensation,%6.1lf,Steer Front,%d,Steer Rear,%d,Front Rear Position Difference,%6.1lf",
					m_defualtparam->VHLName,
					m_mccparam.uSourceNode,
					m_mccparam.uTargetNode,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					HwInfo.Axis1.dSpeed,
					pNodeInfo->dDistSum,HwInfo.Node.nPreCheckCount,HwInfo.Node.nNodeCount,
					pInfoSet->Position.Compensation.dLinkDistError,bSteerFrontRight + 1,bSteerRearRight + 1,
					HwInfo.Axis1.dCurrPos - HwInfo.Axis2.dCurrPos);
	}

	m_mccparam.nPreCount = HwInfo.Node.nPreCheckCount;
	m_mccparam.nNodeCount = HwInfo.Node.nNodeCount;

	return nTmpError;

}

/**
@brief   위치 정보 확인 및 지나간 Classified List 정리
@author  임태웅
@date    2013.08.05
@param HwInfo 입력되는 HW 정보
@param pInfoSet 변경되는 상태 정보
@return 에러 없으면 0반환, 있으면 에러 코드 반환
*/
UINT DrivingControl::checkBackPosition(DRIVING_HW_INFO_SET HwInfo, DRIVING_INFO_SET *pInfoSet)
{

    UINT nTmpError = NO_ERR;
    double dNodeDistOffset = 0.0;

	double dSpeedDownPos    = pInfoSet->Position.CmdRefInfo.dSpeedDownPos;//getSpeedDownPos();

	int nDetectStatus = pHWSet->m_pOHTDetect->GetStatus(); //DETECT_AND_STOP

	DRIVING_CMD_INFO_OF_NODE* pNodeInfo = getNodeInfo(HwInfo.Node.nNodeCount);
	DRIVING_CMD_INFO_OF_PATH* pPathInfo = getPathInfo(HwInfo.Node.nNodeCount);

	PATH_DIVERGENCE_INFO NodeDivInfo = NULL;
	PATH_DIVERGENCE_INFO NextDivInfo = NULL;


	DRIVING_INFO_SET PreInfoSet = *pInfoSet;

	if(pNodeInfo==NULL)
	{

		ADD_LOG("Cnt:%d/%d, ListCnt:%d"
			, HwInfo.Node.nNodeCount
			, pInfoSet->HwInfo.Node.nNodeCount
			, m_ClassifiedCmd.NodeList.getCount())
		ADD_FDC_LOG("ERR/%d/2/5/%06d/%06d/%d/%d/%06d",
				ERR_NOTFIND_NODE,
				m_pOHTMainStatus->StatusCommon.CurNodeID,
				m_pExecuteInfo->ExecutePositionInfo.NextNode,
				m_pOHTMainStatus->StatusCommon.CurNodeOffset,
				m_pOHTMainStatus->StatusCommon.ExistFoup,
				m_pOHTMainStatus->StatusCommon.StopStationID);
        return ERR_NOTFIND_NODE;// 에러 처리 : 명령에 없는 노드 Count 실시
	}

    if( (m_PreviousArrivalInfo.Info.MarkType==MARK_TYPE_NODE)
    &&  (HwInfo.Node.nNodeCount==0)
	)
    {
        dNodeDistOffset = m_pParamSet->Mark[0].Dist.dAddDistAfterSecondMet;
    }


	//1 HW
	pInfoSet->HwInfo = HwInfo;

//	ADD_LOG("<<checkBackPosition>>:%d, %06f", HwInfo.Node.nNodeCount,HwInfo.Axis1.dCurrPos);

    //1 Position
    //2 TargetPosition
	pInfoSet->Position.CurrentAndTarget.TargetPosition.MarkType     = m_ClassifiedCmd.TargetInfo.Type;
    pInfoSet->Position.CurrentAndTarget.TargetPosition.uNode        = m_ClassifiedCmd.TargetInfo.Node;
    pInfoSet->Position.CurrentAndTarget.TargetPosition.uNextNode    = m_ClassifiedCmd.TargetInfo.NextNode;
    pInfoSet->Position.CurrentAndTarget.TargetPosition.uStation     = m_ClassifiedCmd.TargetInfo.Station;
    pInfoSet->Position.CurrentAndTarget.TargetPosition.dOffset      = m_ClassifiedCmd.TargetInfo.dOffset;

	//2 Compensation
	if(HwInfo.Node.dNodePosition!=PreInfoSet.HwInfo.Node.dNodePosition)
	{
		m_RunOffsetDistance = 0.0;
		pInfoSet->Position.Compensation.dDistErrorSum       = 0;
		pInfoSet->Position.Compensation.dLinkDistError      = 0;
        //pInfoSet->Position.Compensation.dPreArriveOffset = // 처음 명령 인가 시 설정
        pInfoSet->Position.Compensation.dWearRatio          = 1.0;

		ADD_LOG("<<Compensation>>dDistSum:%06f,dPreArriveOffset:%06f dDistErrorSum:%06f, dNodePosition:%06f, dCurrPos%06f",
			pNodeInfo->dDistSum,
			pInfoSet->Position.Compensation.dPreArriveOffset,
			pInfoSet->Position.Compensation.dDistErrorSum,
			HwInfo.Node.dNodePosition, HwInfo.Axis1.dCurrPos);

		pInfoSet->EventAndState.Event.CmdAdded==true;

	}

	pInfoSet->Position.Compensation.dCompensatedPosition    = HwInfo.Axis1.dCurrPos
															- pInfoSet->Position.Compensation.dDistErrorSum;
//															- pInfoSet->Position.Compensation.dPreArriveOffset;


	//2 CurrPositionStatus
	if(HwInfo.Node.nBcrId!=0)
	{
		ADD_LOG("<<Compensation>> %d",HwInfo.Node.nBcrId);
		pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.uNode       = HwInfo.Node.nBcrId;
	}
	pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.uNextNode   = 0;
    //pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.uStation = // Mark 마무리서 처리
	pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset     = pInfoSet->Position.Compensation.dCompensatedPosition
																			- HwInfo.Node.dNodePosition;



    //1 임시
    if(m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uStation!=0)
    {
        if( (PreInfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode!=pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.uNode)
        ||  (pInfoSet->HwInfo.Node.nNodeCount>0)
        ||  (pInfoSet->HwInfo.Node.nPreCheckCount>0)
        )
        {
			if(m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uStation!=0)
			{
				m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uStation = 0;
			}
		}
	}


    // Event

	pInfoSet->EventAndState.Event.CmdAdded = ((memcmp(&(PreInfoSet.Position.CurrentAndTarget.TargetPosition)
												, &(pInfoSet->Position.CurrentAndTarget.TargetPosition)
												, sizeof(POSITION_INFO)))==0)   ?false:true;
//	pInfoSet->EventAndState.Event.TargetChanged = pInfoSet->EventAndState.Event.CmdAdded;
//	pInfoSet->EventAndState.Event.Check = (PreInfoSet.HwInfo.Node.nNodeCount<pInfoSet->HwInfo.Node.nNodeCount)?true:false;
//	pInfoSet->EventAndState.Event.SpeedDownPassed = (   (pInfoSet->HwInfo.Axis1.dCurrPos>=pInfoSet->Position.CmdRefInfo.dSpeedDownPos)
////                                                  &&  (PreInfoSet.HwInfo.Axis1.dCurrPos<pInfoSet->Position.CmdRefInfo.dSpeedDownPos))
//													&& (PreInfoSet.EventAndState.State.SpeedDownPassed==false))
//													?true:false;

	pInfoSet->EventAndState.Event.MarkCmd = (   (isMarkArea()==true)
												&& (pInfoSet->EventAndState.State.MarkArea==false))
												?true:false;

	//State
//	pInfoSet->EventAndState.State.SpeedDownPassed   = (pInfoSet->HwInfo.Axis1.dCurrPos>=pInfoSet->Position.CmdRefInfo.dSpeedDownPos)
//													?true:false;
	pInfoSet->EventAndState.State.MarkArea = (pInfoSet->EventAndState.State.MarkArea==true)?true:isMarkArea();
//	EnterCriticalSection(&OHTMainForm->m_CS);
	m_pExecuteInfo->dCompensatedPosition   = HwInfo.Axis1.dCurrPos
											- pInfoSet->Position.Compensation.dDistErrorSum;


	m_pExecuteInfo->FlagInitPositon.dDrivingInitPosition = pNodeInfo->dDistSum
														   - m_InfoSet.Position.Compensation.dPreArriveOffset;


	try
	{
		int TempNodeCount = 0;
		if(getDivergenceInfo(HwInfo.Node.nNodeCount, &NodeDivInfo, &NextDivInfo, &TempNodeCount)==true)
		{
			m_pExecuteInfo->nCheckDivInfo  =   NodeDivInfo;  //분기 정보 갱신
			cRunNextDivInfo = NextDivInfo;

			DRIVING_CMD_INFO_OF_NODE* pTempNodeInfo = getNodeInfo(TempNodeCount);
			if(pNodeInfo != NULL) nRunNextNodeID = pTempNodeInfo->ID;
		}

//		DRIVING_CMD_INFO_OF_NODE* pNextNodeInfo = getNodeInfo(HwInfo.Node.nNodeCount+1);
//		if(pNextNodeInfo != NULL)
//		{
//			nRunNextNodeID = pNextNodeInfo->ID;
//		}

	}catch(...)
	{
		ADD_LOG("<<Exception7777>>");
		ADD_LOG("%x",&pPathInfo->DivInfo);

	}

	m_pExecuteInfo->bSpeedDownFlag =  (pInfoSet->HwInfo.Axis1.dCurrPos>=pInfoSet->Position.CmdRefInfo.dSpeedDownPos)
									   ?true:false;

	m_pExecuteInfo->FlagRunningPositon =true;


	// ============================================================================

	//1 현재 위치 이전 명령 처리
	if(pInfoSet->HwInfo.Node.nNodeCount!=PreInfoSet.HwInfo.Node.nNodeCount)
	{
		clearCmdInfoListsLessThan(pInfoSet->HwInfo.Node.nNodeCount);
	}

	//1 경로변경/삭제 처리 명령 처리
	if(m_pExecuteInfo->FlagPathChange.bPathChange == true)
	{

	m_pExecuteInfo->FlagPathChange.cResult = FAIL;
	m_pExecuteInfo->FlagPathChange.bPathChange =false;



	ADD_LOG("경로 삭제 수행안함.");

	}



	return nTmpError;

}



// CID Select ON
#define CID_SELECT_BEFORE_DELAY	3	// spec 2ms
void DrivingControl::CID_LR_ON(bool LightGuideDirectionIsLeft)
{
	CID_OPERATION_MODE_CID();
	Sleep(CID_SELECT_BEFORE_DELAY);

	if(LightGuideDirectionIsLeft == true) 	// left
		CID_SELECT_DIRECTION_LEFT();
	else
		CID_SELECT_DIRECTION_RIGHT();
}

/*
	CID Information Get Function
	shkim.
	CID 동작에 필요한 정보를 가져온다.
*/
void DrivingControl::getCID_Info(CID_CTRL_INFO* Info, int nCurrentNodeID)
{
	Info->nDetectStatus = m_InfoSet.HwInfo.IO.DetectStatus;

	Info->tmpCurrentNodeID = (int)m_PositionInfo.CurrNode;
	Info->tmpPreNodeID = (int)m_PositionInfo.CurrPreCheckNode;
	Info->tmpNextNodeID = (int)m_PositionInfo.NextNode;
	Info->tmpCurrentCMDID = (int)m_PositionInfo.CurrCommandedNode;
	Info->tmpCurrentStationID = (int)m_PositionInfo.CurrStation;
	Info->uLimitNode = (m_InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType==MARK_TYPE_NODE)
						? m_InfoSet.Position.CurrentAndTarget.TargetPosition.uNode
                        : m_InfoSet.Position.CurrentAndTarget.TargetPosition.uNextNode;
	Info->CMD_StationID = (m_InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType==MARK_TYPE_NODE)
                           ? 0 : m_InfoSet.Position.CurrentAndTarget.TargetPosition.uStation;
	Info->Safety_Level = 0;
	#if 0  //Map 기반
	if(m_InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType==MARK_TYPE_TAG_STATION
		|| m_InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType==MARK_TYPE_QR_STATION_LEFT
		|| m_InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType==MARK_TYPE_QR_STATION_RIGHT)
	{
		STATION_DATA *pSData  =NULL; //Station 정보
		pSData = OHTMainForm->GetStationDataManager()->Find(m_InfoSet.Position.CurrentAndTarget.TargetPosition.uStation);
		//ADD_LOG("111  Info->Safety_Level %d, pSData->Safety_Level %d", Info->Safety_Level, pSData->Safety_Level);
		if (pSData != NULL)
		{
			Info->Safety_Level = pSData->Safety_Level;
			//ADD_LOG("111 2 Info->Safety_Level %d, pSData->Safety_Level %d", Info->Safety_Level, pSData->Safety_Level);
		}
	}
	#else //OCS 기반

	Info->Safety_Level = m_ClassifiedCmd.TargetInfo.StationSafetyLevel;

	if(m_InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType!=MARK_TYPE_NODE)
		Info->bIgnolOverRun = m_ClassifiedCmd.TargetInfo.bIgnolOverRun;
	else
		Info->bIgnolOverRun = false;

	//ADD_LOG("CID m_ClassifiedCmd.TargetInfo.StationSafetyLevel : %d", m_ClassifiedCmd.TargetInfo.StationSafetyLevel);
	#endif
	Info->CIDStopNode1_arr = OHTMainForm->GetMap()->FindNodeIndexFromCIDStop_1(Info->tmpCurrentNodeID);
	Info->CIDStopNode2_arr = OHTMainForm->GetMap()->FindNodeIndexFromCIDStop_2(Info->tmpCurrentNodeID);
	Info->CIDStartNode1_arr = OHTMainForm->GetMap()->FindNodeIndexFromCIDStart_1(Info->tmpCurrentNodeID);
	Info->CIDStartNode2_arr = OHTMainForm->GetMap()->FindNodeIndexFromCIDStart_2(Info->tmpCurrentNodeID);
	Info->CIDResetNode_arr = OHTMainForm->GetMap()->FindNodeIndexFromCIDReset(Info->tmpCurrentNodeID);	
	Info->CIDResetNode_Pre_arr = OHTMainForm->GetMap()->FindNodeIndexFromCIDReset(Info->tmpPreNodeID);
	try{
		if (Info->CIDStopNode1_arr != INDEX_NONE)
		{
		  Info->CIDStopNode1 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStopNode1_arr].StopNode1;
		  Info->CIDResetNode1 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStopNode1_arr].ResetNode;
		  Info->LayoutType_Stop1 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStopNode1_arr].LayoutType;
		}
		if (Info->CIDStopNode2_arr != INDEX_NONE)
		{
		  Info->CIDStopNode2 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStopNode2_arr].StopNode2;
		  Info->CIDResetNode2 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStopNode2_arr].ResetNode;
		  Info->LayoutType_Stop2 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStopNode2_arr].LayoutType;
		}

		if (Info->CIDResetNode_arr != INDEX_NONE)
		{
		  Info->CIDResetNode = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDResetNode_arr].ResetNode;
		  Info->CIDResetNodeType = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDResetNode_arr].ResetNodeType;
		  Info->LayoutType_Reset = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDResetNode_arr].LayoutType;
		}
		//Left
		if (Info->CIDStartNode1_arr != INDEX_NONE)
		{
			Info->tmpStartNode1_1 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStartNode1_arr].CommStartNode1_1;
			Info->tmpStartNode1_2 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStartNode1_arr].CommStartNode1_2;
			Info->tmpStartNode1_3 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStartNode1_arr].CommStartNode1_3;
			Info->tmpStartNode1_4 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStartNode1_arr].CommStartNode1_4;
			Info->tmpStartNode1_5 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStartNode1_arr].CommStartNode1_5;

			Info->tmpStopNode1 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStartNode1_arr].StopNode1;
//			Info->tmpCIDResetNode1 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStartNode1_arr].ResetNode;
//			Info->tmpCIDResetNodeType1 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStartNode1_arr].ResetNodeType;
			Info->tmpResetNode1 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStartNode1_arr].ResetNode;
			Info->tmpResetNodeType1 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStartNode1_arr].ResetNodeType;
			Info->CommStartNode1_Offset = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStartNode1_arr].CommStartNode1_Offset;
		}
		//Right
		if (Info->CIDStartNode2_arr != INDEX_NONE)
		{
			Info->tmpStartNode2_1 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStartNode2_arr].CommStartNode2_1;
			Info->tmpStartNode2_2 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStartNode2_arr].CommStartNode2_2;
			Info->tmpStartNode2_3 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStartNode2_arr].CommStartNode2_3;
			Info->tmpStartNode2_4 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStartNode2_arr].CommStartNode2_4;
			Info->tmpStartNode2_5 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStartNode2_arr].CommStartNode2_5;

			Info->tmpStopNode2 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStartNode2_arr].StopNode2;
//			Info->tmpCIDResetNode2 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStartNode2_arr].ResetNode;
//			Info->tmpCIDResetNodeType2 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStartNode2_arr].ResetNodeType;
			Info->tmpResetNode2 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStartNode2_arr].ResetNode;
			Info->tmpResetNodeType2 = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStartNode2_arr].ResetNodeType;
			Info->CommStartNode2_Offset = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDStartNode2_arr].CommStartNode2_Offset;
		}
		if(Info->CIDResetNode_Pre_arr != INDEX_NONE)
		{
			Info->CIDResetNode_Pre = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDResetNode_Pre_arr].ResetNode;
			Info->CIDResetNodeType_Pre = OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDResetNode_Pre_arr].ResetNodeType;
		}

		// 4분기 처리용 정보
		Info->bLoadUnload 	= CID_4WAY_CONTROL_INFO.bLoadUnload;	// 이적재 유무. true : 이적재 한다. false : 이적재 하지 않음
		Info->tmpLastCMDID 	= CID_4WAY_CONTROL_INFO.tmpLastCMDID;	// 최종 타겟
		Info->NodeDivInfo 	= CID_4WAY_CONTROL_INFO.NodeDivInfo;	// 현재 노드의 분기정보
		Info->NextDivInfo 	= CID_4WAY_CONTROL_INFO.NextDivInfo;	// 다음 노드의 분기정보

   }
   catch(...)
   {
		ADD_LOG("CID Information Exception!!");
   }
}



// CID노드의 Stop Node이거나 지나버렸을 경우의 처리
bool DrivingControl::NormalCid_Return(CID_CTRL_INFO* Info)
{
	unsigned int CIDResetNode_arr = INDEX_NONE;
	int CIDResetNode = 0;
	int CIDResetNodeType = 0;

	//현재 노드가 리셋 노드인데 최초 cid 동작시 리셋노드와 다른경우 현재 노드 기준으로 완료 처리.
	if (Info->CIDResetNode_arr != INDEX_NONE && m_tmpCurrentResetNode != Info->CIDResetNode && Info->CIDResetNodeType != Common_Reset_tag)
	{
		m_tmpCurrentResetNode = Info->CIDResetNode;
		ADD_LOG("[CID] (NORMAL RETURN) ResetNode Changed CIDResetNode : %d, m_tmpCurrentResetNode %d", Info->CIDResetNode, m_tmpCurrentResetNode);
	}
//	ADD_LOG("[CID] Test1 tmpPreNodeID:%d, tmpCurrentNodeID:%d, m_tmpCurrentResetNode:%d", Info->tmpPreNodeID, Info->tmpCurrentNodeID, m_tmpCurrentResetNode);
	CIDResetNode_arr = OHTMainForm->GetMap()->FindNodeIndexFromCIDReset(Info->tmpPreNodeID);
	if (CIDResetNode_arr != INDEX_NONE)
	{
	  CIDResetNode = OHTMainForm->GetCID_STD()->m_NodeArray[CIDResetNode_arr].ResetNode;
	  CIDResetNodeType = OHTMainForm->GetCID_STD()->m_NodeArray[CIDResetNode_arr].ResetNodeType;
	  Info->CIDResetNodeType = CIDResetNodeType;
//	  ADD_LOG("[CID] Test2 tmpPreNodeID:%d, tmpCurrentNodeID:%d, m_tmpCurrentResetNode:%d", Info->tmpPreNodeID, Info->tmpCurrentNodeID, m_tmpCurrentResetNode);
	}
	
	//OHT 링크를 시도하고 있고 현재 내위치가 리셋노드이며 노멀, 경사로 리셋노드이면
//	if((pHWSet->m_pCID->IsLinking() == true)&&((Info->CIDResetNode_arr != INDEX_NONE)
//		&&((Info->CIDResetNodeType == Normal_Reset_tag)
//		||(Info->CIDResetNodeType == Slope_Rear_Reset_tag))))
// CID ResetNode PreChcek 이후 Statino Tag Mark시 PreCheck에서 반납하지 않고 Front만나야 반납
	//ADD_LOG("[CIDTest3]m_tmpCurrentResetNode : %d, m_tmpCurrentResetNode : %d");
	if (pHWSet->m_pCID->IsLinking() == true && (Info->CIDResetNode_arr != INDEX_NONE || CIDResetNode_arr != INDEX_NONE) &&
		//(Info->tmpCurrentNodeID == m_tmpCurrentResetNode) &&
		(Info->tmpPreNodeID == m_tmpCurrentResetNode) &&
	   //	((m_pOHTMainStatus->FinalStationOfPathSearch != 0) ? Info->tmpCurrentNodeID == m_tmpCurrentResetNode : Info->tmpPreNodeID == m_tmpCurrentResetNode) &&
		(Info->CIDResetNodeType == Normal_Reset_tag || Info->CIDResetNodeType == Slope_Rear_Reset_tag))
	{
		pHWSet->m_pCID->Set_CID_Monitor_Cmd(1);	// CID Monitoring ID:124 (OHT -> CID). M Command.

		pHWSet->m_pCID->CID_Occup_compt(1);
		Sleep(20);

		m_CIDMonitoringFlag = true;
		m_CIDComptFlag = true;
		m_bsecond = false;
		m_Igro_CIDStatusPuaseFlag = false;
		m_CIDComptTryFlag = true;

		ADD_LOG("[CID] (NORMAL RETURN) 1 Occup Compt,  CurrenrtNodeID : %d, CurrenrtNextID : %d, CurrentCMDID : %d, CIDStopNode1 : %d, CIDStopNode2 : %d, CIDResetNode : %d, CIDResetNodeType : %d"
		, Info->tmpCurrentNodeID, Info->tmpNextNodeID, Info->tmpCurrentCMDID, Info->CIDStopNode1
		, Info->CIDStopNode2, Info->CIDResetNode, Info->CIDResetNodeType);
		//ADD_LOG("[CIDTest4]m_tmpCurrentResetNode : %d, m_tmpCurrentResetNode : %d");
		IO_INFO_CID();

		return true;
	}
	else
	{
		// ADD_LOG("[CID] (NORMAL RETURN) ELSE");

		static int nTmpCurNodeId115 = 0;
		if(nTmpCurNodeId115 != Info->tmpCurrentNodeID)
		{
			nTmpCurNodeId115 = Info->tmpCurrentNodeID;
			ADD_LOG("[CID] NormalCid_Return() ELSE");
			ADD_LOG("[CID] CIDReset: %d, CIDResetType: %d, m_tmpCurrentResetNode: %d", Info->CIDResetNode, Info->CIDResetNodeType, m_tmpCurrentResetNode);
		}
		return false;
	}
}


// COMMON NODE의 처리
// (Common노드 Tag를 만났을때의 반납처리)
bool DrivingControl::CommonCid_Return(CID_CTRL_INFO* Info, DRIVING_INFO_SET *pInfoSet)
{
	unsigned int CIDResetNode_arr = INDEX_NONE;
	int CIDResetNode = 0;
	int CIDResetNodeType = 0;

	//현재 노드가 리셋 노드인데 최초 cid 동작시 리셋노드와 다른경우 현재 노드 기준으로 완료 처리. 리셋 못하는 경우 이상동작 대비.
	if (Info->CIDResetNode_arr != INDEX_NONE && m_tmpCurrentResetNode != Info->CIDResetNode && Info->CIDResetNodeType != Common_Reset_tag)
	{
		m_tmpCurrentResetNode = Info->CIDResetNode;
		ADD_LOG("[CID] (COMMON RETURN) ResetNode Changed CIDResetNode : %d, m_tmpCurrentResetNode %d", Info->CIDResetNode, m_tmpCurrentResetNode);
	}
	
	CIDResetNode_arr = OHTMainForm->GetMap()->FindNodeIndexFromCIDReset(Info->tmpPreNodeID);
	if (CIDResetNode_arr != INDEX_NONE)
	{
	  CIDResetNode = OHTMainForm->GetCID_STD()->m_NodeArray[CIDResetNode_arr].ResetNode;
	  CIDResetNodeType = OHTMainForm->GetCID_STD()->m_NodeArray[CIDResetNode_arr].ResetNodeType;
	  Info->CIDResetNodeType = CIDResetNodeType;
	}
	
	if(Info->tmpCurrentNodeID == 142)
	ADD_LOG("[CID] Common Bug - FrontMoving : %d RearMoving : %d IsLinking() : %d  m_bsecond : %d CIDResetNode_arr : %d  CIDResetNodeType : %d  m_CIDComptFlag : %d",

			pInfoSet->Steer.FrontMoving, pInfoSet->Steer.RearMoving, pHWSet->m_pCID->IsLinking(),
			m_bsecond, Info->CIDResetNode_arr, Info->CIDResetNodeType, m_CIDComptFlag);

	//조향 변경 중에는 CID 동작을 잠시 멈춤. Front & Rear all false
//	if((pInfoSet->Steer.FrontMoving == false)&&(pInfoSet->Steer.RearMoving == false)&&(pHWSet->m_pCID->IsLinking() == true)
//		&&(m_bsecond==false)&&(Info->CIDResetNode_arr != INDEX_NONE)
//	&&(Info->CIDResetNodeType == Common_Reset_tag)&&(m_CIDComptFlag == false))
//	if ((pHWSet->m_pCID->IsLinking() == true)
//		&&(m_bsecond==false)&&(Info->CIDResetNode_arr != INDEX_NONE)
//		&&(Info->CIDResetNodeType == Common_Reset_tag)&&(m_CIDComptFlag == false))
// CID ResetNode PreChcek 이후 Statino Tag Mark시 PreCheck에서 반납하지 않고 Front만나야 반납
	//ADD_LOG("[CIDTest1]m_tmpCurrentResetNode : %d, m_tmpCurrentResetNode : %d");
	if (pHWSet->m_pCID->IsLinking() == true && (Info->CIDResetNode_arr != INDEX_NONE || CIDResetNode_arr != INDEX_NONE) &&
		//(Info->tmpCurrentNodeID == m_tmpCurrentResetNode) &&
		(((m_pOHTMainStatus->FinalStationOfPathSearch != 0) && (Info->tmpCurrentNodeID == m_tmpCurrentResetNode)) || ((m_pOHTMainStatus->FinalStationOfPathSearch == 0) && (Info->tmpPreNodeID == m_tmpCurrentResetNode))) &&
		(Info->CIDResetNodeType == Common_Reset_tag))
		{
			pHWSet->m_pCID->Set_CID_Monitor_Cmd(2);		// CID Monitoring ID:124 (OHT -> CID). M Command.

			// pHWSet->m_pCID->CID_Common_Occup_compt();	// 통과완료 bit 1세트 & Common Tag bit 1세트
			pHWSet->m_pCID->CID_Occup_compt(2);				// 통과완료 bit 1세트 Only
			Sleep(20);

			m_CIDMonitoringFlag = true;
			m_CIDComptFlag = true;
			m_bsecond = true;
			m_Igro_CIDStatusPuaseFlag = false;
			m_CIDComptTryFlag = true;
			ADD_LOG("[CID] (COMMON RETURN) 1 Common_GO_CID_Occup_compt_IO, CurrenrtNodeID : %d, CurrenrtNextID : %d, CurrentCMDID : %d, CIDResetNode_arr : %d, ResetNodeType : %d",
				Info->tmpCurrentNodeID, Info->tmpNextNodeID, Info->tmpCurrentCMDID,Info->CIDResetNode_arr, Info->CIDResetNodeType);
			//ADD_LOG("[CIDTest2]m_tmpCurrentResetNode : %d, m_tmpCurrentResetNode : %d");
			IO_INFO_CID();

			return true;
		}

	else
		{
			static int nTmpCurNodeId114 = 0;
			if(nTmpCurNodeId114 != Info->tmpCurrentNodeID)
			{
				nTmpCurNodeId114 = Info->tmpCurrentNodeID;
				ADD_LOG("[CID] CommonCid_Return() ELSE");
				ADD_LOG("[CID] CIDReset: %d, CIDResetType: %d, m_tmpCurrentResetNode: %d", Info->CIDResetNode, Info->CIDResetNodeType, m_tmpCurrentResetNode);
			}
			return false;
		}
}


unsigned char DrivingControl::CID_ID_FIND(unsigned char* CID_UniqueID)
{
	unsigned char iReturn=8;
	unsigned char i=0;
	for(i=0 ; i<8 ; i++)
	{
		if(memcmp(m_Diag_CID_R_ID[(m_Diag_CID_index+1+i) & 0x7],CID_UniqueID,6)==0)
		{
			iReturn = (m_Diag_CID_index+1+i) & 0x7;
			break;
		}
	}
	return iReturn;
}

void DrivingControl::CID_ID_Buffer_Clear(unsigned char index)
{
	memset(&m_Diag_CID_R_ID[index][0],'0',6);
	memset(&m_Diag_ResetNode[index],0,sizeof(int));
	memset(&m_Diag_StopNode[index],0,sizeof(int));
}


void DrivingControl::CID_Monitor_Status(CID_CTRL_INFO* Info)
{
	int iReceivedByte = 0;
	unsigned char index_tmp;

	CID_Monitoring_PKT 	RECV_PKT_Monitor;
	CID_Status_PKT 		RECV_PKT_Status;
	CID_NameSet_PKT		RECV_PKT_Name;

	char TempBuffer[10240];

	DWORD   dwCIDMonitoringTrigerTime  = timeGetTime();

//	if((m_CIDMonitoringFlag == false) && (m_CIDStatusFlag == false) && (m_CIDNameReadFlag == false))

	if((m_IsLifterCheck ==true) || (m_IsMTLCheck ==true))
	{
		//ADD_LOG("[CID] DD Command Received :-------Return");
		return;		// not need check
	}

	if (bCountOfCID_Delay > CID_SERIAL_CMD_DELAY_TURN)
	{
		iReceivedByte = pHWSet->m_pCID->ReadData((char *)&TempBuffer, (char)OPC_SERIAL_INIT_ETX);
		//ADD_LOG("[CID]READ!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! %d",iReceivedByte);

		if(iReceivedByte > 1)
		{

			if((TempBuffer[1] == 'S') && (sizeof(RECV_PKT_Status) ==  iReceivedByte))
			{
				memcpy(&RECV_PKT_Status, &TempBuffer, iReceivedByte);
				ADD_LOG("[CID] S Command Received : %c, %c, %c",RECV_PKT_Status.BODY.Setting[0], RECV_PKT_Status.BODY.Setting[1], RECV_PKT_Status.BODY.Setting[2]);
				bCountOfCID_Delay = 0;

				if(iReceivedByte == sizeof(CID_Status_PKT))
				{
					m_pExecuteInfo->FlagCIDInfo.bCIDErrorFlag = true;	// TaskControl::JudgeCIDError() Enable.
					m_pExecuteInfo->FlagCIDInfo.cCIDStateResult = CID_MONITOR_INFO_GET_STATUS;
					m_pExecuteInfo->FlagCIDInfo.sCIDStatus[0] = RECV_PKT_Status.BODY.Setting[0];
					m_pExecuteInfo->FlagCIDInfo.sCIDStatus[1] = RECV_PKT_Status.BODY.Setting[1];
					m_pExecuteInfo->FlagCIDInfo.sCIDStatus[2] = RECV_PKT_Status.BODY.Setting[2];


					m_pExecuteInfo->FlagCIDMonitoring.bCIDFlag = true;	// TaskControl::UpdateCIDStatusDiagData() Enable  진단서버에도 보내기 위함..
					m_pExecuteInfo->FlagCIDMonitoring.nStopNodeID = m_Diag_StopNode[m_Diag_CID_index];
					m_pExecuteInfo->FlagCIDMonitoring.nResetNodeID = m_Diag_ResetNode[m_Diag_CID_index];
					m_pExecuteInfo->FlagCIDMonitoring.cResult = CID_MONITOR_INFO_GET_STATUS;

					m_CIDStatusFlag = false;
					
					m_sCIDStatus[0]=RECV_PKT_Status.BODY.Setting[0];
					m_sCIDStatus[1]=RECV_PKT_Status.BODY.Setting[1];
					m_sCIDStatus[2]=RECV_PKT_Status.BODY.Setting[2];
				}
				else
				{
					m_pExecuteInfo->FlagCIDInfo.bCIDErrorFlag = true;
					m_pExecuteInfo->FlagCIDInfo.cCIDStateResult = CID_MONITOR_INFO_GET_FAIL;
					m_CIDStatusFlag = false;
					ADD_LOG("[CID] S Command Data Receive Err");
				}
			}
			else if((TempBuffer[1] == 'M') && (sizeof(RECV_PKT_Monitor) ==  iReceivedByte))
			{
				ADD_LOG("[CID] M Command Received : %d",iReceivedByte);

				memcpy(&RECV_PKT_Monitor, &TempBuffer, iReceivedByte);

				// if(bMonitorDataRead == true)
				{
					memcpy(&TEST_PKT_Monitor, &TempBuffer, iReceivedByte);	// save for cid light check function
					//bMonitorDataRead = false;
					ADD_LOG("[CID M Cmd Read] Read Ok. CID R : %c%c%c  CID O : %c%c%c",
						TEST_PKT_Monitor.BODY.CIDR_FirstLinkLevel[0], TEST_PKT_Monitor.BODY.CIDR_FirstLinkLevel[1], TEST_PKT_Monitor.BODY.CIDR_FirstLinkLevel[2],
						TEST_PKT_Monitor.BODY.CIDO_FirstLinkLevel[0], TEST_PKT_Monitor.BODY.CIDO_FirstLinkLevel[1], TEST_PKT_Monitor.BODY.CIDO_FirstLinkLevel[2]);
				}
				
				bCountOfCID_Delay = 0;

				if(iReceivedByte == sizeof(CID_Monitoring_PKT))
				{
					//memcpy(&RECV_PKT_Monitor, &TempBuffer, iReceivedByte);
					m_CIDMonitoringFlag 	= false;
					//bCountOfCID_Delay = 0;
					dwCIDMonitoringTrigerTime  = timeGetTime();

					m_pExecuteInfo->FlagCIDMonitoring.bCIDFlag = true;	// TaskControl::UpdateCIDStatusDiagData() Enable

					index_tmp = CID_ID_FIND(RECV_PKT_Monitor.BODY.CID_UniqueID);
					m_pExecuteInfo->FlagCIDMonitoring.nStopNodeID = m_Diag_StopNode[index_tmp];
					m_pExecuteInfo->FlagCIDMonitoring.nResetNodeID = m_Diag_ResetNode[index_tmp];

//					ADD_LOG("[CID] Test4 tmpPreNodeID:%d, tmpCurrentNodeID:%d, m_tmpCurrentResetNode:%d", Info->tmpPreNodeID, Info->tmpCurrentNodeID, m_tmpCurrentResetNode);
					ADD_LOG("[CID] CID Monitoring Data index_tmp : %d, m_Diag_CID_index : %d", index_tmp, m_Diag_CID_index);
					
					m_pExecuteInfo->FlagCIDMonitoring.cResult = CID_MONITOR_INFO_GET_MONITORING;

					if(	m_sCIDStatus[0]!=0 ||
						m_sCIDStatus[1]!=0 ||
						m_sCIDStatus[2]!=0)
					{
						m_pExecuteInfo->FlagCIDMonitoring.cResult = CID_MONITOR_INFO_GET_SUCCESS;
					}

					memmove((char*)m_pExecuteInfo->FlagCIDMonitoring.cMonitoring, (char*)&RECV_PKT_Monitor.BODY ,sizeof(CID_Monitoring_BODY));

					//ADD_LOG("[CID] CID Monitoring Data (OHT -> Agent ID:124) Received : %d Bytes", iReceivedByte);
					ADD_LOG("[CID] CID Monitoring Data stop : %d, Reset : %d, OHT ID : %c%c%c%c%c%c,  CID_UniqueID : %c%c%c%c%c%c", 
						m_pExecuteInfo->FlagCIDMonitoring.nStopNodeID, m_pExecuteInfo->FlagCIDMonitoring.nResetNodeID,
						RECV_PKT_Monitor.BODY.OHTID[0], RECV_PKT_Monitor.BODY.OHTID[1], RECV_PKT_Monitor.BODY.OHTID[2],
						RECV_PKT_Monitor.BODY.OHTID[3], RECV_PKT_Monitor.BODY.OHTID[4], RECV_PKT_Monitor.BODY.OHTID[5],
						RECV_PKT_Monitor.BODY.CID_UniqueID[0], RECV_PKT_Monitor.BODY.CID_UniqueID[1], RECV_PKT_Monitor.BODY.CID_UniqueID[2],
						RECV_PKT_Monitor.BODY.CID_UniqueID[3], RECV_PKT_Monitor.BODY.CID_UniqueID[4], RECV_PKT_Monitor.BODY.CID_UniqueID[5]);
					ADD_LOG("[CID] CID Monitoring m_Diag_CID_R_ID : %c%c%c%c%c%c",
						m_Diag_CID_R_ID[index_tmp][0], m_Diag_CID_R_ID[index_tmp][1], m_Diag_CID_R_ID[index_tmp][2],
						m_Diag_CID_R_ID[index_tmp][3], m_Diag_CID_R_ID[index_tmp][4], m_Diag_CID_R_ID[index_tmp][5]);
					
					if(RECV_PKT_Monitor.BODY.CIDR_FirstLinkLevel[0] < '2' || RECV_PKT_Monitor.BODY.CIDO_FirstLinkLevel[0] < '2')
					{
						CID_MONITOR_LOG("%c%c%c%c%c%c/%c%c%c%c%c%c/CID-R:%c%c%c0/CID-O:%c%c%c0", 
							RECV_PKT_Monitor.BODY.OHTID[0], RECV_PKT_Monitor.BODY.OHTID[1], RECV_PKT_Monitor.BODY.OHTID[2],
							RECV_PKT_Monitor.BODY.OHTID[3], RECV_PKT_Monitor.BODY.OHTID[4], RECV_PKT_Monitor.BODY.OHTID[5],
							RECV_PKT_Monitor.BODY.CID_UniqueID[0], RECV_PKT_Monitor.BODY.CID_UniqueID[1], RECV_PKT_Monitor.BODY.CID_UniqueID[2],
							RECV_PKT_Monitor.BODY.CID_UniqueID[3], RECV_PKT_Monitor.BODY.CID_UniqueID[4], RECV_PKT_Monitor.BODY.CID_UniqueID[5],
							RECV_PKT_Monitor.BODY.CIDR_FirstLinkLevel[0], RECV_PKT_Monitor.BODY.CIDR_FirstLinkLevel[1], RECV_PKT_Monitor.BODY.CIDR_FirstLinkLevel[2],
							RECV_PKT_Monitor.BODY.CIDO_FirstLinkLevel[0], RECV_PKT_Monitor.BODY.CIDO_FirstLinkLevel[1], RECV_PKT_Monitor.BODY.CIDO_FirstLinkLevel[2]);
					}
					//CID_ID_Buffer_Clear(index_tmp);
				}
				else
				{
					m_pExecuteInfo->FlagCIDMonitoring.bCIDFlag = true;
					m_pExecuteInfo->FlagCIDMonitoring.cResult = CID_MONITOR_INFO_GET_FAIL;
					m_CIDMonitoringFlag 	= false;
					ADD_LOG("[CID] M Command Data Receive Err");
				}
				m_sCIDStatus[0] = 0;
				m_sCIDStatus[1] = 0;
				m_sCIDStatus[2] = 0;
			}
			else if((TempBuffer[1] == 'O') && (sizeof(RECV_PKT_Name) ==  iReceivedByte))
			{
				memcpy(&RECV_PKT_Name, &TempBuffer, iReceivedByte);
				bCountOfCID_Delay = 0;
				m_CIDNameReadFlag = false;

				unsigned char	Display_OHTNAME[7] ={0,};
				memcpy(&Display_OHTNAME, RECV_PKT_Name.OHTNAME, 6);
//				Display_OHTNAME[6] = '\n';
				ADD_LOG("[CID] VHL Name is : %s", Display_OHTNAME);

				// ADD_LOG("[CID] VHL Name is : %s", RECV_PKT_Name.OHTNAME);
			}
			else if(TempBuffer[1] == 'L' && TempBuffer[2] == '=' && TempBuffer[3] == 'O' && TempBuffer[4] == 'D' && TempBuffer[5] == '8')
			{
				ADD_LOG("[CID] Save_CID_O_Data");
				pHWSet->m_pCID->Save_CID_O_Data();
			}
			else
			{
				//ADD_LOG("[CID] Monitoring Parsing Error");
				//CID_O Log
				bCountOfCID_Delay = 0;
			}

			m_CIDMonitoringFlag= false;
			m_CIDNameReadFlag = false;
			m_CIDStatusFlag = false;
		}
		else
		{
			bCountOfCID_Delay = 0;	// 수신된 데이터가 없으면 다시 CID_SERIAL_CMD_DELAY_TURN 만큼 기다려본다
		}
	}
	else
	{
		bCountOfCID_Delay++;
	}


}



// CID-R장애여부를 판단하여 문제 있는경우 보고
// I4 = 1로 들어오면 시리얼로 S명령을 줘서 OCS로 정보를 전송해야 한다
void DrivingControl::CID_R_Status_Chk()
{
	 if ((pHWSet->m_pCID->IsLinkOK() == true)&&(pHWSet->m_pCID->ISCidStatusOn() == true)&&(m_CIDStatusFlag == false)
		&&(m_pExecuteInfo->FlagCIDNotuse.bCIDUse == false)&&(m_Igro_CIDStatusPuaseFlag == false))
	 {
		try
		{
			pHWSet->m_pCID->Set_CID_Status_Cmd();
			// m_CIDMonitoringFlag = true;		// is bug shkim
			m_CIDStatusFlag = true;

//			EnterCriticalSection(&OHTMainForm->m_CS);
//			m_pExecuteInfo->FlagCIDInfo.bCIDErrorFlag = true;
//			LeaveCriticalSection(&OHTMainForm->m_CS);
//			pHWSet->m_pCID->CID_Status_Pause(m_CID_Status_Pause);
			//CID 이상상태일때 일시정지 하는 부분 ==>>추후에 꼭 활성화 필요
//			m_CIDStatusPauseFlag = true; // I4 == 1로 정지 설정
			ADD_LOG("[CID] CID_Status REQ");
		}
		catch(...)
		{
			ADD_LOG("[CID] CID_Status Exception!!");
		}
	 }
}

/*
( m_Igro_CIDStatusPuaseFlag )

	- 초기값 false
	- 노멀, 경사로 리셋노드 처리시 false
	- common 리셋노드 처리시 false
	- 작업변경 방향전환 처리시 false

	- CID_OCS_Resume_Cmd_Chk()
	  OCS로 보고한 Pause에 대한 Resume명령을 받아 재주행 시에 ture가 됨

	(사용)
	- CID-R 장애여부 보고시 조건으로 사용 : false일때 보고

	=> 즉, CID-R 보고 플래그로서, 장애발생시 계속 보고하다가, Resume명령 받으면 보고를 멈춤. 다음 리셋노드 만나면 false가 되어 보고

(FlagCIDNotuse.bCIDUse)
	- CID사용유무 설정값

*/

// CID호기번호 설정
UINT DrivingControl::setCID_VHL_Name(char* OHTNAME)
{
	CID_NameSet_PKT NameSet_PKT;

	NameSet_PKT.STX = OPC_SERIAL_INIT_STX;
	NameSet_PKT.CMD = 'O';
	NameSet_PKT.SEP = '=';

	memcpy(&NameSet_PKT.OHTNAME,  OHTNAME, 	sizeof(NameSet_PKT.OHTNAME));

	// sum바로 앞까지 바이트수가 9바이트
	CheckSum((char*)& NameSet_PKT, 9, (char*)&NameSet_PKT.SUM);
	NameSet_PKT.ETX = OPC_SERIAL_INIT_ETX;

	m_CIDNameReadFlag = true;

	return SEND_SERIAL_NOT_CLEAR((char*)&NameSet_PKT, sizeof(CID_NameSet_PKT));
}


// CID호기번호 확인요청
UINT DrivingControl::requestCID_VHL_Name()
{
	CID_Name_Request_PKT NameGet_PKT;

	NameGet_PKT.STX = OPC_SERIAL_INIT_STX;
	NameGet_PKT.CMD = 'O';

	// sum바로 앞까지 바이트수가 2바이트
	CheckSum((char*)& NameGet_PKT, 2, (char*)&NameGet_PKT.SUM);
	NameGet_PKT.ETX = OPC_SERIAL_INIT_ETX;

	return SEND_SERIAL((char*)&NameGet_PKT, sizeof(CID_Name_Request_PKT));
}
/**
@brief   Find Nearest CID Stop, Reset
@author  KJD
@date    2017.09.15
*/

int DrivingControl::CID_Find_Stop_Reset(int callNum, DRIVING_HW_INFO_SET HwInfo, int* StopNode, int* ResetNode)
{
	unsigned int CIDStopNode1_arr, CIDStopNode2_arr, CIDResetNode_arr, TotalCount, cnt;
	DRIVING_CMD_INFO_OF_NODE* pStopNode;
	DRIVING_CMD_INFO_OF_NODE* pResetNode;
	CIDStopNode1_arr = INDEX_NONE;
	CIDStopNode2_arr = INDEX_NONE;
	CIDResetNode_arr = INDEX_NONE;
	static int tmpStopNode = 0;	
	static int tmpResetNode = 0;
	//return 0; 
	try{
		TotalCount = m_ClassifiedCmd.NodeList.getCount();
	}
	catch(...)
	{
		ADD_LOG("[CID] CID_Find_Stop_Reset exception 1");
	}
	for(int i = 0 ; i < TotalCount ; i++)
	{
		try{
			pStopNode = getNodeInfo(HwInfo.Node.nNodeCount+i);
			if(pStopNode != NULL)
			{
				CIDStopNode1_arr = OHTMainForm->GetMap()->FindNodeIndexFromCIDStop_1(pStopNode->ID);
				CIDStopNode2_arr = OHTMainForm->GetMap()->FindNodeIndexFromCIDStop_2(pStopNode->ID);
				//ADD_LOG("[CID] pStopNode->ID : %d", pStopNode->ID);
			}
		}
		catch(...)
		{
			ADD_LOG("[CID] CID_Find_Stop_Reset exception 2");
		}
		//stop을 찾은 경우 다음 노드가 Reset인지 확인
		if(CIDStopNode1_arr != INDEX_NONE || CIDStopNode2_arr != INDEX_NONE)
		{
			try{
				if(i<TotalCount-1)
				{
					pResetNode = getNodeInfo(HwInfo.Node.nNodeCount+i+1);
					if(pResetNode != NULL)
					{
						//ADD_LOG("[CID] pResetNode->ID : %d", pResetNode->ID);
						CIDResetNode_arr = OHTMainForm->GetMap()->FindNodeIndexFromCIDReset(pResetNode->ID);
					}
					//Stop 다음 Reset인 경우 노드정보 리턴
					if(CIDResetNode_arr != INDEX_NONE)
					{
						if(pResetNode != NULL)
						{
							*StopNode = pStopNode->ID;
							*ResetNode = pResetNode->ID;
							if(tmpStopNode != *StopNode || tmpResetNode != *ResetNode)
							{
								ADD_LOG("[CID] Nearest StopNode : %d, Reset : %d, cycle : %d, TotalCount : %d, callNum : %d", pStopNode->ID, pResetNode->ID, i, TotalCount, callNum);
								tmpStopNode = pStopNode->ID;
								tmpResetNode = pResetNode->ID;
							}							
						}
						return 0;
					}
				}
				else
				{
					if(m_pExecuteInfo->nNextNodeIDInfo != 0)
					{
						*StopNode = pStopNode->ID;
						*ResetNode = m_pExecuteInfo->nNextNodeIDInfo;
						if(tmpStopNode != *StopNode || tmpResetNode != *ResetNode)
						{
							ADD_LOG("[CID] Nearest StopNode : %d, Reset(nNextNodeIDInfo) : %d, cycle : %d, TotalCount : %d, callNum : %d", pStopNode->ID, m_pExecuteInfo->nNextNodeIDInfo, i, TotalCount, callNum);
							tmpStopNode = pStopNode->ID;
							tmpResetNode = m_pExecuteInfo->nNextNodeIDInfo;
						}			
						return 0;
					}
					else
					{
						*StopNode = pStopNode->ID;
						*ResetNode = 0;
						return 0;
					}
				}
			}
			catch(...)
			{
				ADD_LOG("[CID] CID_Find_Stop_Reset exception 3");
			}
		}
	}
	//전체 경로에서 Stop, Reset을 못찾은 경우
	*StopNode = 0;
	*ResetNode = 0;
	return 1;
}

/**
@brief   진행 경로의 CID Stop Node, Reset Node 찾는 함수
@author  KYH
@date    2018.05.29
*/

int DrivingControl::CID_Find_Stop_Reset_Change(int callNum, DRIVING_HW_INFO_SET HwInfo, int* StopNode, int* ResetNode, int Num)
{
	unsigned int CIDStopNode1_arr, CIDStopNode2_arr, CIDResetNode_arr, TotalCount, cnt;
	DRIVING_CMD_INFO_OF_NODE* pStopNode;
	DRIVING_CMD_INFO_OF_NODE* pResetNode;
	CIDStopNode1_arr = INDEX_NONE;
	CIDStopNode2_arr = INDEX_NONE;
	CIDResetNode_arr = INDEX_NONE;
	static int tmpStopNode = 0;
	static int tmpResetNode = 0;
	//return 0;
	try{
		TotalCount = m_ClassifiedCmd.NodeList.getCount();
	}
	catch(...)
	{
		ADD_LOG("[CID] CID_Find_Stop_Reset exception 1");
	}
	for(int i = 0 ; i < TotalCount ; i++)
	{
		try{
			pStopNode = getNodeInfo(HwInfo.Node.nNodeCount+i);

			/*
			static int nTmpCurNodeId01502 = 0;
			if(nTmpCurNodeId01502 >= 40)
			{
				ADD_LOG("[CID_TEST] 최종 노드 확인 : %d", pStopNode->ID);
                nTmpCurNodeId01502 = 0;
			}
            nTmpCurNodeId01502++;
			*/

			if(pStopNode != NULL)
			{
				CIDStopNode1_arr = OHTMainForm->GetMap()->FindNodeIndexFromCIDStop_1(pStopNode->ID);
				CIDStopNode2_arr = OHTMainForm->GetMap()->FindNodeIndexFromCIDStop_2(pStopNode->ID);
				//ADD_LOG("[CID] pStopNode->ID : %d", pStopNode->ID);
			}
		}
		catch(...)
		{
			ADD_LOG("[CID] CID_Find_Stop_Reset exception 2");
		}
		//stop을 찾은 경우 다음 노드가 Reset인지 확인
		if(CIDStopNode1_arr != INDEX_NONE || CIDStopNode2_arr != INDEX_NONE)
		{
			try{
				if(i<TotalCount-1)
				{
					pResetNode = getNodeInfo(HwInfo.Node.nNodeCount+i+1);
					if(pResetNode != NULL)
					{
						//ADD_LOG("[CID] pResetNode->ID : %d", pResetNode->ID);
						CIDResetNode_arr = OHTMainForm->GetMap()->FindNodeIndexFromCIDReset(pResetNode->ID);
					}
					//Stop 다음 Reset인 경우 노드정보 리턴
					if(CIDResetNode_arr != INDEX_NONE)
					{
						if(pResetNode != NULL)
						{
							*StopNode = pStopNode->ID;
							*ResetNode = pResetNode->ID;
							if(tmpStopNode != *StopNode || tmpResetNode != *ResetNode)
							{
								ADD_LOG("[CID] Nearest StopNode : %d, Reset : %d, cycle : %d, TotalCount : %d, callNum : %d", pStopNode->ID, pResetNode->ID, i, TotalCount, callNum);
								tmpStopNode = pStopNode->ID;
								tmpResetNode = pResetNode->ID;
							}
						}
						return 0;
					}
					else
					{
						*StopNode = pStopNode->ID;
						*ResetNode = -1;
						return -1;
					}
				}
				else
				{
					*StopNode = pStopNode->ID;
					*ResetNode = 0;
					return 0;
				}
			}
			catch(...)
			{
				ADD_LOG("[CID] CID_Find_Stop_Reset exception 3");
			}
		}
	}
	//전체 경로에서 Stop, Reset을 못찾은 경우
	*StopNode = 0;
	*ResetNode = 0;
	return 1;
}


// CID Control Main Function
#define DEF_CID_INFO_NONE	-1
int DrivingControl::checkCID(DRIVING_HW_INFO_SET HwInfo, DRIVING_INFO_SET *pInfoSet)
{
	int nError = NO_ERR;	// CONTROL_CID()'s result;
	static int nPreviousNodeID = 0;
	static int nPreviousCurrNodeOffset=0;
	int nCurrentNodeID = (int)m_PositionInfo.CurrNode;

//	if(Info.tmpPreNodeID != Info.tmpCurrentNodeID)
//	{
//		ADD_LOG("[CID] Test Temp tmpPreNodeID:%d, tmpCurrentNodeID:%d",Info.tmpPreNodeID, Info.tmpCurrentNodeID);
//	}

	if(nPreviousCurrNodeOffset != m_PositionInfo.CurrNodeOffset)
	{
//		ADD_LOG("[CID] Node : %d, Offset : %d", m_PositionInfo.CurrNode, m_PositionInfo.CurrNodeOffset);
		nPreviousCurrNodeOffset = m_PositionInfo.CurrNodeOffset;
	}
	else
	{}
	// ---------- NameSet -------------
	// OHT의 호기명을 CID-O에 Write하는 함수로 한번만 실행해주면 된다
	static bool bNameWrite = false;
	try{

	if(bNameWrite == false)
	{
		setCID_VHL_Name(m_defualtparam->VHLName);
		bNameWrite = true;
	}
	// ---------------------------------

	m_bCIDNotUse = false;
	memset(&Info, 0, sizeof(CID_CTRL_INFO));
	#if 0
	DRIVING_CMD_INFO_OF_NODE* pPreNodeInfo = getNodeInfo(pInfoSet->HwInfo.Node.nPreCheckCount);
	if(pPreNodeInfo != NULL)
	{
		nCurrentNodeID = (int)pPreNodeInfo->ID;
	}
	else
	{
		nCurrentNodeID = (int)m_PositionInfo.CurrNode;
	}
	#endif
	getCID_Info(&Info, nCurrentNodeID);


	// test code(2016.11.25)  //////////////////////
	static int nTmpCurNodeId00 = 0;
	if(nTmpCurNodeId00 != Info.tmpCurrentNodeID)
	{
		nTmpCurNodeId00 = Info.tmpCurrentNodeID;
		ADD_LOG("[CID] Check Map --> CurrentNode: %d, Stop1: %d, Stop2: %d, Reset1: %d, Reset2: %d, ResetType: %d",
			Info.tmpCurrentNodeID, Info.CIDStopNode1, Info.CIDStopNode2, Info.CIDResetNode1, Info.CIDResetNode2, Info.CIDResetNodeType);
	
		ADD_LOG("[CID] Start 1-1 : %d, 1-2 : %d, 1-3 : %d, 1-4 : %d, 1-5 : %d, Start 2-1 : %d, 2-2 : %d, 2-3 : %d, 2-4 : %d, 2-5 : %d ",
			Info.tmpStartNode1_1, Info.tmpStartNode1_2, Info.tmpStartNode1_3, Info.tmpStartNode1_4, Info.tmpStartNode1_5, Info.tmpStartNode2_1, Info.tmpStartNode2_2, Info.tmpStartNode2_3, Info.tmpStartNode2_4, Info.tmpStartNode2_5);

		ADD_LOG("[CID] ConStep : %d, tmpNextNID : %d, tmpCurrentCMDID : %d, IsLinking : %d, m_CIDComptTryFlag : %d",
					m_nCidControlStep, Info.tmpNextNodeID, Info.tmpCurrentCMDID, pHWSet->m_pCID->IsLinking(), m_CIDComptTryFlag);

		//IO_INFO_CID_ALL();

	}
	///////////////////////////////////////////////////////


	// Manual모드이다가 AutoMode로 전환했을때 한번만 state를 바꿔준다
	if(pHWSet->m_pCID->NeedTO_executeCID_Reset() == true)
	{
		m_nCidControlStep = CID_STEP_CONNECTING;
		ADD_LOG("[CID] Manual -> Auto S/M to CID_STEP_CONNECTING");
		pHWSet->m_pCID->CID_Out_PASS_Compt(ON);
		Sleep(20);
    	pHWSet->m_pCID->CID_Output_Clear(1);// 들어오는지 확인..
		IO_INFO_CID();
	}

	// 현재 상태가 Abnormal비트가 켜져 있는지 보고 켜져있으면 끈다 ,<= 내용 맞는건지...
	// (check CID로 들어온 경우는 Auto Mode 또는 Manual Mode인데 TP 사이클 명령을 받은 경우이며
	//	이 경우 사용자의 수동 조작으로 움직이는 것이 아니므로 꺼야 한다)  ==> [질문]
	if (pHWSet->m_pCID->ISCidManualMode() == true)
	{
		Manual_CID(MANUAL_CID_ABNORMAL_MODE_OFF);
		ADD_LOG("[CID] Check CID Start. Abnormal Mode Off");
	}


	// Common Tag Clear
	if(m_CID_COMMON_bit_off_need == true)
	{
		if(pHWSet->m_pCID->IsCommonTag() == true)
		{
			pHWSet->m_pCID->CID_Out_Common_Tag(1, false);	// Common Tag Off
			m_CID_COMMON_bit_off_need = false;
			ADD_LOG("[CID] Now Common Reset Tag. O7 = 0 clear");
			nTmpCurNodeId00 = 0;// 로그 출력 하기위해
		}
		else
		{
			ADD_LOG("[CID] Common Reset Tag O7 current => not 1. wait");
			return NO_ERR;
		}
	}


	// Lifter, MTL 구간(Op. Mode = 0)과 일반 합류 구간(Op. Mode = 1) 구분
	// CID 구간인 경우 ControlCID 동작
	// 그외 구간인 경우 Lifter 구간 확인 하여, CID_Output_Clear 시킴
	if ((Info.tmpCurrentNodeID == Info.tmpStartNode2_1)	||(Info.tmpCurrentNodeID == Info.tmpStartNode2_2)
		||(Info.tmpCurrentNodeID == Info.tmpStartNode2_3)	||(Info.tmpCurrentNodeID == Info.tmpStartNode2_4)
		||(Info.tmpCurrentNodeID == Info.tmpStartNode2_5)	||(Info.tmpCurrentNodeID == Info.tmpResetNode2)

		||(Info.tmpCurrentNodeID == Info.tmpStartNode1_1)	||(Info.tmpCurrentNodeID == Info.tmpStartNode1_2)
		||(Info.tmpCurrentNodeID == Info.tmpStartNode1_3)	||(Info.tmpCurrentNodeID == Info.tmpStartNode1_4)
		||(Info.tmpCurrentNodeID == Info.tmpStartNode1_5)	||(Info.tmpCurrentNodeID == Info.tmpResetNode1)
		||(m_nCidControlStep == CID_STEP_CHECKING_PATH)
		||(m_nCidControlStep == CID_STEP_OCCUPYING_PATH)
		||(m_nCidControlStep == CID_STEP_WAITING_FOR_PATH)
	   	||(m_nCidControlStep == CID_STEP_ABNORMAL)		//CID_STEP_ABNORMAL 인 경우 현재 노드가 Reset인 경우 처리하는 부분이 존재.
														//현재 노드가 Reset 인 경우 or CID_STEP_ABNORMAL 인 경우 controlCID 호출이 되어야 함.
														//공용 노드인 경우는 start 노드에 포함되어 져서 controlCID이 호출 됨.
		||(m_nCidControlStep == CID_STEP_COMPLETION))
	{
		nError = controlCID(&Info, executeCID_NONE, pInfoSet, HwInfo);
	}
	else if ((pHWSet->m_pCID->IsOutputAllOff() != true) || (pHWSet->m_pCID->IsInputAllOff() != true))
	{
		DRIVING_CMD_INFO_OF_NODE* pNodeInfo = getNodeInfo(pInfoSet->HwInfo.Node.nNodeCount);
		if(pNodeInfo!=NULL)
		{

			if(pNodeInfo->NodeType == NONE_TYPE ||
				pNodeInfo->NodeType == OPT_TAG ||
				pNodeInfo->NodeType == OPT_DISTANCE ||
				pNodeInfo->NodeType == OPT_COMBO)
			{
				ADD_LOG("[CID] pNodeInfo->NodeType : %d",pNodeInfo->NodeType);
				//리프터 구간 아닌 경우 실행 방지
				//NodeType이 일반노드 인 경우 실행
				if(pHWSet->m_pCID->IsLinkOK() == true)
					pHWSet->m_pCID->CID_Occup_compt(3);

				Sleep(20);
				pHWSet->m_pCID->CID_Output_Clear(2);
				ADD_LOG("[CID] Output Reset...");

				m_bsecond = false;
				m_CID_Pause = false;
				m_CIDComptFlag = false;  // cid 완료 처리 Flag
				m_CIDComptTryFlag = false;  // cid 완료 처리 시도 Flag
				m_CID_COMMON_bit_off_need = false;
//				m_CIDMonitoringFlag = false;
				m_CIDLinkFlag = false;
//				m_CIDStatusFlag = false;
				m_CIDStatusPauseFlag = false;
				m_CIDPauseTime = 0;
				m_CID_Status_Pause = false;
				m_Igro_CIDStatusPuaseFlag = false;
				m_bLinkFail = false;
				m_bLinkDisconnected = false;
				m_bInitialLink = false;
				m_CIDDirection = CID_DIRECTION_NOT_LINK;
				m_bCIDNotUse = false;
				m_CIDOperationStarted = false;  // 2016. 12. 23 추가
				m_job_change_flag_no_cid_area = false; //0: not change 1 : change
				m_job_change_flag_exception_CommonTag = false;
				m_CurrCIDStartnode = 0;
				m_sCIDStatus[0]=0;
				m_sCIDStatus[1]=0;
				m_sCIDStatus[2]=0;

				bCountOfCID_Delay    = 0;
				bCountOfCIDLink    = 0; 	   //링크 연결 관련
				m_job_change_without_link_complete = false;
				bCountOfCIDDualOccup	= 0;  //동시진입 관련
				bCountOfCIDComptACK    = 0;  //완료처리 응답 관련

				bDirCIDChage = false;		// 방향전환 전에 완료처리를 함을 나타내는 변수
				tmpStopID = 0;

//				m_CIDNameReadFlag = false;
				m_tmpCurrentResetNode = 0;
				m_tmpCurrentStopNode = 0;
				m_nCIDTerminateCount = 0;

				m_nCidControlStep = CID_STEP_CONNECTING;
			}
		}
	}
	// CID 구간이 아닌 위치에서 감속정지시 주행재개 명령 처리 부분 
	else if(m_pExecuteInfo->FlagCIDReport.bCIDStop == true 
		&& m_CID_Pause == true
		&& m_pExecuteInfo->FlagCIDInfo.cMoveResult == true
		&& m_pExecuteInfo->FlagCIDInfo.bMoveRestart == true)
	{
		m_pExecuteInfo->FlagCIDInfo.bMoveRestart = false;
		pHWSet->m_pCID->CID_Occup_Resume(&m_CID_Pause);
		m_pExecuteInfo->FlagCIDReport.bCIDInterlock= false;
		m_pExecuteInfo->FlagCIDReport.bCIDStop = false;
		
		m_nCidControlStep = CID_STEP_COMPLETION;
		ADD_LOG("[CID] OCS Pause Released.. MoveRestart");
	}
	else
	{
		//NOP
	}
	}catch(...)
         ADD_LOG("[CID] Exception...");


	// ---- Monitoring & Status ----
	//CID_Monitor_Status(&Info);	// M(CID Monitoring ID:124), S(Status bit), O(Name) Command's Response Read.
	CID_R_Status_Chk();		// CID상태 확인. If Status bit=1, S Command Send function

	return nError;
}

void DrivingControl::DrivingCMDExuteFunc(bool bFlag)
{
	m_pExecuteInfo->FlagCmdExcute.bCmdDrivingCMDExcute = bFlag;
}


CID_DIRECTION DrivingControl::CID_Direction_Chk(CID_CTRL_INFO* Info, DRIVING_INFO_SET *pInfoSet, int CID_NearestResetNode, int  CID_NearestStopNode)
{

	// DIRECTION RIGHT
	if(	(Info->CIDStartNode2_arr != INDEX_NONE)&& (Info->CIDResetNode_arr == INDEX_NONE) &&
		(Info->tmpNextNodeID != 0) &&
		((Info->tmpNextNodeID == Info->tmpStartNode2_1) ||(Info->tmpNextNodeID == Info->tmpStartNode2_2)
	   ||(Info->tmpNextNodeID == Info->tmpStartNode2_3)||(Info->tmpNextNodeID == Info->tmpStartNode2_4)
	   ||(Info->tmpNextNodeID == Info->tmpStartNode2_5)||(Info->tmpNextNodeID == Info->tmpResetNode2)) &&
	   (Info->tmpStopNode2 == CID_NearestStopNode &&
			Info->tmpResetNode2 == CID_NearestResetNode &&
			m_pExecuteInfo->FlagCIDNotuse.bCIDUse == false))
	{


		if (Info->tmpStopNode2 == CID_NearestStopNode &&
			Info->tmpResetNode2 == CID_NearestResetNode &&
			m_pExecuteInfo->FlagCIDNotuse.bCIDUse == false)
		{
			m_CIDLinkFlag = true;
			m_bsecond = false;
			bDirCIDChage = false;
			m_bCIDNotUse = false;
			ADD_LOG("[CID] CID_DIRECTION_RIGHT");
			return CID_DIRECTION_RIGHT;	// Cid Direction is Right
		}
		else if (Info->tmpStopNode2 == CID_NearestStopNode &&
			Info->tmpResetNode2 == CID_NearestResetNode &&
			m_pExecuteInfo->FlagCIDNotuse.bCIDUse == true)  // <- m_pExecuteInfo->FlagCIDNotuse.bCIDUse == true 조건으로 들어오지 않음...
		{
			m_bCIDNotUse = true;
			ADD_LOG("[CID] Select ON not required...1 (Current: %d, Stop(CID): %d, Reset(CID): %d, Stop(OCS): %d, Reset(OCS): %d", 
				Info->tmpCurrentNodeID, Info->tmpStopNode2, Info->tmpResetNode2,
				CID_NearestStopNode, CID_NearestResetNode);
			return CID_DIRECTION_NOT_LINK;
		}
		else if (Info->tmpStopNode2 != CID_NearestStopNode ||
			Info->tmpResetNode2 != CID_NearestResetNode)
		{
			m_bCIDNotUse = false;
			static int nTmpCurNodeId1704121 = 0;
			if(nTmpCurNodeId1704121 != Info->tmpCurrentNodeID)
			{
				nTmpCurNodeId1704121 = Info->tmpCurrentNodeID;
				ADD_LOG("[CID] Reset Node Info from CID Map and OCS are different..(Current: %d, Stop(CID): %d, Reset(CID): %d, Stop(OCS): %d, Reset(OCS): %d",
					Info->tmpCurrentNodeID, Info->tmpStopNode2, Info->tmpResetNode2,
					CID_NearestStopNode, CID_NearestResetNode);
			}
			return CID_DIRECTION_NOT_LINK;
		}
		else
		{
			m_bCIDNotUse = false;
			ADD_LOG("[CID] CID_Direction_Chk, [RIGHT] else case");
			return CID_DIRECTION_NOT_LINK;
		}
	}

	// DIRECTION LEFT
	else if((Info->CIDStartNode1_arr != INDEX_NONE)&& (Info->CIDResetNode_arr == INDEX_NONE) &&
		(Info->tmpNextNodeID != 0) &&
		((Info->tmpNextNodeID == Info->tmpStartNode1_1) ||(Info->tmpNextNodeID == Info->tmpStartNode1_2)
	   ||(Info->tmpNextNodeID == Info->tmpStartNode1_3)||(Info->tmpNextNodeID == Info->tmpStartNode1_4)
       ||(Info->tmpNextNodeID == Info->tmpStartNode1_5)||(Info->tmpNextNodeID == Info->tmpResetNode1)) &&
       (Info->tmpStopNode1 == CID_NearestStopNode &&
			Info->tmpResetNode1 == CID_NearestResetNode &&
			m_pExecuteInfo->FlagCIDNotuse.bCIDUse == false))
	{
		if (Info->tmpStopNode1 == CID_NearestStopNode &&
			Info->tmpResetNode1 == CID_NearestResetNode &&
			m_pExecuteInfo->FlagCIDNotuse.bCIDUse == false)
		{
			m_CIDLinkFlag = true;	// 링크 시도중이다
			m_bsecond = false;
			bDirCIDChage = false;	// 방향전환 완료여부 (true : 진행중. false : 완료함)
			m_bCIDNotUse = false;
			ADD_LOG("[CID] CID_DIRECTION_LEFT");
			return CID_DIRECTION_LEFT;
		}
		else if (Info->tmpStopNode1 == CID_NearestStopNode &&
			Info->tmpResetNode1 == CID_NearestResetNode &&
			m_pExecuteInfo->FlagCIDNotuse.bCIDUse == true) // <- m_pExecuteInfo->FlagCIDNotuse.bCIDUse == true 조건으로 들어오지 않음...
		{
			m_bCIDNotUse = true;
			ADD_LOG("[CID] Select ON not required...2 (Current: %d, Stop(CID): %d, Reset(CID): %d, Stop(OCS): %d, Reset(OCS): %d", 
				Info->tmpCurrentNodeID, Info->tmpStopNode1, Info->tmpResetNode1,
				CID_NearestStopNode, CID_NearestResetNode);
			return CID_DIRECTION_NOT_LINK;
		}
		else if (Info->tmpStopNode1 != CID_NearestStopNode ||
			Info->tmpResetNode1 != CID_NearestResetNode)
		{
			static int nTmpCurNodeId1704122 = 0;
			if(nTmpCurNodeId1704122 != Info->tmpCurrentNodeID)
			{
				nTmpCurNodeId1704122 = Info->tmpCurrentNodeID;
				ADD_LOG("[CID] Reset Node Info from CID Map and OCS are different..(Current: %d, Stop(CID): %d, Reset(CID): %d, Stop(OCS): %d, Reset(OCS): %d",
					Info->tmpCurrentNodeID, Info->tmpStopNode1, Info->tmpResetNode1,
					CID_NearestStopNode, CID_NearestResetNode);
			}
			m_bCIDNotUse = false;
			return CID_DIRECTION_NOT_LINK;
		}
		else
		{
			m_bCIDNotUse = false;
			ADD_LOG("[CID] CID_Direction_Chk, [LEFT] else case");
			return CID_DIRECTION_NOT_LINK;
		}

	}
	else if((pInfoSet->Steer.FrontMoving == false)&&(pInfoSet->Steer.RearMoving == false)&&(pHWSet->m_pCID->IsLinking() == false)
			&&(pHWSet->m_pCID->IsLinkOK() == false)
			&& ((Info->CIDResetNode_arr != INDEX_NONE)&&(Info->CIDResetNodeType == Common_Reset_tag)&&(Info->CIDStartNode2_arr != INDEX_NONE)
			&& (Info->tmpNextNodeID != 0)

			&& ((Info->tmpNextNodeID == Info->tmpStartNode2_1)||(Info->tmpNextNodeID == Info->tmpStartNode2_2)||
				(Info->tmpNextNodeID == Info->tmpStartNode2_3)||(Info->tmpNextNodeID == Info->tmpStartNode2_4)||
				(Info->tmpNextNodeID == Info->tmpStartNode2_5)
		 	   ||Info->tmpNextNodeID == Info->tmpResetNode2)))
	{
		if (Info->tmpStopNode2 == CID_NearestStopNode &&
			Info->tmpResetNode2 == CID_NearestResetNode &&
			m_pExecuteInfo->FlagCIDNotuse.bCIDUse == false)
		{
			m_bsecond = true;
	   		m_CIDLinkFlag = true;
	   		bDirCIDChage = false;
			m_bCIDNotUse = false;
			ADD_LOG("[CID] CID_DIRECTION_COMMON_RIGHT");
			return CID_DIRECTION_COMMON_RIGHT;
		}
		else if (Info->tmpStopNode2 == CID_NearestStopNode &&
			Info->tmpResetNode2 == CID_NearestResetNode &&
			m_pExecuteInfo->FlagCIDNotuse.bCIDUse == true)
		{
			m_bCIDNotUse = true;
			ADD_LOG("[CID] Select ON not required...3 (Current: %d, Stop(CID): %d, Reset(CID): %d, Stop(OCS): %d, Reset(OCS): %d", 
			Info->tmpCurrentNodeID, Info->tmpStopNode2, Info->tmpResetNode2,
			CID_NearestStopNode, CID_NearestResetNode);
			return CID_DIRECTION_NOT_LINK;
		}
		else if (Info->tmpStopNode2 != CID_NearestStopNode ||
			Info->tmpResetNode2 != CID_NearestResetNode)
		{
			static int nTmpCurNodeId1704123 = 0;
			if(nTmpCurNodeId1704123 != Info->tmpCurrentNodeID)
			{
				nTmpCurNodeId1704123 = Info->tmpCurrentNodeID;
				ADD_LOG("[CID] Reset Node Info from CID Map and OCS are different..(Current: %d, Stop(CID): %d, Reset(CID): %d, Stop(OCS): %d, Reset(OCS): %d",
					Info->tmpCurrentNodeID, Info->tmpStopNode2, Info->tmpResetNode2,
					CID_NearestStopNode, CID_NearestResetNode);
			}
			m_bCIDNotUse = false;
			return CID_DIRECTION_NOT_LINK;
		}
		else
		{
			m_bCIDNotUse = false;
			ADD_LOG("[CID] CID_Direction_Chk, [RIGHT COMMON] else case");
			return CID_DIRECTION_NOT_LINK;
		}
	}
	else if((pInfoSet->Steer.FrontMoving == false)&&(pInfoSet->Steer.RearMoving == false)&&(pHWSet->m_pCID->IsLinking() == false)
			&&(pHWSet->m_pCID->IsLinkOK() == false)
			&& ((Info->CIDResetNode_arr != INDEX_NONE)&&(Info->CIDResetNodeType == Common_Reset_tag)&&(Info->CIDStartNode1_arr != INDEX_NONE)
			&& (Info->tmpNextNodeID != 0)
			&&((Info->tmpNextNodeID == Info->tmpStartNode1_1)||(Info->tmpNextNodeID == Info->tmpStartNode1_2)||
			   (Info->tmpNextNodeID == Info->tmpStartNode1_3)||(Info->tmpNextNodeID == Info->tmpStartNode1_4)||
			   (Info->tmpNextNodeID == Info->tmpStartNode1_5)
	          ||Info->tmpNextNodeID == Info->tmpResetNode1)))
	{
		if (Info->tmpStopNode1 == CID_NearestStopNode &&
			Info->tmpResetNode1 == CID_NearestResetNode &&
			m_pExecuteInfo->FlagCIDNotuse.bCIDUse == false)
		{
			m_bsecond = true;
			m_CIDLinkFlag = true;
			bDirCIDChage = false;
			m_bCIDNotUse = false;
			ADD_LOG("[CID] CID_DIRECTION_COMMON_LEFT");
			return CID_DIRECTION_COMMON_LEFT;
		}
		else if (Info->tmpStopNode1 == CID_NearestStopNode &&
			Info->tmpResetNode1 == CID_NearestResetNode &&
			m_pExecuteInfo->FlagCIDNotuse.bCIDUse == true)
		{
			m_bCIDNotUse = true;
			ADD_LOG("[CID] Select ON not required...4 (Current: %d, Stop(CID): %d, Reset(CID): %d, Stop(OCS): %d, Reset(OCS): %d", 
				Info->tmpCurrentNodeID, Info->tmpStopNode1, Info->tmpResetNode1,
				CID_NearestStopNode, CID_NearestResetNode);
			return CID_DIRECTION_NOT_LINK;
		}
		else if (Info->tmpStopNode1 != CID_NearestStopNode ||
			Info->tmpResetNode1 != CID_NearestResetNode)
		{
			static int nTmpCurNodeId1704124 = 0;
			if(nTmpCurNodeId1704124 != Info->tmpCurrentNodeID)
			{
				nTmpCurNodeId1704124 = Info->tmpCurrentNodeID;
				ADD_LOG("[CID] Reset Node Info from CID Map and OCS are different..(Current: %d, Stop(CID): %d, Reset(CID): %d, Stop(OCS): %d, Reset(OCS): %d",
					Info->tmpCurrentNodeID, Info->tmpStopNode1, Info->tmpResetNode1,
					CID_NearestStopNode, CID_NearestResetNode);
			}
			m_bCIDNotUse = false;
			return CID_DIRECTION_NOT_LINK;
		}
		else
		{
			m_bCIDNotUse = false;
			ADD_LOG("[CID] CID_Direction_Chk, [LEFT COMMON] else case");
			return CID_DIRECTION_NOT_LINK;
		}
	}
	else
	{
		//m_pExecuteInfo->FlagCIDNotuse.bCIDUse == true 인 경우 모두 else로 진입 함...
		//m_bCIDNotUse = false로 변경하는게 맞는지...
		
		static int nTmpCurNodeId15 = 0;
		if(nTmpCurNodeId15 != Info->tmpCurrentNodeID)
		{
			nTmpCurNodeId15 = Info->tmpCurrentNodeID;
			ADD_LOG("[CID] CID_Direction_Chk : NOT_LINK");
			ADD_LOG("current node: %d, next node: %d", Info->tmpCurrentNodeID, Info->tmpNextNodeID);
			ADD_LOG("stop node1: %d, stop node2: %d,", Info->tmpStopNode1, Info->tmpStopNode2);
			ADD_LOG("reset node1: %d, reset node2: %d,", Info->tmpResetNode1, Info->tmpResetNode2);
			ADD_LOG("start node1_1: %d, start node1_2: %d,", Info->tmpStartNode1_1, Info->tmpStartNode1_2);
			ADD_LOG("start node2_1: %d, start node2_2: %d,", Info->tmpStartNode2_1, Info->tmpStartNode2_2);
			ADD_LOG("m_pExecuteInfo->FlagCIDNotuse.bCIDUse: %d", m_pExecuteInfo->FlagCIDNotuse.bCIDUse);
			ADD_LOG("CIDStartNode1_arr:%d, CIDStartNode2_arr:%d, CIDResetNode_arr:%d, CIDResetNodeType: %d" , Info->CIDStartNode1_arr, Info->CIDStartNode2_arr, Info->CIDResetNode_arr, Info->CIDResetNodeType);
			ADD_LOG("CIDNotuse.nStopNodeID : %d, CIDNotuse.nResetNodeID : %d",CID_NearestStopNode, CID_NearestResetNode);
		}
		m_bCIDNotUse = false;
		return CID_DIRECTION_NOT_LINK;
	}

}
/**
@brief   CID link 시작이 안되는 경우 100ms에 해당하는 거리로 변환하는 함수.
@author  KJD
@date    2017.01.09
*/

int DrivingControl::CID_Comm_Time2Dist(CID_CTRL_INFO* Info)
{
	int rDist=0;
	int NodeIndex = 0;
	NodeIndex = OHTMainForm->GetMap()->FindNodeIndex(Info->tmpCurrentNodeID);
	if(Info->tmpNextNodeID == OHTMainForm->GetMap_STD()->m_NodeArray[NodeIndex].LeftNodeID)
	{
		rDist = OHTMainForm->GetMap_STD()->m_NodeArray[NodeIndex].LeftNodeSpeed * 0.1;
	}
	else if(OHTMainForm->GetMap_STD()->m_NodeArray[NodeIndex].RightNodeID)
	{
		rDist = OHTMainForm->GetMap_STD()->m_NodeArray[NodeIndex].RightNodeSpeed * 0.1;
	}
	else
	{
		// node 정보를 못찾거나 한 경우
		// 3.3m/s 로 기준으로 정의
		// 5m/s 구간도 CID 합류 부는 3.3ms로 설정됨..
		rDist = 330;
	}
	if(Info->CIDResetNode == Info->tmpCurrentNodeID)
	{
		rDist += 200;//공용태그 간격 보상
	}
	return rDist;
}

/**
@brief   CID 관련 제어를 위한 함수
@author  Kunjin
@date    2016.11.23
*/
int DrivingControl::controlCID(CID_CTRL_INFO* Info, executeCID_CMD iCmd, DRIVING_INFO_SET *pInfoSet, DRIVING_HW_INFO_SET HwInfo)
{
	int nError = NO_ERR;
	static unsigned char CID_NotLinkCount = 0;
	static unsigned char CID_SendForStatusCount = 0;
	static bool bResumedbyOCS = false;//임시 생성 - 실제 OCS 결과 값 받아오는 경우 처리 이전 사용
	static unsigned int ResumedbyOCS_count = 0;//임시 생성 - delay 생성을 위해 link 신호 수신 전 식간 확보
	static unsigned int CID_ResetNode = 0;
	static unsigned int CID_StopNode = 0;
	static int CID_NearestResetNode = 0;
	static int CID_NearestStopNode = 0;
	unsigned int CIDResetNode_arr = INDEX_NONE;
	static int CID_Occup_Count = 0;	//동일 경로 작업 변경시 Occup 반납 Count
	static int CID_Occup_Release_Status = 0;	//동일 경로 작업 변경시 Occup 반납 유무 상태  0: 초기값, 1 : 점유 반납 후 동작
	static int CID_Status_Check = 0;  // CID 상태 보고 보고 완료시 1

	double  dSpeedOfNow = pInfoSet->HwInfo.Axis1.dSpeed;
												//CID-R 자체 delay 30ms oht 2cycle? max 62ms?
	// Status bit check 후 On 이면, CID 상태 정보 취득///////////
//	CID_R_Status_Chk();

	////////////////////////////////////////////////


	static int nLinkFailureCount = 0;

	// 1. Link 여부 확인(확인용... disconnected의 경우 CID-O에서 auto retry)
	if ((pHWSet->m_pCID->IsLinking() == true && m_bInitialLink == true)
		&& ((pHWSet->m_pCID->IsLinkOK() == false && m_nCidControlStep != CID_STEP_COMPLETION && m_nCidControlStep != CID_STEP_CONNECTING)
			|| (pHWSet->m_pCID->IsLinkOK() == false && m_nCidControlStep == CID_STEP_COMPLETION && m_CIDComptTryFlag == false)))
	{
		if (nLinkFailureCount > 10)
		{
			ERR_LOG("[CID] Critical Connection Lost...(Step : %d), Current Node : %d)",m_nCidControlStep, Info->tmpCurrentNodeID);
			m_bLinkDisconnected = true;
			m_nCidControlStep = CID_STEP_ABNORMAL;
		}
		else
			nLinkFailureCount++;
	}
	else
	{
		// Do nothing
		nLinkFailureCount = 0;
		//ADD_LOG("[CID] Connection Not Available...(Step : m_nCidControlStep), Current Node : %d)", Info->tmpCurrentNodeID);
	}

	// 2. 작업 변경 시 CID-O 제어

	if (m_CIDOperationStarted == true &&
//	   (CID_ResetNode != CID_NearestResetNode) && //ResetNodeID가 변경된 경우에만 작업변경.
		(((m_pExecuteInfo->bChangeResult == true || m_job_change_flag_no_cid_area == true) && m_nCidControlStep == CID_STEP_COMPLETION && m_CIDComptTryFlag == false)  // 작업 변경 Flag On 필요
		|| ((m_pExecuteInfo->bChangeResult == true || m_job_change_flag_no_cid_area == true) && m_nCidControlStep != CID_STEP_COMPLETION && m_nCidControlStep != CID_STEP_CONNECTING)))
	{
		CID_Find_Stop_Reset(1, HwInfo, &CID_NearestStopNode, &CID_NearestResetNode);
		//Stopnode에서 작업 변경인 경우
		//ResetNode 변경이 없는 경우 작업 변경 무시 처리
		if((Info->CIDStopNode1 == Info->tmpCurrentNodeID || Info->CIDStopNode2 == Info->tmpCurrentNodeID)
		&& (CID_ResetNode == CID_NearestResetNode))
		{
			m_pExecuteInfo->bChangeResult = false;
			static int nTmpCurNodeId1025 = 0;
			if(nTmpCurNodeId1025 != Info->tmpCurrentNodeID)
			{
				nTmpCurNodeId1025 = Info->tmpCurrentNodeID;
				ADD_LOG("[CID] 작업변경 무시 m_pExecuteInfo->bChangeResult = false..");
				//ADD_LOG("[CID_Test] %d, %d", CID_ResetNode, CID_NearestResetNode);
			}
		}
		if(m_pExecuteInfo->bChangeResult == true)
		{
			if(CID_ResetNode != CID_NearestResetNode && CID_NearestResetNode != 0)//ResetNodeID가 변경된 경우에만 작업변경.
			{
				//kyh Link 되기전에 작업변경 시 확인 조건 추가
				if(pHWSet->m_pCID->IsLinking() == true && pHWSet->m_pCID->IsLinkOK() == false && bResumedbyOCS == false
					&& (m_nCidControlStep == CID_STEP_CHECKING_PATH || m_nCidControlStep == CID_STEP_WAITING_FOR_PATH))
				{
					static int nTmpCurNodeId19100101 = 0;
					if(nTmpCurNodeId19100101 != Info->tmpCurrentNodeID)
					{
						nTmpCurNodeId19100101 = Info->tmpCurrentNodeID;
						ADD_LOG("[CID] 작업변경1 Link 대기 %d, %d", CID_ResetNode, CID_NearestResetNode);
					}
				}
				else
				{
					if(m_bLinkFail == true && m_CID_Pause == true && pHWSet->m_pCID->IsLinkOK() == true)  //kyh DecelStop 이후 Link 되었을때 처리
					{
						m_bLinkFail = false;

						pHWSet->m_pCID->CID_Occup_Resume(&m_CID_Pause);
						ADD_LOG("[CID] 작업변경1 Pause Released");
						m_pExecuteInfo->FlagCIDReport.bCIDStop = false;
						bResumedbyOCS = false;
					}

					ADD_LOG("[CID] 작업변경1 %d, %d", CID_ResetNode, CID_NearestResetNode);
					DRIVING_CMD_INFO_OF_NODE* pPreNodeInfo = getNodeInfo(pInfoSet->HwInfo.Node.nPreCheckCount);

					int nCurrentNodeID;
					if(pPreNodeInfo != NULL)
					{
						nCurrentNodeID = (int)pPreNodeInfo->ID;
					}
					else
					{
						nCurrentNodeID = (int)m_PositionInfo.CurrNode;
					}
					getCID_Info(Info, nCurrentNodeID);


					CID_DIRECTION tempCIDDirection = CID_DIRECTION_NOT_LINK;
						//CID_Find_Stop_Reset(HwInfo, &CID_NearestStopNode, &CID_NearestResetNode);
						tempCIDDirection = CID_Direction_Chk(Info, pInfoSet, CID_NearestResetNode, CID_NearestStopNode);

					//진행 방향이 변경 된 경우만 완료 처리
					if ((m_CIDDirection != tempCIDDirection)
						&& (m_CIDDirection != CID_DIRECTION_NOT_LINK))
						//&& (tempCIDDirection != CID_DIRECTION_NOT_LINK))
					{
						// Select Off 전 완료 처리 후 COMPLETION step으로 이동
						pHWSet->m_pCID->CID_Occup_compt(4); // 통과 완료 bit ON
						m_CIDComptTryFlag = true;
						Sleep(20);
						if(pHWSet->m_pCID->ISCompletion_On() == false)
						{
							ADD_LOG("[CID] CID_Occup_compt(5).. Completion_Not_ON");
							pHWSet->m_pCID->CID_Occup_compt(5); // 통과 완료 bit ON
							Sleep(20);
						}
						if(pHWSet->m_pCID->ISCompletionACK_On() == false)
						{
							ADD_LOG("[CID] CID_Occup_compt(5).. ACK delay");
							nEnforcedSelectOffNodeID = CID_NearestResetNode;
							//Sleep(20);  //Sleep제거
						}

						m_nCidControlStep = CID_STEP_COMPLETION;
						//tempCIDDirection = CID_DIRECTION_NOT_LINK;
						//link 안된 경우 작업 변경 처리 조건 추가
						if(pHWSet->m_pCID->IsLinkOK() == false)
						{
							m_job_change_without_link_complete = true;
						}

						if(m_pExecuteInfo->FlagCIDReport.bCIDStop == true)
						{
							//m_pExecuteInfo->FlagCIDReport.bCIDStop = false;
							ADD_LOG("[CID] 추가 필요 ??  m_pExecuteInfo->FlagCIDReport.bCIDStop = false;..");
						}
						ADD_LOG("[CID] Direction changed..");

						//작업 변경 관련 Flag 처리
						//m_bJobChange = false;
						m_pExecuteInfo->bChangeResult = false;    //false 시점 확인
						m_job_change_flag_no_cid_area = false;
						if (Info->tmpPreNodeID == m_tmpCurrentResetNode && Info->CIDResetNodeType == Common_Reset_tag)
						{
							m_job_change_flag_exception_CommonTag = false; // kyh Common CID 처리
						}
						else
						{
							m_job_change_flag_exception_CommonTag = true; // kyh Common CID 미처리
						}

						ADD_LOG("[CID] Path changed..");
						ADD_LOG("[CID] curr: %d, next: %d, stop1: %d, stop2:%d, reset1: %d, reset2: %d", Info->tmpCurrentNodeID, Info->tmpNextNodeID, Info->tmpStopNode1, Info->tmpStopNode2, Info->tmpResetNode1, Info->tmpResetNode2);
						ADD_LOG("[CID] tmpDir: %d, m_CIDDir: %d", tempCIDDirection, m_CIDDirection);
							//ADD_LOG("[CID] executeInfo_stop: %d, executeInfo_reset: %d", m_pExecuteInfo->FlagCIDNotuse.nStopNodeID, m_pExecuteInfo->FlagCIDNotuse.nResetNodeID);
					}

					else
					{
						//ADD_LOG("[CID] 연속 출력시, 작업변경 조건 안 맞아 대기 중..");//작업변경 플래그 처리 필요 확인!! m_pExecuteInfo->bChangeResult

						if (!((Info->tmpCurrentNodeID == Info->tmpStartNode2_1)	||(Info->tmpCurrentNodeID == Info->tmpStartNode2_2)
						||(Info->tmpCurrentNodeID == Info->tmpStartNode2_3)	||(Info->tmpCurrentNodeID == Info->tmpStartNode2_4)
						||(Info->tmpCurrentNodeID == Info->tmpStartNode2_5)	||(Info->tmpCurrentNodeID == Info->tmpResetNode2)

						||(Info->tmpCurrentNodeID == Info->tmpStartNode1_1)	||(Info->tmpCurrentNodeID == Info->tmpStartNode1_2)
						||(Info->tmpCurrentNodeID == Info->tmpStartNode1_3)	||(Info->tmpCurrentNodeID == Info->tmpStartNode1_4)
						||(Info->tmpCurrentNodeID == Info->tmpStartNode1_5)	||(Info->tmpCurrentNodeID == Info->tmpResetNode1)))
						{
							pHWSet->m_pCID->CID_Occup_compt(6); // 통과 완료 bit ON
							m_CIDComptTryFlag = false;

							m_nCidControlStep = CID_STEP_CONNECTING;
							// tempCIDDirection = CID_DIRECTION_NOT_LINK;
							ADD_LOG("[CID] Direction .....Disconnect..");

						}
						static int nTmpCurNodeId21 = 0;
						if(nTmpCurNodeId21 != Info->tmpCurrentNodeID)
						{
							nTmpCurNodeId21 = Info->tmpCurrentNodeID;
							ADD_LOG("[CID] Path is same before/after re-routing..");
							ADD_LOG("[CID] curr: %d, next: %d, stop1: %d, stop2:%d, reset1: %d, reset2: %d", Info->tmpCurrentNodeID, Info->tmpNextNodeID, Info->tmpStopNode1, Info->tmpStopNode2, Info->tmpResetNode1, Info->tmpResetNode2);
							ADD_LOG("[CID] tmpDir: %d, m_CIDDir: %d", tempCIDDirection, m_CIDDirection);
								//ADD_LOG("[CID] executeInfo_stop: %d, executeInfo_reset: %d", m_pExecuteInfo->FlagCIDNotuse.nStopNodeID, m_pExecuteInfo->FlagCIDNotuse.nResetNodeID);
						}
						//작업 변경 Flag set 이후 바로 신규 경로가 들어오지는 않음...
						//m_pExecuteInfo->bChangeResult = false;    //false 시점 확인
						//m_job_change_flag_no_cid_area = false;
					}
				}
			}
			else if(CID_NearestResetNode == 0)//ResetNodeID가 0인 경우 처리 : 점유만 반납
			{
				static int nTmpCurNodeId01500 = 0;
				if(nTmpCurNodeId01500 != Info->tmpCurrentNodeID)
				{
					nTmpCurNodeId01500 = Info->tmpCurrentNodeID;
					ADD_LOG("[CID] 작업변경 0_1 Reset : %d, Nearest : %d, tmpCurrent : %d, tmpNext : %d", CID_ResetNode, CID_NearestResetNode, Info->tmpCurrentNodeID, Info->tmpNextNodeID);
					ADD_LOG("[CID] 작업변경 0_2 Stop : %d, Reset : %d, Stop : %d, Reset : %d )", Info->CIDStopNode1, Info->CIDResetNode1, Info->CIDStopNode2, Info->CIDResetNode2);
				}
				static int nTmpCurNodeId01501 = 0;
				if(nTmpCurNodeId01501 != Info->tmpNextNodeID)
				{
					nTmpCurNodeId01501 = Info->tmpNextNodeID;
					ADD_LOG("[CID] 작업변경 0_1 Reset : %d, Nearest : %d, tmpCurrent : %d, tmpNext : %d", CID_ResetNode, CID_NearestResetNode, Info->tmpCurrentNodeID, Info->tmpNextNodeID);
					ADD_LOG("[CID] 작업변경 0_2 Stop : %d, Reset : %d, Stop : %d, Reset : %d )", Info->CIDStopNode1, Info->CIDResetNode1, Info->CIDStopNode2, Info->CIDResetNode2);
				}

				int nCurrentNodeID = (int)m_PositionInfo.CurrNode;
				getCID_Info(Info, nCurrentNodeID);

				/*
				int FindStopNodeID;
				int FindResetNodeID;

				CID_Find_Stop_Reset_Change(4, HwInfo, &FindStopNodeID, &FindResetNodeID, 1);

				if(((Info->tmpNextNodeID != 0) || (Info->tmpNextNodeID != Info->tmpCurrentNodeID)) && //Stop Node 정지상태가 아닐때
					((((Info->tmpCurrentNodeID == Info->CIDStopNode1) || (Info->tmpCurrentNodeID == Info->tmpStartNode1_1) || (Info->tmpCurrentNodeID == Info->tmpStartNode1_2) || (Info->tmpCurrentNodeID == Info->tmpStartNode1_3) || (Info->tmpCurrentNodeID == Info->tmpStartNode1_4)) && (Info->tmpNextNodeID != Info->CIDResetNode1)) ||
					((Info->tmpCurrentNodeID == Info->CIDStopNode2) || (Info->tmpCurrentNodeID == Info->tmpStartNode2_1) || (Info->tmpCurrentNodeID == Info->tmpStartNode2_2) || (Info->tmpCurrentNodeID == Info->tmpStartNode2_3) || (Info->tmpCurrentNodeID == Info->tmpStartNode2_4) && (Info->tmpNextNodeID != Info->CIDResetNode2))))
					//CID 영역이 아닌 곳으로 작업변경이 왔을때
				*/

				if (CID_Compare_List(HwInfo) == true)
				{
					//kyh Link 되기전에 작업변경 시 확인 조건 추가
					if(pHWSet->m_pCID->IsLinking() == true && pHWSet->m_pCID->IsLinkOK() == false && bResumedbyOCS == false
						&& (m_nCidControlStep == CID_STEP_CHECKING_PATH || m_nCidControlStep == CID_STEP_WAITING_FOR_PATH))
					{
						static int nTmpCurNodeId19100102 = 0;
						if(nTmpCurNodeId19100102 != Info->tmpCurrentNodeID)
						{
							nTmpCurNodeId19100102 = Info->tmpCurrentNodeID;
							ADD_LOG("[CID] 작업변경0_3 Link 대기 %d, %d, %d, %d", CID_ResetNode, CID_NearestResetNode, Info->tmpCurrentNodeID, Info->tmpNextNodeID);
                    	}
					}
					else
					{
						if((m_bLinkFail == true && m_CID_Pause == true && pHWSet->m_pCID->IsLinkOK() == true) || (bResumedbyOCS == true)) //kyh DecelStop 이후 Link || 주행재개 처리
						{
							m_bLinkFail = false;

							pHWSet->m_pCID->CID_Occup_Resume(&m_CID_Pause);
							ADD_LOG("[CID] 작업변경0_3 Pause Released");
							m_pExecuteInfo->FlagCIDReport.bCIDStop = false;
							bResumedbyOCS = false;
						}

						ADD_LOG("[CID] 작업변경0_3 Reset : %d, Nearest : %d, tmpCurrent : %d, tmpNext : %d", CID_ResetNode, CID_NearestResetNode, Info->tmpCurrentNodeID, Info->tmpNextNodeID);

						CID_DIRECTION tempCIDDirection = CID_DIRECTION_NOT_LINK;
						//CID_Find_Stop_Reset(HwInfo, &CID_NearestStopNode, &CID_NearestResetNode);
						tempCIDDirection = CID_Direction_Chk(Info, pInfoSet, CID_NearestResetNode, CID_NearestStopNode);
						//진행 방향이 변경 된 경우만 완료 처리
						if ((m_CIDDirection != tempCIDDirection)
							&& (m_CIDDirection != CID_DIRECTION_NOT_LINK))
							//&& (tempCIDDirection != CID_DIRECTION_NOT_LINK))
						{
							// Select Off 전 완료 처리 후 COMPLETION step으로 이동
							pHWSet->m_pCID->CID_Occup_compt(12); // 통과 완료 bit ON
							m_CIDComptTryFlag = true;
							Sleep(20);
							if(pHWSet->m_pCID->ISCompletion_On() == false)
							{
								ADD_LOG("[CID] CID_Occup_compt(13).. Completion_Not_ON");
								pHWSet->m_pCID->CID_Occup_compt(13); // 통과 완료 bit ON
								Sleep(20);
							}
							if(pHWSet->m_pCID->ISCompletionACK_On() == false)
							{
								ADD_LOG("[CID] CID_Occup_compt(13).. ACK delay");
								nEnforcedSelectOffNodeID = CID_NearestResetNode;
								//Sleep(20);  //Sleep제거
							}

							m_nCidControlStep = CID_STEP_COMPLETION;
							// tempCIDDirection = CID_DIRECTION_NOT_LINK;
							// link 안된 경우 작업 변경 처리 조건 추가
							if(pHWSet->m_pCID->IsLinkOK() == false)
							{
								m_job_change_without_link_complete = true;
							}

							if(m_pExecuteInfo->FlagCIDReport.bCIDStop == true)
							{
								//m_pExecuteInfo->FlagCIDReport.bCIDStop = false;
								ADD_LOG("[CID] 추가 필요 ??  m_pExecuteInfo->FlagCIDReport.bCIDStop = false;..");
							}
							ADD_LOG("[CID] Direction changed..");

							//작업 변경 관련 Flag 처리
							//m_bJobChange = false;
							m_pExecuteInfo->bChangeResult = false;    //false 시점 확인
							m_job_change_flag_no_cid_area = false;
							if (Info->tmpPreNodeID == m_tmpCurrentResetNode && Info->CIDResetNodeType == Common_Reset_tag)
							{
								m_job_change_flag_exception_CommonTag = false; // kyh Common CID 처리
							}
							else
							{
								m_job_change_flag_exception_CommonTag = true; // kyh Common CID 미처리
							}
						}
					}
				}
			}
		}
	}
	else if (m_CIDOperationStarted == false && m_pExecuteInfo->bChangeResult == true)
	{
		//CID 구간 진입 전 작업 변경으로 진행 방향이 변경된 경우 CID 방향을 검사할 기준이 없음..
		//m_job_change_flag_no_cid_area로 진입 전 작업 변경 설정..
		//m_pExecuteInfo->bChangeResult = false 하면 안됨..

		//before
		//m_pExecuteInfo->bChangeResult = false;
		//after
		m_job_change_flag_no_cid_area = true;
		static int nTmpCurNodeId01031 = 0;
		if(nTmpCurNodeId01031 != Info->tmpCurrentNodeID)
		{
			nTmpCurNodeId01031 = Info->tmpCurrentNodeID;
			ADD_LOG("[CID] Job change bit set before CID area...");
		}
	}

	// bChangeResult에 의한 처리가 되지 않은 경우
	// Stop Tag에서 Next Node가 현재 동작 중인 CID-O의 방향과 다른 경우 완료 처리 후 CID-O 방향 전환
	else if ( m_CIDOperationStarted == true && m_pExecuteInfo->bChangeResult == false && m_CIDComptTryFlag == false)
	{

		// Right에서 Left로 전환이 필요한 겅우
		if ((pHWSet->m_pCID->IsLinking_Right() == true && pHWSet->m_pCID->IsLinking_Left() == false
			&& Info->CIDResetNode_arr == INDEX_NONE && Info->CIDStopNode1_arr != INDEX_NONE
			&& Info->tmpNextNodeID == Info->CIDResetNode1 && Info->tmpNextNodeID != 0
			&& Info->CIDStopNode2 != 0)
			||
		// Left에서 Right로 전환이 필요한 겅우
			(pHWSet->m_pCID->IsLinking_Left() == true && pHWSet->m_pCID->IsLinking_Right() == false
			&& Info->CIDResetNode_arr == INDEX_NONE && Info->CIDStopNode2_arr != INDEX_NONE
			&& Info->tmpNextNodeID == Info->CIDResetNode2 && Info->tmpNextNodeID != 0
			&& Info->CIDStopNode1 != 0))
		{
			pHWSet->m_pCID->CID_Occup_compt(7); // 통과 완료 bit ON
			m_CIDComptTryFlag = true;

			m_nCidControlStep = CID_STEP_COMPLETION;
//			tempCIDDirection = CID_DIRECTION_NOT_LINK;
			ADD_LOG("[CID] CID Direction and Path Direction are different...");
			ADD_LOG("[CID] CurrentID: %d, NextID: %d", Info->tmpCurrentNodeID, Info->tmpNextNodeID);
		}
	}


/*
	if(m_pExecuteInfo->bChangeResult == true)
	{
		ADD_LOG("[CID] set bChangeResult = false..");
		ADD_LOG("m_nCidControlStep = %d, m_CIDComptTryFlag : %d",m_nCidControlStep, m_CIDComptTryFlag);

		m_pExecuteInfo->bChangeResult = false;
	}
*/


	if(m_Continue_CID_MODE)
	{
		m_Continue_CID_MODE=0;
		m_CIDOperationStarted = true;
		nEnforcedSelectOffNodeID = 0;
		ResumedbyOCS_count = 0;
		CID_NotLinkCount = 0;
		CID_SendForStatusCount = 0;
		m_pExecuteInfo->FlagCIDReport.bCIDInterlock = false;
		m_pExecuteInfo->FlagCIDReport.bCIDStop= false;
		m_nCIDTerminateCount = 0;
		// 완료 처리해야 할 Reset Node (2016.12.14)
		m_tmpCurrentResetNode = m_Continue_CID_MODE_ResetNode;
		//m_tmpCurrentStopNode = ?;//필요한가 ??
		Info->tmpCurrentResetNodeType = m_Continue_CID_MODE_ResetNodeType;

		m_Diag_CID_index = (m_Diag_CID_index+1) & 0x7;
		
		m_Diag_ResetNode[m_Diag_CID_index] = m_tmpCurrentResetNode;
		m_Diag_StopNode[m_Diag_CID_index] = m_tmpCurrentStopNode;
		int tmp_index = OHTMainForm->GetMap()->FindNodeIndexFromCIDReset(m_tmpCurrentResetNode);
		if(tmp_index != INDEX_NONE)
		{
			memcpy(m_Diag_CID_R_ID[m_Diag_CID_index], OHTMainForm->GetCID_STD()->m_NodeArray[tmp_index].LayoutID, 6);
			ADD_LOG("[CID] CID Monitoring Input LH m_Diag_CID_R_ID : %c%c%c%c%c%c, Reset: %d, Stop: %d, m_Diag_CID_index : %d",
			m_Diag_CID_R_ID[m_Diag_CID_index][0], m_Diag_CID_R_ID[m_Diag_CID_index][1], m_Diag_CID_R_ID[m_Diag_CID_index][2],
			m_Diag_CID_R_ID[m_Diag_CID_index][3], m_Diag_CID_R_ID[m_Diag_CID_index][4], m_Diag_CID_R_ID[m_Diag_CID_index][5], m_Diag_ResetNode[m_Diag_CID_index], m_Diag_StopNode[m_Diag_CID_index], m_Diag_CID_index);
		}
		m_bInitialLink = true;
		
	}

	// 3. CID Step(Connecting, Checking, Occupying, Waiting, Completion, Abnormal)
	switch(m_nCidControlStep)
	{
	// CID-O, CID-R Connection을 위한 Step
	case CID_STEP_CONNECTING:
        //최종 목적지가 현재 노드인 경우 CID 동작을 안하기 위함.

		m_CIDOperationStarted = true;
		nEnforcedSelectOffNodeID = 0;
		ResumedbyOCS_count = 0;
		CID_NotLinkCount = 0;
		CID_SendForStatusCount = 0;
		m_pExecuteInfo->FlagCIDReport.bCIDInterlock = false;
		m_pExecuteInfo->FlagCIDReport.bCIDStop = false;
		m_CIDPauseTime = 0;
		m_job_change_flag_exception_CommonTag = false;
		m_job_change_without_link_complete = false;
		CID_NearestResetNode = 0;
		CID_NearestStopNode = 0;
		CID_Occup_Count = 0;
		CID_Occup_Release_Status = 0;
		CID_Status_Check = 0;
		memset(&CID_Save_Node, 0, sizeof(CID_Save_Node));
		
		//tmpPreNodeID is ResetTag, tmpCurrentNodeID is StopTag 이면 완료 상태.
		if(Info->CIDResetNode_Pre_arr != INDEX_NONE)
		{
			if(Info->tmpPreNodeID == OHTMainForm->GetCID_STD()->m_NodeArray[Info->CIDResetNode_Pre_arr].ResetNode 
				&& Info->tmpCurrentNodeID != Info->tmpPreNodeID
				&& (Info->tmpCurrentNodeID == Info->CIDStopNode1 || Info->tmpCurrentNodeID == Info->CIDStopNode2))
			{
//				ADD_LOG("[CID] CID_STEP_CONNECTING, Info->tmpPreNodeID : %d, Info->tmpCurrentNodeID %d", Info->tmpPreNodeID, Info->tmpCurrentNodeID);
				break;
			}
		}
		
		if(Info->tmpCurrentNodeID == Info->tmpStartNode1_1 || Info->tmpCurrentNodeID == Info->tmpStartNode2_1)
		{
			m_CurrCIDStartnode = Info->tmpCurrentNodeID;
			static int nTmpCurNodeId01093 = 0;
			if(nTmpCurNodeId01093 != Info->tmpCurrentNodeID)
			{
				nTmpCurNodeId01093 = Info->tmpCurrentNodeID;
				ADD_LOG("[CID] m_CurrCIDStartnode: %d", m_CurrCIDStartnode);
			}
		}

		IO_INFO_CID();
		m_nCIDTerminateCount = 0;
		// Output, Input 초기화(All off) 여부 확인
		// if (pHWSet->m_pCID->IsOutputAllOff() == true && pHWSet->m_pCID->IsInputAllOff() == true)

		CID_Find_Stop_Reset(2, HwInfo, &CID_NearestStopNode, &CID_NearestResetNode);
		m_CIDDirection = CID_Direction_Chk(Info, pInfoSet, CID_NearestResetNode, CID_NearestStopNode);

		CID_Save_Start_Stop_Reset(Info); // CID Select ON 할때 위치값 저장

		// CID Slope 처리
#if 0
		// Stop node 기준 CID LayoutType이 Slope 이면, Stop node 기준 방향으로 설정 하여 CID 동작 하도록 함.
		if(Info->LayoutType_Stop1 == CID_LAYOUT_TYPE_SLOPE || Info->LayoutType_Stop2 == CID_LAYOUT_TYPE_SLOPE)
		{
			if(Info->CIDStopNode1_arr != INDEX_NONE && Info->tmpCurrentNodeID == Info->CIDStopNode1)
			{
				m_CIDDirection = CID_DIRECTION_LEFT;
				ADD_LOG("[CID] Slope CID_DIRECTION_LEFT");
			}
			else if(Info->CIDStopNode2_arr != INDEX_NONE && Info->tmpCurrentNodeID == Info->CIDStopNode2)
			{
				m_CIDDirection = CID_DIRECTION_RIGHT;
				ADD_LOG("[CID] Slope CID_DIRECTION_RIGHT");
			}
			else
			{
				m_CIDDirection = CID_DIRECTION_NOT_LINK;
				ADD_LOG("[CID] Slope CID_DIRECTION_NOT_LINK");
			}
		}
#endif
			
		if((pHWSet->m_pCID->IsLinking() == false)&&(pHWSet->m_pCID->IsLinkOK() == false))
		{
			// Select On(LEFT)
			if (m_CIDDirection == CID_DIRECTION_LEFT || m_CIDDirection == CID_DIRECTION_COMMON_LEFT)
			{

				static int nTmpCurNodeId14 = 0;
				if(nTmpCurNodeId14 != Info->tmpCurrentNodeID)
				{
					nTmpCurNodeId14 = Info->tmpCurrentNodeID;
					ADD_LOG("[CID] curr: %d, next: %d, stop1:%d, reset1: %d", Info->tmpCurrentNodeID, Info->tmpNextNodeID, Info->tmpStopNode1, Info->tmpResetNode1);
					ADD_LOG("[CID] executeInfo_stop: %d, executeInfo_reset: %d, CIDNotUse: %d", m_pExecuteInfo->FlagCIDNotuse.nStopNodeID, m_pExecuteInfo->FlagCIDNotuse.nResetNodeID, m_pExecuteInfo->FlagCIDNotuse.bCIDUse);
				}
				// OCS로부터 CID-R 비정상 상태 정보 취득
				// 해당 CID-R의 Stop Node ID와 Reset Node ID를 통과 예정인 Stop/Reset Node ID와 비교

				{

					// 완료 처리해야 할 Reset Node (2016.12.14)
					m_tmpCurrentResetNode = Info->tmpResetNode1;
					m_tmpCurrentStopNode = Info->tmpStopNode1;
					Info->tmpCurrentResetNodeType = Info->tmpResetNodeType1;

					m_Diag_CID_index = (m_Diag_CID_index+1) & 0x7;
					
					m_Diag_ResetNode[m_Diag_CID_index] = m_tmpCurrentResetNode;
					m_Diag_StopNode[m_Diag_CID_index] = m_tmpCurrentStopNode;
					
					int tmp_index = OHTMainForm->GetMap()->FindNodeIndexFromCIDReset(m_tmpCurrentResetNode);
					if(tmp_index != INDEX_NONE)
					{
						memcpy(m_Diag_CID_R_ID[m_Diag_CID_index], OHTMainForm->GetCID_STD()->m_NodeArray[tmp_index].LayoutID, 6);
						ADD_LOG("[CID] CID Monitoring Input LH m_Diag_CID_R_ID : %c%c%c%c%c%c, Reset: %d, Stop: %d, m_Diag_CID_index : %d",
						m_Diag_CID_R_ID[m_Diag_CID_index][0], m_Diag_CID_R_ID[m_Diag_CID_index][1], m_Diag_CID_R_ID[m_Diag_CID_index][2],
						m_Diag_CID_R_ID[m_Diag_CID_index][3], m_Diag_CID_R_ID[m_Diag_CID_index][4], m_Diag_CID_R_ID[m_Diag_CID_index][5], m_Diag_ResetNode[m_Diag_CID_index], m_Diag_StopNode[m_Diag_CID_index], m_Diag_CID_index);
					}					

					if((m_CIDDirection == CID_DIRECTION_COMMON_LEFT) && (m_PositionInfo.CurrNodeOffset < 200))
					{
						ADD_LOG("[CID] Select_ON_Left!!!!!!!!!");
                    }
					else
					{
						pHWSet->m_pCID->Left_Link();
						m_ntempNodeOffset = m_PositionInfo.CurrNodeOffset;

						if(Info->tmpCurrentNodeID == Info->tmpStartNode1_1)
							m_CID_Offet_Target = Info->CommStartNode1_Offset;
						m_nCidControlStep = CID_STEP_CHECKING_PATH;

						//작업 변경 시 사용.
						CID_ResetNode = CID_NearestResetNode;
						
						ADD_LOG("[CID] Select_ON_Left(Step:CID_STEP_CONNECTING, Current Node : %d, Offset: %d )", Info->tmpCurrentNodeID, m_CID_Offet_Target);
                    	m_mccparam.dwCIDLinkOnTime = timeGetTime();
					}
				}
			}
			// Select On(RIGHT)
			else if ((m_CIDDirection == CID_DIRECTION_RIGHT) || (m_CIDDirection == CID_DIRECTION_COMMON_RIGHT))
			{
				// OCS로부터 CID-R 비정상 상태 정보 취득
				// 해당 CID-R의 Stop Node ID와 Reset Node ID를 통과 예정인 Stop/Reset Node ID와 비교
				static int nTmpCurNodeId15 = 0;
				if(nTmpCurNodeId15 != Info->tmpCurrentNodeID)
				{
					nTmpCurNodeId15 = Info->tmpCurrentNodeID;
					ADD_LOG("[CID] curr: %d, next: %d, stop2:%d, reset2: %d", Info->tmpCurrentNodeID, Info->tmpNextNodeID, Info->tmpStopNode2, Info->tmpResetNode2);
					ADD_LOG("[CID] executeInfo_stop: %d, executeInfo_reset: %d, CIDNotUse: %d", m_pExecuteInfo->FlagCIDNotuse.nStopNodeID, m_pExecuteInfo->FlagCIDNotuse.nResetNodeID, m_pExecuteInfo->FlagCIDNotuse.bCIDUse);
				}

				{

					// 완료 처리해야 할 Reset Node (2016.12.14)
					m_tmpCurrentResetNode = Info->tmpResetNode2;
					m_tmpCurrentStopNode = Info->tmpStopNode2;
					Info->tmpCurrentResetNodeType = Info->tmpResetNodeType2;

					m_Diag_CID_index = (m_Diag_CID_index+1) & 0x7;
					
					m_Diag_ResetNode[m_Diag_CID_index] = m_tmpCurrentResetNode;
					m_Diag_StopNode[m_Diag_CID_index] = m_tmpCurrentStopNode;
					int tmp_index = OHTMainForm->GetMap()->FindNodeIndexFromCIDReset(m_tmpCurrentResetNode);
					if(tmp_index != INDEX_NONE)
					{
						memcpy(m_Diag_CID_R_ID[m_Diag_CID_index], OHTMainForm->GetCID_STD()->m_NodeArray[tmp_index].LayoutID, 6);
						ADD_LOG("[CID] CID Monitoring Input RH m_Diag_CID_R_ID : %c%c%c%c%c%c, Reset: %d, Stop: %d, m_Diag_CID_index : %d",
						m_Diag_CID_R_ID[m_Diag_CID_index][0], m_Diag_CID_R_ID[m_Diag_CID_index][1], m_Diag_CID_R_ID[m_Diag_CID_index][2],
						m_Diag_CID_R_ID[m_Diag_CID_index][3], m_Diag_CID_R_ID[m_Diag_CID_index][4], m_Diag_CID_R_ID[m_Diag_CID_index][5], m_Diag_ResetNode[m_Diag_CID_index], m_Diag_StopNode[m_Diag_CID_index], m_Diag_CID_index);
					}

					if((m_CIDDirection == CID_DIRECTION_COMMON_RIGHT) && (m_PositionInfo.CurrNodeOffset < 200))
					{
//						ADD_LOG("[CID] Select_ON_Right!!!!!!!!!");
					}
					else
					{
						pHWSet->m_pCID->Right_Link();
						m_ntempNodeOffset = m_PositionInfo.CurrNodeOffset;

						if(Info->tmpCurrentNodeID == Info->tmpStartNode2_1)
							m_CID_Offet_Target = Info->CommStartNode2_Offset;
						m_nCidControlStep = CID_STEP_CHECKING_PATH;

						//작업 변경 시 사용.
						CID_ResetNode = CID_NearestResetNode;
						
						ADD_LOG("[CID] Select_ON_Right(Step:CID_STEP_CONNECTING, Current Node : %d, Offset: %d )", Info->tmpCurrentNodeID, m_CID_Offet_Target);
						m_mccparam.dwCIDLinkOnTime = timeGetTime();
					}
				}
			}
			else if (m_bCIDNotUse == true)
			{
			   	m_nCidControlStep = CID_STEP_ABNORMAL;
				ADD_LOG("[CID] CID Error reported..Moving to Abnormal step..");
			}
			// No info.
			else
			{
				m_tmpCurrentResetNode = 0; 	// 추가(2016. 12. 20)
				m_tmpCurrentStopNode = 0;

				static int nTmpCurNodeId5 = 0;
				if(nTmpCurNodeId5 != Info->tmpCurrentNodeID)
				{
					nTmpCurNodeId5 = Info->tmpCurrentNodeID;
					IO_INFO_CID();
					ADD_LOG("[CID] CID Direction not found..(Step:CID_STEP_CONNECTING, Current Node : %d)", Info->tmpCurrentNodeID);
				}
			}
		}
		else
		{
			IO_INFO_CID_ALL();
			static int nTmpCurNodeId6 = 0;
			if(nTmpCurNodeId6 != Info->tmpCurrentNodeID)
			{
				nTmpCurNodeId6 = Info->tmpCurrentNodeID;
				ADD_LOG("[CID] IO Abnormally ON(Step:CID_STEP_CONNECTING, Current Node : %d)", Info->tmpCurrentNodeID);
			}

			// CID_DIRECTION_COMMON_LEFT, CID_DIRECTION_COMMON_RIGHT
			if((m_CIDDirection == CID_DIRECTION_LEFT) || (m_CIDDirection == CID_DIRECTION_RIGHT))
			{
//				pHWSet->m_pCID->CID_Out_Left_Select(OFF);
//				pHWSet->m_pCID->CID_Out_Right_Select(OFF);
				IO_INFO_CID_ALL();
			}
		}
		break;

	// CID 연결 시도 후 정보를 확인하는 step
	case CID_STEP_CHECKING_PATH:
		IO_INFO_CID();

		// 0. 한번 점유 후 점유해제 상태 처리 추가
		if(CID_Occup_Release_Status == 1)
		{
			CID_Find_Stop_Reset(3, HwInfo, &CID_NearestStopNode, &CID_NearestResetNode);
			CID_DIRECTION temp_CIDDirection = CID_Direction_Chk(Info, pInfoSet, CID_NearestResetNode, CID_NearestStopNode);
			if(CID_NearestResetNode != 0
			   && temp_CIDDirection != CID_DIRECTION_NOT_LINK
			   && (temp_CIDDirection&0x01) != (m_CIDDirection&0x01)) // 0,2: Left, 1,3: Right
			{
				// 리셋노드 0 인 상태에서 방향 변경시
				// 통과완료 처리 및 CID_STEP_CONNECTING으로 변경
				ADD_LOG("[CID] RestNdoe = 0, Direction Change");
				m_nCidControlStep = CID_STEP_CONNECTING;
				pHWSet->m_pCID->CID_Occup_compt(20);
				Sleep(20);
				pHWSet->m_pCID->TerminateCID(20);
				break;
			}
			else if(CID_NearestResetNode != 0
			   && temp_CIDDirection != CID_DIRECTION_NOT_LINK
			   && (temp_CIDDirection&0x01) == (m_CIDDirection&0x01))
			{
				// 리셋노드 0 인 상태에서 동일 방향 주행시
				ADD_LOG("[CID] RestNdoe = 0, Direction Not Change");
			}
			else
			{
				break;
			}
		}

		// 1. Link 완료 확인 후 Interlock 수신 여부 확인
		if (pHWSet->m_pCID->IsLinking() == true && pHWSet->m_pCID->IsLinkOK() == true)
		{
			m_bInitialLink = true;
			//ADD_LOG("[CID] Info->uLimitNode: %d,m_tmpCurrentResetNode :%d",Info->uLimitNode, m_tmpCurrentResetNode);
			// 1-1. Interlock 미수신한 경우
			if (m_CID_Pause == false && pHWSet->m_pCID->IsInterlock_ON() == false)
			{
				unsigned int CurrentNodeType = 0;
				unsigned int NextNodeType = 0;
		 		if((Info->tmpResetNodeType1 == Slope_Rear_Reset_tag)||(Info->tmpResetNodeType2 == Slope_Rear_Reset_tag))
				{
					//m_nCidControlStep = CID_STEP_OCCUPYING_PATH;
					m_nCidControlStep = CID_STEP_COMPLETION;//slope rear 인 경우 선행 VHL이동을 막기 위한 점유를 할 필요가 없으므로, CID_STEP_COMPLETION 으로 변경 
					ADD_LOG("[CID] Slope CID_STEP_CHECKING_PATH -> CID_STEP_COMPLETION, Current Node : %d)", Info->tmpCurrentNodeID);
		 		}
#if 0
				// 현재 노드가 Stop이고, 다음 노드가 Reset이 아닌 경우 CID_STEP_COMPLETION 으로 변경
				else if((Info->tmpCurrentNodeID == Info->CIDStopNode1 && Info->tmpNextNodeID != Info->CIDResetNode1) || 
					(Info->tmpCurrentNodeID == Info->CIDStopNode2 && Info->tmpNextNodeID != Info->CIDResetNode2))
				{
					m_nCidControlStep = CID_STEP_COMPLETION;//CID_STEP_COMPLETION 과 CID_STEP_CHECKING_PATH를 반복 동작 함..
					ADD_LOG("[CID] StopNode to not CID Node 1, Current Node : %d, NextNode : %d)", Info->tmpCurrentNodeID, Info->tmpNextNodeID);

				}
#endif
				// 목적지에 따라 STEP_OCCUPYING으로 이동 여부 결정
				// 목적지가 Reset Tag이거나 상위이면 OCCUPYING으로 이동, Stop Tag이거나 하위이면 CHECKING에 머무름
				else if ((checkCommandTarget4CID(Info) == false) && (Info->nDetectStatus != DETECT_AND_STOP))
				{
					m_nCidControlStep = CID_STEP_OCCUPYING_PATH;
					ADD_LOG("[CID] Connection Completed..Moving to OCCUPYING Step_1(Step:CID_STEP_CHECKING_PATH, Current Node : %d, CMDID: %d)", Info->tmpCurrentNodeID,Info->tmpCurrentCMDID);
//						m_nCidControlStep = m_nCidControlStep;
					ADD_MCC_LOG(",%s,DRV,CID LINK,Start,FOUP,%06d,%06d,%06d,%d,%6.1lf,CID Link Time,%d,Map CID Link Offset,%d,CID Link Distance,%d",
									m_defualtparam->VHLName,
									m_mccparam.uSourceNode,
									m_mccparam.uTargetNode,
									m_pOHTMainStatus->StatusCommon.CurNodeID,
									m_pOHTMainStatus->StatusCommon.CurNodeOffset,
									dSpeedOfNow,
									OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwCIDLinkOnTime),
									m_CID_Offet_Target,
									m_pOHTMainStatus->StatusCommon.CurNodeOffset);
				}
				else if(Info->uLimitNode == m_tmpCurrentResetNode)
				{
					//stop 과 reset 사이 스테이션이 목적지일 경우 점유
					//if(Info->Safety_Level == 0x00)//Safety_Level 0 만 점유 할 경우 주석 해제
					if(Info->bIgnolOverRun==false)
					{
						m_nCidControlStep = CID_STEP_OCCUPYING_PATH;
						ADD_LOG("[CID] Connection Completed..Moving to OCCUPYING Step_2(Step:CID_STEP_CHECKING_PATH, Current Node : %d, CMDID: %d, Info->Safety_Level:%d)", Info->tmpCurrentNodeID,Info->tmpCurrentCMDID, Info->bIgnolOverRun);
					}
					else//stop 과 reset 사이 스테이션이 목적지이나 bIgnolOverRun 1인 경우 미점유
					{
						//CID_STEP_COMPLETION or waitting
						//m_nCidControlStep = CID_STEP_COMPLETION; //CID_STEP_WAITING_FOR_PATH;

						ADD_LOG("[CID] Connection Completed..Moving to OCCUPYING Step_2 else(Step:CID_STEP_WAITING_FOR_PATH, Current Node : %d, CMDID: %d, Info->bIgnolOverRun:%d)", Info->tmpCurrentNodeID,Info->tmpCurrentCMDID, Info->bIgnolOverRun);

					}
				}
				else
				{
					static int nTmpCurNodeId4 = 0;
					if(nTmpCurNodeId4 != Info->tmpCurrentNodeID)
					{
						nTmpCurNodeId4 = Info->tmpCurrentNodeID;
						ADD_LOG("[CID] Connection Completed..Staying at CHECKING step_3(Step:CID_STEP_CHECKING_PATH, Current Node : %d, CMDID: %d)", Info->tmpCurrentNodeID,Info->tmpCurrentCMDID);
					}
				}
			}
			// 1-2. Interlock 수신한 경우
			else if (m_CID_Pause == false && pHWSet->m_pCID->IsInterlock_ON() == true)
			{
				m_CIDPauseTime = timeGetTime();
				if (checkCommandTarget4CID(Info) == false && Info->nDetectStatus != DETECT_AND_STOP)
				{
					pHWSet->m_pCID->CID_Occup_Pause(&m_CID_Pause);
					//CID_R_Status_Chk 함수 수행 내용이 들어감.
					pHWSet->m_pCID->Set_CID_Status_Cmd();
					m_CIDStatusFlag = true;
					m_CIDStatusPauseFlag = true;
					m_pExecuteInfo->FlagCIDReport.bCIDInterlock = true;
					m_nCidControlStep = CID_STEP_WAITING_FOR_PATH;
					//ADD_LOG("[CID] Connection Completed..Paused due to Interlock1(Step:CID_STEP_CHECKING_PATH, Current Node : %d, CMDID : %d)", Info->tmpCurrentNodeID, Info->tmpCurrentCMDID);
					ERR_LOG("[CID] Connection Completed..Paused due to Interlock1(Step:CID_STEP_CHECKING_PATH, Current Node : %d, CMDID : %d)", Info->tmpCurrentNodeID, Info->tmpCurrentCMDID);
				}
				else if(Info->uLimitNode == m_tmpCurrentResetNode)
				{
					//stop 과 reset 사이 스테이션이 목적지일 경우 정지
					//if(Info->Safety_Level == 0x00)//Safety_Level 0 만 점유 할 경우 주석 해제
					if(Info->bIgnolOverRun==false)
					{
						pHWSet->m_pCID->CID_Occup_Pause(&m_CID_Pause);
						//CID_R_Status_Chk 함수 수행 내용이 들어감.
						pHWSet->m_pCID->Set_CID_Status_Cmd();
						m_CIDStatusFlag = true;
						m_CIDStatusPauseFlag = true;
						m_pExecuteInfo->FlagCIDReport.bCIDInterlock = true;
						m_nCidControlStep = CID_STEP_WAITING_FOR_PATH;
						//ADD_LOG("[CID] Connection Completed..Paused due to Interlock2(Step:CID_STEP_CHECKING_PATH, Current Node : %d, CMDID : %d)", Info->tmpCurrentNodeID, Info->tmpCurrentCMDID);
						ERR_LOG("[CID] Connection Completed..Paused due to Interlock2(Step:CID_STEP_CHECKING_PATH, Current Node : %d, CMDID : %d)", Info->tmpCurrentNodeID, Info->tmpCurrentCMDID);
					}
					else//stop 과 reset 사이 스테이션이 목적지이나 Safety_Level이 1인 경우 미정지
					{
						static int nTmpCurNodeId0819_1 = 0;
						if(nTmpCurNodeId0819_1 != Info->tmpCurrentNodeID)
						{
							nTmpCurNodeId0819_1 = Info->tmpCurrentNodeID;
							
							ADD_LOG("[CID] Connection Completed..Paused due to Interlock2 else (Step:CID_STEP_CHECKING_PATH, Current Node : %d, CMDID : %d)", Info->tmpCurrentNodeID, Info->tmpCurrentCMDID);
						}
					}
				}
				else
				{
					static int nTmpCurNodeId0103 = 0;
					if(nTmpCurNodeId0103 != Info->tmpCurrentNodeID)
					{
						nTmpCurNodeId0103 = Info->tmpCurrentNodeID;
						ADD_LOG("[CID] Interlock ON..No need for OHT pause(Step:CID_STEP_CHECKING_PATH, Current Node : %d, CMDID : %d)", Info->tmpCurrentNodeID, Info->tmpCurrentCMDID);
					}
				}
			}
			// 1-1. Interlock 미수신한 경우 CID pause flag를 변경.
			else if (m_CID_Pause == true && pHWSet->m_pCID->IsInterlock_ON() == false)
			{
				pHWSet->m_pCID->CID_Occup_Resume(&m_CID_Pause);
				m_CIDStatusFlag = false;
				m_CIDStatusPauseFlag = false;
				m_pExecuteInfo->FlagCIDReport.bCIDInterlock = false;
			}
			else
			{
				static int nTmpCurNodeId01151 = 0;
				if(nTmpCurNodeId01151 != Info->tmpCurrentNodeID)
				{
					nTmpCurNodeId01151 = Info->tmpCurrentNodeID;
					ADD_LOG("[CID] m_CID_Pause NOT switched to true..(Step:CID_STEP_CHECKING_PATH, Current Node : %d, CMDID : %d)", Info->tmpCurrentNodeID, Info->tmpCurrentCMDID);
				}
			}
		}

		// CID-O, CID-R 간 연결이 아직 미성립
		else if (pHWSet->m_pCID->IsLinking() == true && pHWSet->m_pCID->IsLinkOK() == false)
		{
		   //	m_bInitialLink = false;
			static int nTmpCurNodeId = 0;
			if (nTmpCurNodeId != Info->tmpCurrentNodeID)
			{
				nTmpCurNodeId = Info->tmpCurrentNodeID;
				ADD_LOG("[CID] Try linking(Step:CID_STEP_CHECKING_PATH, Current Node : %d)", Info->tmpCurrentNodeID);
//				ADD_LOG("[CID] Encoder Reading: %d, Map Offset: %d", m_PositionInfo.CurrNodeOffset, m_CID_Offet_Target);

			}
			int tmp_dist = CID_Comm_Time2Dist(Info);

			if (((Info->tmpCurrentNodeID == Info->tmpStartNode1_1)||(Info->tmpCurrentNodeID == Info->tmpStartNode2_1))
			&& ((m_CID_Offet_Target + tmp_dist + 100) < (m_PositionInfo.CurrNodeOffset - m_ntempNodeOffset)) //CID 시작 offset 거리 + 맵 속도 기반 200ms 기준 거리 + Tag margin 200(common normal 동일값 적용)
			&& m_bInitialLink == false)
			{
				if(m_MoniCFNode != Info->tmpCurrentNodeID)
				{
					m_DiagManager->IncreasePreviosDiagCount(PREVIOS_DIAG_CF); //사전 로그
					if(Info->tmpCurrentNodeID == Info->tmpStartNode1_1)
					{
						ADD_MD_LOG("CF Dis Left Fail  Cur N:%d, Start N : %d",Info->tmpCurrentNodeID ,Info->tmpStartNode1_1 );
					}
				   else if(Info->tmpCurrentNodeID == Info->tmpStartNode2_1)
				   {
						ADD_MD_LOG("CF Dis Right Fail Cur N:%d, Start N : %d",Info->tmpCurrentNodeID ,Info->tmpStartNode2_1 );
				   }

				   m_MoniCFNode =  Info->tmpCurrentNodeID ;

				}

			}

			// 일정 거리 내 Link가 되지 않은 경우 감속 정지 후 OCS 보고(CID 무시 신호 조건 추가 필요)
			// Link 거리 기준 Start1에서 맵 속도 기준으로 100ms 이동 해도 통신이 안된 경우.

			//ADD_LOG("[CID] Encoder Reading: %d, Map Offset: %d, tmp_dist: %d", m_PositionInfo.CurrNodeOffset, m_CID_Offet_Target, tmp_dist);
			if (((Info->tmpCurrentNodeID == Info->tmpStartNode1_1)||(Info->tmpCurrentNodeID == Info->tmpStartNode2_1))
				&& ((m_CID_Offet_Target + tmp_dist + 200) < (m_PositionInfo.CurrNodeOffset - m_ntempNodeOffset)) //CID 시작 offset 거리 + 맵 속도 기반 200ms 기준 거리 + Tag margin 200(common normal 동일값 적용)
				&& m_bInitialLink == false)
//				&& (m_CID_Offet_Target + 2000 < (m_PositionInfo.CurrNodeOffset - m_ntempNodeOffset)) && m_bInitialLink == false)
				//2000->1000 길이 검토
				//startx_1이 stop노드인 경우 거리 변경 필수
			{
				m_bLinkFail = true;
				pHWSet->m_pCID->CID_Occup_Pause(&m_CID_Pause);
				//CID_R_Status_Chk 함수 수행 내용이 들어감.
				pHWSet->m_pCID->Set_CID_Status_Cmd();
				m_CIDStatusFlag = true;
				m_CIDStatusPauseFlag = true;
				m_pExecuteInfo->FlagCIDReport.bCIDStop= true;
				//m_CIDStatusFlag = true;

				m_nCidControlStep = CID_STEP_WAITING_FOR_PATH;

				ADD_LOG("[CID] Paused due to link fail 1 (Step:CID_STEP_CHECKING_PATH, Current Node : %d)", Info->tmpCurrentNodeID);
				ADD_LOG("[CID] Encoder Reading: %d, Map Offset: %d, tmp_dist: %d, total Offset: %d", m_PositionInfo.CurrNodeOffset, m_CID_Offet_Target, tmp_dist, m_CID_Offet_Target+tmp_dist+100);
				ADD_LOG("start node 1_1: %d, start node 2_1: %d", Info->tmpStartNode1_1, Info->tmpStartNode2_1);
				ERR_LOG("[CID_ERR] CID_OFFSET/NID/%d/NextNID/%d/Encoder Reading/%d/Map Offset/%d", Info->tmpCurrentNodeID, Info->tmpNextNodeID, m_PositionInfo.CurrNodeOffset, m_CID_Offet_Target);

			}
			else if((m_CIDDirection == CID_DIRECTION_LEFT) && (Info->tmpCurrentNodeID != Info->tmpStartNode1_1) && m_bInitialLink == false ||
					(m_CIDDirection == CID_DIRECTION_RIGHT) && (Info->tmpCurrentNodeID != Info->tmpStartNode2_1) && m_bInitialLink == false)
			{
				//CID link 시작이 start node 1이 아닌 경우 시간으로 판단 100ms


				if(m_MoniCFNode2 != Info->tmpCurrentNodeID)
				{
					m_DiagManager->IncreasePreviosDiagCount(PREVIOS_DIAG_CF); //사전 로그
					if(m_CIDDirection == CID_DIRECTION_LEFT)
					{
                    	ADD_MD_LOG("CF LEFT FAIL Cur N:%d, Start N : %d",Info->tmpCurrentNodeID ,Info->tmpStartNode1_1 );
					}
				   else if(m_CIDDirection == CID_DIRECTION_RIGHT)
				   {
						ADD_MD_LOG("CF RIGHT FAIL Cur N:%d, Start N : %d",Info->tmpCurrentNodeID ,Info->tmpStartNode2_1 );
				   }

				   m_MoniCFNode2 = Info->tmpCurrentNodeID;

				}

				CID_NotLinkCount++;
				if(CID_NotLinkCount>13) //16ms*15 = 240ms, set 0 in CID_STEP_CONNECTING step, 추후 8로 변경
				{
					m_bLinkFail = true;
					pHWSet->m_pCID->CID_Occup_Pause(&m_CID_Pause);
					m_pExecuteInfo->FlagCIDReport.bCIDStop = true;

					m_nCidControlStep = CID_STEP_WAITING_FOR_PATH;

					ADD_LOG("[CID] Paused due to link fail 2 (Step:CID_STEP_CHECKING_PATH, Current Node : %d)", Info->tmpCurrentNodeID);
					ADD_LOG("start node 1_1: %d, start node 2_1: %d", Info->tmpStartNode1_1, Info->tmpStartNode2_1);

				}
			}
			else
			{
				//NOP
			}

		}

		// Select Off 상태인 경우 : CONNECTING step으로 이동
		else
		{
			ADD_LOG("[CID] Select L/R NOT On yet...waiting(Step:CID_STEP_CHECKING_PATH, Current Node : %d)", Info->tmpCurrentNodeID);
			if(pHWSet->m_pCID->IsLinking_Right() == false && pHWSet->m_pCID->IsLinking_Left() == false)
			{
				if(m_tmpCurrentResetNode == Info->tmpCurrentNodeID)
				{
					m_nCidControlStep = CID_STEP_CONNECTING;
				}
			}
		}

		// 2. 완료 처리 (Checking Step에서 Reset Tag를 만난 경우 완료 처리 필요)
		if ((m_CIDComptTryFlag == false && pHWSet->m_pCID->IsLinkOK() == true) &&
			(m_CurrCIDStartnode != Info->tmpCurrentNodeID)&&	//Reset Tag 가 공용인 경우 start 1 node 배제 하기 위함..
			((NormalCid_Return(Info) == true) 				    // normal, slope
			  || (CommonCid_Return(Info, pInfoSet) == true))) 	// common
		{
			IO_INFO_CID();
			m_nCidControlStep = CID_STEP_COMPLETION;
			ADD_LOG("[CID] Passing Reset Tag..Move to COMPLETION step..(Step:CID_STEP_CHECKING_PATH, Current Node : %d)", Info->tmpCurrentNodeID);
		}
/*
		// L/G type CID에 의해 이전 Step(CID_STEP_CONNECTING)에서 비정상적으로 넘어온 경우에 대한 처리
		// Path, current command, current position,,,
		else if ()
		{
			m_nCidControlStep = CID_STEP_CONNECTING;

		}
*/
		break;

	case CID_STEP_WAITING_FOR_PATH:
		IO_INFO_CID();
		// 앞의 CID_STEP_CHECKING_PATH 스텝에서 IsLinkOK() 를 확인하고 왔으므로
		// 불필요한 조건인지 검토가 필요
		// ([질문] 인터락 들어와서 정지중 링크가 끊어지는 경우가 있을런지)
		// ([질문] 대기중 링크가 끊어져버리면 어떻게 대응해야 하는 것인지)
		if (m_bLinkFail == false && m_CID_Pause == true && pHWSet->m_pCID->IsLinkOK() == true && pHWSet->m_pCID->IsInterlock_ON() == true)
		{
			// 이 경우 여기서 계속 기다린다 (state변경 불필요)

			static int nTmpCurNodeId3 = 0;
			if(nTmpCurNodeId3 != Info->tmpCurrentNodeID)
			{
				nTmpCurNodeId3 = Info->tmpCurrentNodeID;
				ADD_LOG("[CID] Interlock still on(Step:CID_STEP_WAITING_FOR_PATH, Current Node : %d)", Info->tmpCurrentNodeID);
			}

			if(m_CIDStatusPauseFlag == true)
			{
				CID_SendForStatusCount++;
				if(CID_SendForStatusCount>187)//16ms*187 = 2992
				{
					CID_SendForStatusCount=0;
					m_pExecuteInfo->FlagCIDInfo.bCIDErrorFlag = true;
					
					//pHWSet->m_pCID->Set_CID_Status_Cmd();
					//m_CIDStatusFlag = true;
				}
				//인터락 원인이 CID-R Status가 전원OFF 이면, 에러발생
				//시간은 default 30초, parameter
				DRIVING_HW_INFO_SET TmpHwInfo;
				if( m_StatusSet.bIsOnProcess==true)
				{
					TmpHwInfo = m_InfoSet.HwInfo;
			    }
			    else
				{
					TmpHwInfo = getHWInfo();
				}

				if(((m_sCIDStatus[2]&0x02) == 0x02) && TmpHwInfo.IO.DetectStatus!=DETECT_AND_STOP)
				{
					int tmp_CIDPauseTime = timeGetTime();
					if(OHTUTILITY::PreventOverflowGetTimeMs(m_CIDPauseTime) > m_pParamSet->CID_PAUSE_TIMEOVER && m_CIDPauseTime != 0)     //20191104 KDS
					{
						ADD_LOG("[CID] ERR_CID_CONNECTION_OFF_INTERLOCK_ON : Status: %d, %d, %d, time: %d, %d, %d)", m_sCIDStatus[0], m_sCIDStatus[1], m_sCIDStatus[2], tmp_CIDPauseTime, m_CIDPauseTime, m_pParamSet->CID_PAUSE_TIMEOVER);
						//nError = ERR_CID_CONNECTION_OFF_INTERLOCK_ON;//에러발생 미적용
					}
				}
			}
			else
			{

			}
		}
		else if (m_bLinkFail == false && m_CID_Pause == true && pHWSet->m_pCID->IsLinkOK() == true && pHWSet->m_pCID->IsInterlock_ON() == false)
		{
			// Interlock off 1회 확인 후 paused 상태 off 전환(2회 확인 여부 검토 필요)
			pHWSet->m_pCID->CID_Occup_Resume(&m_CID_Pause);
			m_pExecuteInfo->FlagCIDReport.bCIDInterlock = false;
			m_pExecuteInfo->FlagCIDReport.bCIDStop = false;
			m_nCidControlStep = CID_STEP_CHECKING_PATH;
			ADD_LOG("[CID] Interlock off..checking the path again(Step:CID_STEP_WAITING_FOR_PATH, Current Node : %d)", Info->tmpCurrentNodeID);
		}
		else
		{
			static int nTmpCurNodeId01092 = 0;
			if(nTmpCurNodeId01092 != Info->tmpCurrentNodeID)
			{
				nTmpCurNodeId01092 = Info->tmpCurrentNodeID;
				ADD_LOG("[CID] CID_STEP_WAITING_FOR_PATH - else case");
			}
		}



		// 2. OCS에 의한 기동 재개(Link 불가로 감속 정지 ->  OCS 보고 -> Waiting step으로 넘어온 경우)
		// 2-1. Link 연결된 경우
		if (m_bLinkFail == true && m_CID_Pause == true && pHWSet->m_pCID->IsLinkOK() == true && bResumedbyOCS == true)
		{
			m_bLinkFail = false;

			pHWSet->m_pCID->CID_Occup_Resume(&m_CID_Pause);
			m_pExecuteInfo->FlagCIDReport.bCIDInterlock= false;
			m_pExecuteInfo->FlagCIDReport.bCIDStop = false;
			m_nCidControlStep = CID_STEP_CHECKING_PATH;
			ADD_LOG("[CID] OCS Pause Released...Moving to Checking Step..Check CID Map Offset!!");
			ResumedbyOCS_count = 0;
			bResumedbyOCS = false;
		}
		else if (m_bLinkFail == true && m_CID_Pause == true && pHWSet->m_pCID->IsLinkOK() == false && bResumedbyOCS == true)
		{
			// Select Off 전 완료 처리 후 COMPLETION step으로 이동
			pHWSet->m_pCID->CID_Occup_compt(8); // 통과 완료 bit ON
			m_CIDComptTryFlag = true;

			//Link fail시 데드락 지점(2000sec)로 인해 주석처리.
//			pHWSet->m_pCID->SendReq_CID_O();
//			Sleep(50);
//          pHWSet->m_pCID->Save_CID_O_Data();

			pHWSet->m_pCID->CID_Occup_Resume(&m_CID_Pause);
			m_pExecuteInfo->FlagCIDReport.bCIDInterlock= false;
			m_pExecuteInfo->FlagCIDReport.bCIDStop = false;
			m_nCidControlStep = CID_STEP_COMPLETION;
			ADD_LOG("[CID] OCS Pause Released...Moving to Completion Step");
			ResumedbyOCS_count = 0;
			bResumedbyOCS = false;
		}
		else
		{
			if(pHWSet->m_pCID->IsInterlock_ON() != true)
			{
				ResumedbyOCS_count++;
				//if(ResumedbyOCS_count > 300)
				//{
					//카운트 후 강제 OCS resume 임시용
					//bResumedbyOCS = true;
					//ADD_LOG("[CID] OCS Resume 300cycle");
				//}
				//CID Bypass신호가 늦게 들어올 경우는 자동 주행 재개
				if(m_pExecuteInfo->FlagCIDNotuse.bCIDUse== true)
				{
					bResumedbyOCS = true;
					ADD_LOG("[CID] OCS Resume by CIDBypass");
				}
				if ((m_pExecuteInfo->FlagCIDInfo.cMoveResult == true)&&(m_pExecuteInfo->FlagCIDInfo.bMoveRestart == true))
				{
					m_pExecuteInfo->FlagCIDInfo.bMoveRestart = false;
					m_CIDStatusPauseFlag = false;
					bResumedbyOCS = true;
					ADD_LOG("[CID] OCS Resume");
				}
				// 자동 주행 재개 - 링크 연결이 성공한 경우, 1초 후 자동 주행재개처리.
				if (pHWSet->m_pCID->IsLinkOK() == true && ResumedbyOCS_count > 65)
				{
					bResumedbyOCS = true;
					ADD_LOG("[CID] OCS Resume by Link check");
				}
				if(m_CIDStatusPauseFlag == true)
				{
					CID_SendForStatusCount++;
					if(CID_SendForStatusCount>187)//16ms*187 = 2992
					{
						CID_SendForStatusCount=0;
						m_pExecuteInfo->FlagCIDInfo.bCIDErrorFlag = true;
					}
				}
				else
				{

				}
			}
		}
		break;

	case CID_STEP_OCCUPYING_PATH:
		if(pHWSet->m_pCID->IsLinkOK() == true && pHWSet->m_pCID->IsInterlock_ON() == false
			&& pHWSet->m_pCID->ISCompletionACK_On() == false  // Check Input
			&& pHWSet->m_pCID->IsOccupying() == false)	 // 점유 Off 상태
		{
			if ((Info->tmpResetNodeType1 == Slope_Rear_Reset_tag)||(Info->tmpResetNodeType2 == Slope_Rear_Reset_tag))
			{
				m_nCidControlStep = CID_STEP_COMPLETION;
				ADD_LOG("[CID] Slope. not Occup --> move to CID_STEP_COMPLETION, Current Node : %d)", Info->tmpCurrentNodeID);
			}
			// 현재 노드가 Stop이고, 다음 노드가 Reset이 아닌 경우 CID_STEP_COMPLETION 으로 변경
			else if((Info->tmpCurrentNodeID == Info->CIDStopNode1 && Info->tmpNextNodeID != Info->CIDResetNode1) && 
				(Info->tmpCurrentNodeID == Info->CIDStopNode2 && Info->tmpNextNodeID != Info->CIDResetNode2))
			{
				m_nCidControlStep = CID_STEP_COMPLETION;
				//nEnforcedSelectOffNodeID = Info->tmpNextNodeID;
				nEnforcedSelectOffNodeID = Info->tmpCurrentNodeID;
				ADD_LOG("[CID] StopNode to not CID Node 2, Current Node : %d, NextNode : %d)", Info->tmpCurrentNodeID, Info->tmpNextNodeID);
				ADD_LOG("[CID] StopNode to not CID Node 2, Info->CIDStopNode1 : %d, Info->CIDResetNode1 : %d, Info->CIDStopNode2 : %d, Info->CIDResetNode2 : %d )", Info->CIDStopNode1, Info->CIDResetNode1, Info->CIDStopNode2, Info->CIDResetNode2);
			}
		/*
			else if(Info->nDetectStatus == DETECT_AND_STOP)
			{
				ADD_LOG("[CID] Detected and Not Occupying. (STEP : CID_STEP_OCCUPYING_PATH, Current Node : %d)"
						, Info->tmpCurrentNodeID);
			}
		*/ 
			else
			{
				pHWSet->m_pCID->CID_Occup_OK();//한번만 신호 보냄...
				Sleep(20);
				//확인 후 재시도 추가
				if(pHWSet->m_pCID->IS_Occup_On()==FALSE)
				{
					pHWSet->m_pCID->CID_Occup_OK();
				}
				m_nCidControlStep = CID_STEP_COMPLETION;
				ADD_LOG("[CID] Occupying..(Step:CID_STEP_OCCUPYING_PATH, Current Node : %d, tmpNextNodeID : %d)", Info->tmpCurrentNodeID, Info->tmpNextNodeID);

			}
		}
		else if(pHWSet->m_pCID->IsLinkOK() == true && pHWSet->m_pCID->IsInterlock_ON() == true)//true시 동작 추가 : CID_STEP_CHECKING_PATH로 전환
		{
			m_nCidControlStep = CID_STEP_CHECKING_PATH;
		}
		else
		{
		}
		
		break;

	case CID_STEP_COMPLETION:
		IO_INFO_CID();

		// 1. 대차 감지 시 합류점유 반납
		if (m_CIDComptTryFlag == false // 완료 처리 전이고,
			&& (pHWSet->m_pCID->IsLinkOK() == true && pHWSet->m_pCID->IsInterlock_ON() == false
			&& Info->nDetectStatus == DETECT_AND_STOP && pHWSet->m_pDrivingAxis->IsRunning() == false))
		{
			// 다음 이동할 노드가 ResetNode 이면
			// Stop Tag, Reset Tag 사이에 위치한 경우 합류 점유 반납하지 않음
			if (Info->tmpNextNodeID == m_tmpCurrentResetNode)
			{
				static int nTmpCurNodeId6 = 0;
				if(nTmpCurNodeId6 != Info->tmpCurrentNodeID)
				{
					nTmpCurNodeId6 = Info->tmpCurrentNodeID;
					ADD_LOG("[CID] Not Returning occupancy..(Step:CID_STEP_COMPLETION)");
					ADD_LOG("[CID] Check Map --> CurrentNode: %d, ResetNode1: %d, ResetNode2: %d",
					Info->tmpCurrentNodeID, Info->CIDResetNode1, Info->CIDResetNode2);
				}
			}
			// 다음 이동할 노드가 ResetNode 아니면
			// Start Tag에 위치한 경우 (Stop Tag 이전에 정차한 경우) 합류 점유 반납
			else
			{
				pHWSet->m_pCID->CID_Occup_return(1);
				m_nCidControlStep = CID_STEP_CHECKING_PATH;

				static int nTmpCurNodeId7 = 0;
				if(nTmpCurNodeId7 != Info->tmpCurrentNodeID)
				{
					nTmpCurNodeId7 = Info->tmpCurrentNodeID;
					ADD_LOG("[CID] Returning occupancy due to detection status..(Step:CID_STEP_COMPLETION)");
					ADD_LOG("[CID] Check Map --> CurrentNode: %d, ResetNode1: %d, ResetNode2: %d",
						Info->tmpCurrentNodeID, Info->CIDResetNode1, Info->CIDResetNode2);
				}
				break;
			}
			
		}

		// 2. Interlock On
		// 2-1. 경사로 후방 광 Fiber 구간에서 Interlock On 시 정지
		if ((m_CIDComptTryFlag == false)
			&& ((Info->tmpResetNodeType1 == Slope_Rear_Reset_tag)||(Info->tmpResetNodeType2 == Slope_Rear_Reset_tag)))
		{
			if(pHWSet->m_pCID->IsLinkOK() == true && pHWSet->m_pCID->IsInterlock_ON() == true
				&& pHWSet->m_pDrivingAxis->IsRunning() == true)
			{
				pHWSet->m_pCID->CID_Occup_Pause(&m_CID_Pause);
				m_pExecuteInfo->FlagCIDReport.bCIDInterlock= true;
				m_nCidControlStep = CID_STEP_WAITING_FOR_PATH;
				ADD_LOG("[CID] Slope -> Interlock Checked.. OHT Paused");
				break;
			}
		}
		// 2-2. 일반 합류 구간 내 동시 진입
		else if ((m_CIDComptTryFlag == false)
			&& (pHWSet->m_pCID->IsLinkOK() == true && pHWSet->m_pCID->IsInterlock_ON() == true
				&& pHWSet->m_pCID->IsOccupying() == true && pHWSet->m_pDrivingAxis->IsRunning() == true))
		{
			nError = ERR_CID_OCCUP_ON_INTERLOCK_ON;
			ADD_LOG("[CID] Intelock on detected while occupying..(Step:CID_STEP_COMPLETION, Current Node : %d)", Info->tmpCurrentNodeID);
			pHWSet->m_pCID->SendReq_CID_O();
			ADD_FDC_LOG("ERR/%d/1/5/%06d/%06d/%d/%d/%06d",
					ERR_CID_OCCUP_ON_INTERLOCK_ON,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pExecuteInfo->ExecutePositionInfo.NextNode,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					m_pOHTMainStatus->StatusCommon.ExistFoup,
					m_pOHTMainStatus->StatusCommon.StopStationID);
			break;
		}
		// 2-3. 일반 합류 구간 내 합류 미점유 상태에서 Interlock On  (재확인 후 삭제)
		else if ((m_CIDComptTryFlag == false)
			&& (pHWSet->m_pCID->IsLinkOK() == true && pHWSet->m_pCID->IsInterlock_ON() == true
				&& pHWSet->m_pCID->IsOccupying() == false && pHWSet->m_pDrivingAxis->IsRunning() == true))
		{
			pHWSet->m_pCID->CID_Occup_Pause(&m_CID_Pause);
			m_pExecuteInfo->FlagCIDReport.bCIDInterlock= true;
			m_nCidControlStep = CID_STEP_WAITING_FOR_PATH;
			ADD_LOG("[CID] Interlock on detected..(Step:CID_STEP_COMPLETION, Current Node : %d)", Info->tmpCurrentNodeID);
			break;
		}
		// 2-4. 작업변경 없이 VHL이 CID 점유 후 목적지가 Stopnode로 변경시 CID 점유 반납 처리.
		else if( (m_CIDComptTryFlag == false) &&
		        (Info->tmpNextNodeID != m_tmpCurrentResetNode) &&
				(Info->tmpCurrentNodeID == Info->tmpCurrentCMDID) &&
				(Info->tmpCurrentNodeID == Info->CIDStopNode1 || Info->tmpCurrentNodeID == Info->CIDStopNode2))
		{
			pHWSet->m_pCID->CID_Occup_return(2);
			m_nCidControlStep = CID_STEP_CHECKING_PATH;

			static int nTmpCurNodeId8 = 0;
			if(nTmpCurNodeId8 != Info->tmpCurrentNodeID)
			{
				nTmpCurNodeId8 = Info->tmpCurrentNodeID;
				ADD_LOG("[CID] Returning occupancy due to tmpCurrentCMDID is Stopnode..(Step:CID_STEP_COMPLETION, Current Node : %d)", Info->tmpCurrentNodeID);
				ADD_LOG("[CID] Check Map --> CurrentNode: %d, StopNode1: %d, StopNode2: %d, ResetNode1: %d, ResetNode2: %d",
					Info->tmpCurrentNodeID, Info->CIDStopNode1, Info->CIDStopNode2, Info->CIDResetNode1, Info->CIDResetNode2);
			}
			break;
		}
		else if (m_CIDComptTryFlag == false)
		{
			static int nTmpCurNodeId2 = 0;
			if(nTmpCurNodeId2 != Info->tmpCurrentNodeID)
			{
				nTmpCurNodeId2 = Info->tmpCurrentNodeID;
				ADD_LOG("[CID] Checking Interlock Signal..(Step:CID_STEP_COMPLETION, Current Node : %d)", Info->tmpCurrentNodeID);
			}
		}
		else
		{
			static int nTmpCurNodeId20171113 = 0;
			if(nTmpCurNodeId20171113 != Info->tmpCurrentNodeID)
			{
				nTmpCurNodeId20171113 = Info->tmpCurrentNodeID;
				ADD_LOG("[CID] Completion Step, Interlock on/off else case");
			}
		}

		// 3. 완료 처리(통과 완료 bit 'On' 전송)
		nError = completeCIDComm(Info, pInfoSet);
		if (CID_Status_Check == 0)
		{
			CID_Status_Check = 1;
			pHWSet->m_pCID->Clear_CID_Status_Cmd(); //CID 정상 상태 보고
		}

		break;

	case CID_STEP_ABNORMAL:
		IO_INFO_CID();
		// 1. Link 최초 연결 후 Link 장애 발생한 경우 처리
		if (m_bCIDNotUse == false && m_bInitialLink == true && m_bLinkDisconnected == true)
		{
			// 1-1. Reconnected...
			if (pHWSet->m_pCID->IsLinkOK() == true)
			{
				m_bLinkDisconnected = false;
				nLinkFailureCount = 0;
				m_nCidControlStep = CID_STEP_CHECKING_PATH;
				ADD_LOG("[CID] Abnormal Step..Reconnected");
				break;
			}
			// 1-2. 재연결이 되지 않은 상태로 Reset Tag까지 주행한 경우, 완료 처리
			//      (연결이 되었으나 CID-O의 Link 입력 이상한 경우를 위한 처리)
			else if (Info->CIDResetNode_arr != INDEX_NONE &&
				(Info->CIDResetNodeType == Normal_Reset_tag ||
				Info->CIDResetNodeType == Common_Reset_tag ||
				Info->CIDResetNodeType == Slope_Rear_Reset_tag))
			{
				pHWSet->m_pCID->CID_Occup_compt(9); // 통과 완료 bit ON
				Sleep(20);
				//m_CIDComptTryFlag = true;
				//m_nCidControlStep = CID_STEP_COMPLETION;
				ADD_LOG("[CID] Abnormal Step..Arrived at Reset Tag");

				if (Info->CIDResetNodeType == Common_Reset_tag)
				{
					pHWSet->m_pCID->CID_Out_Common_Tag(11, true);	// Common Tag On
					ADD_LOG("[CID] Now Common Reset Tag. O7 = 1 set");
					m_CID_COMMON_bit_off_need = true;
					Sleep(10);
				}
				m_bLinkDisconnected = false;

				pHWSet->m_pCID->TerminateCID(4);	// Pass Ok. CID All Off // bReadyOperation -> on
				bCountOfCIDComptACK = 0;

				m_CIDDirection = CID_DIRECTION_NOT_LINK;
				m_CIDComptFlag = false;
				m_CIDComptTryFlag = false;
				m_bInitialLink = false;
				m_bCIDNotUse = false;
				m_CIDOperationStarted = false;
				m_job_change_flag_no_cid_area = false;
				m_pExecuteInfo->bChangeResult = false;
				m_ntempNodeOffset = 0;


				m_pExecuteInfo->bChangeResult = false;    //false 시점 확인

				ADD_LOG("[CID] CID 종료, %d" , bCountOfCIDComptACK);
				m_nCidControlStep = CID_STEP_CONNECTING;
				
				break;
			}
		}

		// Link 장애 시 COMPLETION step을 거쳐 Abnormal로 넘어온 경우 처리
		// Outputs(Select, 점유, 완료, Abnormal, Mode) reset 후 대기
		if (m_bCIDNotUse == false && (m_bLinkFail == true || m_bLinkDisconnected == true)
			&& m_CIDComptTryFlag == false
			&& (Info->CIDResetNode_arr != INDEX_NONE &&
				(Info->CIDResetNodeType == Normal_Reset_tag ||
				Info->CIDResetNodeType == Common_Reset_tag ||
				Info->CIDResetNodeType == Slope_Rear_Reset_tag)))
		{
			m_bLinkFail = false;
			m_bLinkDisconnected = false;
			m_bInitialLink = false;
			m_CIDComptTryFlag = false;
			if (Info->CIDResetNodeType == Common_Reset_tag)
			{
				pHWSet->m_pCID->CID_Out_Common_Tag(2, true);	// Common Tag On
				ADD_LOG("[CID] Abnormal Step...Now Common Reset Tag1. O7 = 1 set");
				m_CID_COMMON_bit_off_need = true;
			}
			m_nCidControlStep = CID_STEP_CONNECTING;
			ADD_LOG("[CID] Arrived at Reset Tag after Link Failure..Move to CONNECTING step(Step:CID_STEP_ABNORMAL, Current Node : %d)", Info->tmpCurrentNodeID);
			ERR_LOG("[CID] Arrived at Reset Tag after Link Failure..Move to CONNECTING step(Step:CID_STEP_ABNORMAL, Current Node : %d)", Info->tmpCurrentNodeID);
			break;
		}
		else if (Info->CIDResetNode_arr != INDEX_NONE &&
				(Info->CIDResetNodeType == Normal_Reset_tag ||
				Info->CIDResetNodeType == Common_Reset_tag ||
				Info->CIDResetNodeType == Slope_Rear_Reset_tag))
		{
			ADD_LOG("[CID] Abnormal Step, else if...m_bCIDNotUse: %d, m_bLinkFail: %d, m_bLinkDisconnected: %d, m_CIDComptTryFlag: %d, CIDResetNodeType: %d",
					m_bCIDNotUse, m_bLinkFail, m_bLinkDisconnected, m_CIDComptTryFlag, Info->CIDResetNodeType);
			ERR_LOG("[CID] Abnormal Step, else if...m_bCIDNotUse: %d, m_bLinkFail: %d, m_bLinkDisconnected: %d, m_CIDComptTryFlag: %d, CIDResetNodeType: %d",
					m_bCIDNotUse, m_bLinkFail, m_bLinkDisconnected, m_CIDComptTryFlag, Info->CIDResetNodeType);
			m_bLinkFail = false;
			m_bLinkDisconnected = false;
			m_bInitialLink = false;
			m_CIDComptTryFlag = false;
			if (Info->CIDResetNodeType == Common_Reset_tag)
			{
				 //해당 처리시 다음 CID에 연결되는 현상 제거
				//  pHWSet->m_pCID->CID_Out_Common_Tag(3, true);	// Common Tag On
				//	ADD_LOG("[CID] Abnormal Step...Now Common Reset Tag2. O7 = 1 set");
			    //  m_CID_COMMON_bit_off_need = true;
			}
			m_nCidControlStep = CID_STEP_CONNECTING;
			break;
		}
		else
		{
			//CIDResetNodeType 이 Slope_Front_Reset_tag 인 경우
			//CIDResetNodeType 이 없는 경우 진입하게 됨.(현재 노드가 Reset 노드가 아닌경우)
			static int nTmpCurNodeId01042 = 0;
			if(nTmpCurNodeId01042 != Info->tmpCurrentNodeID)
			{
				nTmpCurNodeId01042 = Info->tmpCurrentNodeID;
				ADD_LOG("[CID] Abnormal Step, else...m_bCIDNotUse: %d, m_bLinkFail: %d, m_bLinkDisconnected: %d, m_CIDComptTryFlag: %d, CIDResetNodeType: %d",
					m_bCIDNotUse, m_bLinkFail, m_bLinkDisconnected, m_CIDComptTryFlag, Info->CIDResetNodeType);
			}
		}


		// 합류 점유한 채로 대차 감지 중 Link 신호가 비정상적으로 Off 된 경우 처리(2016.11.25)
		if (m_bCIDNotUse == false && m_bLinkDisconnected == true && pHWSet->m_pCID->IsOccupying() == true &&
			Info->nDetectStatus == DETECT_AND_STOP && pHWSet->m_pDrivingAxis->IsRunning() == false)
		{

			// write code here...
			m_CIDComptTryFlag = false;
			//
			static int nTmpCurNodeId7 = 0;
			if(nTmpCurNodeId7 != Info->tmpCurrentNodeID)
			{
				nTmpCurNodeId7 = Info->tmpCurrentNodeID;
				ADD_LOG("[CID] OHT detected and connection lost while Occupying PASS_OK(Step:CID_STEP_ABNORMAL, Current Node : %d)", Info->tmpCurrentNodeID);
			}

		}

		// CID 무시 신호 수신 시 Abnormal Step에서의 처리   [용도는 ??]
		// 무시 신호는 모든 리셋 Tag 만날시 처리
		if (m_bCIDNotUse == true
			&& (Info->CIDResetNode_arr != INDEX_NONE &&
				(Info->CIDResetNodeType == Normal_Reset_tag ||
				Info->CIDResetNodeType == Common_Reset_tag ||
				Info->CIDResetNodeType == Slope_Front_Reset_tag ||
				Info->CIDResetNodeType == Slope_Rear_Reset_tag)))
		{
			m_nCidControlStep = CID_STEP_CONNECTING;
			m_bCIDNotUse = false;
			m_bLinkFail = false;
			m_bLinkDisconnected = false;
			m_bInitialLink = false;
			m_CIDComptTryFlag = false;
			ADD_LOG("[CID] Arrived at Reset Node while m_bCIDNotUse is on..(Step:CID_STEP_ABNORMAL, Current Node : %d)", Info->tmpCurrentNodeID);
		}
		break;

	default:
		break;
	}

	return nError;
}


/**
@brief   합류부 통과 시 CID 완료 처리를 위한 함수
@author  Kunjin
@date    2016.11.24
*/
int DrivingControl::completeCIDComm(CID_CTRL_INFO* Info, DRIVING_INFO_SET *pInfoSet)
{
	int nError = 0;

	double  dSpeedOfNow = pInfoSet->HwInfo.Axis1.dSpeed;

	if (m_CIDComptTryFlag == false &&			// 완료시도 하지 않은 상태이면
		(m_CurrCIDStartnode != Info->tmpCurrentNodeID || m_CurrCIDStartnode != Info->tmpPreNodeID)) // 공용 노드인 경우 처리 추가. 현재노드가 start_1 노드가 아니면 수행 함.
	{
		if((NormalCid_Return(Info) == true)				// normal, slope
			|| (CommonCid_Return(Info, pInfoSet) == true)) 	// common
		{
			IO_INFO_CID();
			nEnforcedSelectOffNodeID = Info->tmpNextNodeID;

			ADD_LOG("[CID] Completion Processing..(Step:CID_STEP_COMPLETION, Current Node : %d, tmpPreNodeID : %d, m_CIDComptTryFlag : %d)", Info->tmpCurrentNodeID, Info->tmpPreNodeID, m_CIDComptTryFlag);
		}
		else
		{
			static int nTmpCurNodeId14 = 0;
			if(nTmpCurNodeId14 != Info->tmpCurrentNodeID)
			{
				nTmpCurNodeId14 = Info->tmpCurrentNodeID;
				ADD_LOG("[CID] Curr: %d, CIDReset: %d, CIDResetType: %d, mTmpCurrentReset: %d",
					Info->tmpCurrentNodeID, Info->CIDResetNode, Info->CIDResetNodeType, m_tmpCurrentResetNode);
			}
		}
	}
	else
	{
		static int nTmpCurNodeId0109 = 0;
		if(nTmpCurNodeId0109 != Info->tmpCurrentNodeID)
		{
			nTmpCurNodeId0109 = Info->tmpCurrentNodeID;
			ADD_LOG("[CID] completeCIDComm() m_CIDComptTryFlag: %d, nEnforcedSelectOffNodeID: %d" ,m_CIDComptTryFlag, nEnforcedSelectOffNodeID);
		}
		// Link 장애 시 감속 정지 후 OCS 기동 재개로 COMPLETION step으로 넘어온 경우 처리
		if (m_bLinkFail == true || m_bLinkDisconnected == true)
		{
			if (m_nCIDTerminateCount > 5)
			{
				if(m_pExecuteInfo->FlagCIDReport.bCIDStop == true)
				{
					m_pExecuteInfo->FlagCIDReport.bCIDStop = false;
					pHWSet->m_pCID->CID_Occup_Resume(&m_CID_Pause);
					ADD_LOG("[CID] CID_Occup_Resume1");
				}
				pHWSet->m_pCID->TerminateCID(1);
				m_bCIDNotUse = false;
				m_CIDComptTryFlag = false;
//				m_bInitialLink = false;
				nEnforcedSelectOffNodeID = 0;
				m_nCIDTerminateCount = 0;
				m_ntempNodeOffset = 0;

				m_CIDOperationStarted = false;
				m_job_change_flag_no_cid_area = false;
				m_pExecuteInfo->bChangeResult = false;
				m_CIDDirection = CID_DIRECTION_NOT_LINK;
				m_nCidControlStep = CID_STEP_ABNORMAL;

				ADD_LOG("[CID] Completion ACK: %d", pHWSet->m_pCID->ISCompletionACK_On());
				ADD_LOG("[CID] Link Lost...CID output terminated...Current Node : %d)", Info->tmpCurrentNodeID);
			}
			else
				m_nCIDTerminateCount++;
		}


		// 통과 완료 bit를 on 했지만 꺼져 있는 경우
		else if ((m_CurrCIDStartnode != Info->tmpCurrentNodeID || m_CurrCIDStartnode != Info->tmpPreNodeID) && // 공용 노드인 경우 처리 추가. 현재노드가 start_1 노드가 아니면 수행 함.
			(pHWSet->m_pCID->ISCompletionACK_On() == false && pHWSet->m_pCID->ISCompletion_On() == false))
		{
			if((NormalCid_Return(Info) == true) 				// normal, slope
				|| (CommonCid_Return(Info, pInfoSet) == true))	// common
			{
				IO_INFO_CID();
				pHWSet->m_pCID->CID_Occup_compt(10);
				ADD_LOG("[CID] Completion Processing..second trial(Step:CID_STEP_COMPLETION, Current Node : %d)", Info->tmpCurrentNodeID);
			}
		}

		// 합류부 점유 반납 후 CID-R ACK 확인
		else if (pHWSet->m_pCID->ISCompletionACK_On() == true)	// 완료처리 시작후 점유해제 ACK를 받음
		{
			IO_INFO_CID();
			if (Info->CIDResetNodeType == Common_Reset_tag || Info->CIDResetNodeType_Pre == Common_Reset_tag)
			{
				if(m_job_change_flag_exception_CommonTag == false)//작업변경시 완료처리는 common 처리 안하기 위함
				{
				pHWSet->m_pCID->CID_Out_Common_Tag(4, true);	// Common Tag On
				ADD_LOG("[CID] Now Common Reset Tag. O7 = 1 set");
				m_CID_COMMON_bit_off_need = true;
				Sleep(10);
				}
				else
				{
					ADD_LOG("[CID] 작업변경 완료처리 시 common 처리 안함.");
				}
			}

			pHWSet->m_pCID->TerminateCID(2);	// Pass Ok. CID All Off // bReadyOperation -> on
			
			m_CIDDirection = CID_DIRECTION_NOT_LINK;
			m_CIDComptFlag = false;
			m_CIDComptTryFlag = false;
			m_bInitialLink = false;
			m_bCIDNotUse = false;
			m_CIDOperationStarted = false;
			m_job_change_flag_no_cid_area = false;
			m_pExecuteInfo->bChangeResult = false;
			m_ntempNodeOffset = 0;

			nEnforcedSelectOffNodeID = 0;

			m_pExecuteInfo->bChangeResult = false;	  //false 시점 확인

			ADD_LOG("[CID] CID 종료, %d" , bCountOfCIDComptACK);
			
			bCountOfCIDComptACK = 0;

			memset(&CID_Save_Node, 0, sizeof(CID_Save_Node));

			m_nCidControlStep = CID_STEP_CONNECTING;
			//IO_INFO_CID_ALL(); IO_INFO_CID와 동일 로그 중복 출력

			ADD_MCC_LOG(",%s,DRV,CID LINK,End,FOUP,%06d,%06d,%06d,%d,%6.1lf,CID R First Link Level,%c%c%c,CID R FiberError,%c%c,CID R RFError,%c%c,CID R Max Current,%c%c%c,CID R Max Voltage,%c%c%c,CID R Max Temp,%c%c,CID R Noise,%c%c%c,CID O First Link Level,%c%c%c,CID O FiberError,%c%c,CID O RFError,%c%c",
									m_defualtparam->VHLName,
									m_mccparam.uSourceNode,
									m_mccparam.uTargetNode,
									m_pOHTMainStatus->StatusCommon.CurNodeID,
									m_pOHTMainStatus->StatusCommon.CurNodeOffset,
									dSpeedOfNow,
									TEST_PKT_Monitor.BODY.CIDR_FirstLinkLevel[0],TEST_PKT_Monitor.BODY.CIDR_FirstLinkLevel[1],TEST_PKT_Monitor.BODY.CIDR_FirstLinkLevel[2],
									TEST_PKT_Monitor.BODY.FiberError_Per[0],TEST_PKT_Monitor.BODY.FiberError_Per[1],
									TEST_PKT_Monitor.BODY.RFError_Per[0],TEST_PKT_Monitor.BODY.RFError_Per[1],
									TEST_PKT_Monitor.BODY.CIDR_MAXCurrent[0],TEST_PKT_Monitor.BODY.CIDR_MAXCurrent[1],TEST_PKT_Monitor.BODY.CIDR_MAXCurrent[2],
									TEST_PKT_Monitor.BODY.CIDR_MAXVoltage[0],TEST_PKT_Monitor.BODY.CIDR_MAXVoltage[1],TEST_PKT_Monitor.BODY.CIDR_MAXVoltage[2],
									TEST_PKT_Monitor.BODY.CIDR_MAXTemp[0],TEST_PKT_Monitor.BODY.CIDR_MAXTemp[1],
									TEST_PKT_Monitor.BODY.CIDR_StandbyFiberNoise[0],TEST_PKT_Monitor.BODY.CIDR_StandbyFiberNoise[1],TEST_PKT_Monitor.BODY.CIDR_StandbyFiberNoise[2],
									TEST_PKT_Monitor.BODY.CIDO_FirstLinkLevel[0],TEST_PKT_Monitor.BODY.CIDO_FirstLinkLevel[1],TEST_PKT_Monitor.BODY.CIDO_FirstLinkLevel[2],
									TEST_PKT_Monitor.BODY.CIDO_FiberCommError[0],TEST_PKT_Monitor.BODY.CIDO_FiberCommError[1],
									TEST_PKT_Monitor.BODY.CIDO_RFCommError[0],TEST_PKT_Monitor.BODY.CIDO_RFCommError[1]);
		}

		// 통과 완료 처리에 대한 ACK 미수신 시 강제로 Select Off 필요(시간 or 위치 조건)
		// Common Tag의 경우 일반 Reset Tag보다 빨리 Select off 필요
		else if ((m_CurrCIDStartnode != Info->tmpCurrentNodeID &&	//Reset Tag 가 공용인 경우 start 1 node 배제 하기 위함..
				  bCountOfCIDComptACK > 10 && (Info->CIDResetNodeType == Common_Reset_tag || Info->CIDResetNodeType_Pre == Common_Reset_tag ))//Prenode 로 변경하면서 bCountOfCIDComptACK을 5에서 10으로 변경
			|| (Info->tmpCurrentNodeID == nEnforcedSelectOffNodeID)//Info->tmpCurrentNodeID 가 다음 노드로 변경 되므로 Info->CIDResetNodeType은 알 수 없음...
			//nEnforcedSelectOffNodeID를 작업 변경 시 현재 리셋노드로 넣도록 함.  [CID] CID_Occup_compt(5).. ACK delay 
			)
			// 다음 노드 가긴 전 처리 검토 필요.. !!
			// bCountOfCIDComptACK > 50 && Info->CIDResetNodeType == Normal_Reset_tag) 이런식으로..
//			|| (Info->CIDResetNodeType == Normal_Reset_tag && Info->tmpCurrentNodeID == nEnforcedSelectOffNodeID))
		{
			IO_INFO_CID();

			pHWSet->m_pCID->CID_Occup_compt(11);
			Sleep(20);
			
			if (Info->CIDResetNodeType == Normal_Reset_tag || Info->CIDResetNodeType_Pre == Normal_Reset_tag)
			{
				ADD_LOG("[CID] Now Normal Reset Tag. O7 = 0 set Enforced");
			}
			// Common Tag 인 경우 Common Tag bit 'On'
			else if (Info->CIDResetNodeType == Common_Reset_tag  || Info->CIDResetNodeType_Pre == Common_Reset_tag)
			{
				if(m_job_change_flag_exception_CommonTag == false)//작업변경시 완료처리는 common 처리 안하기 위함
				{
				pHWSet->m_pCID->CID_Out_Common_Tag(5, true);	// Common Tag On
				Sleep(10);
				ADD_LOG("[CID] Now Common Reset Tag. O7 = 1 set Enforced");
				m_CID_COMMON_bit_off_need = true;
				}
				else
				{
					ADD_LOG("[CID] 작업변경시 완료처리는 common 처리 안함.");
				}
			}
			else
			{
				ADD_LOG("[CID] Now Normal Reset Tag. O7 = 0 set Enforced");
			}

			ADD_LOG("[CID] Info->tmpCurrentNodeID: %d, nEnforcedSelectOffNodeID: %d, m_CurrCIDStartnode : %d, bCountOfCIDComptACK : %d" , Info->tmpCurrentNodeID, nEnforcedSelectOffNodeID, m_CurrCIDStartnode, bCountOfCIDComptACK);

			
			pHWSet->m_pCID->TerminateCID(3);

			memset(&CID_Save_Node, 0, sizeof(CID_Save_Node));

			m_nCidControlStep = CID_STEP_CONNECTING;
			m_CIDDirection = CID_DIRECTION_NOT_LINK;
			bCountOfCIDComptACK = 0;
			m_CIDComptFlag = false;
			m_CIDComptTryFlag = false;
			m_bInitialLink = false;
			m_bCIDNotUse = false;
			m_CIDOperationStarted = false;
			m_job_change_flag_no_cid_area = false;
			m_pExecuteInfo->bChangeResult = false;
			m_ntempNodeOffset = 0;


			nEnforcedSelectOffNodeID = 0;

			ADD_LOG("[CID] CID timeout 종료, %d" , bCountOfCIDComptACK);
			ADD_LOG("[CID] m_nCidControlStep : %d" , m_nCidControlStep);
		}
		else if(m_job_change_without_link_complete == true)
		{
			pHWSet->m_pCID->TerminateCID(5);	// Pass Ok. CID All Off // bReadyOperation -> on
			
			m_CIDDirection = CID_DIRECTION_NOT_LINK;
			m_CIDComptFlag = false;
			m_CIDComptTryFlag = false;
			m_bInitialLink = false;
			m_bCIDNotUse = false;
			m_CIDOperationStarted = false;
			m_job_change_flag_no_cid_area = false;
			m_pExecuteInfo->bChangeResult = false;
			m_ntempNodeOffset = 0;

			nEnforcedSelectOffNodeID = 0;

			m_pExecuteInfo->bChangeResult = false;	  //false 시점 확인

			
			m_job_change_without_link_complete = false;

			ADD_LOG("[CID] CID 종료 : 작업 변경 전 링크 안된 경우 종료처리 : %d", bCountOfCIDComptACK);
			
			bCountOfCIDComptACK = 0;
			m_nCidControlStep = CID_STEP_CONNECTING;

			memset(&CID_Save_Node, 0, sizeof(CID_Save_Node));
		}
		else
			bCountOfCIDComptACK++;
	}
	return nError;
}



bool DrivingControl::checkCommandTarget4CID(CID_CTRL_INFO* Info)
{
	// Command target이 Reset Tag를 넘지 않는 경우 true 호출
	bool bCMDTarget = false;
	if (((Info->CIDStartNode1_arr != INDEX_NONE)
		&& ((Info->tmpCurrentCMDID == Info->tmpStartNode1_1)
		|| (Info->tmpCurrentCMDID == Info->tmpStartNode1_2)
		|| (Info->tmpCurrentCMDID == Info->tmpStartNode1_3)
		|| (Info->tmpCurrentCMDID == Info->tmpStartNode1_4)
		|| (Info->tmpCurrentCMDID == Info->tmpStartNode1_5)))
		|| ((Info->CIDStartNode2_arr != INDEX_NONE)
		&& ((Info->tmpCurrentCMDID == Info->tmpStartNode2_1)
		|| (Info->tmpCurrentCMDID == Info->tmpStartNode2_2)
		|| (Info->tmpCurrentCMDID == Info->tmpStartNode2_3)
		|| (Info->tmpCurrentCMDID == Info->tmpStartNode2_4)
		|| (Info->tmpCurrentCMDID == Info->tmpStartNode2_5))))
	{
		bCMDTarget = true;
	}
	return bCMDTarget;
}




// 변화가 있다 - return true, 없다 - return false
bool DrivingControl::IO_INFO_CID(void)
{

	AnsiString strLogTmp;  	// strLogTmp.sprintf
	static AnsiString strBeforeLog;


strLogTmp.sprintf("[CID] Link Complete : %d	Interlock On : %d  Pass ACK : %d  Status : %d // Left : %d  Right : %d  Reserve : %d  Pass : %d  Abnormal : %d  OpMode : %d  Common : %d",
			pHWSet->m_pCID->IsLinkOK(), 		pHWSet->m_pCID->IsInterlock_ON(),
			pHWSet->m_pCID->ISCompletionACK_On(),	pHWSet->m_pCID->ISCidStatusOn(),

			pHWSet->m_pCID->IsLinking_Left(),		pHWSet->m_pCID->IsLinking_Right(),	pHWSet->m_pCID->IsOccupying(),
			pHWSet->m_pCID->ISCompletion_On(),	pHWSet->m_pCID->ISCidManualMode(),
			pHWSet->m_pCID->ISCidOperatingMode(),	pHWSet->m_pCID->ISCommonTagMode());

	if(strBeforeLog != strLogTmp)
	{
		strBeforeLog = strLogTmp;
		ADD_LOG(strLogTmp.c_str());
		return true;
	}
	else
	{
		return false;
	}
}

void DrivingControl::IO_INFO_CID_ALL(void)
{

	AnsiString strLogTmp;  	// strLogTmp.sprintf
    static AnsiString strBeforeLog;

	strLogTmp.sprintf("[CID] I/O ----> Link Complete : %d	Interlock On : %d  Pass ACK : %d  Status : %d // Left : %d  Right : %d  Reserve : %d  Pass : %d  Abnormal : %d  OpMode : %d  Common : %d",
			pHWSet->m_pCID->IsLinkOK(), 		pHWSet->m_pCID->IsInterlock_ON(),
			pHWSet->m_pCID->ISCompletionACK_On(),	pHWSet->m_pCID->ISCidStatusOn(),

			pHWSet->m_pCID->IsLinking_Left(),		pHWSet->m_pCID->IsLinking_Right(),	pHWSet->m_pCID->IsOccupying(),
			pHWSet->m_pCID->ISCompletion_On(),	pHWSet->m_pCID->ISCidManualMode(),
			pHWSet->m_pCID->ISCidOperatingMode(),	pHWSet->m_pCID->ISCommonTagMode());

	if(strBeforeLog != strLogTmp)
	{
		strBeforeLog = strLogTmp;
		ADD_LOG(strLogTmp.c_str());

	}

}

/**
@brief   진행 경로의 CID Start Node, Stop Node, Reset Node 저장하는 함수
@author  KYH
@date    2018.07.03
*/
void DrivingControl::CID_Save_Start_Stop_Reset(CID_CTRL_INFO* Info)
{
	//ADD_LOG("[CID_TEST1]");
	if ((m_CIDDirection == 0) || (m_CIDDirection == 2)) // CID Left
	{
		if(Info->tmpStartNode1_1 != INDEX_NONE)
		{
			CID_Save_Node[0] = Info->tmpStartNode1_1;
			CID_Save_Node[1] = Info->tmpStartNode1_2;
			CID_Save_Node[2] = Info->tmpStartNode1_3;
			CID_Save_Node[3] = Info->tmpStartNode1_4;
			CID_Save_Node[4] = Info->tmpStartNode1_5;
			CID_Save_Node[5] = Info->tmpResetNode1;
			ADD_LOG("[CID]SaveNdoe Reset1 : %d", CID_Save_Node[5]);
			//ADD_LOG("[CID_TEST2]%d, %d, %d, %d, %d, %d", CID_Save_Node[0], CID_Save_Node[1], CID_Save_Node[2], CID_Save_Node[3], CID_Save_Node[4], CID_Save_Node[5]);
		}
	}
	else if ((m_CIDDirection == 1) || (m_CIDDirection == 3)) // CID Right
	{
		if(Info->tmpStartNode2_1 != INDEX_NONE)
		{
			CID_Save_Node[0] = Info->tmpStartNode2_1;
			CID_Save_Node[1] = Info->tmpStartNode2_2;
			CID_Save_Node[2] = Info->tmpStartNode2_3;
			CID_Save_Node[3] = Info->tmpStartNode2_4;
			CID_Save_Node[4] = Info->tmpStartNode2_5;
			CID_Save_Node[5] = Info->tmpResetNode2;
			ADD_LOG("[CID]SaveNdoe Reset2 : %d", CID_Save_Node[5]);
			//ADD_LOG("[CID_TEST3]Save2 : %d, %d, %d, %d, %d, %d", CID_Save_Node[0], CID_Save_Node[1], CID_Save_Node[2], CID_Save_Node[3], CID_Save_Node[4], CID_Save_Node[5]);
		}
	}
	else // CID_DIRECTION_NOT_LINK
	{
	}
}

/**
@brief   동일 CID인지 판단 하는 함수
@author  KYH
@date    2018.07.10
*/
bool DrivingControl::CID_Compare_List(DRIVING_HW_INFO_SET HwInfo)
{
	bool CIDChangeReturn = false;
	int CIDArrayCount = 0;
	unsigned int TotalCount = 0;
	DRIVING_CMD_INFO_OF_NODE* pCIDListNode;
	unsigned int CIDListNodeID = 0;
	int NodeListCount = 0;

	DRIVING_CMD_INFO_OF_NODE* pCurrentNodeID = getNodeInfo(HwInfo.Node.nNodeCount);
	unsigned int nCurrentNodeID = pCurrentNodeID->ID;

	for (int i = 0; i < 5; i++) // 현재 노드와 동일 CID 위치 파악
	{
		if (nCurrentNodeID == CID_Save_Node[i])
		{
			CIDArrayCount = i;
			//ADD_LOG("[CID_TEST4] %d, %d, %d" , nCurrentNodeID, CID_Save_Node[i], i);
			break;
		}
		else
		{
		}
	}

	try
	{
		TotalCount = m_ClassifiedCmd.NodeList.getCount() -1;
		//ADD_LOG("[CID_TEST5] %d", TotalCount);
	}
	catch(...)
	{
		ADD_LOG("[CID] CID_Find_Stop_Reset exception 3");
	}

	for (int i = CIDArrayCount; i < 6; i++) // 현재노드부터 CID 영역의 남은 경로 비교
	{
		if (CID_Save_Node[i] == 0)
		{
			// CID StartNode가 0일경우 Pass
			//ADD_LOG("[CID_TEST9]");
		}
		else
		{
			pCIDListNode = getNodeInfo(HwInfo.Node.nNodeCount + NodeListCount);
			CIDListNodeID = pCIDListNode->ID;
			if (CIDListNodeID == CID_Save_Node[i])
			{
				// 기존 경로와 CID가 동일
				//ADD_LOG("[CID_TEST10] %d, %d", TotalCount, NodeListCount);
			}
			else
			{
				CIDChangeReturn = true;
				//ADD_LOG("[CID_TEST6] %d, %d, %d, %d", CIDListNodeID, CID_Save_Node[i], i, NodeListCount);
				static unsigned int nTmpCurNodeId19112101 = 0;
				if(nTmpCurNodeId19112101 != nCurrentNodeID)
				{
					nTmpCurNodeId19112101 = nCurrentNodeID;
					ADD_LOG("[CID] Direction Change ListNode : %d, SaveNode : %d", CIDListNodeID, CID_Save_Node[i]);
				}
				break;
			}

			if (TotalCount == NodeListCount) // 자신의 마지막 Count일 경우 (자신의 경로가 변경 전 CID 영역과 동일한 크기거나  짧은 경우)
			{
				CIDChangeReturn = false;
				//ADD_LOG("[CID_TEST7] %d, %d, %d, %d", CIDListNodeID, CID_Save_Node[i], TotalCount, NodeListCount);
				static unsigned int nTmpCurNodeId19112102 = 0;
				if(nTmpCurNodeId19112102 != nCurrentNodeID)
				{
					nTmpCurNodeId19112102 = nCurrentNodeID;
					ADD_LOG("[CID] Not Change ListNode : %d, SaveNode : %d", CIDListNodeID, CID_Save_Node[i]);
                }
				break;
			}
			NodeListCount++;
		}
	}
	//ADD_LOG("[CID_TEST8]");

	static unsigned int nTmpCurNodeId01510 = 0;
	if(nTmpCurNodeId01510 != nCurrentNodeID)
	{
		nTmpCurNodeId01510 = nCurrentNodeID;
		ADD_LOG("[CID] CID_Compare_List");
	}

	return CIDChangeReturn;
}



/*
	OHT가 Manual모드일때 처리하는 함수이다
	Auto일 때에는 CID Status머신이 통합 처리하지만,
	Manual일 때에는 이 함수로 정리하여 처리하도록 한다
*/
UINT DrivingControl::Manual_CID(int iManualCtrl)
{
	DRIVING_HW_INFO_SET TmpHwInfo;

	static int iDelayCnt = 0;
	static unsigned char ManualSteerStatus = 0;//0 : 초기값, 1 : 명령과 센서값이 다른 경우 발생

	//조향
	//bool    bSteerFrontLeft = TmpHwInfo.IO.SteerFrontLeftInOn;
	//bool    bSteerFrontRight    = TmpHwInfo.IO.SteerFrontRightInOn;
	unsigned char SteerFront;
	unsigned char SteerRear;
	unsigned char SteerCmdFront;
	unsigned char SteerCmdRear;

	SteerFront = pHWSet->m_pSteer->GetFrontPos();
	SteerRear = pHWSet->m_pSteer->GetRearPos();
	SteerCmdFront = pHWSet->m_pSteer->GetFrontCmd();
	SteerCmdRear = pHWSet->m_pSteer->GetRearCmd();

	switch(iManualCtrl)
	{
		case MANUAL_CID_MODE: 	// Operation Mode를 CID로 변경
		{
			CID_OPERATION_MODE_CID();
			ADD_LOG("[CID] change CID MODE - MANUAL");
		}
		break;

		case MANUAL_CID_SETTING: 	// Abnormal 세트 (O5는 1로 설정)
		{
			 pHWSet->m_pCID->CID_Manual_Mode_On();
			 ADD_LOG("[CID] Abnormal 세트 (O5는 1로 설정)");
		}
		break;

		// 조향정보를 감시한다
		// Left or Right설정 (Left = O1, Right = O2) : AllOff후 해당방향을 켠다
		// 조향 정보를 알수 없는 경우 LH, RH 모두 On 가능한 동작인지 확인 필요...
		case MANUAL_CID_DIRECTION_CHK:
		{
			ADD_LOG("[CID] SteerFront : %d, SteerRear", SteerFront, SteerRear);
			if( SteerFront == SteerRear &&
				(SteerFront == HW_STEER_DIRECTION_RIGHT || SteerFront == HW_STEER_DIRECTION_LEFT))
			{
				if (SteerFront == HW_STEER_DIRECTION_RIGHT)
				{
					if(pHWSet->m_pCID->IsLinking_Left() == true)
					{
						pHWSet->m_pCID->CID_Out_PASS_Compt(ON);
						Sleep(20);
						pHWSet->m_pCID->CID_Out_PASS_Compt(OFF);

						pHWSet->m_pCID->CID_Out_Left_Select(OFF);
						pHWSet->m_pCID->CID_Occup_return(3);
						Sleep(20);

						ADD_LOG("[CID] MAN - L Link Off");
					}

					pHWSet->m_pCID->Right_Link();
					ADD_LOG("[CID] R-Link_Manual On");
				}
				else if(SteerFront == HW_STEER_DIRECTION_LEFT)
				{
					if(pHWSet->m_pCID->IsLinking_Right() == true)
					{
						pHWSet->m_pCID->CID_Out_PASS_Compt(ON);
						Sleep(20);
						pHWSet->m_pCID->CID_Out_PASS_Compt(OFF);

						pHWSet->m_pCID->CID_Out_Right_Select(OFF);
						pHWSet->m_pCID->CID_Occup_return(4);
						Sleep(20);
						ADD_LOG("[CID] MAN - R Link Off");
					}

					pHWSet->m_pCID->Left_Link();
					ADD_LOG("[CID] L-Link_Manual On");
				}
				else
				{
					//NOP
				}

				if(SteerCmdFront != SteerFront &&
					ManualSteerStatus == 1)
				{
					if(SteerFront == HW_STEER_DIRECTION_LEFT)
					{
						pHWSet->m_pSteer->SetFrontDirection(HW_STEER_DIRECTION_CMD_LEFT);
						pHWSet->m_pSteer->SetRearDirection(HW_STEER_DIRECTION_CMD_LEFT);
						ADD_LOG("[CID] MAN CMD - Left ");
						ManualSteerStatus = 0;
					}
					else if(SteerFront == HW_STEER_DIRECTION_RIGHT)
					{
						pHWSet->m_pSteer->SetFrontDirection(HW_STEER_DIRECTION_CMD_RIGHT);
						pHWSet->m_pSteer->SetRearDirection(HW_STEER_DIRECTION_CMD_RIGHT);
						ADD_LOG("[CID] MAN CMD - Right ");
						ManualSteerStatus = 0;
					}
					else
					{
						//NOP
					}

				}
			}
			else	//SteerFront != SteerRear
			{
				if(SteerCmdFront != SteerFront ||
					SteerCmdRear != SteerRear)
				{
					ADD_LOG("[CID] L-R-Link_Manual On");
					pHWSet->m_pCID->CID_Out_Right_Select(ON);
					pHWSet->m_pCID->CID_Out_Left_Select(ON);

					ManualSteerStatus = 1;
				}
			}


		}
		break;

		// 점유를 켠다 (O3 = 1).
		// 조향확인 단계 (MANUAL_CID_DIRECTION_CHK) 로 이동하여 반복 진행한다
		case MANUAL_CID_RESERVED_ON:
		{
			pHWSet->m_pCID->CID_Occup_OK();
			ADD_LOG("[CID] Manual Reserve CID_Occup_OK");

		}
		break;

		case MANUAL_CID_RESERVED_OFF:
		{
			// pHWSet->m_pCID->CID_Output_Clear();
			pHWSet->m_pCID->CID_Occup_return(5);
			ADD_LOG("[CID] Manual Reserve clear CID_Occup_return");
		}
		break;

		case MANUAL_CID_ABNORMAL_MODE_ON:
		{
			pHWSet->m_pCID->CID_Manual_Mode_On();
			ADD_LOG("[CID] Manual_On");
		}
		break;

		case MANUAL_CID_ABNORMAL_MODE_OFF:
		{
			pHWSet->m_pCID->CID_Manual_Mode_Off();
			ADD_LOG("[CID] Abnormal_off");
		}
		break;

		case MANUAL_CID_LEFT_SELECT:
		{
			pHWSet->m_pCID->CID_Out_Right_Select(OFF);
			pHWSet->m_pCID->CID_Out_Left_Select(ON);
			ADD_LOG("[CID] LEFT_SELECT");
		}
		break;

		case MANUAL_CID_RIGHT_SELECT:
		{
			pHWSet->m_pCID->CID_Out_Left_Select(OFF);
			pHWSet->m_pCID->CID_Out_Right_Select(ON);
			ADD_LOG("[CID] RIGHT_SELECT");
		}
		break;

		case MANUAL_CID_COMMON_TAG:
		{
			pHWSet->m_pCID->CID_Out_Common_Tag(6, true);	// Common Tag On
			Sleep(30);
			pHWSet->m_pCID->CID_Out_Common_Tag(7, false);	// Common Tag Off
		}
		break;
	}
}



#define OBS_DETECT_COUNT_LIMIT_FOR_STEER		20

/**
@brief    조향 상태 설정 및 명령 생성
@author  임태웅
@date    2013.08.06
@param pInfoSet 입력/변경되는 상태 정보
@param pSteerCtrl 조향 명령 정보
@return 에러 없으면 0반환, 있으면 에러 코드 반환
*/
UINT DrivingControl::checkSteer(DRIVING_INFO_SET *pInfoSet)
{
	UINT nTmpError = NO_ERR;

	DWORD dwCurrTime = timeGetTime();

	CTRL_INFO_OF_STEER SteerCtrl;
	memset(&SteerCtrl, 0, sizeof(CTRL_INFO_OF_STEER));

	CTRL_INFO_OF_STEER* pSteerCtrl = &(pInfoSet->Control.Steer);

	int nPreCheckCount = ((pInfoSet->HwInfo.Node.nPreCheckCount-pInfoSet->HwInfo.Node.nNodeCount)>1)
							?(pInfoSet->HwInfo.Node.nNodeCount+1)
							:(pInfoSet->HwInfo.Node.nPreCheckCount);

	DRIVING_CMD_INFO_OF_PATH* pPathInfo = getPathInfo(pInfoSet->HwInfo.Node.nNodeCount);

	//2 처음 시작할 때 PreCheck가 Node 를 넘어가있는 경우:
	//2 PreCheck 가 감지 되지 않아 무언 정지가 생길 수 있다.  이 경우 PreCheckCount 를 강제로 1로 만들어 준다
	if( (nPreCheckCount==0)
	&&  (pInfoSet->Position.bPreCheckIsOverFirstNode==true)
	)
	{
		nPreCheckCount=1;
	}

	//에러 발생으로 조향명령 미발생
	if(fabs(m_dCheckPrecheckNodecountPosition) > DIST_MARGIN_OF_NODE)
		return nTmpError;

	bool bSteerChangeAreaByGuide = isSteerChangeAreaByGuide();  // N분기 가이드 레일에 의해 조향이 변경되는 구간

	bool bCmdExist          = false;    // 조향 명령이 있을 경우
	bool bCmdStart[2]       = {false,}; // 조향 명령을 실시한 경우
	bool bTorqueDown[2] = {false,}; // 토크 변경을 실시한 경우
	bool bCmdArrived[2] = {false,}; // 조향이 명령 위치에 도달한 경우
	bool bCmdFinish[2]      = {false,}; // 전후 각각 조향 명령이 완료한 경우 ( 채터링 포함)
	bool bCmdCompleted      = false;    // 조향 명령 완료한 경우 ( 채터링 포함)

	bool bTorqueTraction[2] = {false,}; // Traction 토크로 변경 인가 여부
	static bool bTorqueTractionStart[2] = {false,}; // Traction 토크로 변경 명령 실행 flag

	bool bTorqueObstacle[2] = {false,}; 			// Obstacle 토크로 변경 인가 여부
	bool bTorqueObstacleEnd[2] = {false,}; 			// Obstacle 토크 종료
	static bool bTorqueObstacleStart[2] = {false,}; // Obstacle 토크로 변경 명령 실행 flag
	static HW_STEER_TORQUE SteerTorque4Obstacle[2] = {HW_STEER_TORQUE_STOP, HW_STEER_TORQUE_STOP};
	static int nObsDetectCntForSteer = 0;

	double  dSpeedOfNow                 = pInfoSet->HwInfo.Axis1.dSpeed;              //m_pDrivingAxis->GetCurrentPosition(); //미보정 현재 위치


	STEER_HW_INFO_CMD SteerCmd = STEER_HW_INFO_CMD_LEFT;

	//1  명령 생성 가능성 확인
	if(bSteerChangeAreaByGuide==false)
	{
		bCmdExist = getSteerCmd(nPreCheckCount,&SteerCmd);  // EndNode Count 사용
//      ADD_LOG("getSteerCmd: %d,%d,%d",bCmdExist, nPreCheckCount, SteerCmd);
	}
	else
	{
		bCmdExist = getSteerCmdOnNBranch(&SteerCmd);
	}

	//1 상태 반영
	pInfoSet->Steer.PathSteer = (pPathInfo!=NULL)?pPathInfo->Steering:STEERING_NONE;
//	pInfoSet->Steer.PathDirection = (pPathInfo!=NULL)?pPathInfo->Direction:PATH_DIRECTION_NO_USE;
	pInfoSet->Steer.FrontPosition = getSteerPosition(pInfoSet->HwInfo.IO.SteerFrontLeftInOn, pInfoSet->HwInfo.IO.SteerFrontRightInOn);
	pInfoSet->Steer.RearPosition = getSteerPosition(pInfoSet->HwInfo.IO.SteerRearLeftInOn, pInfoSet->HwInfo.IO.SteerRearRightInOn);

	if(bCmdExist==true)
	{
//		if(SteerCmd!=pInfoSet->HwInfo.IO.SteerFrontDirCmd) //pInfoSet->Steer.FrontCmdDirection)
//		{
//			pInfoSet->Steer.FrontCmdDirection = SteerCmd;
//			pInfoSet->Steer.FrontMoving = true;
//			bCmdStart[0] = true;
//		}

		if((SteerCmd!=pInfoSet->HwInfo.IO.SteerFrontDirCmd) || (SteerCmd!=pInfoSet->HwInfo.IO.SteerRearDirCmd))//pInfoSet->Steer.RearCmdDirection)
		{

			pInfoSet->Steer.FrontCmdDirection = SteerCmd;
			pInfoSet->Steer.FrontMoving = true;
			bCmdStart[0] = true;

			pInfoSet->Steer.RearCmdDirection = SteerCmd;
			pInfoSet->Steer.RearMoving = true;
			bCmdStart[1] = true;

			if(SteerCmd == STEER_HW_INFO_CMD_LEFT)
			{
				if(m_mccparam.bSteerFrontFlag == false)
				{
					ADD_MCC_LOG(",%s,DRV,STEER FRONT LEFT,Start,FOUP,%06d,%06d,%06d,%d,%6.1lf,Next Node Dist,%6.1lf,OHT Detect Output Status,%d,OBS Output Status,%d",
							m_defualtparam->VHLName,
								m_mccparam.uSourceNode,
								m_mccparam.uTargetNode,
							m_pOHTMainStatus->StatusCommon.CurNodeID,
							m_pOHTMainStatus->StatusCommon.CurNodeOffset,
								dSpeedOfNow,
								pPathInfo->dLength - m_pOHTMainStatus->StatusCommon.CurNodeOffset,
								m_pOHTDetect->GetUbgAreaStatus(),
								m_pObstacle->GetObsAreaStatus());
					ADD_MCC_LOG(",%s,DRV,STEER REAR LEFT,Start,FOUP,%06d,%06d,%06d,%d,%6.1lf,Next Node Dist,%6.1lf,OHT Detect Output Status,%d,OBS Output Status,%d",
							m_defualtparam->VHLName,
								m_mccparam.uSourceNode,
								m_mccparam.uTargetNode,
							m_pOHTMainStatus->StatusCommon.CurNodeID,
							m_pOHTMainStatus->StatusCommon.CurNodeOffset,
								dSpeedOfNow,
								pPathInfo->dLength - m_pOHTMainStatus->StatusCommon.CurNodeOffset,
								m_pOHTDetect->GetUbgAreaStatus(),
								m_pObstacle->GetObsAreaStatus());
					if(m_mccparam.dwSteerFrontTime == 0)
				{
						m_mccparam.dwSteerFrontTime = timeGetTime();
						m_mccparam.dwSteerRearTime = timeGetTime();
					}
					m_mccparam.bSteerFrontFlag = true;
					m_mccparam.bSteerRearFlag = true;
				}
			}
			else if(SteerCmd == STEER_HW_INFO_CMD_RIGHT)
			{
				if(m_mccparam.bSteerFrontFlag == false)
				{
					ADD_MCC_LOG(",%s,DRV,STEER FRONT RIGHT,Start,FOUP,%06d,%06d,%06d,%d,%6.1lf,Next Node Dist,%6.1lf,OHT Detect Output Status,%d,OBS Output Status,%d",
							m_defualtparam->VHLName,
								m_mccparam.uSourceNode,
								m_mccparam.uTargetNode,
							m_pOHTMainStatus->StatusCommon.CurNodeID,
							m_pOHTMainStatus->StatusCommon.CurNodeOffset,
								dSpeedOfNow,
								pPathInfo->dLength - m_pOHTMainStatus->StatusCommon.CurNodeOffset,
								m_pOHTDetect->GetUbgAreaStatus(),
								m_pObstacle->GetObsAreaStatus());
					ADD_MCC_LOG(",%s,DRV,STEER REAR RIGHT,Start,FOUP,%06d,%06d,%06d,%d,%6.1lf,Next Node Dist,%6.1lf,OHT Detect Output Status,%d,OBS Output Status,%d",
							m_defualtparam->VHLName,
								m_mccparam.uSourceNode,
								m_mccparam.uTargetNode,
							m_pOHTMainStatus->StatusCommon.CurNodeID,
							m_pOHTMainStatus->StatusCommon.CurNodeOffset,
								dSpeedOfNow,
								pPathInfo->dLength - m_pOHTMainStatus->StatusCommon.CurNodeOffset,
								m_pOHTDetect->GetUbgAreaStatus(),
								m_pObstacle->GetObsAreaStatus());
					if(m_mccparam.dwSteerFrontTime == 0)
				{
						m_mccparam.dwSteerFrontTime = timeGetTime();
						m_mccparam.dwSteerRearTime = timeGetTime();
					}
					m_mccparam.bSteerFrontFlag = true;
					m_mccparam.bSteerRearFlag = true;
				}
            }
		}
	}

	if(pInfoSet->Steer.FrontCmdDirection==STEER_HW_INFO_CMD_LEFT)
	{
		if(pInfoSet->HwInfo.IO.SteerFrontLeftInOn==true)
		{
			bCmdArrived[0] = true;
			pHWSet->m_pCID->CID_Steerring_N_Branch_Select_Off();
		}
		if(pInfoSet->HwInfo.IO.SteerRearLeftInOn==true)     bCmdArrived[1] = true;
	}
	if(pInfoSet->Steer.FrontCmdDirection==STEER_HW_INFO_CMD_RIGHT)
	{
		if(pInfoSet->HwInfo.IO.SteerFrontRightInOn==true)
		{
			bCmdArrived[0] = true;
			pHWSet->m_pCID->CID_Steerring_N_Branch_Select_Off();
		}
		if(pInfoSet->HwInfo.IO.SteerRearRightInOn==true)    bCmdArrived[1] = true;
	}

	if((bCmdExist==false) || ((pInfoSet->HwInfo.IO.SteerFrontDirCmd==pInfoSet->Steer.FrontCmdDirection) && (pInfoSet->HwInfo.IO.SteerRearDirCmd==pInfoSet->Steer.RearCmdDirection)))
	{
		if(     (pInfoSet->Time.Steer.FrontSteeringDeparted.bFlag==true)
			&&  (OHTUTILITY::PreventOverflowGetTimeMs(pInfoSet->Time.Steer.FrontSteeringDeparted.dwTime)>m_pParamSet->Steer.dwMovingTorqueTime)
			&&  (pInfoSet->HwInfo.IO.SteerFrontTorque!=HW_STEER_TORQUE_STOP)
		)
		{
			bTorqueDown[0] = true;
		}
		if(     (pInfoSet->Time.Steer.RearSteeringDeparted.bFlag==true)
			&&  (OHTUTILITY::PreventOverflowGetTimeMs(pInfoSet->Time.Steer.RearSteeringDeparted.dwTime)>m_pParamSet->Steer.dwMovingTorqueTime)
			&&  (pInfoSet->HwInfo.IO.SteerRearTorque!=HW_STEER_TORQUE_STOP)
		)
		{
			bTorqueDown[1] = true;

		}
	}
//	 ADD_LOG("SteeringCmd bCmdExist=%d,pInfoSet->HwInfo.IO.SteerFrontDirCmd %d %d", bCmdExist,pInfoSet->Steer.FrontCmdDirection,pInfoSet->Steer.RearCmdDirection);
	if( (bCmdExist==false) || ((pInfoSet->HwInfo.IO.SteerFrontDirCmd==pInfoSet->Steer.FrontCmdDirection) && (pInfoSet->HwInfo.IO.SteerRearDirCmd==pInfoSet->Steer.RearCmdDirection)))
	{
		if(     (pInfoSet->Time.Steer.FrontSteeringArrived.bFlag==true)
			&&  (OHTUTILITY::PreventOverflowGetTimeMs(pInfoSet->Time.Steer.FrontSteeringArrived.dwTime)>m_pParamSet->Steer.dwCompleteCheckTime)
			&&  (pInfoSet->HwInfo.IO.DetectStatus != DETECT_AND_STOP)
			&&  (pInfoSet->Steer.FrontMoving==true)
		)
		{
			pInfoSet->Steer.FrontMoving = false;
			bTorqueTractionStart[0] = false;
			bCmdFinish[0] = true;
//			m_pSteer->CalculateMaxFrontMovingTime();//doori.shin Front Steering 이동시간 계산

			if(pInfoSet->HwInfo.IO.SteerFrontTorque!=1) bTorqueDown[0] = true;

            if(pInfoSet->HwInfo.IO.SteerFrontLeftInOn==true)
			{
				ADD_MCC_LOG(",%s,DRV,STEER FRONT LEFT,End,FOUP,%06d,%06d,%06d,%d,%6.1lf,Next Node Dist,%6.1lf,Steer Front Left Time,%d,Steer Front Left Hunting Count,%d,OHT Detect Output Status,%d,OBS Output Status,%d,Steer Front Right Off Time,%d,Steer Front Left On Time,%d,Steer Front Trq0 On Time,%d,Steer Front Trq0 Off Time,%d,Steer Front DIR Off Time,%d",
							m_defualtparam->VHLName,
							m_mccparam.uSourceNode,
							m_mccparam.uTargetNode,
							m_pOHTMainStatus->StatusCommon.CurNodeID,
							m_pOHTMainStatus->StatusCommon.CurNodeOffset,
							dSpeedOfNow,
							pPathInfo->dLength - m_pOHTMainStatus->StatusCommon.CurNodeOffset,
							OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwSteerFrontTime),
							m_mccparam.nSteerFrontHuntingCount,
							m_pOHTDetect->GetUbgAreaStatus(),
							m_pObstacle->GetObsAreaStatus(),
							m_mccparam.dwSteerFRightOffTime,
							m_mccparam.dwSteerFLeftOnTime,
							m_mccparam.dwSteerFTRQ0OnTime,
							m_mccparam.dwSteerFTRQ0OffTime,
							m_mccparam.dwSteerFTDIROffTime);
				m_mccparam.dwSteerFrontTime = 0;
				m_mccparam.bSteerFrontFlag = false;
				m_mccparam.nSteerFrontHuntingCount = 0;
			}
			if(pInfoSet->HwInfo.IO.SteerFrontRightInOn==true)
			{
				ADD_MCC_LOG(",%s,DRV,STEER FRONT RIGHT,End,FOUP,%06d,%06d,%06d,%d,%6.1lf,Next Node Dist,%6.1lf,Steer Front Right Time,%d,Steer Front Right Hunting Count,%d,OHT Detect Output Status,%d,OBS Output Status,%d,Steer Front Left Off Time,%d,Steer Front Right On Time,%d,Steer Front Trq0 On Time,%d,Steer Front Trq0 Off Time,%d,Steer Front DIR On Time,%d",
							m_defualtparam->VHLName,
							m_mccparam.uSourceNode,
							m_mccparam.uTargetNode,
							m_pOHTMainStatus->StatusCommon.CurNodeID,
							m_pOHTMainStatus->StatusCommon.CurNodeOffset,
							dSpeedOfNow,
							pPathInfo->dLength - m_pOHTMainStatus->StatusCommon.CurNodeOffset,
							OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwSteerFrontTime),
							m_mccparam.nSteerFrontHuntingCount,
							m_pOHTDetect->GetUbgAreaStatus(),
							m_pObstacle->GetObsAreaStatus(),
							m_mccparam.dwSteerFLeftOffTime,
							m_mccparam.dwSteerFRightOnTime,
							m_mccparam.dwSteerFTRQ0OnTime,
							m_mccparam.dwSteerFTRQ0OffTime,
							m_mccparam.dwSteerFDIROnTime);
				m_mccparam.dwSteerFrontTime = 0;
				m_mccparam.bSteerFrontFlag = false;
				m_mccparam.nSteerFrontHuntingCount = 0;
			}
		}
		if(     (pInfoSet->Time.Steer.RearSteeringArrived.bFlag==true)
			&&  (OHTUTILITY::PreventOverflowGetTimeMs(pInfoSet->Time.Steer.RearSteeringArrived.dwTime)>m_pParamSet->Steer.dwCompleteCheckTime)
			&&  (pInfoSet->HwInfo.IO.DetectStatus != DETECT_AND_STOP)
			&&  (pInfoSet->Steer.RearMoving==true)
		)
		{
			pInfoSet->Steer.RearMoving = false;
			bTorqueTractionStart[1] = false;
			bCmdFinish[1] = true;
//			m_pSteer->CalculateMaxRearMovingTime(); //doori.shin Rear Steering 이동시간 계산

			if(pInfoSet->HwInfo.IO.SteerRearTorque!=1)  bTorqueDown[1] = true;

			if(pInfoSet->HwInfo.IO.SteerRearLeftInOn==true)
			{
				ADD_MCC_LOG(",%s,DRV,STEER REAR LEFT,End,FOUP,%06d,%06d,%06d,%d,%6.1lf,Next Node Dist,%6.1lf,Steer Rear Left Time,%d,Steer Rear Left Hunting Count,%d,OHT Detect Output Status,%d,OBS Output Status,%d,Steer Rear Right Off Time,%d,Steer Rear Left On Time,%d,Steer Rear Trq0 On Time,%d,Steer Rear Trq0 Off Time,%d,Steer Rear DIR Off Time,%d",
							m_defualtparam->VHLName,
							m_mccparam.uSourceNode,
							m_mccparam.uTargetNode,
							m_pOHTMainStatus->StatusCommon.CurNodeID,
							m_pOHTMainStatus->StatusCommon.CurNodeOffset,
							dSpeedOfNow,
							pPathInfo->dLength - m_pOHTMainStatus->StatusCommon.CurNodeOffset,
							OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwSteerRearTime),
							m_mccparam.nSteerRearHuntingCount,
							m_pOHTDetect->GetUbgAreaStatus(),
							m_pObstacle->GetObsAreaStatus(),
							m_mccparam.dwSteerRRightOffTime,
							m_mccparam.dwSteerRLeftOnTime,
							m_mccparam.dwSteerRTRQ0OnTime,
							m_mccparam.dwSteerRTRQ0OffTime,
							m_mccparam.dwSteerRDIROffTime);
				m_mccparam.dwSteerRearTime = 0;
				m_mccparam.bSteerRearFlag = false;
				m_mccparam.nSteerRearHuntingCount = 0;
			}
			if(pInfoSet->HwInfo.IO.SteerRearRightInOn==true)
			{
				ADD_MCC_LOG(",%s,DRV,STEER REAR RIGHT,End,FOUP,%06d,%06d,%06d,%d,%6.1lf,Next Node Dist,%6.1lf,Steer Rear Right Time,%d,Steer Rear Left Hunting Count,%d,OHT Detect Output Status,%d,OBS Output Status,%d,Steer Rear Left Off Time,%d,Steer Rear Right On Time,%d,Steer Rear Trq0 On Time,%d,Steer Rear Trq0 Off Time,%d,Steer Rear DIR On Time,%d",
							m_defualtparam->VHLName,
							m_mccparam.uSourceNode,
							m_mccparam.uTargetNode,
							m_pOHTMainStatus->StatusCommon.CurNodeID,
							m_pOHTMainStatus->StatusCommon.CurNodeOffset,
							dSpeedOfNow,
							pPathInfo->dLength - m_pOHTMainStatus->StatusCommon.CurNodeOffset,
							OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwSteerRearTime),
							m_mccparam.nSteerRearHuntingCount,
							m_pOHTDetect->GetUbgAreaStatus(),
							m_pObstacle->GetObsAreaStatus(),
							m_mccparam.dwSteerRLeftOffTime,
							m_mccparam.dwSteerRRightOnTime,
							m_mccparam.dwSteerRTRQ0OnTime,
							m_mccparam.dwSteerRTRQ0OffTime,
							m_mccparam.dwSteerRDIROnTime);
				m_mccparam.dwSteerRearTime = 0;
				m_mccparam.bSteerRearFlag = false;
				m_mccparam.nSteerRearHuntingCount = 0;
			}
		}

		if( (pInfoSet->Steer.FrontMoving==false) && (pInfoSet->Steer.RearMoving==false) )
		{
			bCmdCompleted = true;
			if(pInfoSet->EventAndState.State.SteerAllCompleted==false)
			{
				ADD_LOG("SteeringCmd bCmdCompleted=%d", bCmdCompleted);

//				m_pSteer->IncreaseSteerMovingCount();//doori.shin Steering 이동시간 증가
			}
		}
	}


	//1 Time 확인
	//--------------------------------------------------------------------------------------//
	if((bCmdStart[0]==true) || (bCmdStart[1]==true))
	{
		pInfoSet->Time.Steer.SteeringChangeCmded.bFlag = true;
		pInfoSet->Time.Steer.SteeringChangeCmded.dwTime = dwCurrTime;
	}
	else if(bCmdCompleted==true)
	{
		pInfoSet->Time.Steer.SteeringChangeCmded.bFlag = false;
	}

	if(pInfoSet->Time.Steer.SteeringChangeCmded.bFlag == true)
	{
#if(UBG_SENSOR_ENABLE==ON)
		if( (pInfoSet->HwInfo.IO.DetectStatus == DETECT_AND_STOP)
		||  (pInfoSet->HwInfo.IO.ObsStatus == DETECT_AND_STOP)
		||  (pHWSet->GetAMCPauseStatus() == STATUS_OHT_PAUSED)
		)
#else
		if(pInfoSet->HwInfo.IO.ObsStatus==DETECT_AND_STOP)
#endif
		{
			pInfoSet->Time.Steer.SteeringChangeCmded.dwTime = dwCurrTime;

			nObsDetectCntForSteer++;

			if( !bTorqueObstacleStart[0]
				&& (pInfoSet->Time.Steer.FrontSteeringDeparted.bFlag == false)
				&& pInfoSet->Steer.FrontMoving
				&& !bCmdArrived[0]
				&& pInfoSet->Time.Steer.SteeringChangeCmded.bFlag
				&& (nObsDetectCntForSteer > OBS_DETECT_COUNT_LIMIT_FOR_STEER)
			)
			{
				if(!bCmdStart[0])
				{
					bTorqueObstacle[0] = true;
					bTorqueObstacleStart[0] = true;

					ADD_LOG("SteeringCmd Front Obstacle Detect");
				}
				else
				{
					nObsDetectCntForSteer = 0;
				}
			}

			if( !bTorqueObstacleStart[1]
				&& (pInfoSet->Time.Steer.RearSteeringDeparted.bFlag == false)
				&& pInfoSet->Steer.RearMoving
				&& !bCmdArrived[1]
				&& pInfoSet->Time.Steer.SteeringChangeCmded.bFlag
				&& (nObsDetectCntForSteer > OBS_DETECT_COUNT_LIMIT_FOR_STEER)
			)
			{
				if(!bCmdStart[1])
				{
					bTorqueObstacle[1] = true;
					bTorqueObstacleStart[1] = true;

					ADD_LOG("SteeringCmd Rear Obstacle Detect");
				}
				else
				{
					nObsDetectCntForSteer = 0;
				}
			}
		}
		else
		{
			if(bTorqueObstacleStart[0] == true)
			{
				bTorqueObstacleStart[0] = false;

				if(!bCmdStart[0])
				{
					bTorqueObstacleEnd[0] = true;
					ADD_LOG("SteeringCmd Front Obstacle No-Detect");
				}
			}

			if(bTorqueObstacleStart[1] == true)
			{
				bTorqueObstacleStart[1] = false;

				if(!bCmdStart[1])
				{
					bTorqueObstacleEnd[1] = true;
					ADD_LOG("SteeringCmd Rear Obstacle No-Detect");
				}
			}

			nObsDetectCntForSteer = 0;
		}
	}

	//--------------------------------------------------------------------------------------//
    if(bCmdArrived[0]==true)
    {
        if(pInfoSet->Time.Steer.FrontSteeringArrived.bFlag==false)
        {
            pInfoSet->Time.Steer.FrontSteeringArrived.bFlag = true;
            pInfoSet->Time.Steer.FrontSteeringArrived.dwTime = dwCurrTime;
        }
    }
    else
    {
        pInfoSet->Time.Steer.FrontSteeringArrived.bFlag = false;
    }
    //--------------------------------------------------------------------------------------//
    if(bCmdArrived[1]==true)
    {
        if(pInfoSet->Time.Steer.RearSteeringArrived.bFlag==false)
        {
            pInfoSet->Time.Steer.RearSteeringArrived.bFlag = true;
            pInfoSet->Time.Steer.RearSteeringArrived.dwTime = dwCurrTime;
        }
    }
    else
    {
        pInfoSet->Time.Steer.RearSteeringArrived.bFlag = false;
    }
    //--------------------------------------------------------------------------------------//
    if(     (pInfoSet->Steer.FrontMoving==true)
        &&  (pInfoSet->HwInfo.IO.SteerFrontLeftInOn==false)
        &&  (pInfoSet->HwInfo.IO.SteerFrontRightInOn==false)
    )
    {
        if(pInfoSet->Time.Steer.FrontSteeringDeparted.bFlag==false)
        {
            pInfoSet->Time.Steer.FrontSteeringDeparted.bFlag = true;
            pInfoSet->Time.Steer.FrontSteeringDeparted.dwTime = dwCurrTime;
        }
    }
    else if(bCmdStart[0]==true)
    {
        pInfoSet->Time.Steer.FrontSteeringDeparted.bFlag = false;
    }

    //--------------------------------------------------------------------------------------//
    if(     (pInfoSet->Steer.RearMoving==true)
        &&  (pInfoSet->HwInfo.IO.SteerRearLeftInOn==false)
        &&  (pInfoSet->HwInfo.IO.SteerRearRightInOn==false)
    )
    {
        if(pInfoSet->Time.Steer.RearSteeringDeparted.bFlag==false)
        {
            pInfoSet->Time.Steer.RearSteeringDeparted.bFlag = true;
            pInfoSet->Time.Steer.RearSteeringDeparted.dwTime = dwCurrTime;
        }
    }
    else if(bCmdStart[1]==true)
    {
        pInfoSet->Time.Steer.RearSteeringDeparted.bFlag = false;
    }
    //--------------------------------------------------------------------------------------//

    // by zzang9un 2014.03.21 : 아래 중간 비교문 주석 처리(Steering이 달라질 때 에러 발생을 위해 수정)
	if(     (bSteerChangeAreaByGuide==false && pInfoSet->Steer.FrontMoving==false && pInfoSet->Steer.RearMoving==false)
        // &&  ((pInfoSet->HwInfo.IO.SteerFrontDirCmd!=pInfoSet->Steer.FrontCmdDirection) || (pInfoSet->HwInfo.IO.SteerRearDirCmd!=pInfoSet->Steer.RearCmdDirection))
        &&  ((bCmdArrived[0]==false)||(bCmdArrived[1]==false))
	)
	{
		if(pInfoSet->Time.Steer.SteeringNotMatch.bFlag==false)
		{
			pInfoSet->Time.Steer.SteeringNotMatch.bFlag = true;
            pInfoSet->Time.Steer.SteeringNotMatch.dwTime = dwCurrTime;

			ADD_LOG("SteeringNotMatch[%d]: N(%d) M(%d:%d) F(%d!=%d) R(%d!=%d) A(%d:%d)"
            , dwCurrTime
			, bSteerChangeAreaByGuide
            , pInfoSet->Steer.FrontMoving
			, pInfoSet->Steer.RearMoving
            , pInfoSet->HwInfo.IO.SteerFrontDirCmd
            , pInfoSet->Steer.FrontCmdDirection
            , pInfoSet->HwInfo.IO.SteerRearDirCmd
            , pInfoSet->Steer.RearCmdDirection
            , bCmdArrived[0]
            , bCmdArrived[1]
            )

		}

	}
	else
    {
        pInfoSet->Time.Steer.SteeringNotMatch.bFlag = false;
    }
    //--------------------------------------------------------------------------------------//

    //1 Events & States
    // Event
    pInfoSet->EventAndState.Event.FrontSteerMoved = bTorqueDown[0];
    pInfoSet->EventAndState.Event.RearSteerMoved = bTorqueDown[1];
    pInfoSet->EventAndState.Event.FrontSteerCompleted = bCmdFinish[0];
    pInfoSet->EventAndState.Event.SteerAllCompleted = bCmdCompleted&(bCmdFinish[0]|bCmdFinish[1]);
    pInfoSet->EventAndState.Event.PushedByGuide = (bSteerChangeAreaByGuide==true)?bCmdExist:false;

    //State
    pInfoSet->EventAndState.State.SteerMoving = pInfoSet->Steer.FrontMoving|pInfoSet->Steer.RearMoving;
    pInfoSet->EventAndState.State.SteerFrontCompleted = !pInfoSet->Steer.FrontMoving;
    pInfoSet->EventAndState.State.SteerAllCompleted = bCmdCompleted;
    pInfoSet->EventAndState.State.SteerChangeAreaByGuide = bSteerChangeAreaByGuide;

    //1 명령 인가 / Back Up
    if(bCmdStart[0]==true)
    {
        SteerCtrl.FrontCmdOn = true;
        SteerCtrl.FrontDirection = SteerCmd;
		if(bSteerChangeAreaByGuide == true)
        {
			SteerCtrl.FrontTorque = HW_STEER_TORQUE_STOP;
			pHWSet->m_pCID->CID_Steerring_N_Branch();
        }
        else
        {
			SteerCtrl.FrontTorque = HW_STEER_TORQUE_MOVING;
		}
    }

    if(bCmdStart[1]==true)
    {
        SteerCtrl.RearCmdOn = true;
        SteerCtrl.RearDirection = SteerCmd;
		if(bSteerChangeAreaByGuide == true)
        {
			SteerCtrl.RearTorque = HW_STEER_TORQUE_STOP;
		}
        else
        {
            SteerCtrl.RearTorque = HW_STEER_TORQUE_MOVING;
        }
	}

    if(bTorqueDown[0]==true)
    {
        SteerCtrl.FrontCmdOn = true;
        SteerCtrl.FrontDirection = pInfoSet->HwInfo.IO.SteerRearDirCmd;
        SteerCtrl.FrontTorque = HW_STEER_TORQUE_STOP;
    }
    if(bTorqueDown[1]==true)
    {
        SteerCtrl.RearCmdOn = true;
        SteerCtrl.RearDirection = pInfoSet->HwInfo.IO.SteerRearDirCmd;
        SteerCtrl.RearTorque = HW_STEER_TORQUE_STOP;
    }

    // -------------------------------------------
    // [BEGIN] by zzang9un 2014.02.12 : Steering Retry

    // 명령 수행 후 Retry를 위한 시간 체크
    // Left
    if(!bTorqueTractionStart[0] &&
        pInfoSet->Steer.FrontMoving && !bCmdArrived[0] &&
        pInfoSet->Time.Steer.SteeringChangeCmded.bFlag &&
		(OHTUTILITY::PreventOverflowGetTimeMs(pInfoSet->Time.Steer.SteeringChangeCmded.dwTime) > TIME_STEERING_RETRY)
    )
    {
	    if(!bCmdStart[0])
    	{
	        bTorqueTraction[0] = true;
    	    bTorqueTractionStart[0] = true;
    	}
    }

    // Right
    if(!bTorqueTractionStart[1] &&
        pInfoSet->Steer.RearMoving && !bCmdArrived[1] &&
        pInfoSet->Time.Steer.SteeringChangeCmded.bFlag &&
		(OHTUTILITY::PreventOverflowGetTimeMs(pInfoSet->Time.Steer.SteeringChangeCmded.dwTime) > TIME_STEERING_RETRY)
    )
    {
	    if(!bCmdStart[1])
    	{
	        bTorqueTraction[1] = true;
    	    bTorqueTractionStart[1] = true;
    	}
    }

    // Left
    if(bTorqueTraction[0])
    {
        SteerCtrl.FrontCmdOn = true;
   	    SteerCtrl.FrontDirection = pInfoSet->HwInfo.IO.SteerFrontDirCmd;
       	SteerCtrl.FrontTorque = HW_STEER_TORQUE_TRACTION;
    }

    // Right
    if(bTorqueTraction[1])
    {
        SteerCtrl.RearCmdOn = true;
        SteerCtrl.RearDirection = pInfoSet->HwInfo.IO.SteerRearDirCmd;
        SteerCtrl.RearTorque = HW_STEER_TORQUE_TRACTION;
    }

    // Left
    if(bTorqueObstacle[0])
    {
        SteerCtrl.FrontCmdOn = true;

		SteerCtrl.FrontDirection = pInfoSet->HwInfo.IO.SteerFrontDirCmd;
        SteerCtrl.FrontTorque = HW_STEER_TORQUE_STOP;
		SteerTorque4Obstacle[0] = pInfoSet->HwInfo.IO.SteerFrontTorque;
    }

    // Right
    if(bTorqueObstacle[1])
    {
		SteerCtrl.RearCmdOn = true;

		SteerCtrl.RearDirection = pInfoSet->HwInfo.IO.SteerRearDirCmd;
        SteerCtrl.RearTorque = HW_STEER_TORQUE_STOP;
		SteerTorque4Obstacle[1] = pInfoSet->HwInfo.IO.SteerRearTorque;
    }

    if(bTorqueObstacleEnd[0])
    {
        SteerCtrl.FrontCmdOn = true;
   	    SteerCtrl.FrontDirection = pInfoSet->HwInfo.IO.SteerFrontDirCmd;
       	SteerCtrl.FrontTorque = SteerTorque4Obstacle[0];
    }

    if(bTorqueObstacleEnd[1])
    {
        SteerCtrl.RearCmdOn = true;
   	    SteerCtrl.RearDirection = pInfoSet->HwInfo.IO.SteerRearDirCmd;
       	SteerCtrl.RearTorque = SteerTorque4Obstacle[1];
    }

    // [END] by zzang9un 2014.02.12 : Steering Retry 시 견인 토크 인가
    // -------------------------------------------

    if((bCmdStart[0]==true)||(bTorqueDown[0]==true)||(bCmdStart[1]==true)||(bTorqueDown[1]==true) ||
        bTorqueTraction[0] || bTorqueTraction[1] ||
        bTorqueObstacle[0] || bTorqueObstacle[1] ||
		bTorqueObstacleEnd[0] || bTorqueObstacleEnd[1]
	)
	{
		*pSteerCtrl = SteerCtrl;
		ADD_LOG("SteeringCmd [F:%d:%d:%d:%d:%d/R:%d:%d:%d:%d:%d] F(%d:%d:%d) R(%d:%d:%d) ST:%4X NC(%d:%d:%d)"
			,bCmdStart[0], bTorqueObstacle[0], bTorqueObstacleEnd[0], bTorqueTraction[0], bTorqueDown[0]
			,bCmdStart[1], bTorqueObstacle[1], bTorqueObstacleEnd[1], bTorqueTraction[1], bTorqueDown[1]
            ,SteerCtrl.FrontCmdOn,SteerCtrl.FrontDirection,SteerCtrl.FrontTorque
            ,SteerCtrl.RearCmdOn,SteerCtrl.RearDirection,SteerCtrl.RearTorque
			,pInfoSet->Steer
            ,pInfoSet->HwInfo.Node.nPreCheckCount
			,pInfoSet->HwInfo.Node.nNodeCount
			,nPreCheckCount);
    }

	if((m_mccparam.bSteerFrontFlag == true) || (m_mccparam.bSteerRearFlag == true))
	{
		if(m_mccparam.bSteerTimeCheckFlag == true)
		{
			if((m_mccparam.bPreSteerFTRQ0 == 0) && (pHWSet->m_pSteer->IsFTorque0On() == 1))
			{
				m_mccparam.dwSteerFTRQ0OnTime = dwCurrTime;
			}
			if((m_mccparam.bPreSteerFTRQ0 == 1) && (pHWSet->m_pSteer->IsFTorque0On() == 0))
			{
				m_mccparam.dwSteerFTRQ0OffTime = dwCurrTime;
			}
			if((m_mccparam.bPreSteerRTRQ0 == 0) && (pHWSet->m_pSteer->IsRTorque0On() == 1))
			{
				m_mccparam.dwSteerRTRQ0OnTime = dwCurrTime;
			}
			if((m_mccparam.bPreSteerRTRQ0 == 1) && (pHWSet->m_pSteer->IsRTorque0On() == 0))
			{
				m_mccparam.dwSteerRTRQ0OffTime = dwCurrTime;
			}
			if((m_mccparam.bPreSteerFDIR == 0) && (pHWSet->m_pSteer->IsFDirOn() == 1))
			{
				m_mccparam.dwSteerFDIROnTime = dwCurrTime;
			}
			if((m_mccparam.bPreSteerFDIR == 1) && (pHWSet->m_pSteer->IsFDirOn() == 0))
			{
				m_mccparam.dwSteerFTDIROffTime = dwCurrTime;
			}
			if((m_mccparam.bPreSteerRDIR == 0) && (pHWSet->m_pSteer->IsRDirOn() == 1))
			{
				m_mccparam.dwSteerRDIROnTime = dwCurrTime;
			}
			if((m_mccparam.bPreSteerRDIR == 1) && (pHWSet->m_pSteer->IsRDirOn() == 0))
			{
				m_mccparam.dwSteerRDIROffTime = dwCurrTime;
			}
			if((m_mccparam.bPreSteerFrontLeft == 0) && (pHWSet->m_pSteer->IsFrontLeftOn() == 1))
			{
				m_mccparam.dwSteerFLeftOnTime = dwCurrTime;
			}
			if((m_mccparam.bPreSteerFrontLeft == 1) && (pHWSet->m_pSteer->IsFrontLeftOn() == 0))
			{
				m_mccparam.dwSteerFLeftOffTime = dwCurrTime;
			}
			if((m_mccparam.bPreSteerRearLeft == 0) && (pHWSet->m_pSteer->IsRearLeftOn() == 1))
			{
				m_mccparam.dwSteerRLeftOnTime = dwCurrTime;
			}
			if((m_mccparam.bPreSteerRearLeft == 1) && (pHWSet->m_pSteer->IsRearLeftOn() == 0))
			{
				m_mccparam.dwSteerRLeftOffTime = dwCurrTime;
			}
			if((m_mccparam.bPreSteerFrontRight == 0) && (pHWSet->m_pSteer->IsFrontRightOn() == 1))
			{
				m_mccparam.dwSteerFRightOnTime = dwCurrTime;
			}
			if((m_mccparam.bPreSteerFrontRight == 1) && (pHWSet->m_pSteer->IsFrontRightOn() == 0))
			{
				m_mccparam.dwSteerFRightOffTime = dwCurrTime;
			}
			if((m_mccparam.bPreSteerRearRight == 0) && (pHWSet->m_pSteer->IsRearRightOn() == 1))
			{
				m_mccparam.dwSteerRRightOnTime = dwCurrTime;
			}
			if((m_mccparam.bPreSteerRearRight == 1) && (pHWSet->m_pSteer->IsRearRightOn() == 0))
			{
				m_mccparam.dwSteerRRightOffTime = dwCurrTime;
			}

			if(pHWSet->m_pSteer->IsFDirOn() == 0)
			{
				if((m_mccparam.bPreSteerFrontLeft == 1) && (pHWSet->m_pSteer->IsFrontLeftOn() == 0))
				{
					m_mccparam.nSteerFrontHuntingCount++;
				}
				if((m_mccparam.bPreSteerRearLeft == 1) && (pHWSet->m_pSteer->IsRearLeftOn() == 0))
				{
					m_mccparam.nSteerRearHuntingCount++;
                }
			}

			if(pHWSet->m_pSteer->IsFDirOn() == 1)
			{
				if((m_mccparam.bPreSteerFrontRight == 1) && (pHWSet->m_pSteer->IsFrontRightOn() == 0))
				{
					m_mccparam.nSteerFrontHuntingCount++;
				}
				if((m_mccparam.bPreSteerRearRight == 1) && (pHWSet->m_pSteer->IsRearRightOn() == 0))
				{
					m_mccparam.nSteerRearHuntingCount++;
                }
			}
		}

		m_mccparam.bSteerTimeCheckFlag = true;

		m_mccparam.bPreSteerFTRQ0 = pHWSet->m_pSteer->IsFTorque0On();
		m_mccparam.bPreSteerRTRQ0 = pHWSet->m_pSteer->IsRTorque0On();
		m_mccparam.bPreSteerFDIR = pHWSet->m_pSteer->IsFDirOn();
		m_mccparam.bPreSteerRDIR = pHWSet->m_pSteer->IsRDirOn();
		m_mccparam.bPreSteerFrontLeft = pHWSet->m_pSteer->IsFrontLeftOn();
		m_mccparam.bPreSteerRearLeft = pHWSet->m_pSteer->IsRearLeftOn();
		m_mccparam.bPreSteerFrontRight = pHWSet->m_pSteer->IsFrontRightOn();
		m_mccparam.bPreSteerRearRight = pHWSet->m_pSteer->IsRearRightOn();
	}
	else if (m_mccparam.bSteerTimeCheckFlag == true)
	{
		m_mccparam.bSteerTimeCheckFlag == false;
		m_mccparam.dwSteerFTRQ0OnTime = 0;
		m_mccparam.dwSteerFTRQ0OffTime = 0;
		m_mccparam.dwSteerRTRQ0OnTime = 0;
		m_mccparam.dwSteerRTRQ0OffTime = 0;
		m_mccparam.dwSteerFDIROnTime = 0;
		m_mccparam.dwSteerFTDIROffTime = 0;
		m_mccparam.dwSteerRDIROnTime = 0;
		m_mccparam.dwSteerRDIROffTime = 0;
		m_mccparam.dwSteerFLeftOnTime = 0;
		m_mccparam.dwSteerFLeftOffTime = 0;
		m_mccparam.dwSteerFRightOnTime = 0;
		m_mccparam.dwSteerFRightOffTime = 0;
		m_mccparam.dwSteerRLeftOnTime = 0;
		m_mccparam.dwSteerRLeftOffTime = 0;
		m_mccparam.dwSteerRRightOnTime = 0;
		m_mccparam.dwSteerRRightOffTime = 0;
	}



    return nTmpError;

}


/**
@brief    조향 상태 설정 및 명령 생성
@author  임태웅
@date    2013.08.06
@param pInfoSet 입력/변경되는 상태 정보
@param pSteerCtrl 조향 명령 정보
@return 에러 없으면 0반환, 있으면 에러 코드 반환
*/
UINT DrivingControl::checkBackSteer(DRIVING_INFO_SET *pInfoSet)
{
	UINT nTmpError = NO_ERR;

	DWORD dwCurrTime = timeGetTime();

	CTRL_INFO_OF_STEER SteerCtrl;
	memset(&SteerCtrl, 0, sizeof(CTRL_INFO_OF_STEER));

	CTRL_INFO_OF_STEER* pSteerCtrl = &(pInfoSet->Control.Steer);

	int nPreCheckCount = pInfoSet->HwInfo.Node.nNodeCount; //기존 정상주행시 Precheck

	DRIVING_CMD_INFO_OF_PATH* pPathInfo = getPathInfo(pInfoSet->HwInfo.Node.nNodeCount);

	//2 처음 시작할 때 PreCheck가 Node 를 넘어가있는 경우:
	//2 PreCheck 가 감지 되지 않아 무언 정지가 생길 수 있다.  이 경우 PreCheckCount 를 강제로 1로 만들어 준다
	if( (nPreCheckCount==0)
	&&  (pInfoSet->Position.bPreCheckIsOverFirstNode==true)
	)
	{
		nPreCheckCount=1;
	}

//	bool bSteerChangeAreaByGuide = isSteerChangeAreaByGuide();  // N분기 가이드 레일에 의해 조향이 변경되는 구간

	bool bCmdExist          = false;    // 조향 명령이 있을 경우
	bool bCmdStart[2]       = {false,}; // 조향 명령을 실시한 경우
	bool bTorqueDown[2] = {false,}; // 토크 변경을 실시한 경우
	bool bCmdArrived[2] = {false,}; // 조향이 명령 위치에 도달한 경우
	bool bCmdFinish[2]      = {false,}; // 전후 각각 조향 명령이 완료한 경우 ( 채터링 포함)
	bool bCmdCompleted      = false;    // 조향 명령 완료한 경우 ( 채터링 포함)

	bool bTorqueTraction[2] = {false,}; // Traction 토크로 변경 인가 여부
	static bool bTorqueTractionStart[2] = {false,}; // Traction 토크로 변경 명령 실행 flag

	bool bTorqueObstacle[2] = {false,}; 			// Obstacle 토크로 변경 인가 여부
	bool bTorqueObstacleEnd[2] = {false,}; 			// Obstacle 토크 종료
	static bool bTorqueObstacleStart[2] = {false,}; // Obstacle 토크로 변경 명령 실행 flag
	static HW_STEER_TORQUE SteerTorque4Obstacle[2] = {HW_STEER_TORQUE_STOP, HW_STEER_TORQUE_STOP};
	static int nObsDetectCntForSteer = 0;

	STEER_HW_INFO_CMD SteerCmd = STEER_HW_INFO_CMD_LEFT;

	//1  명령 생성 가능성 확인

	bCmdExist = getSteerCmd(nPreCheckCount,&SteerCmd);  // EndNode Count 사용

	//1 상태 반영
	pInfoSet->Steer.PathSteer = (pPathInfo!=NULL)?pPathInfo->Steering:STEERING_NONE;
//	pInfoSet->Steer.PathDirection = (pPathInfo!=NULL)?pPathInfo->Direction:PATH_DIRECTION_NO_USE;
	pInfoSet->Steer.FrontPosition = getSteerPosition(pInfoSet->HwInfo.IO.SteerFrontLeftInOn, pInfoSet->HwInfo.IO.SteerFrontRightInOn);
	pInfoSet->Steer.RearPosition = getSteerPosition(pInfoSet->HwInfo.IO.SteerRearLeftInOn, pInfoSet->HwInfo.IO.SteerRearRightInOn);

	if(bCmdExist==true)
	{
		if(SteerCmd!=pInfoSet->HwInfo.IO.SteerFrontDirCmd)//pInfoSet->Steer.FrontCmdDirection)
		{
			pInfoSet->Steer.FrontCmdDirection = SteerCmd;
			pInfoSet->Steer.FrontMoving = true;
			bCmdStart[0] = true;
		}

		if(SteerCmd!=pInfoSet->HwInfo.IO.SteerRearDirCmd)//pInfoSet->Steer.RearCmdDirection)
		{
			pInfoSet->Steer.RearCmdDirection = SteerCmd;
			pInfoSet->Steer.RearMoving = true;
			bCmdStart[1] = true;
		}
	}

	if(pInfoSet->Steer.FrontCmdDirection==STEER_HW_INFO_CMD_LEFT)
	{
		if(pInfoSet->HwInfo.IO.SteerFrontLeftInOn==true)
		{
			bCmdArrived[0] = true;
			pHWSet->m_pCID->CID_Steerring_N_Branch_Select_Off();
		}
		if(pInfoSet->HwInfo.IO.SteerRearLeftInOn==true)     bCmdArrived[1] = true;
	}
	if(pInfoSet->Steer.FrontCmdDirection==STEER_HW_INFO_CMD_RIGHT)
	{
		if(pInfoSet->HwInfo.IO.SteerFrontRightInOn==true)
		{
			bCmdArrived[0] = true;
			pHWSet->m_pCID->CID_Steerring_N_Branch_Select_Off();
		}
		if(pInfoSet->HwInfo.IO.SteerRearRightInOn==true)    bCmdArrived[1] = true;
	}

	if((bCmdExist==false) || ((pInfoSet->HwInfo.IO.SteerFrontDirCmd==pInfoSet->Steer.FrontCmdDirection) && (pInfoSet->HwInfo.IO.SteerRearDirCmd==pInfoSet->Steer.RearCmdDirection)))
	{
		if(     (pInfoSet->Time.Steer.FrontSteeringDeparted.bFlag==true)
			&&  (OHTUTILITY::PreventOverflowGetTimeMs(pInfoSet->Time.Steer.FrontSteeringDeparted.dwTime)>m_pParamSet->Steer.dwMovingTorqueTime)
			&&  (pInfoSet->HwInfo.IO.SteerFrontTorque!=HW_STEER_TORQUE_STOP)
		)
		{
			bTorqueDown[0] = true;
		}
		if(     (pInfoSet->Time.Steer.RearSteeringDeparted.bFlag==true)
			&&  (OHTUTILITY::PreventOverflowGetTimeMs(pInfoSet->Time.Steer.RearSteeringDeparted.dwTime)>m_pParamSet->Steer.dwMovingTorqueTime)
			&&  (pInfoSet->HwInfo.IO.SteerRearTorque!=HW_STEER_TORQUE_STOP)
		)
		{
			bTorqueDown[1] = true;

		}
	}

	if( (bCmdExist==false) || ((pInfoSet->HwInfo.IO.SteerFrontDirCmd==pInfoSet->Steer.FrontCmdDirection) && (pInfoSet->HwInfo.IO.SteerRearDirCmd==pInfoSet->Steer.RearCmdDirection)))
	{
		if(     (pInfoSet->Time.Steer.FrontSteeringArrived.bFlag==true)
			&&  (OHTUTILITY::PreventOverflowGetTimeMs(pInfoSet->Time.Steer.FrontSteeringArrived.dwTime)>m_pParamSet->Steer.dwCompleteCheckTime)
			&&  (pInfoSet->Steer.FrontMoving==true)
		)
		{
			pInfoSet->Steer.FrontMoving = false;
			bTorqueTractionStart[0] = false;
			bCmdFinish[0] = true;

//			m_pSteer->CalculateMaxFrontMovingTime();//doori.shin Front Steering 이동시간 계산

			if(pInfoSet->HwInfo.IO.SteerFrontTorque!=1) bTorqueDown[0] = true;
		}
		if(     (pInfoSet->Time.Steer.RearSteeringArrived.bFlag==true)
			&&  (OHTUTILITY::PreventOverflowGetTimeMs(pInfoSet->Time.Steer.RearSteeringArrived.dwTime)>m_pParamSet->Steer.dwCompleteCheckTime)
			&&  (pInfoSet->Steer.RearMoving==true)
		)
		{
			pInfoSet->Steer.RearMoving = false;
			bTorqueTractionStart[1] = false;
			bCmdFinish[1] = true;

//			m_pSteer->CalculateMaxRearMovingTime(); //doori.shin Rear Steering 이동시간 계산

			if(pInfoSet->HwInfo.IO.SteerRearTorque!=1)  bTorqueDown[1] = true;
		}

		if( (pInfoSet->Steer.FrontMoving==false) && (pInfoSet->Steer.RearMoving==false) )
		{
			bCmdCompleted = true;
			if(pInfoSet->EventAndState.State.SteerAllCompleted==false)
			{
				ADD_LOG("SteeringCmd bCmdCompleted=%d", bCmdCompleted);

//				m_pSteer->IncreaseSteerMovingCount();//doori.shin Steering 이동시간 증가
			}
		}
	}


	//1 Time 확인
	//--------------------------------------------------------------------------------------//
	if((bCmdStart[0]==true) || (bCmdStart[1]==true))
	{
		pInfoSet->Time.Steer.SteeringChangeCmded.bFlag = true;
		pInfoSet->Time.Steer.SteeringChangeCmded.dwTime = dwCurrTime;
	}
	else if(bCmdCompleted==true)
	{
		pInfoSet->Time.Steer.SteeringChangeCmded.bFlag = false;
	}

	if(pInfoSet->Time.Steer.SteeringChangeCmded.bFlag == true)
	{
#if(UBG_SENSOR_ENABLE==ON)
		if( (pInfoSet->HwInfo.IO.DetectStatus == DETECT_AND_STOP)
		||  (pInfoSet->HwInfo.IO.ObsStatus == DETECT_AND_STOP)
		||  (pHWSet->GetAMCPauseStatus() == STATUS_OHT_PAUSED)
		)
#else
		if(pInfoSet->HwInfo.IO.ObsStatus==DETECT_AND_STOP)
#endif
		{
			pInfoSet->Time.Steer.SteeringChangeCmded.dwTime = dwCurrTime;

			nObsDetectCntForSteer++;

			if( !bTorqueObstacleStart[0]
				&& (pInfoSet->Time.Steer.FrontSteeringDeparted.bFlag == false)
				&& pInfoSet->Steer.FrontMoving
				&& !bCmdArrived[0]
				&& pInfoSet->Time.Steer.SteeringChangeCmded.bFlag
				&& (nObsDetectCntForSteer > OBS_DETECT_COUNT_LIMIT_FOR_STEER)
			)
			{
				if(!bCmdStart[0])
				{
					bTorqueObstacle[0] = true;
					bTorqueObstacleStart[0] = true;

					ADD_LOG("SteeringCmd Front Obstacle Detect");
				}
				else
				{
					nObsDetectCntForSteer = 0;
				}
			}

			if( !bTorqueObstacleStart[1]
				&& (pInfoSet->Time.Steer.RearSteeringDeparted.bFlag == false)
				&& pInfoSet->Steer.RearMoving
				&& !bCmdArrived[1]
				&& pInfoSet->Time.Steer.SteeringChangeCmded.bFlag
				&& (nObsDetectCntForSteer > OBS_DETECT_COUNT_LIMIT_FOR_STEER)
			)
			{
				if(!bCmdStart[1])
				{
					bTorqueObstacle[1] = true;
					bTorqueObstacleStart[1] = true;

					ADD_LOG("SteeringCmd Rear Obstacle Detect");
				}
				else
				{
					nObsDetectCntForSteer = 0;
				}
			}
		}
		else
		{

			pInfoSet->Time.Steer.SteeringChangeCmded.dwTime = dwCurrTime;

			if(bTorqueObstacleStart[0] == true)
			{
				bTorqueObstacleStart[0] = false;

				if(!bCmdStart[0])
				{
					bTorqueObstacleEnd[0] = true;
					ADD_LOG("SteeringCmd Front Obstacle No-Detect");
				}
			}

			if(bTorqueObstacleStart[1] == true)
			{
				bTorqueObstacleStart[1] = false;

				if(!bCmdStart[1])
				{
					bTorqueObstacleEnd[1] = true;
					ADD_LOG("SteeringCmd Rear Obstacle No-Detect");
				}
			}

			nObsDetectCntForSteer = 0;
		}
	}

	//--------------------------------------------------------------------------------------//
    if(bCmdArrived[0]==true)
    {
        if(pInfoSet->Time.Steer.FrontSteeringArrived.bFlag==false)
        {
            pInfoSet->Time.Steer.FrontSteeringArrived.bFlag = true;
            pInfoSet->Time.Steer.FrontSteeringArrived.dwTime = dwCurrTime;
        }
    }
    else
    {
        pInfoSet->Time.Steer.FrontSteeringArrived.bFlag = false;
    }
    //--------------------------------------------------------------------------------------//
    if(bCmdArrived[1]==true)
    {
        if(pInfoSet->Time.Steer.RearSteeringArrived.bFlag==false)
        {
            pInfoSet->Time.Steer.RearSteeringArrived.bFlag = true;
            pInfoSet->Time.Steer.RearSteeringArrived.dwTime = dwCurrTime;
        }
    }
    else
    {
        pInfoSet->Time.Steer.RearSteeringArrived.bFlag = false;
    }
    //--------------------------------------------------------------------------------------//
    if(     (pInfoSet->Steer.FrontMoving==true)
        &&  (pInfoSet->HwInfo.IO.SteerFrontLeftInOn==false)
        &&  (pInfoSet->HwInfo.IO.SteerFrontRightInOn==false)
    )
    {
        if(pInfoSet->Time.Steer.FrontSteeringDeparted.bFlag==false)
        {
            pInfoSet->Time.Steer.FrontSteeringDeparted.bFlag = true;
            pInfoSet->Time.Steer.FrontSteeringDeparted.dwTime = dwCurrTime;
        }
    }
    else if(bCmdStart[0]==true)
    {
        pInfoSet->Time.Steer.FrontSteeringDeparted.bFlag = false;
    }

    //--------------------------------------------------------------------------------------//
    if(     (pInfoSet->Steer.RearMoving==true)
        &&  (pInfoSet->HwInfo.IO.SteerRearLeftInOn==false)
        &&  (pInfoSet->HwInfo.IO.SteerRearRightInOn==false)
    )
    {
        if(pInfoSet->Time.Steer.RearSteeringDeparted.bFlag==false)
        {
            pInfoSet->Time.Steer.RearSteeringDeparted.bFlag = true;
            pInfoSet->Time.Steer.RearSteeringDeparted.dwTime = dwCurrTime;
        }
    }
    else if(bCmdStart[1]==true)
    {
        pInfoSet->Time.Steer.RearSteeringDeparted.bFlag = false;
    }
    //--------------------------------------------------------------------------------------//

    // by zzang9un 2014.03.21 : 아래 중간 비교문 주석 처리(Steering이 달라질 때 에러 발생을 위해 수정)
	if((pInfoSet->Steer.FrontMoving==false && pInfoSet->Steer.RearMoving==false)
        // &&  ((pInfoSet->HwInfo.IO.SteerFrontDirCmd!=pInfoSet->Steer.FrontCmdDirection) || (pInfoSet->HwInfo.IO.SteerRearDirCmd!=pInfoSet->Steer.RearCmdDirection))
        &&  ((bCmdArrived[0]==false)||(bCmdArrived[1]==false))
	)
	{
		if(pInfoSet->Time.Steer.SteeringNotMatch.bFlag==false)
		{
			pInfoSet->Time.Steer.SteeringNotMatch.bFlag = true;
            pInfoSet->Time.Steer.SteeringNotMatch.dwTime = dwCurrTime;

			ADD_LOG("SteeringNotMatch[%d]: M(%d:%d) F(%d!=%d) R(%d!=%d) A(%d:%d)"
            , dwCurrTime
            , pInfoSet->Steer.FrontMoving
			, pInfoSet->Steer.RearMoving
            , pInfoSet->HwInfo.IO.SteerFrontDirCmd
            , pInfoSet->Steer.FrontCmdDirection
            , pInfoSet->HwInfo.IO.SteerRearDirCmd
            , pInfoSet->Steer.RearCmdDirection
            , bCmdArrived[0]
            , bCmdArrived[1]
            )

		}

	}
	else
    {
        pInfoSet->Time.Steer.SteeringNotMatch.bFlag = false;
    }
    //--------------------------------------------------------------------------------------//

    //1 Events & States
    // Event
    pInfoSet->EventAndState.Event.FrontSteerMoved = bTorqueDown[0];
    pInfoSet->EventAndState.Event.RearSteerMoved = bTorqueDown[1];
    pInfoSet->EventAndState.Event.FrontSteerCompleted = bCmdFinish[0];
    pInfoSet->EventAndState.Event.SteerAllCompleted = bCmdCompleted&(bCmdFinish[0]|bCmdFinish[1]);
    pInfoSet->EventAndState.Event.PushedByGuide = false;

    //State
    pInfoSet->EventAndState.State.SteerMoving = pInfoSet->Steer.FrontMoving|pInfoSet->Steer.RearMoving;
    pInfoSet->EventAndState.State.SteerFrontCompleted = !pInfoSet->Steer.FrontMoving;
    pInfoSet->EventAndState.State.SteerAllCompleted = bCmdCompleted;
    pInfoSet->EventAndState.State.SteerChangeAreaByGuide = false;

    //1 명령 인가 / Back Up
    if(bCmdStart[0]==true)
    {
        SteerCtrl.FrontCmdOn = true;
        SteerCtrl.FrontDirection = SteerCmd;

		SteerCtrl.FrontTorque = HW_STEER_TORQUE_MOVING;

    }

    if(bCmdStart[1]==true)
    {
        SteerCtrl.RearCmdOn = true;
        SteerCtrl.RearDirection = SteerCmd;

		SteerCtrl.RearTorque = HW_STEER_TORQUE_MOVING;

	}

    if(bTorqueDown[0]==true)
    {
        SteerCtrl.FrontCmdOn = true;
        SteerCtrl.FrontDirection = pInfoSet->HwInfo.IO.SteerRearDirCmd;
        SteerCtrl.FrontTorque = HW_STEER_TORQUE_STOP;
    }
    if(bTorqueDown[1]==true)
    {
        SteerCtrl.RearCmdOn = true;
        SteerCtrl.RearDirection = pInfoSet->HwInfo.IO.SteerRearDirCmd;
        SteerCtrl.RearTorque = HW_STEER_TORQUE_STOP;
    }

    // -------------------------------------------
    // [BEGIN] by zzang9un 2014.02.12 : Steering Retry

    // 명령 수행 후 Retry를 위한 시간 체크
    // Left
    if(!bTorqueTractionStart[0] &&
        pInfoSet->Steer.FrontMoving && !bCmdArrived[0] &&
        pInfoSet->Time.Steer.SteeringChangeCmded.bFlag &&
		(OHTUTILITY::PreventOverflowGetTimeMs(pInfoSet->Time.Steer.SteeringChangeCmded.dwTime) > TIME_STEERING_RETRY)
    )
    {
	    if(!bCmdStart[0])
    	{
	        bTorqueTraction[0] = true;
    	    bTorqueTractionStart[0] = true;
    	}
    }

    // Right
    if(!bTorqueTractionStart[1] &&
        pInfoSet->Steer.RearMoving && !bCmdArrived[1] &&
        pInfoSet->Time.Steer.SteeringChangeCmded.bFlag &&
        (OHTUTILITY::PreventOverflowGetTimeMs(pInfoSet->Time.Steer.SteeringChangeCmded.dwTime) > TIME_STEERING_RETRY)
    )
    {
	    if(!bCmdStart[1])
    	{
	        bTorqueTraction[1] = true;
    	    bTorqueTractionStart[1] = true;
    	}
    }

    // Left
    if(bTorqueTraction[0])
    {
        SteerCtrl.FrontCmdOn = true;
   	    SteerCtrl.FrontDirection = pInfoSet->HwInfo.IO.SteerFrontDirCmd;
       	SteerCtrl.FrontTorque = HW_STEER_TORQUE_TRACTION;
    }

    // Right
    if(bTorqueTraction[1])
    {
        SteerCtrl.RearCmdOn = true;
        SteerCtrl.RearDirection = pInfoSet->HwInfo.IO.SteerRearDirCmd;
        SteerCtrl.RearTorque = HW_STEER_TORQUE_TRACTION;
    }

    // Left
    if(bTorqueObstacle[0])
    {
        SteerCtrl.FrontCmdOn = true;

		SteerCtrl.FrontDirection = pInfoSet->HwInfo.IO.SteerFrontDirCmd;
        SteerCtrl.FrontTorque = HW_STEER_TORQUE_STOP;
		SteerTorque4Obstacle[0] = pInfoSet->HwInfo.IO.SteerFrontTorque;
    }

    // Right
    if(bTorqueObstacle[1])
    {
		SteerCtrl.RearCmdOn = true;

		SteerCtrl.RearDirection = pInfoSet->HwInfo.IO.SteerRearDirCmd;
        SteerCtrl.RearTorque = HW_STEER_TORQUE_STOP;
		SteerTorque4Obstacle[1] = pInfoSet->HwInfo.IO.SteerRearTorque;
    }

    if(bTorqueObstacleEnd[0])
    {
        SteerCtrl.FrontCmdOn = true;
   	    SteerCtrl.FrontDirection = pInfoSet->HwInfo.IO.SteerFrontDirCmd;
       	SteerCtrl.FrontTorque = SteerTorque4Obstacle[0];
    }

    if(bTorqueObstacleEnd[1])
    {
        SteerCtrl.RearCmdOn = true;
   	    SteerCtrl.RearDirection = pInfoSet->HwInfo.IO.SteerRearDirCmd;
       	SteerCtrl.RearTorque = SteerTorque4Obstacle[1];
    }

    // [END] by zzang9un 2014.02.12 : Steering Retry 시 견인 토크 인가
    // -------------------------------------------

    if((bCmdStart[0]==true)||(bTorqueDown[0]==true)||(bCmdStart[1]==true)||(bTorqueDown[1]==true) ||
        bTorqueTraction[0] || bTorqueTraction[1] ||
        bTorqueObstacle[0] || bTorqueObstacle[1] ||
		bTorqueObstacleEnd[0] || bTorqueObstacleEnd[1]
	)
	{
		*pSteerCtrl = SteerCtrl;
		ADD_LOG("SteeringCmd [F:%d:%d:%d:%d:%d/R:%d:%d:%d:%d:%d] F(%d:%d:%d) R(%d:%d:%d) ST:%4X NC(%d:%d:%d)"
			,bCmdStart[0], bTorqueObstacle[0], bTorqueObstacleEnd[0], bTorqueTraction[0], bTorqueDown[0]
			,bCmdStart[1], bTorqueObstacle[1], bTorqueObstacleEnd[1], bTorqueTraction[1], bTorqueDown[1]
            ,SteerCtrl.FrontCmdOn,SteerCtrl.FrontDirection,SteerCtrl.FrontTorque
            ,SteerCtrl.RearCmdOn,SteerCtrl.RearDirection,SteerCtrl.RearTorque
			,pInfoSet->Steer
            ,pInfoSet->HwInfo.Node.nPreCheckCount
			,pInfoSet->HwInfo.Node.nNodeCount
			,nPreCheckCount);
    }

    return nTmpError;

}


void DrivingControl::CID_N_BRANCH_SELECT_OFF()
{
	pHWSet->m_pCID->CID_Steerring_N_Branch_Select_Off();
}
/*
@brief    작업변경  확인 부분
@author  박태욱
@date    2016.11.06
@return 에러 없으면 0반환, 있으면 에러 코드 반환
*/
UINT DrivingControl::checkJobChange(DRIVING_INFO_SET *pInfoSet)
{
	int nError = NO_ERR;
	DWORD dwCurrTime = timeGetTime();

	DRIVING_CMD_INFO_OF_NODE* pNodeInfo = NULL;
	double dSpeedResult =0.0;


	try{
		//1 경로변경/삭제 처리 명령 처리
		if(m_pExecuteInfo->FlagPathChange.bPathChange == true)
		{
			bool bCheckChange = false; //주행부 삭제할 데이터 유무 확인 용
			CLASSIFIED_DRIVING_CHANGE	TempDrivnigInfo;

			memset(&TempDrivnigInfo, 0x00, sizeof(CLASSIFIED_DRIVING_CHANGE));
			bCheckChange = checkCmdInfoNodeList(&(m_ClassifiedCmd.NodeList), (int)m_pExecuteInfo->FlagPathChange.nChageNodeID, &TempDrivnigInfo);  ///< List 정보로부터 Node위치 확인

			if(bCheckChange ==true)
			{

				bCheckChange = clearCmdInfoListsLessAfter(TempDrivnigInfo);

				if(bCheckChange == true)
				{
					m_pExecuteInfo->FlagPathChange.cResult = SUCCESS;


					pInfoSet->EventAndState.Event.TargetChanged  = true;
					//둘다 CheckNodeCount(변경되는 위치)보다 클경우,
					if((pInfoSet->Position.CmdRefInfo.nCount >= TempDrivnigInfo.nCheckNodeCount) &&
						(pInfoSet->Position.CmdRefInfo.nKeyCount >= TempDrivnigInfo.nCheckNodeCount))
					{
                    	//전체 초기화
						pInfoSet->Position.CmdRefInfo.dCmdSpeed =  0.0;
						pInfoSet->Position.CmdRefInfo.dRefSpeed =  0.0;
						pInfoSet->Position.CmdRefInfo.dCmdDecel =  0.0;
						pInfoSet->Position.CmdRefInfo.dDist = 0.0;
						pInfoSet->Position.CmdRefInfo.dSpeedDownPos = 0.0;

						pInfoSet->Position.CmdRefInfo.nCount =pInfoSet->HwInfo.Node.nNodeCount;
						pInfoSet->Position.CmdRefInfo.nKeyCount =pInfoSet->HwInfo.Node.nNodeCount;

						/*
						double	dCmdSpeed;		///< 명령 내려진 속도
						double	dRefSpeed;		///< 기준 속도 (Map)
						double	dCmdDecel;		///< 명령 내려진 가속도
						int		nKeyCount;		///< 명령 내려진 위치의 Node Count
						int		nCount;			///< 명령 내려진 위치의 Node Count
						double	dDist;			///< 명령 내려진 실 거리 (모터 값)
						double	dSpeedDownPos;	///< 감속 시작 실 위치 (모터 값)
						*/
						ADD_LOG("경로 삭제 성공_1");
					}
					else if(pInfoSet->Position.CmdRefInfo.nKeyCount == TempDrivnigInfo.nCheckNodeCount)
					{
						//전체 초기화
						pInfoSet->Position.CmdRefInfo.dCmdSpeed =  0.0;
						pInfoSet->Position.CmdRefInfo.dRefSpeed =  0.0;
						pInfoSet->Position.CmdRefInfo.dCmdDecel =  0.0;
						pInfoSet->Position.CmdRefInfo.dDist = 0.0;
						pInfoSet->Position.CmdRefInfo.dSpeedDownPos = 0.0;

						pInfoSet->Position.CmdRefInfo.nCount =pInfoSet->HwInfo.Node.nNodeCount;
						pInfoSet->Position.CmdRefInfo.nKeyCount =pInfoSet->HwInfo.Node.nNodeCount;

						/*
						double	dCmdSpeed;		///< 명령 내려진 속도
						double	dRefSpeed;		///< 기준 속도 (Map)
						double	dCmdDecel;		///< 명령 내려진 가속도
						int		nKeyCount;		///< 명령 내려진 위치의 Node Count
						int		nCount;			///< 명령 내려진 위치의 Node Count
						double	dDist;			///< 명령 내려진 실 거리 (모터 값)
						double	dSpeedDownPos;	///< 감속 시작 실 위치 (모터 값)
						*/
						ADD_LOG("경로 삭제 성공_2");
					}
					else if(pInfoSet->Position.CmdRefInfo.nCount >= TempDrivnigInfo.nCheckNodeCount)
					{

						//마지막 위치가 짧아지는 경우는 그위치까지 낼수있는 Max Speed를 확인한다.
						pNodeInfo = getNodeInfo(TempDrivnigInfo.nCheckNodeCount);
						dSpeedResult = getMaxSpeed(m_pParamSet->Axis.Default.dDefaultAccel
														,m_pParamSet->Axis.Default.dDefaultDecel
														,(getRealPos(pNodeInfo->dDistSum)-pInfoSet->HwInfo.Axis1.dCurrPos));

						//Data 일부 초기화
						if(dSpeedResult < pInfoSet->Position.CmdRefInfo.dCmdSpeed)
							pInfoSet->Position.CmdRefInfo.dCmdSpeed =  dSpeedResult;

						if(dSpeedResult  < pInfoSet->Position.CmdRefInfo.dRefSpeed)
							pInfoSet->Position.CmdRefInfo.dRefSpeed =  dSpeedResult;

						pInfoSet->Position.CmdRefInfo.dDist = pInfoSet->HwInfo.Axis1.dCurrPos;

						pInfoSet->Position.CmdRefInfo.nCount = TempDrivnigInfo.nCheckNodeCount;
					}

					ADD_LOG("경로 삭제 성공 CurrCount:%d, CmdRefInfo[Count:%d,nKeyCount:%d,Speed :%f]  CheckNode :%d, %f"
					,pInfoSet->HwInfo.Node.nNodeCount
					,pInfoSet->Position.CmdRefInfo.nCount
					,pInfoSet->Position.CmdRefInfo.nKeyCount
					,pInfoSet->HwInfo.Axis1.dSpeed
					,TempDrivnigInfo.nCheckNodeCount,dSpeedResult);




				}
				else
				{
					m_pExecuteInfo->FlagPathChange.cResult = FAIL;
					ADD_LOG("경로 삭제 실패1");
				}

			}
			else
			{
				m_pExecuteInfo->FlagPathChange.cResult = FAIL;
				ADD_LOG("경로 삭제 실패2");
			}

			m_pExecuteInfo->FlagPathChange.bPathChange =false;

		}
	}catch(...)
		ADD_LOG("경로 삭제 Exception");


	return  nError;


}

/*
@brief    MTL 빼냄 확인 부분
@author   puting
@date    2016.11.06
@brief	 현재 PIO가 8점 지원안됨.
@return 에러 없으면 0반환, 있으면 에러 코드 반환
*/
UINT DrivingControl::checMTLTakeOut(DRIVING_HW_INFO_SET HwInfo)
{

	int nError = NO_ERR;

	//---------------------------------------------------------
	NODE_INFO_STD_PATHDATA Pathdata;
  	int tmpCurrenrtNodeID = 0;
	int tmpCurrentStationID = 0;
	bool bCheckTakeoutStart = false;

	tmpCurrenrtNodeID = (int)m_PositionInfo.CurrNode;
	tmpCurrentStationID = (int)m_PositionInfo.CurrStation;

//배출
	 //타이머 체크
    DWORD dwCurrTime = timeGetTime();
	static  DWORD   dwMTLTakeOutTime = timeGetTime();

	 if((m_nMTLTakeOutPIOStep != MTL_TakeOut_CTRL_STEP_NONE) && (m_nMTLTakeOutPIOStep != MTL_TakeOut_CTRL_STEP_COMPLETE))
	 {

		if(OHTUTILITY::PreventOverflowGetTimeMs(dwMTLTakeOutTime) > (4*60000))
		{
		  	return ERR_MTL_TAKEOUT_TIME_OUT;
     	}
	 }

 //PIO 세팅 김태균
	if(m_pExecuteInfo->FlagMTLInfo.bTakeoutCycle == true)
	{
			if(tmpCurrentStationID != 0 )
			{
				nError = OHTMainForm->GetPathDataManager_STD()->GetPathData(OHTMainForm->GetPathData_STD(),&Pathdata, tmpCurrentStationID);

				if((nError == NO_ERR) && (Pathdata.LayoutType == 0x01))
				{
					if((Pathdata.LeftNodeIDIn == tmpCurrentStationID) || (Pathdata.RightNodeIDIn == tmpCurrentStationID))
						bCheckTakeoutStart = true;
				}

//				ADD_LOG("======TakeOUT Start %d, %d %d %d Error %d %d %d",
//				tmpCurrentStationID,m_pExecuteInfo->FlagMTLInfo.nTakeOut,Pathdata.LeftNodeIDIn,Pathdata.RightNodeIDIn
//				,nError,bCheckTakeoutStart,Pathdata.LayoutType);

			   if ((bCheckTakeoutStart == true)&&(pHWSet->m_pDrivingAxis->IsRunning() == false)
				&&((m_pExecuteInfo->FlagMTLInfo.nTakeOut == INIT) || (m_pExecuteInfo->FlagMTLInfo.nTakeOut == COMPLETE))
				&&(m_nMTLTakeOutPIOStep == MTL_TakeOut_CTRL_STEP_NONE)
				&&(m_nMTLTakeInPIOStep == MTL_TakeIn_CTRL_STEP_NONE))
			   {

					nError = pHWSet->m_pLeftEQPIO->Set_RFPIO_Data_RS232_Hybrid(0,0,0,0, m_defualtparam->VHLName);
					m_pMTLPIO->PIOEnable();
					m_nMTLTakeOutPIOStep = MTL_TakeOut_CTRL_STEP_INIT;
					ADD_LOG("======TakeOUT Start3333=====");

					dwMTLTakeOutTime = timeGetTime();
			   }
		   }else
		   {
				//주회주행
			   if(m_nMTLTakeOutPIOStep == MTL_TakeOut_CTRL_NG_COMPLETE)
					m_nMTLTakeOutPIOStep = MTL_TakeOut_CTRL_STEP_NONE;
		   }
	 }else
	 {
	 	//주회주행
       	if(m_nMTLTakeOutPIOStep == MTL_TakeOut_CTRL_NG_COMPLETE)
			m_nMTLTakeOutPIOStep = MTL_TakeOut_CTRL_STEP_NONE;
	 }


	switch(m_nMTLTakeOutPIOStep)
	{
		case MTL_TakeOut_CTRL_STEP_INIT:
		{

			if (m_pMTLPIO->IsGoSignalOn()== true)
			{
			   m_pMTLPIO->OHTInpositionOnOff_TR(ON);
			   ADD_LOG("배출전 정위치");
			   dwMTLTakeOutTime = timeGetTime();
			   m_nMTLTakeOutPIOStep++;
			}else
			{
             	m_pMTLPIO->PIOEnable();
            }
		}
		break;
		case MTL_TakeOut_CTRL_STEP_OCSReport_CHECK:
		  {

		  	dwMTLTakeOutTime = timeGetTime();
			m_nMTLTakeOutPIOStep++;
		  }
		  break;

		case MTL_TakeOut_CTRL_STEP_TakeOutREQ_ON:
		{
			if (m_pMTLPIO->IsGoSignalOn()== true)
			{
				m_pMTLPIO->TakeoutReqOnOff_CS1(ON);
				ADD_LOG("빼냄 요구 ON");
				dwMTLTakeOutTime = timeGetTime();
				m_nMTLTakeOutPIOStep++;
			}
		}
		break;

		case MTL_TakeOut_CTRL_STEP_TakeOutOk_SIGNAL_CHECK:
		{
		  if (m_pMTLPIO->IsGoSignalOn()== true)
		  {
			if(m_pMTLPIO->IsTakeOutOkOn_LR() == true)
			{
				ADD_LOG("빼냄 가능 ON");
				dwMTLTakeOutTime = timeGetTime();
				m_nMTLTakeOutPIOStep++;
			}
			else if (m_pMTLPIO->IsTakeOutNGOn_UR() == true)
			 {
				EnterCriticalSection(&OHTMainForm->m_CS);
				m_pExecuteInfo->FlagMTLInfo.nTakeOut = FAIL;
				LeaveCriticalSection(&OHTMainForm->m_CS);
				m_nMTLTakeOutPIOStep = MTL_TakeOut_CTRL_NG_COMPLETE;

				ADD_LOG("빼냄 실패");
			 }
		  }

		}
		break;

		case MTL_TakeOut_CTRL_STEP_TakeOutREQ_OFF:
		{
			if (m_pMTLPIO->IsGoSignalOn()== true)
			{
				m_pMTLPIO->TakeoutReqOnOff_CS1(OFF);
				ADD_LOG("뺴냄요구 OFF");
				dwMTLTakeOutTime = timeGetTime();
				m_nMTLTakeOutPIOStep++;
			}
		}
		break;

		case MTL_TakeOut_CTRL_STEP_FrontMoveOK_SIGNAL_CHECK:
		{
			if (m_pMTLPIO->IsGoSignalOn()== true)
			{
				if ((m_pMTLPIO->IsMoveOKOn_RD() == true)&&(m_pMTLPIO->IsFrontMoveOn_HA() == true))
				{
					EnterCriticalSection(&OHTMainForm->m_CS);
					m_pExecuteInfo->FlagMTLInfo.nTakeOut = SUCCESS;
					LeaveCriticalSection(&OHTMainForm->m_CS);
					ADD_LOG("전진 이동 가능 ON");
					dwMTLTakeOutTime = timeGetTime();
					m_nMTLTakeOutPIOStep++;
				}
			}
		}
		break;

		case MTL_TakeOut_CTRL_STEP_OHT_MTL_Insert_Start:
		{
			//이동시작
		   	m_pMTLPIO->AllPIOOff();
			if(OHTUTILITY::PreventOverflowGetTimeMs(dwMTLTakeOutTime) > 4000)
			{
                ADD_LOG("이동시작");
				dwMTLTakeOutTime = timeGetTime();
				m_nMTLTakeOutPIOStep++;
			}
		}
		break;

		case MTL_TakeOut_CTRL_STEP_OHT_MTL_Insert_End:
		{
			nError = OHTMainForm->GetPathDataManager_STD()->GetPathData(OHTMainForm->GetPathData_STD(),&Pathdata, tmpCurrentStationID);

			if((nError == NO_ERR) && (Pathdata.LayoutType == 0x01))
			{
				if((Pathdata.LeftNodeIDMiddle == tmpCurrentStationID) || (Pathdata.RightNodeIDMiddle == tmpCurrentStationID))
				  bCheckTakeoutStart = true;
			}

			if ((bCheckTakeoutStart == true)&&(pHWSet->m_pDrivingAxis->IsRunning() == false))
			{
					ADD_LOG("이동완료");
					dwMTLTakeOutTime = timeGetTime();
					m_nMTLTakeOutPIOStep++;
			}
		}
		break;

		case MTL_TakeOut_CTRL_STEP_OHT_Inposition_CHECK:
		{
			if (m_pMTLPIO->IsGoSignalOn()== true)
			{
				if(OHTUTILITY::PreventOverflowGetTimeMs(dwMTLTakeOutTime) > 4000)
				{
					m_pMTLPIO->OHTInpositionOnOff_TR(ON);
					ADD_LOG("승강부 정위치 ON");
					dwMTLTakeOutTime = timeGetTime();
					m_nMTLTakeOutPIOStep++;
				}
			}else
			{
				m_pMTLPIO->PIOEnable();
			}
		}
		break;

		case MTL_TakeOut_CTRL_STEP_TakeOutCompt_CHECK:
		{
			if (m_pMTLPIO->IsGoSignalOn()== true)
			{
			   if (m_pMTLPIO->IsTakeOutNGOn_UR() == true)
			   {
				m_pMTLPIO->AllPIOOff();
				ADD_LOG("빼냄 완료 신호 Check");
				dwMTLTakeOutTime = timeGetTime();
				m_nMTLTakeOutPIOStep++;
			   }
			}
		}
		break;

		case MTL_TakeOut_CTRL_STEP_COMPLETE:
		{
		  if (m_pMTLPIO->IsGoSignalOn() == true)
			{
				m_pMTLPIO->AllPIOOff();

				ADD_LOG("배출 완료");
			}
		}
		break;

		case MTL_TakeOut_CTRL_NG_COMPLETE:
		{
			ADD_LOG("뺴냄 NG 완료");
			m_pMTLPIO->AllPIOOff();
//			m_nMTLTakeOutPIOStep = MTL_TakeOut_CTRL_STEP_NONE;
        }
	}




    //----------------------------------------------------
	return nError;

}



/*
@brief    투입 확인 부분
@author  puting
@date    2016.11.06
@brief	 현재 PIO가 8점 지원안됨.
@return 에러 없으면 0반환, 있으면 에러 코드 반환
*/
UINT DrivingControl::checMTLTakeIn(DRIVING_HW_INFO_SET HwInfo)
{
	int nError = NO_ERR;

	//---------------------------------------------------------
	int tmpCurrenrtNodeID = 0;
	int tmpCurrentStationID = 0;

	NODE_INFO_STD_PATHDATA Pathdata;

	tmpCurrenrtNodeID = (int)m_PositionInfo.CurrNode;
	tmpCurrentStationID = (int)m_PositionInfo.CurrStation;

	bool bCheckTakeInStart = false;
	//투입   김태균

	//타이머 체크
	DWORD dwCurrTime = timeGetTime();
	static  DWORD   dwMTLTakeInTime = timeGetTime();

	 if(m_nMTLTakeInPIOStep != MTL_TakeIn_CTRL_STEP_NONE)
	 {

		if(OHTUTILITY::PreventOverflowGetTimeMs(dwMTLTakeInTime) > (4*60000))
		{
		  return ERR_MTL_TAKEIN_TIME_OUT;
		}
	 }


	if((m_pExecuteInfo->ExecuteMode == EXECUTE_MODE_AUTO)
	 && (pHWSet->m_pDrivingAxis->IsRunning() == false)
	 && (m_nMTLTakeOutPIOStep == MTL_TakeOut_CTRL_STEP_NONE)
	 && (m_nMTLTakeInPIOStep == MTL_TakeIn_CTRL_STEP_NONE))
	 {

			if(tmpCurrentStationID != 0 )
			{
				nError = OHTMainForm->GetPathDataManager_STD()->GetPathData(OHTMainForm->GetPathData_STD(),&Pathdata, tmpCurrentStationID);

			   if((nError == NO_ERR) && (Pathdata.LayoutType == 0x01))
			   {
					if((Pathdata.LeftNodeIDMiddle == tmpCurrentStationID) || (Pathdata.RightNodeIDMiddle == tmpCurrentStationID))
						bCheckTakeInStart = true;
			   }

			   if (bCheckTakeInStart == true)
			   {

					//PIO로 투입 상태 확인
					if (m_pMTLPIO->IsGoSignalOn()== false)
					{
						pHWSet->m_pLeftEQPIO->Set_RFPIO_Data_RS232_Hybrid(0,0,0,0,m_defualtparam->VHLName);

					}
					else
					{
						m_pMTLPIO->OHTInpositionOnOff_TR(ON); //투입전 정위치 신호

						if (m_pMTLPIO->IsTakeOutOkOn_LR() == true) //MTL로부터 투입 시작신호가 올경우 시작.
						{

							m_nMTLTakeInPIOStep = MTL_TakeIn_CTRL_STEP_INIT;
							dwMTLTakeInTime = timeGetTime();
							ADD_LOG("TakeIn Start");
						}
					}
			   }
		   }

	}


   switch(m_nMTLTakeInPIOStep)
   {
	   case MTL_TakeIn_CTRL_STEP_INIT:
	   {

			EnterCriticalSection(&OHTMainForm->m_CS);
			m_pExecuteInfo->FlagMTLInfo.nTakeIn = REQ_INSERT;
			m_pExecuteInfo->FlagMTLInfo.nRailNum = 0x01;
			m_pExecuteInfo->FlagMTLInfo.bTakeInCycle = true;
			LeaveCriticalSection(&OHTMainForm->m_CS);

			ADD_LOG("OCS 투입요청");
			dwMTLTakeInTime = timeGetTime();
			m_nMTLTakeInPIOStep++;

	   }
	   break;

	   case MTL_TakeIn_CTRL_STEP_OHTTakeIn_OK_CHECK:
	   {
		 if (m_pMTLPIO->IsGoSignalOn()== true)
		 {
			if (m_pExecuteInfo->FlagMTLInfo.nTakeInOrder == SUCCESS)
			{
				m_pMTLPIO->TakeInOKOnOff_VA(ON);
				ADD_LOG("OCS 투입 가능")

				dwMTLTakeInTime = timeGetTime();
				m_nMTLTakeInPIOStep++;
			}
			else if (m_pExecuteInfo->FlagMTLInfo.nTakeInOrder == FAIL)
			{
				m_nMTLTakeInPIOStep = MTL_TakeIn_CTRL_STEP_OCSReport_Error;
			  	ADD_LOG("OCS 투입 불가능 종료")
			}
		 }else
		 {
             m_pMTLPIO->PIOEnable();
         }
	   }
	   break;

	   case MTL_TakeIn_CTRL_STEP_TakeIn_SIGNAL_CHECK:
	   {
			if (m_pMTLPIO->IsGoSignalOn()== true)
			{
				if ((m_pMTLPIO->IsMoveOKOn_RD() == true)&&(m_pMTLPIO->IsFrontMoveOn_HA() == true))
				{
					ADD_LOG("전진 이동 가능 ON");
					dwMTLTakeInTime = timeGetTime();
					m_nMTLTakeInPIOStep++;
				}
//				ADD_LOG("전진 이동 %d %d",m_pMTLPIO->IsMoveOKOn_RD(),m_pMTLPIO->IsFrontMoveOn_HA());
			}
	   }
	   break;

	  case MTL_TakeIn_CTRL_STEP_OHT_MTL_TakeIn_Start:
	  {
			//이동시작
			m_pMTLPIO->AllPIOOff();
			if(OHTUTILITY::PreventOverflowGetTimeMs(dwMTLTakeInTime) > 4000)
			{
				ADD_LOG("이동시작");
				dwMTLTakeInTime = timeGetTime();
				m_nMTLTakeInPIOStep++;
			}
	  }
	  break;

	  case MTL_TakeIn_CTRL_STEP_OHT_MTL_TakeIn_End:
	  {
	  	   nError = OHTMainForm->GetPathDataManager_STD()->GetPathData(OHTMainForm->GetPathData_STD(),&Pathdata, tmpCurrentStationID);
		   if((nError == NO_ERR) && (Pathdata.LayoutType == 0x01))
		   {
				if(((Pathdata.LeftDriveDirection == 0) &&(Pathdata.LeftNodeIDOut == tmpCurrentStationID))||
				   ((Pathdata.RightDriveDirection == 0) &&(Pathdata.RightNodeIDOut == tmpCurrentStationID)) ||
				   ((Pathdata.LeftDriveDirection == 1) &&(Pathdata.LeftNodeIDIn == tmpCurrentStationID)) ||
				   ((Pathdata.RightDriveDirection == 1) &&(Pathdata.RightNodeIDIn == tmpCurrentStationID))
				   )
					bCheckTakeInStart = true;
		   }

			if ((bCheckTakeInStart == true)&&(pHWSet->m_pDrivingAxis->IsRunning() == false))
			{
				ADD_LOG("이동완료");
				dwMTLTakeInTime = timeGetTime();
				m_nMTLTakeInPIOStep++;
			}
	  }
	  break;

	  case MTL_TakeIn_CTRL_STEP_OHT_Inposition_CHECK:
		{
			if (m_pMTLPIO->IsGoSignalOn()== true)
			{
				if(OHTUTILITY::PreventOverflowGetTimeMs(dwMTLTakeInTime) > 4000)
				{
					m_pMTLPIO->OHTInpositionOnOff_TR(ON);
					ADD_LOG("MTL Out Node 정위치");
					dwMTLTakeInTime = timeGetTime();
					m_nMTLTakeInPIOStep++;
				}
			}else
			{
                m_pMTLPIO->PIOEnable();
            }
		}
		break;

	  case MTL_TakeIn_CTRL_STEP_TakeInCompt_CHECK:
		{
			if (m_pMTLPIO->IsGoSignalOn()== true)
			{
			   if (m_pMTLPIO->IsMoveOKOn_RD() == true)
			   {
				m_pMTLPIO->AllPIOOff();
				ADD_LOG("투입 완료 신호 Check");
				dwMTLTakeInTime = timeGetTime();
				m_nMTLTakeInPIOStep++;
			   }
			}
		}
		break;

		case MTL_TakeIn_CTRL_STEP_COMPLETE:
		{
		  if (m_pMTLPIO->IsGoSignalOn() == true)
			{
				m_pMTLPIO->AllPIOOff();
				ADD_LOG("투입 완료");

				EnterCriticalSection(&OHTMainForm->m_CS);
				m_pExecuteInfo->FlagMTLInfo.bTakeInCycle = false;
				m_pExecuteInfo->FlagMTLInfo.nTakeInOrder = INIT;
				LeaveCriticalSection(&OHTMainForm->m_CS);
				m_nMTLTakeInPIOStep = MTL_TakeIn_CTRL_STEP_NONE;
			}
		}
		break;

		case MTL_TakeIn_CTRL_STEP_OCSReport_Error:
		{
		  m_pMTLPIO->AllPIOOff();
		  ADD_LOG("OCS 투입불가  Error");
		  //return OCS 투입불가 Error 처리
		  EnterCriticalSection(&OHTMainForm->m_CS);
		  m_pExecuteInfo->FlagMTLInfo.bTakeInCycle = false;
		  m_pExecuteInfo->FlagMTLInfo.nTakeInOrder = INIT;
		  LeaveCriticalSection(&OHTMainForm->m_CS);
		  m_nMTLTakeInPIOStep = MTL_TakeIn_CTRL_STEP_NONE;
		}
		break;


   }




    //----------------------------------------------------
	return nError;

}


/*
@brief    MTL 빼냄 확인 부분
@author   puting
@date    2016.11.06
@brief	 현재 PIO가 8점 지원안됨.
@return 에러 없으면 0반환, 있으면 에러 코드 반환
*/
UINT DrivingControl::checMTLTakeOut_PIO8(DRIVING_HW_INFO_SET HwInfo)
{

	int nError = NO_ERR;
	//---------------------------------------------------------
	NODE_INFO_STD_PATHDATA Pathdata;
  	int tmpCurrenrtNodeID = 0;
	int tmpCurrentStationID = 0;
	bool bCheckTakeoutStart = false;

	static bool bIsBack = false;

	tmpCurrenrtNodeID = (int)m_PositionInfo.CurrNode;
	tmpCurrentStationID = (int)m_PositionInfo.CurrStation;

//배출
	 //타이머 체크
    DWORD dwCurrTime = timeGetTime();
	static  DWORD   dwMTLTakeOutTime = timeGetTime();

	 if((m_nMTLTakeOutPIOStep != MTL_TakeOut_CTRL_STEP_NONE) && (m_nMTLTakeOutPIOStep != MTL_TakeOut_CTRL_STEP_COMPLETE))
	 {

		if(OHTUTILITY::PreventOverflowGetTimeMs(dwMTLTakeOutTime) > (4*60000))
		{
		  	return ERR_MTL_TAKEOUT_TIME_OUT;
     	}
	 }

 //PIO 세팅 김태균
	if(m_pExecuteInfo->FlagMTLInfo.bTakeoutCycle == true)
	{
			if(tmpCurrentStationID != 0 )
			{
				nError = OHTMainForm->GetPathDataManager_STD()->GetPathData(OHTMainForm->GetPathData_STD(),&Pathdata, tmpCurrentStationID);

				if((nError == NO_ERR) && (Pathdata.LayoutType == 0x01))
				{
					if((Pathdata.LeftNodeIDIn == tmpCurrentStationID) || (Pathdata.RightNodeIDIn == tmpCurrentStationID))
					{
						if(Pathdata.LeftNodeIDIn == tmpCurrentStationID)
							bIsBack  = Pathdata.LeftDriveDirection;
						else
							bIsBack  = Pathdata.RightDriveDirection;

						bCheckTakeoutStart = true;
					}
				}

//				ADD_LOG("======TakeOUT Start %d, %d %d %d Error %d %d %d",
//				tmpCurrentStationID,m_pExecuteInfo->FlagMTLInfo.nTakeOut,Pathdata.LeftNodeIDIn,Pathdata.RightNodeIDIn
//				,nError,bCheckTakeoutStart,Pathdata.LayoutType);

			   if ((bCheckTakeoutStart == true)&&(pHWSet->m_pDrivingAxis->IsRunning() == false)
				&&((m_pExecuteInfo->FlagMTLInfo.nTakeOut == INIT) || (m_pExecuteInfo->FlagMTLInfo.nTakeOut == COMPLETE))
				&&(m_nMTLTakeOutPIOStep == MTL_TakeOut_CTRL_STEP_NONE)
				&&(m_nMTLTakeInPIOStep == MTL_TakeIn_CTRL_STEP_NONE))
			   {

					nError = pHWSet->m_pLeftEQPIO->Set_RFPIO_Data_RS232_Hybrid(0,0,0,0, m_defualtparam->VHLName);
					m_pMTLPIO->PIOEnable();
					m_nMTLTakeOutPIOStep = MTL_TakeOut_CTRL_STEP_INIT;
					ADD_LOG("======TakeOUT Start3333=====");

					dwMTLTakeOutTime = timeGetTime();
			   }
		   }else
		   {
				//주회주행
			   if(m_nMTLTakeOutPIOStep == MTL_TakeOut_CTRL_NG_COMPLETE)
					m_nMTLTakeOutPIOStep = MTL_TakeOut_CTRL_STEP_NONE;
		   }
	 }else
	 {
	 	//주회주행
       	if(m_nMTLTakeOutPIOStep == MTL_TakeOut_CTRL_NG_COMPLETE)
			m_nMTLTakeOutPIOStep = MTL_TakeOut_CTRL_STEP_NONE;
	 }


	switch(m_nMTLTakeOutPIOStep)
	{
		case MTL_TakeOut_CTRL_STEP_INIT:
		{

			if (m_pMTLPIO->IsGoSignalOn()== true)
			{
			   m_pMTLPIO->OHTInpositionOnOff_TR(ON);
			   ADD_LOG("배출전 정위치");
			   dwMTLTakeOutTime = timeGetTime();
			   m_nMTLTakeOutPIOStep++;
			}else
			{
             	m_pMTLPIO->PIOEnable();
            }
		}
		break;
		case MTL_TakeOut_CTRL_STEP_OCSReport_CHECK:
		  {

		  	dwMTLTakeOutTime = timeGetTime();
			m_nMTLTakeOutPIOStep++;
		  }
		  break;

		case MTL_TakeOut_CTRL_STEP_TakeOutREQ_ON:
		{
			if (m_pMTLPIO->IsGoSignalOn()== true)
			{
				m_pMTLPIO->TakeoutReqOnOff_CS1(ON);
				ADD_LOG("빼냄 요구 ON");
				dwMTLTakeOutTime = timeGetTime();
				m_nMTLTakeOutPIOStep++;
			}
		}
		break;

		case MTL_TakeOut_CTRL_STEP_TakeOutOk_SIGNAL_CHECK:
		{
		  if (m_pMTLPIO->IsGoSignalOn()== true)
		  {
			if(m_pMTLPIO->IsTakeOutOK_PIO8() == true)
			{
				ADD_LOG("빼냄 가능 ON");
				dwMTLTakeOutTime = timeGetTime();
				m_nMTLTakeOutPIOStep++;
			}
			else if (m_pMTLPIO->IsTakeOutNG_PIO8() == true)
			 {
				EnterCriticalSection(&OHTMainForm->m_CS);
				m_pExecuteInfo->FlagMTLInfo.nTakeOut = FAIL;
				LeaveCriticalSection(&OHTMainForm->m_CS);
				m_nMTLTakeOutPIOStep = MTL_TakeOut_CTRL_NG_COMPLETE;

				ADD_LOG("빼냄 실패");
			 }
		  }

		}
		break;

		case MTL_TakeOut_CTRL_STEP_TakeOutREQ_OFF:
		{
			if (m_pMTLPIO->IsGoSignalOn()== true)
			{
				m_pMTLPIO->TakeoutReqOnOff_CS1(OFF);
				ADD_LOG("뺴냄요구 OFF");
				dwMTLTakeOutTime = timeGetTime();
				m_nMTLTakeOutPIOStep++;
			}
		}
		break;

		case MTL_TakeOut_CTRL_STEP_FrontMoveOK_SIGNAL_CHECK:
		{
			if (m_pMTLPIO->IsGoSignalOn()== true)
			{
				if(bIsBack ==false)
				{
					if ((m_pMTLPIO->IsMoveOK_PIO8() == true)&&(m_pMTLPIO->IsMove_Front_PIO8() == true))
					{
						EnterCriticalSection(&OHTMainForm->m_CS);
						m_pExecuteInfo->FlagMTLInfo.nTakeOut = SUCCESS;
						LeaveCriticalSection(&OHTMainForm->m_CS);
						ADD_LOG("전진 이동 가능 ON");
						dwMTLTakeOutTime = timeGetTime();
						m_nMTLTakeOutPIOStep++;
					}
				}else
				{
					if ((m_pMTLPIO->IsMoveOK_PIO8() == true)&&(m_pMTLPIO->IsMove_Back_PIO8() == true))
					{
						EnterCriticalSection(&OHTMainForm->m_CS);
						m_pExecuteInfo->FlagMTLInfo.nTakeOut = SUCCESS;
						LeaveCriticalSection(&OHTMainForm->m_CS);
						ADD_LOG("후진 이동 가능 ON");
						dwMTLTakeOutTime = timeGetTime();
						m_nMTLTakeOutPIOStep++;
					}
				}
			}
		}
		break;

		case MTL_TakeOut_CTRL_STEP_OHT_MTL_Insert_Start:
		{
			//이동시작
			m_pMTLPIO->AllPIOOff();
			if(OHTUTILITY::PreventOverflowGetTimeMs(dwMTLTakeOutTime) > 4000)
			{
                ADD_LOG("이동시작");
				dwMTLTakeOutTime = timeGetTime();
				m_nMTLTakeOutPIOStep++;
			}
		}
		break;

		case MTL_TakeOut_CTRL_STEP_OHT_MTL_Insert_End:
		{
			nError = OHTMainForm->GetPathDataManager_STD()->GetPathData(OHTMainForm->GetPathData_STD(),&Pathdata, tmpCurrentStationID);

			if((nError == NO_ERR) && (Pathdata.LayoutType == 0x01))
			{
				if((Pathdata.LeftNodeIDMiddle == tmpCurrentStationID) || (Pathdata.RightNodeIDMiddle == tmpCurrentStationID))
				  bCheckTakeoutStart = true;
			}

			if ((bCheckTakeoutStart == true)&&(pHWSet->m_pDrivingAxis->IsRunning() == false))
			{
				ADD_LOG("이동완료");

					dwMTLTakeOutTime = timeGetTime();
					m_nMTLTakeOutPIOStep++;
			}
		}
		break;

		case MTL_TakeOut_CTRL_STEP_OHT_Inposition_CHECK:
		{
			if (m_pMTLPIO->IsGoSignalOn()== true)
			{
				if(OHTUTILITY::PreventOverflowGetTimeMs(dwMTLTakeOutTime) > 4000)
				{
					m_pMTLPIO->OHTInpositionOnOff_TR(ON);
					ADD_LOG("승강부 정위치 ON");
					dwMTLTakeOutTime = timeGetTime();
					m_nMTLTakeOutPIOStep++;
				}
			}else
			{
                m_pMTLPIO->PIOEnable();
            }
		}
		break;

		case MTL_TakeOut_CTRL_STEP_TakeOutCompt_CHECK:
		{
			if (m_pMTLPIO->IsGoSignalOn()== true)
			{
			   if (m_pMTLPIO->IsTakeOutComplete_PIO8() == true)
			   {
				m_pMTLPIO->AllPIOOff();
				ADD_LOG("빼냄 완료 신호 Check");
				dwMTLTakeOutTime = timeGetTime();
				m_nMTLTakeOutPIOStep++;
			   }
			}
		}
		break;

		case MTL_TakeOut_CTRL_STEP_COMPLETE:
		{
		  if (m_pMTLPIO->IsGoSignalOn() == true)
			{
				m_pMTLPIO->AllPIOOff();

				ADD_LOG("배출 완료");
			}
		}
		break;

		case MTL_TakeOut_CTRL_NG_COMPLETE:
		{
			ADD_LOG("뺴냄 NG 완료");
			m_pMTLPIO->AllPIOOff();
//			m_nMTLTakeOutPIOStep = MTL_TakeOut_CTRL_STEP_NONE;
        }
	}




    //----------------------------------------------------
	return nError;

}



/*
@brief    투입 확인 부분 (투입은 후진 X)
@author  puting
@date    2016.11.06
@brief	 현재 PIO가 8점 지원안됨.
@return 에러 없으면 0반환, 있으면 에러 코드 반환
*/
UINT DrivingControl::checMTLTakeIn_PIO8(DRIVING_HW_INFO_SET HwInfo)
{
	int nError = NO_ERR;

	static int nCheckCount = 0;
	//---------------------------------------------------------
	int tmpCurrenrtNodeID = 0;
	int tmpCurrentStationID = 0;

	NODE_INFO_STD_PATHDATA Pathdata;

	tmpCurrenrtNodeID = (int)m_PositionInfo.CurrNode;
	tmpCurrentStationID = (int)m_PositionInfo.CurrStation;

	bool bCheckTakeInStart = false;
	//투입   김태균

	//타이머 체크
	DWORD dwCurrTime = timeGetTime();
	static  DWORD   dwMTLTakeInTime = timeGetTime();

	 if(m_nMTLTakeInPIOStep != MTL_TakeIn_CTRL_STEP_NONE)
	 {

		if(OHTUTILITY::PreventOverflowGetTimeMs(dwMTLTakeInTime) > (4*60000))
		{
		  return ERR_MTL_TAKEIN_TIME_OUT;
		}
	 }


	if((m_pExecuteInfo->ExecuteMode == EXECUTE_MODE_AUTO)
	 && (pHWSet->m_pDrivingAxis->IsRunning() == false)
	 && (m_nMTLTakeOutPIOStep == MTL_TakeOut_CTRL_STEP_NONE)
	 && (m_nMTLTakeInPIOStep == MTL_TakeIn_CTRL_STEP_NONE))
	 {

			if(tmpCurrentStationID != 0 )
			{
				nError = OHTMainForm->GetPathDataManager_STD()->GetPathData(OHTMainForm->GetPathData_STD(),&Pathdata, tmpCurrentStationID);

			   if((nError == NO_ERR) && (Pathdata.LayoutType == 0x01))
			   {
					if((Pathdata.LeftNodeIDMiddle == tmpCurrentStationID) || (Pathdata.RightNodeIDMiddle == tmpCurrentStationID))
						bCheckTakeInStart = true;
			   }

			   if (bCheckTakeInStart == true)
			   {
					nError = pHWSet->m_pLeftEQPIO->Set_RFPIO_Data_RS232_Hybrid(0,0,0,0,m_defualtparam->VHLName);

					//PIO로 투입 상태 확인
					if (m_pMTLPIO->IsGoSignalOn()== false)
					{
						m_pMTLPIO->PIOEnable();
					}
					else
					{
						m_pMTLPIO->OHTInpositionOnOff_TR(ON); //투입전 정위치 신호

						if (m_pMTLPIO->IsTakeInReq_Rail_1_PIO8() == true) //MTL로부터 투입 시작신호가 올경우 시작.
						{
							m_nMTLTakeInPIOStep = MTL_TakeIn_CTRL_STEP_INIT;
							dwMTLTakeInTime = timeGetTime();
							ADD_LOG("TakeIn Start");
						}
					}
			   }
		   }

	}


   switch(m_nMTLTakeInPIOStep)
   {
	   case MTL_TakeIn_CTRL_STEP_INIT:
	   {

			EnterCriticalSection(&OHTMainForm->m_CS);
			m_pExecuteInfo->FlagMTLInfo.nTakeIn = REQ_INSERT;
			m_pExecuteInfo->FlagMTLInfo.nRailNum = 0x01;
			m_pExecuteInfo->FlagMTLInfo.bTakeInCycle = true;
			LeaveCriticalSection(&OHTMainForm->m_CS);

			ADD_LOG("OCS 투입요청");
			dwMTLTakeInTime = timeGetTime();
			m_nMTLTakeInPIOStep++;

	   }
	   break;

	   case MTL_TakeIn_CTRL_STEP_OHTTakeIn_OK_CHECK:
	   {
		 if (m_pMTLPIO->IsGoSignalOn()== true)
		 {
			if (m_pExecuteInfo->FlagMTLInfo.nTakeInOrder == SUCCESS)
			{
				m_pMTLPIO->TakeInOKOnOff_VA(ON);
				ADD_LOG("OCS 투입 가능")

				dwMTLTakeInTime = timeGetTime();
				m_nMTLTakeInPIOStep++;
			}
			else if (m_pExecuteInfo->FlagMTLInfo.nTakeInOrder == FAIL)
			{
				m_nMTLTakeInPIOStep = MTL_TakeIn_CTRL_STEP_OCSReport_Error;
			  	ADD_LOG("OCS 투입 불가능 종료")
			}
		 }else
		 {
             m_pMTLPIO->PIOEnable();
         }
	   }
	   break;

	   case MTL_TakeIn_CTRL_STEP_TakeIn_SIGNAL_CHECK:
	   {
			if (m_pMTLPIO->IsGoSignalOn()== true)
			{
				if ((m_pMTLPIO->IsMoveOK_PIO8() == true)&&(m_pMTLPIO->IsMove_Front_PIO8() == true))
				{
					ADD_LOG("전진 이동 가능 ON");
					dwMTLTakeInTime = timeGetTime();
					m_nMTLTakeInPIOStep++;
				}
//				ADD_LOG("전진 이동 %d %d",m_pMTLPIO->IsMoveOKOn_RD(),m_pMTLPIO->IsFrontMoveOn_HA());
			}
	   }
	   break;

	  case MTL_TakeIn_CTRL_STEP_OHT_MTL_TakeIn_Start:
	  {
			//이동시작
			m_pMTLPIO->AllPIOOff();
			if(OHTUTILITY::PreventOverflowGetTimeMs(dwMTLTakeInTime) > 4000)
			{
				ADD_LOG("이동시작");
				dwMTLTakeInTime = timeGetTime();
				m_nMTLTakeInPIOStep++;
			}
	  }
	  break;

	  case MTL_TakeIn_CTRL_STEP_OHT_MTL_TakeIn_End:
	  {
	  	   nError = OHTMainForm->GetPathDataManager_STD()->GetPathData(OHTMainForm->GetPathData_STD(),&Pathdata, tmpCurrentStationID);
		   if((nError == NO_ERR) && (Pathdata.LayoutType == 0x01))
		   {
				if(((Pathdata.LeftDriveDirection == 0) &&(Pathdata.LeftNodeIDOut == tmpCurrentStationID))||
				   ((Pathdata.RightDriveDirection == 0) &&(Pathdata.RightNodeIDOut == tmpCurrentStationID)) ||
				   ((Pathdata.LeftDriveDirection == 1) &&(Pathdata.LeftNodeIDIn == tmpCurrentStationID)) ||
				   ((Pathdata.RightDriveDirection == 1) &&(Pathdata.RightNodeIDIn == tmpCurrentStationID))
				   )
					bCheckTakeInStart = true;
		   }

			if ((bCheckTakeInStart == true)&&(pHWSet->m_pDrivingAxis->IsRunning() == false))
			{
				ADD_LOG("이동완료");
				dwMTLTakeInTime = timeGetTime();
				m_nMTLTakeInPIOStep++;
			}
	  }
	  break;

	  case MTL_TakeIn_CTRL_STEP_OHT_Inposition_CHECK:
		{
			if (m_pMTLPIO->IsGoSignalOn()== true)
			{
				if(OHTUTILITY::PreventOverflowGetTimeMs(dwMTLTakeInTime) > 4000)
				{
					m_pMTLPIO->OHTInpositionOnOff_TR(ON);
					ADD_LOG("MTL Out Node 정위치");
					dwMTLTakeInTime = timeGetTime();
					m_nMTLTakeInPIOStep++;
				}
			}else
			{
                m_pMTLPIO->PIOEnable();
            }
		}
		break;

	  case MTL_TakeIn_CTRL_STEP_TakeInCompt_CHECK:
		{
			if (m_pMTLPIO->IsGoSignalOn()== true)
			{
			   if (m_pMTLPIO->IsTakeInComplete_PIO8() == true)
			   {
				m_pMTLPIO->AllPIOOff();
				ADD_LOG("투입 완료 신호 Check");
				dwMTLTakeInTime = timeGetTime();
				m_nMTLTakeInPIOStep++;
			   }
			}
		}
		break;

		case MTL_TakeIn_CTRL_STEP_COMPLETE:
		{
		  if (m_pMTLPIO->IsGoSignalOn() == true)
			{
				m_pMTLPIO->AllPIOOff();
				ADD_LOG("투입 완료");

				EnterCriticalSection(&OHTMainForm->m_CS);
				m_pExecuteInfo->FlagMTLInfo.bTakeInCycle = false;
				m_pExecuteInfo->FlagMTLInfo.nTakeInOrder = INIT;
				LeaveCriticalSection(&OHTMainForm->m_CS);
				m_nMTLTakeInPIOStep = MTL_TakeIn_CTRL_STEP_NONE;
			}
		}
		break;

		case MTL_TakeIn_CTRL_STEP_OCSReport_Error:
		{
		  m_pMTLPIO->AllPIOOff();
		  ADD_LOG("OCS 투입불가  Error");
		  //return OCS 투입불가 Error 처리
		  EnterCriticalSection(&OHTMainForm->m_CS);
		  m_pExecuteInfo->FlagMTLInfo.bTakeInCycle = false;
		  m_pExecuteInfo->FlagMTLInfo.nTakeInOrder = INIT;
		  LeaveCriticalSection(&OHTMainForm->m_CS);
		  m_nMTLTakeInPIOStep = MTL_TakeIn_CTRL_STEP_NONE;
		}
		break;


   }

    //----------------------------------------------------
	return nError;

}

/*
@brief    Servo 내부제한토크  상태 설정 및 명령 생성
@author  박태욱
@date    2016.08.06
@param pInfoSet 입력/변경되는 상태 정보
@param pDetectCtrl 전방 감지 명령 정보
@return 에러 없으면 0반환, 있으면 에러 코드 반환
*/
UINT DrivingControl::checkServoTorqueFlag(DRIVING_INFO_SET *pInfoSet)
{
	int nError = NO_ERR;
	DWORD dwCurrTime = timeGetTime();
	static int nCheckCount = 0;
	static int nCheckCount_Torqur90=0;
	static int nCheckCount_Torqur800=0;

	DRIVING_CMD_INFO_OF_NODE* pNodeInfo = getNodeInfo(pInfoSet->HwInfo.Node.nNodeCount);

	//경사로 유무 판단하는 부분
//	if(pNodeInfo->NodeType != m_cSlopeNodeInfo)
//	{
	if(pNodeInfo->NodeType ==SLOPE_NTYPE)
	{
		if(pNodeInfo->NodeType != m_cSlopeNodeInfo)
		{
			ADD_LOG("SetSlopeTime");
			m_pDrivingAxis->SetSlopeTime();
		}

	}
	else
	{
		if((m_cSlopeNodeInfo ==SLOPE_NTYPE) || (m_cSlopeNodeInfo ==INIT_NTYPE))
		{
			ADD_LOG("Release SlopeTime");
			m_pDrivingAxis->SetSlopeTimeRelease();
		}
	}

	m_cSlopeNodeInfo = pNodeInfo->NodeType;

//	ADD_LOG("IsSlope %d",m_cSlopeNodeInfo);
//	}


	if(pNodeInfo==NULL)
    {
		ADD_LOG("checkServoTorqueFlag :Cnt:%d, ListCnt:%d"
			, pInfoSet->HwInfo.Node.nNodeCount
			, m_ClassifiedCmd.NodeList.getCount())
		ADD_FDC_LOG("ERR/%d/3/5/%06d/%06d/%d/%d/%06d",
					ERR_NOTFIND_NODE,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pExecuteInfo->ExecutePositionInfo.NextNode,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					m_pOHTMainStatus->StatusCommon.ExistFoup,
					m_pOHTMainStatus->StatusCommon.StopStationID);
		return ERR_NOTFIND_NODE;// 에러 처리 : 명령에 없는 노드 Count 실시
	}

//	ADD_LOG("checkServoTorqueFlag %d",pHWSet->GetAMCTorqueStatus());

	if(m_cSlopeNodeInfo ==SLOPE_NTYPE)
	{
		// 설정 토크제한 설정
		if(pHWSet->GetAMCTorqueStatus()==SETSLOPE)
		{
			nCheckCount++;
			if(nCheckCount ==5)
			{

				if(m_pServoControl->IsSetInnerLimitTorque_90() ==false)

					m_pServoControl->SetInnerLimitTorque_90();


				if(m_pServoControl->IsSetInnerLimitTorque_90() ==true)
				{
					m_pDrivingAxis->SetTorqueLimit();
					nCheckCount_Torqur90 =0;
				}
				else
				{
					nCheckCount_Torqur90++;
					if(nCheckCount_Torqur90> 10)    //5*10*16
					{
						nError = ERR_SERVO_DRIVING_ALARM;
						ERR_LOG("[checkServoTorqueFlag1] Fail SetInnerLimitTorque_90");
						nCheckCount_Torqur90 =0;
					}
				}

				nCheckCount =0;
				ADD_LOG("SetTorqueLimit %d",m_pServoControl->IsSetInnerLimitTorque_90());
			}
		}
		  // 설정 토크제한 해지
		else if(pHWSet->GetAMCTorqueStatus()==RELSLOPE)
		{
			nCheckCount++;
			if(nCheckCount ==5)
			{
				if(m_pServoControl->IsSetInnerLimitTorque_800() ==false)
					m_pServoControl->SetInnerLimitTorque_800();


				if(m_pServoControl->IsSetInnerLimitTorque_800() ==true)
				{
					m_pDrivingAxis->SetTorqueLimitRelease();
					nCheckCount_Torqur800=0;
				}
				else
				{
					nCheckCount_Torqur800++;
					if(nCheckCount_Torqur800>10)
					{
						nError = ERR_SERVO_DRIVING_ALARM;
						ERR_LOG("[checkServoTorqueFlag1] Fail SetInnerLimitTorque_800");
						nCheckCount_Torqur800=0;
					}
                }
				nCheckCount=0;
			}
		}
		else
		{
			nCheckCount = 0;
			nCheckCount_Torqur90 = 0;
			nCheckCount_Torqur800=0;
		}


	}
	else
	{
		if(m_pServoControl->IsSetInnerLimitTorque_800() ==false)
			m_pServoControl->SetInnerLimitTorque_800();
	}

	return nError;

}
/*
@brief    전방 감지 상태 설정 및 명령 생성
@author  임태웅
@date    2013.08.06
@param pInfoSet 입력/변경되는 상태 정보
@param pDetectCtrl 전방 감지 명령 정보
@return 에러 없으면 0반환, 있으면 에러 코드 반환
*/
UINT DrivingControl::checkFrontObservation(DRIVING_INFO_SET *pInfoSet)
{
    UINT nTmpError = NO_ERR;
	static int nDistNotMatch = 0;
	static int nUBGNotMatch = 0;

    DWORD dwCurrTime = timeGetTime();
    bool bStopWithNoReason = false;
	USER_DETECT_INFO DetectInfo;

	double  dSpeedOfNow = pInfoSet->HwInfo.Axis1.dSpeed;

//	memset(&DetectInfo, 0, sizeof(CTRL_INFO_OF_FRONT_DETECT));
	memset(&DetectInfo, 0, sizeof(USER_DETECT_INFO));
    // Control 정보
	CTRL_INFO_OF_FRONT_DETECT* pDetectCtrl = &(pInfoSet->Control.FrontObservation);

    //2 Time
#if(UBG_SENSOR_ENABLE == ON)
	if(pInfoSet->HwInfo.IO.DetectStatus==DETECT_UNIT_FAIL)
	{
		if(pInfoSet->Time.FrontObserve.OHTDetectFail.bFlag==false)
		{
			pInfoSet->Time.FrontObserve.OHTDetectFail.bFlag = true;
			pInfoSet->Time.FrontObserve.OHTDetectFail.dwTime = dwCurrTime;
		}
	}
	else
	{
		pInfoSet->Time.FrontObserve.OHTDetectFail.bFlag = false;
	}
#endif

	if(pInfoSet->HwInfo.IO.ObsStatus==DETECT_UNIT_FAIL)
    {
        if(pInfoSet->Time.FrontObserve.OBSDetectFail.bFlag==false)
        {
            pInfoSet->Time.FrontObserve.OBSDetectFail.bFlag = true;
			pInfoSet->Time.FrontObserve.OBSDetectFail.dwTime = dwCurrTime;
		}
    }
	else
    {
		pInfoSet->Time.FrontObserve.OBSDetectFail.bFlag = false;
    }


#if(UBG_SENSOR_ENABLE == ON)
	if(     (pInfoSet->HwInfo.IO.ObsStatus==DETECT_AND_STOP)
        &&  (pInfoSet->HwInfo.IO.DetectStatus==DETECT_NONE)
        &&  (pHWSet->GetAMCPauseStatus() != STATUS_OHT_PAUSED)
        )
#else
	if(pInfoSet->HwInfo.IO.ObsStatus==DETECT_AND_STOP)
#endif
    {
        if(pInfoSet->Time.FrontObserve.OBSDetect.bFlag==false)
        {
            pInfoSet->Time.FrontObserve.OBSDetect.bFlag = true;
            pInfoSet->Time.FrontObserve.OBSDetect.dwTime = dwCurrTime;
        }
    }
    else
    {
        pInfoSet->Time.FrontObserve.OBSDetect.bFlag = false;
    }

#if(UBG_SENSOR_ENABLE == ON)
	if(     ((pInfoSet->HwInfo.IO.ObsStatus == DETECT_AND_STOP)
		||  (pInfoSet->HwInfo.IO.DetectStatus == DETECT_AND_STOP))
		&&	(dSpeedOfNow == 0.0))
#else
	if((pInfoSet->HwInfo.IO.ObsStatus == DETECT_AND_STOP) && (dSpeedOfNow == 0.0))
#endif
	{
		if(m_mccparam.bDetectStatus == false)
		{
			ADD_MCC_LOG(",%s,DRV,OHT DETECT AND STOP,Start,FOUP,%06d,%06d,%06d,%d,%6.1lf,OHT Detect Status,%d,OBS Detect Status,%d",
								m_defualtparam->VHLName,
								m_mccparam.uSourceNode,
								m_mccparam.uTargetNode,
								m_pOHTMainStatus->StatusCommon.CurNodeID,
								m_pOHTMainStatus->StatusCommon.CurNodeOffset,
								dSpeedOfNow,
								pInfoSet->HwInfo.IO.DetectStatus,
								pInfoSet->HwInfo.IO.ObsStatus);
			m_mccparam.bDetectStatus = true;
		}

		if((pInfoSet->HwInfo.IO.ObsStatus == DETECT_AND_STOP) && (m_mccparam.dwOBSDetectTime == 0))
		{
			m_mccparam.dwOBSDetectTime = dwCurrTime;
		}
#if(UBG_SENSOR_ENABLE == ON)
		if((pInfoSet->HwInfo.IO.DetectStatus == DETECT_AND_STOP) && (m_mccparam.dwUBGDetectTime == 0))
		{
			m_mccparam.dwUBGDetectTime = dwCurrTime;
		}
#endif
	}


#if(UBG_SENSOR_ENABLE == ON)
	if((m_mccparam.bDetectStatus == true) && (dSpeedOfNow != 0.0) &&
		((pInfoSet->HwInfo.IO.ObsStatus != DETECT_AND_STOP)
		&&  (pInfoSet->HwInfo.IO.DetectStatus != DETECT_AND_STOP)))
#else
	if((m_mccparam.bDetectStatus == true) && (dSpeedOfNow != 0.0) &&
		(pInfoSet->HwInfo.IO.ObsStatus != DETECT_AND_STOP))
#endif
	{
		ADD_MCC_LOG(",%s,DRV,OHT DETECT AND STOP,End,FOUP,%06d,%06d,%06d,%d,%6.1lf,OHT Detect Stop Time,%d,OBS Detect Stop Time,%d",
							m_defualtparam->VHLName,
							m_mccparam.uSourceNode,
							m_mccparam.uTargetNode,
							m_pOHTMainStatus->StatusCommon.CurNodeID,
							m_pOHTMainStatus->StatusCommon.CurNodeOffset,
							dSpeedOfNow,
							OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwUBGDetectTime),
							OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwOBSDetectTime));
		m_mccparam.bDetectStatus = false;
		m_mccparam.dwOBSDetectTime = 0;
		m_mccparam.dwUBGDetectTime = 0;
	}

    pInfoSet->EventAndState.Event.StopWithNoReason = false; //1 임시 초기화

#if(UBG_SENSOR_ENABLE == ON)
	if(     (pInfoSet->HwInfo.IO.Axis1Running!=true)
		&&  (pInfoSet->HwInfo.IO.ObsStatus!=DETECT_AND_STOP)
		&&  (pInfoSet->HwInfo.IO.DetectStatus!=DETECT_AND_STOP)
		&&	(pHWSet->GetAMCPauseStatus() != STATUS_OHT_PAUSED)
		)
#else
	if(     (pInfoSet->HwInfo.IO.Axis1Running!=true)
		&&  (pInfoSet->HwInfo.IO.ObsStatus!=DETECT_AND_STOP)
		)
#endif
	{
        // 전방 감지 상태가 Stop이 아닌데 OHT가 움직이지 않는 경우
        if(pInfoSet->Time.Stop.OnAbnormalStop.bFlag==false)
        {
            // OnAbnormalStop.bFlag만 True로 변경함
            pInfoSet->Time.Stop.OnAbnormalStop.bFlag = true;
            pInfoSet->Time.Stop.OnAbnormalStop.dwTime = dwCurrTime;
            bStopWithNoReason = true;
            ADD_LOG("[OnAbnormalStop.bFlag] Axis1Running:%d, ObsStatus:%d, DetectStatus:%d, dwTime:%d Pos:%6.1lf(P:%6.1lf,%3d,%d)(N:%6.1lf,%3d,%d)(F:%6.1lf,%d:%6.1lf,%d)"
                , pInfoSet->HwInfo.IO.Axis1Running
                , pInfoSet->HwInfo.IO.ObsStatus
                , pInfoSet->HwInfo.IO.DetectStatus
                , pInfoSet->Time.Stop.OnAbnormalStop.dwTime

                , pInfoSet->HwInfo.Axis1.dCurrPos

				, pInfoSet->HwInfo.Node.dPreCheckPosition
                , pInfoSet->HwInfo.Node.nPreCheckCount
                , pInfoSet->HwInfo.IO.NodePreCheckOn

                , pInfoSet->HwInfo.Node.dNodePosition
                , pInfoSet->HwInfo.Node.nNodeCount
                , pInfoSet->HwInfo.IO.NodeOn

                , pInfoSet->HwInfo.TagStaion.dFrontPosition
                , pInfoSet->HwInfo.IO.TagStationFrontOn
                , pInfoSet->HwInfo.TagStaion.dRearPosition
                , pInfoSet->HwInfo.IO.TagStationRearOn
                );
        }

        if(pInfoSet->Time.Stop.OnAbnormalRetry.bFlag==false)//1 긴급 작업
        {
            pInfoSet->Time.Stop.OnAbnormalRetry.bFlag = true;
            pInfoSet->Time.Stop.OnAbnormalRetry.dwTime = dwCurrTime;
        }
        else if(OHTUTILITY::PreventOverflowGetTimeMs(pInfoSet->Time.Stop.OnAbnormalRetry.dwTime)>500)
		{
            if(fabs(pInfoSet->HwInfo.Axis1.dFinalPos-pInfoSet->HwInfo.Axis1.dCurrPos)>ACCEPTABLE_DRIVING_POSITION_ERROR)
            {
				pInfoSet->Time.Stop.OnAbnormalRetry.bFlag = false;
                pInfoSet->EventAndState.Event.StopWithNoReason = true;
            }
        }
    }
    else
    {
        pInfoSet->Time.Stop.OnAbnormalStop.bFlag = false;
		pInfoSet->Time.Stop.OnAbnormalRetry.bFlag = false;
    }

    //2 Events & States
    // Event
    pInfoSet->EventAndState.Event.StopWithNoReason = bStopWithNoReason;
    if(fabs(pInfoSet->HwInfo.Axis1.dFinalPos-pInfoSet->Control.Axis.Dynamic.dDist)>ACCEPTABLE_DRIVING_POSITION_ERROR)
    {
        nDistNotMatch++;
    }
    else
    {
        nDistNotMatch = 0;
    }
    pInfoSet->EventAndState.Event.DistNotMatch = (nDistNotMatch>5)?true:false;
    if(nDistNotMatch>5)
    {
        nDistNotMatch = 0;
    }

    if(pInfoSet->EventAndState.Event.DistNotMatch==true && m_StatusSet.uStep==DRIVING_CTRL_STEP_GO_RUN)
	{

		if((m_bOnBackMove ==false)
		&& (pInfoSet->Control.Axis.Dynamic.dDist !=0.0)
		&& (pInfoSet->HwInfo.Axis1.dSpeed < -0.1)
		&& (pInfoSet->HwInfo.Axis1.dCurrPos > pInfoSet->Control.Axis.Dynamic.dDist))
		{
			//후진 방지 기능 1차 적용  E1069
			ADD_LOG("DistNotMAtch Stop Speed:%f!",pInfoSet->HwInfo.Axis1.dSpeed);
			m_pDrivingAxis->MoveStop(DEFAULT_EMERGENCY_DECEL);
        }

        ADD_LOG("DistNotMAtch %7.1lf (%7.1lf - %7.1lf) > %7.1lf"
            , (pInfoSet->HwInfo.Axis1.dFinalPos-pInfoSet->Control.Axis.Dynamic.dDist)
			, pInfoSet->HwInfo.Axis1.dFinalPos
			, pInfoSet->Control.Axis.Dynamic.dDist
            , ACCEPTABLE_DRIVING_POSITION_ERROR);
    }

    //State
#if(UBG_SENSOR_ENABLE == ON)
	pInfoSet->EventAndState.State.StopByFrontDetect = ((pInfoSet->HwInfo.IO.Axis1Running!=true)
													&&((pInfoSet->HwInfo.IO.ObsStatus==DETECT_AND_STOP)||(pInfoSet->HwInfo.IO.DetectStatus==DETECT_AND_STOP)))
                                                    ?true:false;
    pInfoSet->EventAndState.State.SpeedDownByFrontDetect = ((pInfoSet->HwInfo.IO.Axis1Running==true)
                                                    &&((pInfoSet->HwInfo.IO.ObsStatus==DETECT_AND_MOVE)||(pInfoSet->HwInfo.IO.DetectStatus==DETECT_AND_MOVE)))
                                                    ?true:false;
#else
	pInfoSet->EventAndState.State.StopByFrontDetect = ((pInfoSet->HwInfo.IO.Axis1Running!=true)
													&&(pInfoSet->HwInfo.IO.ObsStatus==DETECT_AND_STOP))
													?true:false;
	pInfoSet->EventAndState.State.SpeedDownByFrontDetect = ((pInfoSet->HwInfo.IO.Axis1Running==true)
													&&(pInfoSet->HwInfo.IO.ObsStatus==DETECT_AND_MOVE))
													?true:false;
#endif



	//1  명령 작성 및 BackUp

	if(((m_pOHTDetect->CheckSensorOff() == true) || (pHWSet->GetAMCVHLDetectStatus() ==0))&& (m_StatusSet.uStep==DRIVING_CTRL_STEP_GO_RUN))
	{
		if(getFrontObservation(pInfoSet->HwInfo.Node.nNodeCount, &DetectInfo)==true)
		{

			if((DetectInfo.UseFollowControlFlag != pDetectCtrl->Info.UseFollowControlFlag)
#if(USE_CHANGENODE == 1)
			|| (DetectInfo.OHTDetectType != pDetectCtrl->Info.OHTDetectType)
			|| (DetectInfo.OBSDetectType!= pDetectCtrl->Info.OBSDetectType)
			|| (DetectInfo.OHTDetectTypeOpt != pDetectCtrl->Info.OHTDetectTypeOpt)
			|| (DetectInfo.OBSDetectTypeOpt != pDetectCtrl->Info.OBSDetectTypeOpt)
#else
			|| (DetectInfo.Type != pDetectCtrl->Info.Type)
#endif
			|| (DetectInfo.NodeCount != pDetectCtrl->Info.NodeCount)
			|| (DetectInfo.DistSumOfStraightPath != pDetectCtrl->Info.DistSumOfStraightPath)
			|| (DetectInfo.FollowCommandType != pDetectCtrl->Info.FollowCommandType)
			|| (DetectInfo.PBSIgnoreFlag != pDetectCtrl->Info.PBSIgnoreFlag)
			|| (pHWSet->GetAMCVHLDetectStatus() ==0)
			)
			{

				nUBGNotMatch++;
				if((nUBGNotMatch >5) && (pHWSet->GetAMCVHLDetectStatus() ==0))
				{
	               nTmpError = ERR_DETECT_SENSOR_FAIL;
				   ADD_FDC_LOG("ERR/%d/1/5/%06d/%06d/%d/%d/%06d",
							ERR_DETECT_SENSOR_FAIL,
							m_pOHTMainStatus->StatusCommon.CurNodeID,
							m_pExecuteInfo->ExecutePositionInfo.NextNode,
							m_pOHTMainStatus->StatusCommon.CurNodeOffset,
							m_pOHTMainStatus->StatusCommon.ExistFoup,
							m_pOHTMainStatus->StatusCommon.StopStationID);
				}

				pDetectCtrl->bCmdOn = true;
				pDetectCtrl->Info = DetectInfo;
			}
		}
    }
	else
	{
		nUBGNotMatch = 0;
		if( (getFrontObservation(pInfoSet->HwInfo.Node.nPreCheckCount, &DetectInfo)==true)
		||  (pInfoSet->EventAndState.MarkState.FollowCtrlOffArea==true) )
		{
			//2 근접 제어 센서를 Off 시키는 조건
			if(pInfoSet->EventAndState.MarkState.FollowCtrlOffArea==true) // 아래 임시로 사용
			{
				memset(&DetectInfo,0,sizeof(USER_DETECT_INFO));
			}

			if((DetectInfo.UseFollowControlFlag != pDetectCtrl->Info.UseFollowControlFlag)
#if(USE_CHANGENODE == 1)
			|| (DetectInfo.OHTDetectType != pDetectCtrl->Info.OHTDetectType)
			|| (DetectInfo.OBSDetectType!= pDetectCtrl->Info.OBSDetectType)
			|| (DetectInfo.OHTDetectTypeOpt != pDetectCtrl->Info.OHTDetectTypeOpt)
			|| (DetectInfo.OBSDetectTypeOpt != pDetectCtrl->Info.OBSDetectTypeOpt)
#else
			|| (DetectInfo.Type != pDetectCtrl->Info.Type)
#endif
			|| (DetectInfo.NodeCount != pDetectCtrl->Info.NodeCount)
			|| (DetectInfo.DistSumOfStraightPath != pDetectCtrl->Info.DistSumOfStraightPath)
			|| (DetectInfo.FollowCommandType != pDetectCtrl->Info.FollowCommandType)
			|| (DetectInfo.PBSIgnoreFlag != pDetectCtrl->Info.PBSIgnoreFlag)
			)
			{
	//			ADD_LOG("Pre:%d Node:%06X", pInfoSet->HwInfo.Node.nPreCheckCount, pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.uNode);
	//
	//			ADD_LOG("%d %d %d %.4f %d %d", DetectInfo.UseFollowControlFlag, DetectInfo.Type, DetectInfo.NodeCount,
	//			DetectInfo.DistSumOfStraightPath, DetectInfo.FollowCommandType, DetectInfo.PBSIgnoreFlag);
	//
	//			ADD_LOG("%d %d %d %.4f %d %d", pDetectCtrl->Info.UseFollowControlFlag, pDetectCtrl->Info.Type, pDetectCtrl->Info.NodeCount,
	//			pDetectCtrl->Info.DistSumOfStraightPath, pDetectCtrl->Info.FollowCommandType, pDetectCtrl->Info.PBSIgnoreFlag);

				pDetectCtrl->bCmdOn = true;
				pDetectCtrl->Info = DetectInfo;
			}
		}
	}

	return nTmpError;
}

/*
@brief	장애물 감지 설정
@author 김경수
@date	2015.04.30
@param	pInfoSet 입력/변경되는 상태 정보
@param
@return 에러 없으면 0반환, 있으면 에러 코드 반환
*/
UINT DrivingControl::checkOBSAreaforNoFollowControl(DRIVING_INFO_SET* pInfoSet)
{
	UINT nTmpError = NO_ERR;

	int nOBSAreaSelect = SICK_OBS_AREA_0;
	int nNowOBSAreaSelect = 0;

	double dRealDistSumToTarget = getRealPos(m_ClassifiedCmd.TargetInfo.dDistSumToNode+m_ClassifiedCmd.TargetInfo.dOffset);
	double dRestDistance = dRealDistSumToTarget - m_InfoSet.HwInfo.Axis1.dCurrPos;

    if(dRestDistance <= OBS_REST_DISTANCE_800mm)
	{
		nOBSAreaSelect = SICK_OBS_AREA_6;
	}else
	{
		return nTmpError;
	}

#if(USE_CHANGENODE == 1)
	if((m_pExecuteInfo->ExecuteMode != EXECUTE_MODE_MANUAL) && (pInfoSet->Control.FrontObservation.Info.OHTDetectType == OHT_DETECT_CMD_PATH_DIRECTION_NORMAL))
#else
	if((m_pExecuteInfo->ExecuteMode != EXECUTE_MODE_MANUAL) && (pInfoSet->Control.FrontObservation.Info.Type == OHT_DETECT_CMD_PATH_DIRECTION_NORMAL))
#endif
	{
		nNowOBSAreaSelect = m_pObstacle->GetObsAreaStatus();

		if(nOBSAreaSelect != nNowOBSAreaSelect)
		{

			if(nOBSAreaSelect == SICK_OBS_AREA_6)
			{
				m_pObstacle->AreaSelect(nOBSAreaSelect);

				ADD_LOG("Obs setting #2, RD(%7.1lf), TP(%7.1lf), CP(%7.1lf), ToDoAS(%d), NowAS(%d)",
					dRestDistance,
					dRealDistSumToTarget,
					m_InfoSet.HwInfo.Axis1.dCurrPos,
					nOBSAreaSelect,
					nNowOBSAreaSelect
				)
			}
		}
	}

	return nTmpError;
}



UINT DrivingControl::checkAxisFirstNode(DRIVING_INFO_SET* pInfoSet)
{
    int nTmpError = NO_ERR;

	DWORD   dwCurrTime = timeGetTime();
	static DWORD dwTimeOfFirstNode = timeGetTime();
	static int nNodeCountClearCheck = 0;

    CTRL_INFO_OF_SYNC_AXIS_MOVE AxisCtrlInfo;
    CTRL_INFO_OF_SYNC_AXIS_MOVE *pAxisCtrl = &(pInfoSet->Control.Axis);
    CTRL_INFO_OF_ID_READER_CMD_TYPE *pIdReaderCmdType   = pInfoSet->Control.IdReader;   // ID Reader 배열의 첫번째 주소를 가지고 옮: Node
    DRIVING_HW_INFO_SET HwInfo = pInfoSet->HwInfo;

    int nStartID = pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.uNode;
    bool* bFirstNIDIsCorrect = &(pInfoSet->Position.bFirstNIDIsCorrect);
    bool bIsRunning = HwInfo.IO.Axis1Running;
    double dCurrPos = HwInfo.Axis1.dCurrPos;
    double dAxisTarget = HwInfo.Axis1.dFinalPos;    // 0 이 아님
    double dTarget = m_pParamSet->Mark[0].Dist.dLengthOfSecond;


	m_bFirstNodeStep = true; //위치값 갱신시 초기 무시처리를 위해 사용함. puting
    // ( 30-0.5 ) mm 이동 후에도 노드가 나타나지 않을 경우 정지 시 에러 발생
    if( (bIsRunning==false )
    &&  (dCurrPos>(DIST_TO_CHECK_FIRST_NODE_MARGIN-ACCEPTABLE_DRIVING_FRISTNODE_POSITION_ERROR))
    )
    {
        ERR_LOG("[checkAxisFirstNode] ERR_NOTMATCH_TAGLENGTH Pos:%6.1lf", dCurrPos);
//        nTmpError = ERR_NOTMATCH_TAGLENGTH; //에러처리는 하지 않고 다음단계로 넘어가는 시퀀스로 진행.

		*bFirstNIDIsCorrect=true;
		return nTmpError;
    }

    if( (bIsRunning==false )
    &&  (dCurrPos<(dTarget-ACCEPTABLE_DRIVING_FRISTNODE_POSITION_ERROR))
    )
    {
        *bFirstNIDIsCorrect=false;
        *pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;

		dwTimeOfFirstNode = timeGetTime();
        nNodeCountClearCheck = 0;
        memset(&(pAxisCtrl->Dynamic.AdditionalInfo),0,sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
        pAxisCtrl->Dynamic.dAccel   = m_pParamSet->Axis.Default.dDefaultAccel;
        pAxisCtrl->Dynamic.dDecel   = m_pParamSet->Axis.Default.dDefaultDecel;
        pAxisCtrl->Dynamic.dSpeed   = 0.1;  // 이값은 0.3보다 작아야 함 (50mm 갈 때의 최대 속도)
        pAxisCtrl->Dynamic.dDist = DIST_TO_CHECK_FIRST_NODE_MARGIN;
        pAxisCtrl->byType = AXIS_CTRL_CMD_MOVE_DS;
        ADD_LOG("Move Cmd %6.1lf,%6.1lf,%6.1lf,%6.1lf"
        , pAxisCtrl->Dynamic.dAccel
        , pAxisCtrl->Dynamic.dDecel
        , pAxisCtrl->Dynamic.dSpeed
        , pAxisCtrl->Dynamic.dDist
        );
    }
    else
    {
        // Node Count를 계속 Reset 한다.
        memset(&(pAxisCtrl->Static), 0x00, sizeof(STATIC_SYNC_AXIS_CTRL_INFO));
        if(bIsRunning==true)
        {
			pAxisCtrl->Static.NodeCountReset = true;
			pAxisCtrl->byType = AXIS_CTRL_CMD_STATIC;
			nNodeCountClearCheck++;
		}

		if(OHTUTILITY::PreventOverflowGetTimeMs(dwTimeOfFirstNode) > 200)
		{
			*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
             dwTimeOfFirstNode = timeGetTime();
		}

		if(HwInfo.Node.nBcrId!=0)
		{
			if(HwInfo.Node.nBcrId==nStartID)
			{
				if(( dCurrPos > DIST_TO_CHECK_FIRST_NODE_POSITION) ||
				((HwInfo.IO.NodeOn ==true)&& (nNodeCountClearCheck >1)))
				{
					*bFirstNIDIsCorrect = true;
				}
				ADD_LOG("[checkAxisFirstNode] bFirstNIDIsCorrect become true (%6X==%6X) %6.11f %d", HwInfo.Node.nBcrId, nStartID,dCurrPos,HwInfo.IO.NodeOn);

			}
            else
            {
                nTmpError = ERR_NOTFIND_NODE;
				ADD_FDC_LOG("ERR/%d/4/5/%06d/%06d/%d/%d/%06d",
							ERR_NOTFIND_NODE,
							m_pOHTMainStatus->StatusCommon.CurNodeID,
							m_pExecuteInfo->ExecutePositionInfo.NextNode,
							m_pOHTMainStatus->StatusCommon.CurNodeOffset,
							m_pOHTMainStatus->StatusCommon.ExistFoup,
							m_pOHTMainStatus->StatusCommon.StopStationID);
                ERR_LOG("[checkAxisFirstNode] ID Result!=StartID (%6X!=%6X)", HwInfo.Node.nBcrId, nStartID);
            }
        }
    }

    return nTmpError;

}





UINT DrivingControl::checkAxisRun(DRIVING_INFO_SET* pInfoSet)
{
	int nTmpError = NO_ERR;

//  double  dSpeed= 0.0;
//  int     nStopNodeCount = 0;
    bool    bCmdExist = false;

    CTRL_INFO_OF_SYNC_AXIS_MOVE AxisCtrlInfo;
    CTRL_INFO_OF_SYNC_AXIS_MOVE *pAxisCtrl = &(pInfoSet->Control.Axis);

//  DRIVING_HW_INFO_SET HwInfo = pInfoSet->HwInfo;
//  double  dRealDistSumToTarget = 0.0;
	//int     nTargetID = 0;


    if( ((pInfoSet->EventAndState.Event.CmdAdded==true)
	||  (pInfoSet->EventAndState.Event.TargetChanged==true)
	||  (pInfoSet->EventAndState.Event.PreCheck==true)
	||  (pInfoSet->EventAndState.Event.Check==true)
	||  (pInfoSet->EventAndState.Event.SpeedDownPassed==true)
    ||  (pInfoSet->EventAndState.Event.FrontSteerCompleted==true)
	||  (pInfoSet->EventAndState.Event.SteerAllCompleted==true)
	||  (pInfoSet->EventAndState.Event.StopWithNoReason==true)
	||  ((pInfoSet->EventAndState.Event.DistNotMatch==true) && (pHWSet->GetAMCPauseStatus() == STATUS_NORMAL))
	||  (pInfoSet->EventAndState.Event.MarkCmd==true)))
	{
		if(pInfoSet->EventAndState.Event.TargetChanged == true)
		{
			ADD_LOG("TargetChange %d %d %d %d %d %d %d %d %d %d",
			pHWSet->m_pOHTDetect->GetStatus(),
			pHWSet->GetAMCPauseStatus(),
			pInfoSet->EventAndState.Event.CmdAdded,
			pInfoSet->EventAndState.Event.StopWithNoReason,
			pInfoSet->EventAndState.Event.MarkCmd,
			pInfoSet->EventAndState.Event.PreCheck,
			pInfoSet->EventAndState.Event.Check,
			pInfoSet->EventAndState.Event.FrontSteerCompleted,
			pInfoSet->EventAndState.Event.SteerAllCompleted,
			pInfoSet->EventAndState.Event.DistNotMatch);
		}

		 try{
		if(m_bOnBackMove == false)
			bCmdExist = getAxisCmdInfo(pInfoSet, &AxisCtrlInfo);
		else
			bCmdExist = getAxisCmdInfoBack(pInfoSet, &AxisCtrlInfo);
		}
		catch(...)
		{
			 ADD_LOG("AxisRun Exception!!");
		}
		if(bCmdExist==true)
		{
			pAxisCtrl->byType = AXIS_CTRL_CMD_MOVE_DS;
			*pAxisCtrl = AxisCtrlInfo;
		}
		else if(    (pInfoSet->EventAndState.Event.DistNotMatch==true)
//              ||  (pInfoSet->EventAndState.Event.StopWithNoReason==true)
				)
		{
			//pAxisCtrl->byType = AXIS_CTRL_CMD_MOVE_DS;
			ADD_LOG("AxisRun Retry[%06d(%3d:%3d,%6.1lf)]:%6.4lf,%6.4lf, %3.1lf ,%6.1lf(←%6.1lf:E%6.1lf)Event[%4X]SPDN[(%6.1lf)]"
				, pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.uNode
				, pInfoSet->HwInfo.Node.nNodeCount
				, pInfoSet->HwInfo.Node.nPreCheckCount
				, pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset
				, pAxisCtrl->Dynamic.dAccel, pAxisCtrl->Dynamic.dDecel
				, pAxisCtrl->Dynamic.dSpeed, pAxisCtrl->Dynamic.dDist
				, pInfoSet->HwInfo.Axis1.dCurrPos
				, pInfoSet->Position.Compensation.dLinkDistError
				, pInfoSet->EventAndState.Event
				, pInfoSet->Position.CmdRefInfo.dSpeedDownPos
				);

		}
    }

	getPostionInfoOnRunning(*pInfoSet, &m_PositionInfo);

    return nTmpError;

}


UINT DrivingControl::checkAxisMark(DRIVING_INFO_SET* pInfoSet)
{
   int nTmpError = NO_ERR;

    DRIVING_HW_INFO_SET HwInfo      = pInfoSet->HwInfo;
	double  dRealDistSumToTarget    = getRealPos(m_ClassifiedCmd.TargetInfo.dDistSumToNode+m_ClassifiedCmd.TargetInfo.dOffset);
	double  dSpeedLimit         = getMarkSpeedLimitOnGoing(HwInfo.Node.nNodeCount);
	int     nTargetID               = (m_ClassifiedCmd.TargetInfo.Type==MARK_TYPE_NODE)
									?m_ClassifiedCmd.TargetInfo.Node:m_ClassifiedCmd.TargetInfo.Station;
	int     nNodeCount          = m_ClassifiedCmd.TargetInfo.nCount;
	DRIVING_MARK_STATE*                 pMarkState          = &(pInfoSet->EventAndState.MarkState);
	CTRL_INFO_OF_SYNC_AXIS_MOVE*        pAxisCtrl           = &(pInfoSet->Control.Axis);
	CTRL_INFO_OF_ID_READER_CMD_TYPE*    pIdReaderCmdType    = NULL;
	int     nID = 0;

	double dSTBOffset = m_ClassifiedCmd.TargetInfo.dSTBOffset;

	static  DWORD   dwShutterTrigerTime  = timeGetTime();
	DWORD       dwCurrTime  = timeGetTime();
	bool bOverrunIngn = m_ClassifiedCmd.TargetInfo.bIgnolOverRun;

    DRIVING_CMD_INFO_OF_NODE* pNodeInfo=NULL;


	//1 마크 처리
	switch(m_ClassifiedCmd.TargetInfo.Type)
	{
	case MARK_TYPE_NODE:
		pIdReaderCmdType = (pInfoSet->Control.IdReader);
		nTmpError = markOnNode(HwInfo, dRealDistSumToTarget, dSpeedLimit, nTargetID, nNodeCount, pMarkState, pAxisCtrl, pIdReaderCmdType, &nID);
		break;
	case MARK_TYPE_TAG_STATION:
		pIdReaderCmdType = ((pInfoSet->Control.IdReader)+1);
		nTmpError = markOnTagStation(HwInfo, dRealDistSumToTarget, dSpeedLimit, nTargetID, pMarkState, pAxisCtrl, pIdReaderCmdType, &nID,bOverrunIngn);
		break;
	case MARK_TYPE_QR_STATION_LEFT:
		pIdReaderCmdType = ((pInfoSet->Control.IdReader)+2);
		if(m_pParamSet->Mark[2].MakerType ==MAKER_TYPE_KEYENCE)
			nTmpError = markOnQRStation(true, HwInfo, dRealDistSumToTarget, dSpeedLimit, nTargetID, pMarkState, pAxisCtrl, pIdReaderCmdType, &nID);
		else if(m_pParamSet->Mark[2].MakerType ==MAKER_TYPE_OMRON)
			nTmpError = markOnQRStationDiffType(true, HwInfo, dRealDistSumToTarget, dSpeedLimit, nTargetID, pMarkState, pAxisCtrl, pIdReaderCmdType, &nID);
		else   //DM50 코그닉스
			nTmpError = markOnQRStationDiffType2(true, HwInfo, dRealDistSumToTarget, dSpeedLimit, nTargetID, pMarkState, pAxisCtrl, pIdReaderCmdType, &nID,bOverrunIngn,dSTBOffset);
        break;
    case MARK_TYPE_QR_STATION_RIGHT:
		pIdReaderCmdType = ((pInfoSet->Control.IdReader)+3);
		if(m_pParamSet->Mark[3].MakerType ==MAKER_TYPE_KEYENCE)
			nTmpError = markOnQRStation(false, HwInfo, dRealDistSumToTarget, dSpeedLimit, nTargetID, pMarkState, pAxisCtrl, pIdReaderCmdType, &nID);
		else if(m_pParamSet->Mark[3].MakerType ==MAKER_TYPE_OMRON)
			nTmpError = markOnQRStationDiffType(false, HwInfo, dRealDistSumToTarget, dSpeedLimit, nTargetID, pMarkState, pAxisCtrl, pIdReaderCmdType, &nID);
		else  //DM50 코그닉스
			nTmpError = markOnQRStationDiffType2(false, HwInfo, dRealDistSumToTarget, dSpeedLimit, nTargetID, pMarkState, pAxisCtrl, pIdReaderCmdType, &nID,bOverrunIngn,dSTBOffset);
		break;


	//후진 기능 적용
	case MARK_TYPE_TAG_STATION_BACK:
		pIdReaderCmdType = ((pInfoSet->Control.IdReader)+1);
		nTmpError = markOnTagStationBack(HwInfo, dRealDistSumToTarget, dSpeedLimit, nTargetID, pMarkState, pAxisCtrl, pIdReaderCmdType, &nID);
		break;

	}


	if((m_ClassifiedCmd.TargetInfo.Type == MARK_TYPE_TAG_STATION)
	|| (m_ClassifiedCmd.TargetInfo.Type == MARK_TYPE_QR_STATION_LEFT)
	|| (m_ClassifiedCmd.TargetInfo.Type == MARK_TYPE_QR_STATION_RIGHT))
	{

		   //1.사전 Shutter 동작 작업 실시.
		   //1.1내림 싸이클시 실시. (Load)
		if(nTmpError == NO_ERR)
		{
//		   ADD_LOG("[PreTrans] Shutter: %d :PIO %d",m_pExecuteInfo->FlagPreTrans.bPreShutter,m_pExecuteInfo->FlagPreTrans.bPrePIO);
		   if((m_defualtparam->PreShutter) &&
			  (dRealDistSumToTarget > 300.0))
		   {
			   if(m_pExecuteInfo->FlagPreTrans.bPreShutter == true)
			   {
					if(m_ClassifiedCmd.TargetInfo.Station == m_pExecuteInfo->FlagPreTrans.nTargetID)
					{
                    	//대차 유무에 따라 분류
						if(((pHWSet->m_pOHTDetect->GetCheckStatus() == true) ||
						   (pHWSet->m_pObstacle->GetStatus() == DETECT_AND_STOP)) && (pHWSet->GetAMCVHLDetectStatus() ==1))
						{
							if(pMarkState->Arrived ==true)
							{
								if(m_bShutterCloseFlag == false)
								{
									ExeCmdShutterOpen(HwInfo.Axis1.dSpeed);
								}
							}else
								dwShutterTrigerTime  = timeGetTime();
						}
						else if((pHWSet->m_pOHTDetect->GetStatus() == DETECT_AND_MOVE) && (pHWSet->GetAMCVHLDetectStatus() ==1))   //Long경우만 해당.
						{
							if(pMarkState->SecondMet ==true)    //대차 유무에 따라 분류 필요.
							{
								//사전작업 실시필요시 동작.
								if(OHTUTILITY::PreventOverflowGetTimeMs(dwShutterTrigerTime) > 100)
								{
									if(m_bShutterCloseFlag == false)
									{
										ExeCmdShutterOpen(HwInfo.Axis1.dSpeed);
									}
								}

							}else
								dwShutterTrigerTime  = timeGetTime();
						}
						else
						{
							if((m_pExecuteInfo->FlagPreTrans.cPortType != PORT_TYPE_STB_L)
							&&(m_pExecuteInfo->FlagPreTrans.cPortType != PORT_TYPE_STB_R)
							&&(m_pExecuteInfo->FlagPreTrans.cPortType != PORT_TYPE_UTB))
							{
								if((pMarkState->FirstMet ==true) || (pMarkState->SecondMet ==true))    //대차 유무에 따라 분류 필요.
								{
									if(OHTUTILITY::PreventOverflowGetTimeMs(dwShutterTrigerTime) > 100)
									{
										//사전작업 실시필요시 동작.
										if(m_bShutterCloseFlag == false)
										{
											ExeCmdShutterOpen(HwInfo.Axis1.dSpeed);
										}
									}
								}else
									dwShutterTrigerTime  = timeGetTime();
							}else
							{
								if(pMarkState->OnRoutineIn ==true)    //대차 유무에 따라 분류 필요.
								{
									//사전작업 실시필요시 동작.
									if(m_bShutterCloseFlag == false)
									{
										ExeCmdShutterOpen(HwInfo.Axis1.dSpeed);
									}
								}
                            }

						}
					}

			   }
		   }


		   //2. 사전 EQ PIO 동작 실시.  (내림/올림싸이클 모두)
		   if((m_defualtparam->PreEQPIO)
		   && (m_pExecuteInfo->FlagMTLInfo.bTakeoutCycle == false)
		   && (m_pExecuteInfo->FlagMTLInfo.bTakeInCycle == false))
		   {
			   if(m_pExecuteInfo->FlagPreTrans.bPrePIO == true)
			   {
					if(m_ClassifiedCmd.TargetInfo.Station ==  m_pExecuteInfo->FlagPreTrans.nTargetID)
					{
					   if((m_pExecuteInfo->FlagPreTrans.cPortType != PORT_TYPE_STB_L)
						&&(m_pExecuteInfo->FlagPreTrans.cPortType != PORT_TYPE_STB_R)
						&&(m_pExecuteInfo->FlagPreTrans.cPortType != PORT_TYPE_UTB))
						{
							if(m_pExecuteInfo->FlagPreTrans.nPIOID ==0)
								nTmpError = ExeCmdEQPIOOpen(TYPE_PIO_IR, m_pExecuteInfo->FlagPreTrans.nPIOID, m_pExecuteInfo->FlagPreTrans.nPIOChannel, 0);
							else
								nTmpError = ExeCmdEQPIOOpen(OHTMainForm->Get_EQPIO_Type(), m_pExecuteInfo->FlagPreTrans.nPIOID, m_pExecuteInfo->FlagPreTrans.nPIOChannel, 0);
						}
					}
				}
			}
		}

	}



    if(pAxisCtrl->byType==AXIS_CTRL_CMD_MOVE_DS)
    {
        ADD_LOG("AxisMark[%06d(%7.4lf)]: %7.4lf, %7.4lf, %3.1lf, %7.1lf(←%7.1lf), %5.1lf [%5.1lf(%d):%5.1lf(%d)]"
            , pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.uNode
            , pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset
            , pAxisCtrl->Dynamic.dAccel, pAxisCtrl->Dynamic.dDecel
            , pAxisCtrl->Dynamic.dSpeed, pAxisCtrl->Dynamic.dDist
            , HwInfo.Axis1.dCurrPos
            , pAxisCtrl->Dynamic.AdditionalInfo.dSmallDistance
            , HwInfo.TagStaion.dFrontPosition
            , HwInfo.IO.TagStationFrontOn
            , HwInfo.TagStaion.dRearPosition
            , HwInfo.IO.TagStationRearOn
            );
    }
     //오버런은 별도로 또 정리할것..
    //1 결과 정리
    if(pMarkState->Arrived)
    {
		pNodeInfo = getNodeInfo(HwInfo.Node.nNodeCount);

        //2  현재 위치 정리
        pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.bMarked = true;
        if(m_ClassifiedCmd.TargetInfo.Type==MARK_TYPE_NODE)
        {
            pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.uNode=nID;
            pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.uNextNode=0;
            pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.uRealArrivedNode=nID;
            pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.uStation=0;
        }
        else
        {
            pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info = pInfoSet->Position.CurrentAndTarget.TargetPosition;
//          pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.uRealArrivedNode
//              = (pNodeInfo!=NULL)
//              ?(pNodeInfo->ID):(pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.uNode);
            pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.uStation=nID;
        }
        pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.MarkType =  m_ClassifiedCmd.TargetInfo.Type;

        //2 마크 정보로 정리
        pInfoSet->Position.Mark.dFrontPosition  = HwInfo.Axis1.dCurrPos;
        pInfoSet->Position.Mark.dRearPosition   = HwInfo.Axis2.dCurrPos;
        pInfoSet->Position.Mark.PositionStatus  = pInfoSet->Position.CurrentAndTarget.CurrPositionStatus;


        //2 마크 정보를 멤버변수로 저장
        setPreviousArrivalInfo(pInfoSet->Position.Mark.PositionStatus);
        ADD_LOG("checkAxisMark: (%d)%5.1lf (%06d~%06d) --> (%d)%5.1lf (%06d~%06d)"
            , pInfoSet->Position.Mark.PositionStatus.Info.MarkType
            , pInfoSet->Position.Mark.PositionStatus.Info.dOffset
            , pInfoSet->Position.Mark.PositionStatus.Info.uNode
            , pInfoSet->Position.Mark.PositionStatus.Info.uNextNode
            , m_PreviousArrivalInfo.Info.MarkType
            , m_PreviousArrivalInfo.Info.dOffset
            , m_PreviousArrivalInfo.Info.uNode
            , m_PreviousArrivalInfo.Info.uNextNode
            );

        	getPostionInfoOnRunning(*pInfoSet, &m_PositionInfo);
			getPostionInfoOnMarked(*pInfoSet, &m_PositionInfo);
	}
	else if(nTmpError !=NO_ERR)
	{
		if(m_ClassifiedCmd.TargetInfo.Type==MARK_TYPE_NODE)
		{
            pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.uNode=nID;
            pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.uNextNode=0;
            pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.uRealArrivedNode=nID;
            pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.uStation=0;
        }
        else
        {
            pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info = pInfoSet->Position.CurrentAndTarget.TargetPosition;
            pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.uStation=nID;
		}

		if((nTmpError == ERR_BCR_READTIMEOUT) //오버런시 현재위치가 offset 0.0mm offset인 경우만
		  && (m_ClassifiedCmd.TargetInfo.Type!=MARK_TYPE_NODE)
		  && (pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset == 0.0))
		{
			getPostionInfoOnRunning(*pInfoSet, &m_PositionInfo);
			getPostionInfoOnMarked(*pInfoSet, &m_PositionInfo);
        }

	}else
	{
		getPostionInfoOnRunning(*pInfoSet, &m_PositionInfo);
	}

	return nTmpError;

}



void DrivingControl::measureDist(DRIVING_INFO_SET InfoSet, List<EXECUTE_RESPONSE_MAPMAKING_INFO*> *pListOfTmpStationData, List<EXECUTE_RESPONSE_MAPMAKING_INFO*> *pListOfMapData)
{
    bool bInit = false;
    bool bNodeUpdated = false;
    UINT uCurrNID = 0;
    double  dCurrNodeMarkPosition = 0.0;

    EXECUTE_RESPONSE_MAPMAKING_INFO *pNodeInfo;    //저장할 Map 구조체
    EXECUTE_RESPONSE_MAPMAKING_INFO *pStationInfo; //저장할 Map 구조체

	//1 Node
	pNodeInfo=NULL;
	pNodeInfo=measureNodeDist(InfoSet, &uCurrNID, &dCurrNodeMarkPosition, &bInit);
	if(pNodeInfo!=NULL)
	{
		bNodeUpdated = true;
		pListOfMapData->insertBack(pNodeInfo);
	}

	//1 Tag Station
	if(m_bMapMakeType.MapMake_StopTag ==ON)
	{
		pStationInfo=NULL;
		pStationInfo=measureTagStatationDist(InfoSet, uCurrNID, dCurrNodeMarkPosition, bInit);
		if(pStationInfo!=NULL)
		{
			pListOfTmpStationData->insertBack(pStationInfo);
		}
	}

	//1 QR Left Station
	if(m_bMapMakeType.MapMake_QR_Left_Tag ==ON)
	{
		pStationInfo=NULL;
		pStationInfo=measureQRStatationDist(true, InfoSet, uCurrNID, dCurrNodeMarkPosition, bInit);
		if(pStationInfo!=NULL)
		{
			pListOfTmpStationData->insertBack(pStationInfo);
		}
	}

	//1 QR Right Station
	if(m_bMapMakeType.MapMake_QR_Right_Tag ==ON)
	{
		pStationInfo=NULL;
		pStationInfo=measureQRStatationDist(false, InfoSet, uCurrNID, dCurrNodeMarkPosition, bInit);
		if(pStationInfo!=NULL)
		{
			pListOfTmpStationData->insertBack(pStationInfo);
		}
	}

    //1 Station Info 정리
    if((bNodeUpdated==true) && (pNodeInfo!=NULL))
    {
		insertStationInfo(*pNodeInfo, pListOfTmpStationData, pListOfMapData);
    }

}


EXECUTE_RESPONSE_MAPMAKING_INFO* DrivingControl::measureNodeDist(DRIVING_INFO_SET InfoSet, UINT *puCurrNID, double *pdCurrNodeMarkPosition, bool *pbInit)
{
    EXECUTE_RESPONSE_MAPMAKING_INFO *pMapMakeInfo=NULL; //저장할 Map 구조체

    static int nNodeCount = -1; // Node Count

    static  UINT    uPreNID = 0;    // 이전 Node의 ID
    static  UINT    uCurrNID = 0;   // 현재 Node의 ID
    static  double  dPreNodeMarkPosition = 0.0; // 이전 Node 의 Mark 위치
    static  double  dCurrNodeMarkPosition = 0.0;    // 현재 Node 의 Mark 위치

    double dNodeDistOffset = (InfoSet.HwInfo.Node.nNodeCount==0)?(-1*m_pParamSet->Mark[0].Dist.dAddDistAfterSecondMet):0;   // Mark 위치를 구하기 위한 Offset

    UINT uTmpNID = InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode;         // 현재 Node의 ID
    int nTmpNodeCount = InfoSet.HwInfo.Node.nNodeCount;                                     // 현재 Node Count
    double dTmpCurrNodeMarkPosition = InfoSet.HwInfo.Node.dNodePosition+dNodeDistOffset;    // 현재까지 만난 Node의 중심 위치
	double dTmpCurrPosition = InfoSet.HwInfo.Axis1.dCurrPos;                                // 현재 위치

	UINT uTmpBCRNodeID = InfoSet.HwInfo.Node.nBcrId;
	static UINT uCurrentBCRID = 0;
	static  UINT    uBCRCheckCount = 0;   // 현재 Node의 ID

    bool bMarked = InfoSet.Position.CurrentAndTarget.CurrPositionStatus.bMarked;
    bool bTmpMarkPositionPassed = false;

	UINT uPathIndex = 0;
	UINT uPreDis = 0;
	bool bSkipDis = false;

    //1 1. 초기화
	if(nTmpNodeCount==0 &&
	 ((nNodeCount!=0) || (uCurrentBCRID != uTmpNID) || (dCurrNodeMarkPosition !=0.0)))
	{
		nNodeCount = 0;
		uPreNID = uTmpNID;
		uCurrNID = uTmpNID;
		uCurrentBCRID = uTmpNID;
		uBCRCheckCount = 0;
//      dPreNodeMarkPosition = 0.0;
        dPreNodeMarkPosition = -1*m_pParamSet->Mark[0].Dist.dAddDistAfterSecondMet;
        dCurrNodeMarkPosition = 0.0;
		*pbInit = true;
		ADD_LOG("[MapMake] Init");
    }
    else
    {
//      dPreNodeMarkPosition = 0.0;
        *pbInit = false;
    }
	if((uTmpBCRNodeID !=  uCurrentBCRID) && (uTmpBCRNodeID !=0))
	{
		uCurrentBCRID = uTmpBCRNodeID;
		ADD_LOG("[MapMake] BCR OK %d",uCurrentBCRID);

	}

	//1 2. 다음 Node 만났을 때의 처리
	if(dTmpCurrPosition>=dTmpCurrNodeMarkPosition)
	{
		bTmpMarkPositionPassed = true;
	}
	else if(bMarked==true)
	{
		bTmpMarkPositionPassed = true;
		ADD_LOG("[MapMake] Marked");
	}

	if( (nTmpNodeCount!=nNodeCount)
	&&  (bTmpMarkPositionPassed==true)
	)
	{
		//2 1) 정보 획득
		if(uCurrentBCRID  == uTmpNID)  //BCR이 Read실패할 경우 에러처리.
		{
			nNodeCount = nTmpNodeCount;
			dCurrNodeMarkPosition = dTmpCurrNodeMarkPosition;
			uCurrNID = uTmpNID;

			//2 Map 데이터에서 거리값 불러오기
			uPathIndex = OHTMainForm->GetMap()->GetPathIndex(uPreNID, uCurrNID);
			uPreDis = OHTMainForm->GetMap()->m_PathArray[uPathIndex].Distance;

			//2 2) 구조체 작성
			pMapMakeInfo = new EXECUTE_RESPONSE_MAPMAKING_INFO;
			memset(pMapMakeInfo, 0, sizeof(EXECUTE_RESPONSE_MAPMAKING_INFO));

			if(m_bMapMakeType.MapMake_DrivingTag ==ON)
			{
				ADD_LOG("[MapMake] MapMake_DrivingTag ON");
				// Map Make 진행한 거리값이 OFFSET 값만큼 클 경우 업데이트 진행
				if(fabs((int)(dCurrNodeMarkPosition - dPreNodeMarkPosition)-uPreDis) > PATH_DIS_OFFSET)
				{
					pMapMakeInfo->NodeOffsetInfo[0].Dist        = (int)(dCurrNodeMarkPosition - dPreNodeMarkPosition);
					bSkipDis = false;
				}
				else
				{
					pMapMakeInfo->NodeOffsetInfo[0].Dist        = uPreDis;
					bSkipDis = true;
				}
			}
			else
			{
					ADD_LOG("[MapMake] MapMake_DrivingTag OFF");
					//주행업데이트 플레그가 off일 경우 기존꺼 사용.
					pMapMakeInfo->NodeOffsetInfo[0].Dist        = uPreDis;
					bSkipDis = true;
			}

			pMapMakeInfo->NodeOffsetInfo[0].StartNodeID = uPreNID;
			pMapMakeInfo->NodeOffsetInfo[0].EndNodeID   = uCurrNID;
			pMapMakeInfo->StationID = 0;
			pMapMakeInfo->StationType   = MARK_TYPE_NODE;


			//2 3) 주행 노드 좌표 변경
	//		Set_Node_XorY(pMapMakeInfo, uPreNID, uCurrNID,pMapMakeInfo->NodeOffsetInfo[0].Dist, bSkipDis);
			pMapMakeInfo->NodeDataInfo.NID = 0;

			//2 4) 로그 작성
			ADD_LOG("[MapMake] Type:%d, NID(%6d~%6d) Dist:%4d(%6.1lf=%6.1lf-%6.1lf) / Skip Dis(%d) / Dis Offset(%d) %d"
				, pMapMakeInfo->StationType
				, pMapMakeInfo->NodeOffsetInfo[0].StartNodeID
				, pMapMakeInfo->NodeOffsetInfo[0].EndNodeID
				, pMapMakeInfo->NodeOffsetInfo[0].Dist
				, (dCurrNodeMarkPosition - dPreNodeMarkPosition)
				, dCurrNodeMarkPosition
				, dPreNodeMarkPosition
				, bSkipDis
				, PATH_DIS_OFFSET
				,uBCRCheckCount);

			//2 4) 정보 정리(다음 Node를 위해)
			dPreNodeMarkPosition = dCurrNodeMarkPosition;
			uPreNID = uCurrNID;
			uBCRCheckCount = 0;
			if(bMarked==true)
			{
				nNodeCount = -1;
			}


		}
		else
		{
			uBCRCheckCount++;
			//Node는 만났으나, BCR이 위치에 맞는 값으로 갱신안되는 경우 Check
			if(uBCRCheckCount > m_pParamSet->MapMakerCount_Driving)
			{
                m_StatusSet.uError = ERR_BCR_READ;    //에러 코드 분류 필요.
				return pMapMakeInfo;
            }
		}
	}

	*puCurrNID = uCurrNID;
    *pdCurrNodeMarkPosition = dCurrNodeMarkPosition;

    return pMapMakeInfo;
}



EXECUTE_RESPONSE_MAPMAKING_INFO* DrivingControl::measureTagStatationDist(DRIVING_INFO_SET InfoSet, UINT uCurrNID, double dCurrNodeMarkPosition, bool bInit)
{
    EXECUTE_RESPONSE_MAPMAKING_INFO *pStationInfo=NULL; //저장할 Map 구조체

    static UINT uPreStationID = 0;  // 사용하지 않는 값
	static double dPreStationPosition = 0.0; // 사용하지 않는 값

	static int nCheckCountBCRRead = 0; //BCR Read 횟수 확인

    double dStationDistOffset = 0.0;//(InfoSet.HwInfo.Node.nNodeCount==0)?m_pParamSet->Mark[1].Dist.dAddDistAfterSecondMet:0;   // Mark 위치를 구하기 위한 Offset

	static UINT uTmpStationID = 0;//InfoSet.HwInfo.TagStaion.nBcrId;
    bool bRearOn = InfoSet.HwInfo.IO.TagStationRearOn;
	double dTmpStationPosition = InfoSet.HwInfo.TagStaion.dRearPosition;
	double dTmpStationFrontPosion = InfoSet.HwInfo.TagStaion.dFrontPosition;

	double dTmpCurrPosition = InfoSet.HwInfo.Axis1.dCurrPos;    // 현재 위치

	static double dPreStationCheckPosition = 0.0; // 사용하지 않는 값

	//1 1. 초기화
    if(bInit==true)
	{
		uTmpStationID = 0;
        uPreStationID = 0;
		dPreStationPosition = 0.0;
		nCheckCountBCRRead = 0;
		 ADD_LOG("[MapMake] Init");
    }
    else
    {

	}

	if(uTmpStationID==0)
	{
		if(InfoSet.HwInfo.TagStaion.nBcrId !=0)
		{
			dPreStationCheckPosition = dTmpCurrPosition;  //BCR 인식된 위치 저장
			uTmpStationID = InfoSet.HwInfo.TagStaion.nBcrId;
		}
	}
	else
	{
		//반사판 미인식 될경우 이전데이터 무시처리
		if((dTmpCurrPosition - dPreStationCheckPosition) > 250.0) //반사판 미인식 될경우 다음 Station 정상인식을 위한 초기화처리
		{
			if(dTmpStationPosition!=dPreStationPosition)
			{
				ADD_LOG("[MapMake][Abnormal]Station ID:%d !! dTmpCurrPosition -dPreStationCheckPosition",uTmpStationID);
				dPreStationPosition =  dTmpStationPosition;//dTmpStationPosition로 변경이 필요하지 않은지?? puting
			}
			uTmpStationID = 0;
		}
	}


	//1 2. Station 만났을 때의 처리
	if(uTmpStationID!=0 && uTmpStationID!=uPreStationID)
	{
		if(((bRearOn==true)
		&& (dTmpStationPosition==0.0))
		|| (((dTmpStationPosition!=0.0) && (dTmpStationPosition!=dPreStationPosition)
		&& (fabs(dTmpStationPosition-dTmpCurrPosition)<(m_pParamSet->Mark[1].Dist.dDistFromFirstToSecond+10))))
		)
		{
            //2 1) 정보 획득
			if((dTmpStationFrontPosion >250.0)  && (dTmpStationPosition!=0.0) &&
			((nCheckCountBCRRead <  m_pParamSet->MapMakerCount_Trans)||
			((dTmpStationPosition - dTmpStationFrontPosion) < m_pParamSet->ScatteredReflection)))
			{
				ADD_LOG("[MapMake][Abnormal]CheckCountBCRRead %d, %f %f",nCheckCountBCRRead,dTmpStationFrontPosion,dTmpStationPosition);
				m_StatusSet.uError = ERR_BCR_READ_TRANS;
				return pStationInfo;
			}

			//2 2) 구조체 작성
			pStationInfo = new EXECUTE_RESPONSE_MAPMAKING_INFO;
			memset(pStationInfo, 0, sizeof(EXECUTE_RESPONSE_MAPMAKING_INFO));
			if(dTmpStationPosition!=0.0)
			{
				if((dTmpStationPosition - dCurrNodeMarkPosition + dStationDistOffset) > 0.0)
				{
					pStationInfo->NodeOffsetInfo[0].Dist        = (int)(dTmpStationPosition - dCurrNodeMarkPosition + dStationDistOffset);
				}
				else
				{
					//Station값이 갱신되기 전에 다음노드로 넘어간 경우 처리됨.
					ADD_LOG("[MapMake][Abnormal]Case1 %d %f %f",uTmpStationID,dCurrNodeMarkPosition,dTmpStationPosition);
					pStationInfo->NodeOffsetInfo[0].Dist        = 0;
				}
			}
			else
			{
				//Rear On과 StationRear 위치값 갱신차이가 발생할 경우 처리됨.
				ADD_LOG("[MapMake][Abnormal]Case2 %d %f %f",uTmpStationID,dCurrNodeMarkPosition,dTmpStationPosition);
				pStationInfo->NodeOffsetInfo[0].Dist        = (int)(dTmpCurrPosition - dCurrNodeMarkPosition + dStationDistOffset);
			}

			pStationInfo->NodeOffsetInfo[0].StartNodeID = uCurrNID;
            pStationInfo->NodeOffsetInfo[0].EndNodeID   = 0;    // 우선 비워둔다
            pStationInfo->StationID                     = uTmpStationID;
			pStationInfo->StationType                   = MARK_TYPE_TAG_STATION;

            //2 3) 로그 작성
            ADD_LOG("[MapMake]Type:%d, NID(%6d~%6d) / Station(ID:%6d,Offset:%4d(%6.1lf=%6.1lf-%6.1lf)) [%6.1lf:%6.1lf]Count%d"
                , pStationInfo->StationType
                , pStationInfo->NodeOffsetInfo[0].StartNodeID,  pStationInfo->NodeOffsetInfo[0].EndNodeID
                , pStationInfo->StationID
                , pStationInfo->NodeOffsetInfo[0].Dist
				, (dTmpStationPosition - dCurrNodeMarkPosition)
                , dTmpStationPosition, dCurrNodeMarkPosition, dTmpCurrPosition, dTmpStationFrontPosion,nCheckCountBCRRead);

			//2 4) 정보 정리(다음 Node를 위해)
			dPreStationPosition =  dTmpStationPosition;//dTmpStationPosition로 변경이 필요하지 않은지?? puting
			uPreStationID = uTmpStationID;
			nCheckCountBCRRead = 0;
			uTmpStationID = 0;

		}else
		{
			//동일한 Tag 인식 횟수 확인
//        	 ADD_LOG("[nCheckCountBCRRead] %d",nCheckCountBCRRead);
			if(InfoSet.HwInfo.TagStaion.nBcrId !=0)
			{
				if(uTmpStationID ==InfoSet.HwInfo.TagStaion.nBcrId)
					nCheckCountBCRRead++;
			}
		}
	}

    return pStationInfo;

}

EXECUTE_RESPONSE_MAPMAKING_INFO* DrivingControl::measureQRStatationDist(bool bIsLeft, DRIVING_INFO_SET InfoSet, UINT uCurrNID, double dCurrNodeMarkPosition, bool bInit)
{

    EXECUTE_RESPONSE_MAPMAKING_INFO *pStationInfo=NULL; //저장할 Map 구조체

	static UINT uPreStationID = 0;  // 사용하지 않는 값
	static UINT uPreStationID_Right = 0;  // 사용하지 않는 값

    UINT uTmpStationID = 0;
    double dStationDistOffset = 0.0;//(InfoSet.HwInfo.Node.nNodeCount==0)?m_pParamSet->Mark[1].Dist.dAddDistAfterSecondMet:0;   // Mark 위치를 구하기 위한 Offset
//  double dStationDistOffset = 0.0;    // Mark 위치를 구하기 위한 Offset

    double dTmpCurrPosition = InfoSet.HwInfo.Axis1.dCurrPos;    // 현재 위치

    if(bIsLeft==true)
    {
        uTmpStationID = InfoSet.HwInfo.QrStaionLeft.nQrId;
        dStationDistOffset += InfoSet.HwInfo.QrStaionLeft.dQrOffset;
    }
    else
    {
        uTmpStationID = InfoSet.HwInfo.QrStaionRight.nQrId;
        dStationDistOffset += InfoSet.HwInfo.QrStaionRight.dQrOffset;
    }

    //1 1. 초기화
    if(bInit==true)
    {
		uPreStationID = 0;
		uPreStationID_Right = 0;
    }

    //1 2. Station 만났을 때의 처리
	if((uTmpStationID!=0) &&
		(((bIsLeft == true) && (uTmpStationID!=uPreStationID)) ||
		((bIsLeft == false) && (uTmpStationID!=uPreStationID_Right))))
	{
		//2 1) 정보 획득


        //2 2) 구조체 작성
        pStationInfo = new EXECUTE_RESPONSE_MAPMAKING_INFO;
        memset(pStationInfo, 0, sizeof(EXECUTE_RESPONSE_MAPMAKING_INFO));
        pStationInfo->NodeOffsetInfo[0].Dist        = (int)(dTmpCurrPosition - dCurrNodeMarkPosition + dStationDistOffset);
        pStationInfo->NodeOffsetInfo[0].StartNodeID = uCurrNID;
        pStationInfo->NodeOffsetInfo[0].EndNodeID   = 0;    // 우선 비워둔다
        pStationInfo->StationID                     = uTmpStationID;
        pStationInfo->StationType                   = (bIsLeft==true)?MARK_TYPE_QR_STATION_LEFT:MARK_TYPE_QR_STATION_RIGHT;

        //2 3) 로그 작성
        ADD_LOG("[MapMake]Type:%d, NID(%6d~%6d) / Station(ID:%6d,Offset:%4d(%6.1lf=%6.1lf-%6.1lf+%6.1lf))"
            , pStationInfo->StationType
            , pStationInfo->NodeOffsetInfo[0].StartNodeID,  pStationInfo->NodeOffsetInfo[0].EndNodeID
            , pStationInfo->StationID
            , pStationInfo->NodeOffsetInfo[0].Dist, (dTmpCurrPosition - dCurrNodeMarkPosition + dStationDistOffset)
            , dTmpCurrPosition, dCurrNodeMarkPosition, dStationDistOffset);

		//2 4) 정보 정리(다음 Node를 위해)
		if(bIsLeft ==true)
			uPreStationID = uTmpStationID;
		else
          	uPreStationID_Right = uTmpStationID;
    }

    return pStationInfo;

}



void DrivingControl::insertStationInfo(EXECUTE_RESPONSE_MAPMAKING_INFO NodeInfo, List<EXECUTE_RESPONSE_MAPMAKING_INFO*> *pListOfTmpStationData, List<EXECUTE_RESPONSE_MAPMAKING_INFO*> *pListOfMapData)
{
    EXECUTE_RESPONSE_MAPMAKING_INFO *pStationInfo=NULL; //저장할 Map 구조체
    int nCountOfList = pListOfTmpStationData->getCount();

    for(int n=0; n<nCountOfList; n++)
	{

		pStationInfo = pListOfTmpStationData->popFront();

		if( (pStationInfo->NodeOffsetInfo[0].Dist <=(NodeInfo.NodeOffsetInfo[0].Dist-m_pParamSet->MapMakerMargin_Gap))
		||  (NodeInfo.NodeOffsetInfo[0].EndNodeID == m_InfoSet.Position.CurrentAndTarget.TargetPosition.uNode)
		 )
		{
			if(pStationInfo->NodeOffsetInfo[0].Dist <=(NodeInfo.NodeOffsetInfo[0].Dist-m_pParamSet->MapMakerMargin_Gap))
			{
				pStationInfo->NodeOffsetInfo[0].EndNodeID = NodeInfo.NodeOffsetInfo[0].EndNodeID;
				pListOfMapData->insertBack(pStationInfo);
				//ADD_LOG("[MapMake] insertStationInfo OK STID:%d Offset%d", pStationInfo->NodeOffsetInfo[0].StartNodeID,pStationInfo->NodeOffsetInfo[0].Dist);

			}
			else
			{
				// 어떻게 처리할지 고민할것.
				pStationInfo->NodeOffsetInfo[0].StartNodeID = NodeInfo.NodeOffsetInfo[0].EndNodeID;
				pStationInfo->NodeOffsetInfo[0].Dist        = 0.0;//MAX(NodeInfo.NodeOffsetInfo[0].Dist,0.0);
				pStationInfo->NodeOffsetInfo[0].EndNodeID   = 0;
				pListOfMapData->insertBack(pStationInfo);
				//ADD_LOG("[MapMake] insertStationInfo Delete(Not Match) STID:%d Offset%d", pStationInfo->NodeOffsetInfo[0].StartNodeID,pStationInfo->NodeOffsetInfo[0].Dist)
				//delete pStationInfo;
//				pStationInfo->NodeOffsetInfo[0].StartNodeID = NodeInfo.NodeOffsetInfo[0].EndNodeID;
//				pStationInfo->NodeOffsetInfo[0].Dist        = 0.0;//MAX(NodeInfo.NodeOffsetInfo[0].Dist,0.0);
//				pStationInfo->NodeOffsetInfo[0].EndNodeID   = 0;
				//추후에 쓸경우 변경해줄것. 현재 Station Editor 컨셉으로는 불가함. puting
			}
		}
		else
        {
//          pStationInfo->NodeOffsetInfo[1] = pStationInfo->NodeOffsetInfo[0];
//          pStationInfo->NodeOffsetInfo[1].EndNodeID = NodeInfo.NodeOffsetInfo[0].EndNodeID;
            pStationInfo->NodeOffsetInfo[0].StartNodeID = NodeInfo.NodeOffsetInfo[0].EndNodeID;
            pStationInfo->NodeOffsetInfo[0].Dist        = 0.0;//MAX(NodeInfo.NodeOffsetInfo[0].Dist,0.0);
            pStationInfo->NodeOffsetInfo[0].EndNodeID   = 0;

            pListOfTmpStationData->insertBack(pStationInfo);

			//ADD_LOG("[MapMake] insertStationInfo NG(NextNode) STID:%d Offset%d", pStationInfo->NodeOffsetInfo[0].StartNodeID,pStationInfo->NodeOffsetInfo[0].Dist);

        }

	}


}



/**
@brief  Passbox control
@author 김경수
@date   2014.12.16
@param  puStep 주행의 Step 변수
@return 에러 없으면 0반환, 있으면 에러 코드 반환
*/
UINT DrivingControl::executeOpenPassBox(DRIVING_HW_INFO_SET HwInfo, DRIVING_INFO_SET *pInfoSet, UINT *puStep)
{
	UINT nError = NO_ERR;
    static DWORD dwPassBoxPIOWaitTime = 0;

    if((nError == NO_ERR) && (m_nPassBoxPIOStep >= PASSBOX_CTRL_STEP_OHT_STATUS_ON) && (m_nPassBoxPIOStep < PASSBOX_CTRL_STEP_COMPLETE))
	{
		if(m_pPassBoxPIO->Check_GoOffTime(PASSBOX_PIO_CHECK_GO_SIGNAL_CHECK_TIME) == RTN_FAIL)
		{
			nError = ERR_PASSBOX_PIO_GO_SIGNAL_CHECK_ABNORMAL_OFF;
			ADD_LOG("ERR_PASSBOX_PIO_GO_SIGNAL_CHECK_ABNORMAL_OFF, m_nPassBoxPIOStep(%d), Err(%d)", m_nPassBoxPIOStep, nError);
			ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d/%d",
									ERR_PASSBOX_PIO_GO_SIGNAL_CHECK_ABNORMAL_OFF,
									m_pOHTMainStatus->StatusCommon.CurNodeID,
									m_pExecuteInfo->ExecutePositionInfo.NextNode,
									m_pOHTMainStatus->StatusCommon.CurNodeOffset,
									m_pOHTMainStatus->StatusCommon.ExistFoup,
									m_pOHTMainStatus->StatusCommon.StopStationID,
									m_nPassBoxPIOStep);
		}
   	}

    if((nError == NO_ERR) && (m_nPassBoxPIOStep >= PASSBOX_CTRL_STEP_OHT_STATUS_ON) && (m_nPassBoxPIOStep < PASSBOX_CTRL_STEP_COMPLETE))
	{
		if(m_pPassBoxPIO->Check_ESOffTime(PASSBOX_PIO_CHECK_ES_SIGNAL_CHECK_TIME) == RTN_FAIL)
		{
			nError = ERR_PASSBOX_PIO_ES_SIGNAL_CHECK_ABNORMAL_OFF;
			ADD_LOG("ERR_PASSBOX_PIO_ES_SIGNAL_CHECK_ABNORMAL_OFF, m_nPassBoxPIOStep(%d), Err(%d)", m_nPassBoxPIOStep, nError);
			ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d/%d",
									ERR_PASSBOX_PIO_ES_SIGNAL_CHECK_ABNORMAL_OFF,
									m_pOHTMainStatus->StatusCommon.CurNodeID,
									m_pExecuteInfo->ExecutePositionInfo.NextNode,
									m_pOHTMainStatus->StatusCommon.CurNodeOffset,
									m_pOHTMainStatus->StatusCommon.ExistFoup,
									m_pOHTMainStatus->StatusCommon.StopStationID,
									m_nPassBoxPIOStep);
		}
   	}

    if((nError == NO_ERR) && (m_nPassBoxPIOStep >= PASSBOX_CTRL_STEP_OHT_STATUS_ON) && (m_nPassBoxPIOStep < PASSBOX_CTRL_STEP_COMPLETE))
	{
		if(m_pPassBoxPIO->Check_PB_AVBL_OffTime(PASSBOX_PIO_CHECK_PB_AVBL_SIGNAL_CHECK_TIME) == RTN_FAIL)
		{
			nError = ERR_PASSBOX_PIO_PB_AVBL_SIGNAL_CHECK_ABNORMAL_OFF;
			ADD_LOG("ERR_PASSBOX_PIO_PB_AVBL_SIGNAL_CHECK_ABNORMAL_OFF, m_nPassBoxPIOStep(%d), Err(%d)", m_nPassBoxPIOStep, nError);
        	ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d/%d",
									ERR_PASSBOX_PIO_PB_AVBL_SIGNAL_CHECK_ABNORMAL_OFF,
									m_pOHTMainStatus->StatusCommon.CurNodeID,
									m_pExecuteInfo->ExecutePositionInfo.NextNode,
									m_pOHTMainStatus->StatusCommon.CurNodeOffset,
									m_pOHTMainStatus->StatusCommon.ExistFoup,
									m_pOHTMainStatus->StatusCommon.StopStationID,
									m_nPassBoxPIOStep);
		}
   	}

	// PassBox Open을 위한 PIO 통신
	switch (m_nPassBoxPIOStep)
	{
		case PASSBOX_CTRL_STEP_INIT :
			if(nError == NO_ERR)
			{
				nError = m_pPassBoxPIO->PIOEnable();
				dwPassBoxPIOWaitTime = timeGetTime();
				m_nPassBoxPIOStep++;
			}
			break;

		case PASSBOX_CTRL_STEP_GO_SIGNAL_CHECK :
			if((nError==NO_ERR) && (m_pPassBoxPIO->IsGoSignalOn() == true))
			{
				m_nPassBoxPIOStep++;
				ADD_LOG("[PASSBOX_PIO]PASSBOX_CTRL_STEP_GO_SIGNAL_CHECK, m_nPassBoxPIOStep(%d)", m_nPassBoxPIOStep);
			}
			else
			{
				if(OHTUTILITY::PreventOverflowGetTimeMs(dwPassBoxPIOWaitTime) > PASSBOX_PIO_CHECK_GO_SIGNAL_WAIT_TIME)
				{
					nError = ERR_PASSBOX_PIO_GO_SIGNAL_ABNORMAL_OFF;
					ADD_LOG("ERR_PASSBOX_PIO_GO_SIGNAL_ABNORMAL_OFF, m_nPassBoxPIOStep(%d), Err(%d), Time(%d)", m_nPassBoxPIOStep, nError, OHTUTILITY::PreventOverflowGetTimeMs(dwPassBoxPIOWaitTime));
					dwPassBoxPIOWaitTime = 0;
					ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d/%d",
									ERR_PASSBOX_PIO_GO_SIGNAL_ABNORMAL_OFF,
									m_pOHTMainStatus->StatusCommon.CurNodeID,
									m_pExecuteInfo->ExecutePositionInfo.NextNode,
									m_pOHTMainStatus->StatusCommon.CurNodeOffset,
									m_pOHTMainStatus->StatusCommon.ExistFoup,
									m_pOHTMainStatus->StatusCommon.StopStationID,
									m_nPassBoxPIOStep);
				}
			}
			break;

		case PASSBOX_CTRL_STEP_SIGNAL_OFF :
			if(nError==NO_ERR)
			{
				m_pPassBoxPIO->AllPIOOff();
				dwPassBoxPIOWaitTime = timeGetTime();
				m_nPassBoxPIOStep++;
				ADD_LOG("[PASSBOX_PIO]PASSBOX_CTRL_STEP_SIGNAL_OFF, m_nPassBoxPIOStep:(%d)", m_nPassBoxPIOStep);
			}
			break;

		case PASSBOX_CTRL_STEP_ES_SIGNAL_CHECK :
			if((nError==NO_ERR) && (m_pPassBoxPIO->IsESOn()	== true))
			{
				dwPassBoxPIOWaitTime = timeGetTime();
				m_nPassBoxPIOStep++;
				ADD_LOG("[PASSBOX_PIO]PASSBOX_CTRL_STEP_ES_SIGNAL_CHECK, m_nPassBoxPIOStep(%d)", m_nPassBoxPIOStep);
			}
			else
			{
				if(OHTUTILITY::PreventOverflowGetTimeMs(dwPassBoxPIOWaitTime) > PASSBOX_PIO_CHECK_ES_SIGNAL_WAIT_TIME)
				{
					nError = ERR_PASSBOX_PIO_ES_SIGNAL_ABNORMAL_OFF;
					ADD_LOG("ERR_PASSBOX_PIO_ES_SIGNAL_ABNORMAL_OFF, m_nPassBoxPIOStep(%d), Err(%d), Time(%d)", m_nPassBoxPIOStep, nError, OHTUTILITY::PreventOverflowGetTimeMs(dwPassBoxPIOWaitTime));
					dwPassBoxPIOWaitTime = 0;
					ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d/%d",
									ERR_PASSBOX_PIO_ES_SIGNAL_ABNORMAL_OFF,
									m_pOHTMainStatus->StatusCommon.CurNodeID,
									m_pExecuteInfo->ExecutePositionInfo.NextNode,
									m_pOHTMainStatus->StatusCommon.CurNodeOffset,
									m_pOHTMainStatus->StatusCommon.ExistFoup,
									m_pOHTMainStatus->StatusCommon.StopStationID,
									m_nPassBoxPIOStep);
				}
			}
			break;

		case PASSBOX_CTRL_STEP_PB_AVBL_SIGNAL_CHECK :
			if((nError==NO_ERR) && (m_pPassBoxPIO->IsPBAVBLOn() == true))
			{
				m_nPassBoxPIOStep++;
				dwPassBoxPIOWaitTime = timeGetTime();
				ADD_LOG("[PASSBOX_PIO]PASSBOX_CTRL_STEP_PB_AVBL_SIGNAL_CHECK, m_nPassBoxPIOStep(%d)", m_nPassBoxPIOStep);
			}
			else
			{
				if(OHTUTILITY::PreventOverflowGetTimeMs(dwPassBoxPIOWaitTime) > PASSBOX_PIO_CHECK_PB_AVBL_SIGNAL_WAIT_TIME)
				{
					nError = ERR_PASSBOX_PIO_PB_AVBL_SIGNAL_ABNORMAL_OFF;
					ADD_LOG("ERR_PASSBOX_PIO_PB_AVBL_SIGNAL_ABNORMAL_OFF, m_nPassBoxPIOStep(%d), Err(%d), Time(%d)", m_nPassBoxPIOStep, nError, OHTUTILITY::PreventOverflowGetTimeMs(dwPassBoxPIOWaitTime));
					dwPassBoxPIOWaitTime = 0;
					ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d/%d",
									ERR_PASSBOX_PIO_PB_AVBL_SIGNAL_ABNORMAL_OFF,
									m_pOHTMainStatus->StatusCommon.CurNodeID,
									m_pExecuteInfo->ExecutePositionInfo.NextNode,
									m_pOHTMainStatus->StatusCommon.CurNodeOffset,
									m_pOHTMainStatus->StatusCommon.ExistFoup,
									m_pOHTMainStatus->StatusCommon.StopStationID,
									m_nPassBoxPIOStep);
				}
			}
			break;

		case PASSBOX_CTRL_STEP_ABNORMAL_SIGNAL_CHECK :
			if((nError==NO_ERR)
				&& (m_pPassBoxPIO->IsCloseOn() == false)
				&& (m_pPassBoxPIO->IsBusyOn() == false)
				&& (m_pPassBoxPIO->IsOpenOn() == false)
			)
			{
				m_nPassBoxPIOStep++;
				ADD_LOG("[PASSBOX_PIO]PASSBOX_CTRL_STEP_ABNORMAL_SIGNAL_CHECK, m_nPassBoxPIOStep(%d)", m_nPassBoxPIOStep);
			}
			else
			{
				if(OHTUTILITY::PreventOverflowGetTimeMs(dwPassBoxPIOWaitTime) > PASSBOX_PIO_CHECK_ABNORMAL_SIGNAL_WAIT_TIME)
				{
					if(m_pPassBoxPIO->IsCloseOn() == true)
					{
						nError = ERR_PASSBOX_PIO_CLOSE_SIGNAL_INIT_ABNORMAL_ON;
						ADD_LOG("ERR_PASSBOX_PIO_CLOSE_SIGNAL_INIT_ABNORMAL_ON, m_nPassBoxPIOStep(%d), Err(%d), Time(%d)", m_nPassBoxPIOStep, nError, OHTUTILITY::PreventOverflowGetTimeMs(dwPassBoxPIOWaitTime));
						ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d/%d",
									ERR_PASSBOX_PIO_CLOSE_SIGNAL_INIT_ABNORMAL_ON,
									m_pOHTMainStatus->StatusCommon.CurNodeID,
									m_pExecuteInfo->ExecutePositionInfo.NextNode,
									m_pOHTMainStatus->StatusCommon.CurNodeOffset,
									m_pOHTMainStatus->StatusCommon.ExistFoup,
									m_pOHTMainStatus->StatusCommon.StopStationID,
									m_nPassBoxPIOStep);
					}
					else if(m_pPassBoxPIO->IsBusyOn() == true)
					{
						nError = ERR_PASSBOX_PIO_BUSY_SIGNAL_INIT_ABNORMAL_ON;
						ADD_LOG("ERR_PASSBOX_PIO_BUSY_SIGNAL_INIT_ABNORMAL_ON, m_nPassBoxPIOStep(%d), Err(%d), Time(%d)", m_nPassBoxPIOStep, nError, OHTUTILITY::PreventOverflowGetTimeMs(dwPassBoxPIOWaitTime));
						ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d/%d",
									ERR_PASSBOX_PIO_BUSY_SIGNAL_INIT_ABNORMAL_ON,
									m_pOHTMainStatus->StatusCommon.CurNodeID,
									m_pExecuteInfo->ExecutePositionInfo.NextNode,
									m_pOHTMainStatus->StatusCommon.CurNodeOffset,
									m_pOHTMainStatus->StatusCommon.ExistFoup,
									m_pOHTMainStatus->StatusCommon.StopStationID,
									m_nPassBoxPIOStep);
					}
					else
					{
						nError = ERR_PASSBOX_PIO_OPEN_SIGNAL_INIT_ABNORMAL_ON;
						ADD_LOG("ERR_PASSBOX_PIO_OPEN_SIGNAL_INIT_ABNORMAL_ON, m_nPassBoxPIOStep(%d), Err(%d), Time(%d)", m_nPassBoxPIOStep, nError, OHTUTILITY::PreventOverflowGetTimeMs(dwPassBoxPIOWaitTime));
                    	ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d/%d",
									ERR_PASSBOX_PIO_OPEN_SIGNAL_INIT_ABNORMAL_ON,
									m_pOHTMainStatus->StatusCommon.CurNodeID,
									m_pExecuteInfo->ExecutePositionInfo.NextNode,
									m_pOHTMainStatus->StatusCommon.CurNodeOffset,
									m_pOHTMainStatus->StatusCommon.ExistFoup,
									m_pOHTMainStatus->StatusCommon.StopStationID,
									m_nPassBoxPIOStep);
					}
					dwPassBoxPIOWaitTime = 0;
				}
			}
			break;

		case PASSBOX_CTRL_STEP_OHT_STATUS_ON :
			if(nError==NO_ERR)
			{
				nError = m_pPassBoxPIO->OHTStatusOnOff(ON);
				dwPassBoxPIOWaitTime = timeGetTime();
				ADD_LOG("[PASSBOX_PIO]PASSBOX_CTRL_STEP_OHT_STATUS, m_nPassBoxPIOStep(%d)", m_nPassBoxPIOStep);
				m_nPassBoxPIOStep++;
			}
			break;

		case PASSBOX_CTRL_STEP_CLOSE_ON_CHECK :
			if((nError==NO_ERR) && (m_pPassBoxPIO->IsCloseOn() == true))
			{
				Sleep(100);		// TP1
				m_nPassBoxPIOStep++;
				ADD_LOG("[PASSBOX_PIO]PASSBOX_CTRL_STEP_CLOSE_ON_CHECK, m_nPassBoxPIOStep(%d)", m_nPassBoxPIOStep);
			}
			else
			{
				if(OHTUTILITY::PreventOverflowGetTimeMs(dwPassBoxPIOWaitTime) > PASSBOX_PIO_CHECK_CLOSE_ON_SIGNAL_TA1)
				{
					nError = ERR_PASSBOX_PIO_CLOSE_SIGNAL_ABNORMAL_OFF;
					ADD_LOG("ERR_PASSBOX_PIO_CLOSE_SIGNAL_ABNORMAL_OFF, m_nPassBoxPIOStep(%d), Err(%d), Time(%d)", m_nPassBoxPIOStep, nError, OHTUTILITY::PreventOverflowGetTimeMs(dwPassBoxPIOWaitTime));
					dwPassBoxPIOWaitTime = 0;
					ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d/%d",
									ERR_PASSBOX_PIO_CLOSE_SIGNAL_ABNORMAL_OFF,
									m_pOHTMainStatus->StatusCommon.CurNodeID,
									m_pExecuteInfo->ExecutePositionInfo.NextNode,
									m_pOHTMainStatus->StatusCommon.CurNodeOffset,
									m_pOHTMainStatus->StatusCommon.ExistFoup,
									m_pOHTMainStatus->StatusCommon.StopStationID,
									m_nPassBoxPIOStep);
				}
			}
			break;

		case PASSBOX_CTRL_STEP_DOOR_SELECT :
			if(nError==NO_ERR)
			{
				nError = m_pPassBoxPIO->DoorSelectOnOff(ON);
				ADD_LOG("[PASSBOX_PIO]PASSBOX_CTRL_STEP_DOOR_SELECT, m_nPassBoxPIOStep(%d)", m_nPassBoxPIOStep);
				m_nPassBoxPIOStep++;
			}
			break;

		case PASSBOX_CTRL_STEP_OPEN_REQ :
			if(nError==NO_ERR)
			{
				nError = m_pPassBoxPIO->OpenReqOnOff(ON);
				dwPassBoxPIOWaitTime = timeGetTime();
				ADD_LOG("[PASSBOX_PIO]PASSBOX_CTRL_STEP_OPEN_REQ, m_nPassBoxPIOStep(%d)", m_nPassBoxPIOStep);
				m_nPassBoxPIOStep++;
			}
			break;

		case PASSBOX_CTRL_STEP_BUSY_ON_SIGNAL_CHECK :
			if((nError==NO_ERR) && (m_pPassBoxPIO->IsBusyOn() == true))
			{
				Sleep(100);		// TP2
				m_nPassBoxPIOStep++;
				ADD_LOG("[PASSBOX_PIO]PASSBOX_CTRL_STEP_BUSY_ON_SIGNAL_CHECK, m_nPassBoxPIOStep(%d)", m_nPassBoxPIOStep);
			}
			else
			{
				if(OHTUTILITY::PreventOverflowGetTimeMs(dwPassBoxPIOWaitTime) > PASSBOX_PIO_CHECK_BUSY_ON_SIGNAL_TA2)
				{
					nError = ERR_PASSBOX_PIO_BUSY_SIGNAL_ABNORMAL_OFF;
					ADD_LOG("ERR_PASSBOX_PIO_BUSY_SIGNAL_ABNORMAL_OFF, m_nPassBoxPIOStep(%d), Err(%d), Time(%d)", m_nPassBoxPIOStep, nError, OHTUTILITY::PreventOverflowGetTimeMs(dwPassBoxPIOWaitTime));
					dwPassBoxPIOWaitTime = 0;
					ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d/%d",
									ERR_PASSBOX_PIO_BUSY_SIGNAL_ABNORMAL_OFF,
									m_pOHTMainStatus->StatusCommon.CurNodeID,
									m_pExecuteInfo->ExecutePositionInfo.NextNode,
									m_pOHTMainStatus->StatusCommon.CurNodeOffset,
									m_pOHTMainStatus->StatusCommon.ExistFoup,
									m_pOHTMainStatus->StatusCommon.StopStationID,
									m_nPassBoxPIOStep);
				}
			}
			break;

		case PASSBOX_CTRL_STEP_READY_ON :
			if(nError==NO_ERR)
			{
				nError = m_pPassBoxPIO->ReadyOnOff(ON);
				dwPassBoxPIOWaitTime = timeGetTime();
				ADD_LOG("[PASSBOX_PIO]PASSBOX_CTRL_STEP_READY_ON, m_nPassBoxPIOStep(%d)", m_nPassBoxPIOStep);
				m_nPassBoxPIOStep++;
			}
			break;

		case PASSBOX_CTRL_STEP_CLOSE_OFF_CHECK :
			if((nError==NO_ERR) && (m_pPassBoxPIO->IsCloseOn() == false))
			{
				Sleep(100);		// TP3
				nError = m_pPassBoxPIO->OpenReqOnOff(OFF);
				dwPassBoxPIOWaitTime = timeGetTime();
				ADD_LOG("[PASSBOX_PIO]PASSBOX_CTRL_STEP_CLOSE_OFF_CHECK, m_nPassBoxPIOStep(%d)", m_nPassBoxPIOStep);
				m_nPassBoxPIOStep++;
			}
			else
			{
				if(OHTUTILITY::PreventOverflowGetTimeMs(dwPassBoxPIOWaitTime) > PASSBOX_PIO_CHECK_CLOSE_OFF_SIGNAL_TA3)
				{
					nError = ERR_PASSBOX_PIO_CLOSE_SIGNAL_ABNORMAL_ON;
					ADD_LOG("ERR_PASSBOX_PIO_CLOSE_SIGNAL_ABNORMAL_ON, m_nPassBoxPIOStep(%d), Err(%d), Time(%d)", m_nPassBoxPIOStep, nError, OHTUTILITY::PreventOverflowGetTimeMs(dwPassBoxPIOWaitTime));
					dwPassBoxPIOWaitTime = 0;
					ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d/%d",
									ERR_PASSBOX_PIO_CLOSE_SIGNAL_ABNORMAL_ON,
									m_pOHTMainStatus->StatusCommon.CurNodeID,
									m_pExecuteInfo->ExecutePositionInfo.NextNode,
									m_pOHTMainStatus->StatusCommon.CurNodeOffset,
									m_pOHTMainStatus->StatusCommon.ExistFoup,
									m_pOHTMainStatus->StatusCommon.StopStationID,
									m_nPassBoxPIOStep);
				}
			}
			break;

		case PASSBOX_CTRL_STEP_BUSY_OFF_CHECK :
			if((nError==NO_ERR) && (m_pPassBoxPIO->IsBusyOn() == false))
			{
				Sleep(100);		// TP4
				nError = m_pPassBoxPIO->ReadyOnOff(OFF);
				dwPassBoxPIOWaitTime = timeGetTime();
				ADD_LOG("[PASSBOX_PIO]PASSBOX_CTRL_STEP_BUSY_OFF_CHECK, m_nPassBoxPIOStep(%d)", m_nPassBoxPIOStep);
				m_nPassBoxPIOStep++;
			}
			else
			{
				if(OHTUTILITY::PreventOverflowGetTimeMs(dwPassBoxPIOWaitTime) > PASSBOX_PIO_CHECK_BUSY_OFF_SIGNAL_TA4)
				{
					nError = ERR_PASSBOX_PIO_BUSY_SIGNAL_ABNORMAL_ON;
					ADD_LOG("ERR_PASSBOX_PIO_BUSY_SIGNAL_ABNORMAL_ON, m_nPassBoxPIOStep(%d), Err(%d), Time(%d)", m_nPassBoxPIOStep, nError, OHTUTILITY::PreventOverflowGetTimeMs(dwPassBoxPIOWaitTime));
					dwPassBoxPIOWaitTime = 0;
					ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d/%d",
									ERR_PASSBOX_PIO_BUSY_SIGNAL_ABNORMAL_ON,
									m_pOHTMainStatus->StatusCommon.CurNodeID,
									m_pExecuteInfo->ExecutePositionInfo.NextNode,
									m_pOHTMainStatus->StatusCommon.CurNodeOffset,
									m_pOHTMainStatus->StatusCommon.ExistFoup,
									m_pOHTMainStatus->StatusCommon.StopStationID,
									m_nPassBoxPIOStep);
				}
			}
			break;

		case PASSBOX_CTRL_STEP_PASSBOX_DOOR_OPEN_CHECK :
			if((nError==NO_ERR) && (m_pPassBoxPIO->IsOpenOn() == true))
			{
				m_pPassBoxPIO->ReadyOnOff(OFF);
				Sleep(10);
				m_pPassBoxPIO->DoorSelectOnOff(OFF);
				Sleep(10);
				m_pPassBoxPIO->OHTStatusOnOff(OFF);
				Sleep(100);

				ADD_LOG("[PASSBOX_PIO]PASSBOX_CTRL_STEP_PASSBOX_DOOR_OPEN_CHECK, m_nPassBoxPIOStep(%d)", m_nPassBoxPIOStep);
				m_nPassBoxPIOStep++;
			}
			else
			{
				if(OHTUTILITY::PreventOverflowGetTimeMs(dwPassBoxPIOWaitTime) > PASSBOX_PIO_CHECK_OPEN_ON_WAIT_TIME)
				{
					nError = ERR_PASSBOX_PIO_OPEN_SIGNAL_ABNORMAL_OFF;
					ADD_LOG("ERR_PASSBOX_PIO_OPEN_SIGNAL_ABNORMAL_OFF, m_nPassBoxPIOStep(%d), Err(%d), Time(%d)", m_nPassBoxPIOStep, nError, OHTUTILITY::PreventOverflowGetTimeMs(dwPassBoxPIOWaitTime));
					dwPassBoxPIOWaitTime = 0;
					ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d/%d",
									ERR_PASSBOX_PIO_OPEN_SIGNAL_ABNORMAL_OFF,
									m_pOHTMainStatus->StatusCommon.CurNodeID,
									m_pExecuteInfo->ExecutePositionInfo.NextNode,
									m_pOHTMainStatus->StatusCommon.CurNodeOffset,
									m_pOHTMainStatus->StatusCommon.ExistFoup,
									m_pOHTMainStatus->StatusCommon.StopStationID,
									m_nPassBoxPIOStep);
				}
			}
			break;

		case PASSBOX_CTRL_STEP_COMPLETE :
			ADD_LOG("[STEP] DRIVING_CTRL_STEP_GO_PASSBOX");
			m_pPassBoxPIO->PIODisable(true);
			*puStep = DRIVING_CTRL_STEP_GO_INIT;
			break;
	}

	return nError;
}

/*
   리프터를 미리 부르는 동작 제어
*/

UINT DrivingControl::executePreEvevetor(DEVICE_NODE_TYPE DirType)
{
	UINT nError = NO_ERR;
	int iReturn;

	AnsiString OHTNAME;
	int Priority;
	int Turn;
	unsigned char LightGuideID;
	bool LightGuideDirectionIsLeft;


	static int iRetryCnt = 0;
	OHTNAME = m_strOhtName;
	Priority = PRIORITY_LEVEL_9;
	if(m_defualtparam->VHLLifterPassEnable == 0)
	{
		Turn = PASS_DIRECTION_REQUEST_ALL;

      if (m_nElevetorDirection == PASS_DIRECTION_REQUEST_RIGHT)	// 내가 하부에 진입하고, 상부로 가고 싶다
			LightGuideID = LIGHT_GUIDE_ID_INPUT_UP;
	  else
			LightGuideID = LIGHT_GUIDE_ID_INPUT_DOWN;
	}
	else // AOHC-217 VHLLifter 속도 개선 jhoun.lim 181107
	{
		Turn = m_nElevetorDirection; // jhoun.lim 181107
		LightGuideID = LIGHT_GUIDE_ID_NONE;	 // AOHC-217 VHLLifter 속도 개선 jhoun.lim 181107
	}

	if((DirType >=MTL_SEL_ON_LEFT) && (DirType <=MTL_STOP_RIGTH))
       LightGuideID = LIGHT_GUIDE_ID_INPUT_DOWN;

	if((DirType == LIFTPRE_NTYPE_LEFT) ||(DirType ==MTL_SEL_ON_LEFT) ||(DirType ==LIFTIN_NTYPE_LEFT) ||(DirType ==MTL_STOP_LEFT))
		LightGuideDirectionIsLeft = true;
	else
        LightGuideDirectionIsLeft = false;


	AnsiString strLogTmp;

	static int iDelayCnt = 0;
	// -----------------------------

	if(m_nElevetorRideStep >VHL_ELEVETOR_RIDE_CTRL_STEP_CID_INIT)
	{
		if(!(CID_Check_Mode_Lifter(LightGuideDirectionIsLeft)))
		{
			CID_IO_SETTING_LIFTER(LightGuideDirectionIsLeft);
			ADD_CID_LOG("[LIFTER] [Pre] Lifter_Checking");
		}
	}

	switch(m_nElevetorRideStep)
	{
		case VHL_ELEVETOR_RIDE_CTRL_STEP_CID_INIT:
		{
			ADD_CID_LOG("\n------------------------------");
			ADD_CID_LOG("[LIFTER PRE(01)] CID_INIT");

			CID_IO_SETTING_LIFTER(LightGuideDirectionIsLeft);
			m_iLifterPrePass = VHL_ELEVETOR_PREPASS_STEP_TOUCH;

			iRetryCnt = 0;
			m_nElevetorRideStep++;	// next step
			//AOHC-217 VHLLifter 속도 개선
		   // if (0 : off Pass), (1 : on Pass) jhoun.lim 19.10.15
			if(m_defualtparam->VHLLifterPassEnable == 0)
			{
				m_nElevetorDirection = PASS_DIRECTION_REQUEST_ALL;
			}
			else
			{
				m_nElevetorDirection = PASS_DIRECTION_REQUEST_BEFORECHECK;   // jhoun.lim 18.11.14
			}
		}
		break;

// -------------------

		case VHL_ELEVETOR_RIDE_CTRL_STEP_SERIAL_INIT:
		{
			ADD_CID_LOG("[\nLIFTER PRE (02)] - SERIAL_INIT");

		// Try Reset
			nError = VHL_OPC_RESET();

			if(nError == NO_ERR)
			{
				ADD_CID_LOG("[LIFTER PRE] OPC RESET... Return Code is : NO_ERR");
				iDelayCnt = 0;
				m_nElevetorRideStep++;
			}
			else
			{
				// Sleep(DELAY_SERIAL_RESET);
				iRetryCnt = iRetryCnt + DELAY_SERIAL_READ;
				strLogTmp.sprintf("[LIFTER PRE] OPC B/D RESET... Return Code is : %d (ERROR Exist).. ErrTime(ms) : %d", nError, iRetryCnt);
				ADD_CID_LOG(strLogTmp);

			}

			if(iRetryCnt > LIFTER_PASS_TIME_OUT_MS)
			{
				ADD_CID_LOG("[LIFTER PRE] SERIAL_INIT retry over");

				if((DirType >=MTL_SEL_ON_LEFT) && (DirType <=MTL_STOP_RIGTH))
					return ERR_MTL_LG_OPC_RESET_CMD_SEND_FAIL;
				else
					return ERR_LIFTER_OPC_RESET_CMD_SEND_FAIL;
			}
		}
		break;

		case VHL_ELEVETOR_RIDE_CTRL_STEP_SERIAL_WAIT:
			if (iDelayCnt > (DELAY_SERIAL_RESET / 10))
			{
				ADD_CID_LOG("\n[LIFTER PRE STEP(03)] - SERIAL_WAIT");
				// Sleep(DELAY_SERIAL_RESET);

				ADD_CID_LOG("[LIFTER PRE]  VHL_OPC_RESET_RESPONSE() - BEFORE");
				iReturn = VHL_OPC_RESET_RESPONSE();

				strLogTmp.sprintf("[LIFTER PRE] OPC B/D RESET Response. Return Code is (HEX) : %02X  (CHAR) : %c", iReturn, iReturn);
				ADD_CID_LOG(strLogTmp);

				if(iReturn == TRANSPER_STATUS_DATA_RECEIVED_OK)
				{
					iRetryCnt = 0;
					m_nElevetorRideStep++;
					ADD_CID_LOG("[LIFTER PRE] OPC B/D RESET Response - RECEIVED_OK");
				}
				else if(iReturn == TRANSPER_STATUS_DATA_NOT_RECEIVED)
				{
					m_nElevetorRideStep = VHL_ELEVETOR_RIDE_CTRL_STEP_SERIAL_INIT;	// retry
					iRetryCnt = iRetryCnt + DELAY_SERIAL_READ;
					strLogTmp.sprintf("[LIFTER PRE] OPC B/D RESET Response - DATA_NOT_RECEIVED ErrTime(ms) : %d ", iRetryCnt);
					ADD_CID_LOG(strLogTmp);
				}
				else
				{
					m_nElevetorRideStep = VHL_ELEVETOR_RIDE_CTRL_STEP_SERIAL_INIT;	// retry
					iRetryCnt = iRetryCnt + DELAY_SERIAL_READ;
					strLogTmp.sprintf("[LIFTER PRE] OPC B/D RESET Response - OTHER ERR	ErrTime(ms) : %d ", iRetryCnt);
					ADD_CID_LOG(strLogTmp);
				}
/*
				if(iRetryCnt > LIFTER_PASS_TIME_OUT_MS)
				{
					ADD_CID_LOG("[LIFTER PRE] SERIAL_INIT retry over");
					return ERR_LIFTER_OPC_RESET_CMD_RESULT_FAIL;
				}
*/
			}
			else
			{
				iDelayCnt++;
			}
		break;


// -------------------
		case VHL_ELEVETOR_RIDE_CTRL_STEP_INPUT_REQUEST: 	// 투입허가 요청함
		{
			ADD_CID_LOG("\n[LIFTER PRE (04)] - INPUT_REQUEST");

			strLogTmp.sprintf("[LIFTER PRE] Pass Request - OHTNAME : %s Priority : %c Turn : %c LightGuideID : %c",
								m_defualtparam->VHLName, Priority, Turn, LightGuideID);
			ADD_CID_LOG(strLogTmp);

			nError = VHL_OPC_PASS_REQUEST(m_defualtparam->VHLName, Priority, Turn, LightGuideID);

			if(nError == NO_ERR)
			{
				ADD_CID_LOG("[LIFTER PRE] INPUT_REQUEST STEP OK...");
				iDelayCnt = 0;
				m_nElevetorRideStep++;
			}
			else
			{
				// Sleep(DELAY_SERIAL_READ);
				iRetryCnt = iRetryCnt + DELAY_SERIAL_READ;
				strLogTmp.sprintf("[LIFTER PRE] VHL_OPC_PASS_REQUEST - Return : %d ErrTime(ms) : %d", nError, iRetryCnt);
				ADD_CID_LOG(strLogTmp);
			}

			if(iRetryCnt > LIFTER_PASS_TIME_OUT_MS)
			{
				ADD_CID_LOG("[LIFTER PRE] SERIAL_INIT retry over");


				if((DirType >=MTL_SEL_ON_LEFT) && (DirType <=MTL_STOP_RIGTH))
					return ERR_MTL_LG_REQUEST_CMD_SEND_FAIL;
				else
					return ERR_LIFTER_INPUT_REQUEST_CMD_SEND_FAIL;
			}
		}
		break;


		case VHL_ELEVETOR_RIDE_CTRL_STEP_INPUT_CONFIRM_WAIT:	// 투입허가 승인대기
			if (iDelayCnt > (DELAY_SERIAL_WAIT_N_REQUEST_RETRY / 10))
			{
				ADD_CID_LOG("\n[LIFTER PRE (05)] - CONFIRM_WAIT");
				// Sleep(DELAY_SERIAL_WAIT_N_REQUEST_RETRY);

				iReturn = VHL_OPC_PASS_RESPONSE(LightGuideID);

				//AOHC-217 VHLLifter 속도 개선
				if(iReturn == VHL_LIFTER_TO_CID_R_ALL_PASS_OK || iReturn == VHL_LIFTER_TO_CID_R_ALL_PASS_OK_P) // jhoun.lim
				{
					strLogTmp.sprintf("[LIFTER] INPUT_CONFIRM_WAIT OK...%c", iReturn);
					ADD_CID_LOG(strLogTmp);
					//ADD_CID_LOG("[LIFTER PRE] INPUT_CONFIRM OK...");
					iRetryCnt = 0;
					m_nElevetorRideStep++;
				}
				else
				{
					iRetryCnt = iRetryCnt + DELAY_SERIAL_WAIT_N_REQUEST_RETRY;
					strLogTmp.sprintf("[LIFTER PRE] CONFIRM_WAIT Err. Code : %c ErrTime(ms) : %d", iReturn, iRetryCnt);
					ADD_CID_LOG(strLogTmp);
					m_nElevetorRideStep = VHL_ELEVETOR_RIDE_CTRL_STEP_INPUT_REQUEST;
				}

				if(iRetryCnt > LIFTER_PASS_TIME_OUT_MS)
				{
					ADD_CID_LOG("[LIFTER PRE] SERIAL_INIT retry over");

					if((DirType >=MTL_SEL_ON_LEFT) && (DirType <=MTL_STOP_RIGTH))
						return ERR_MTL_LG_REQUEST_CONFIRM_TIME_OUT;
					else
						return ERR_LIFTER_INPUT_REQUEST_CONFIRM_TIME_OUT;
				}

			}
			else
			{
				iDelayCnt++;
			}
		break;

// -------------------

		case VHL_ELEVETOR_RIDE_CTRL_STEP_COMPLETE:		// 스테이트 머신 끝날땐 어떻게 처리해줘야 하나
		{
			ADD_CID_LOG("\n[LIFTER PRE(06)");
			Sleep(20);

            //초기화
			VHL_OPC_RESET();
			Sleep(DELAY_SERIAL_RESET);
			VHL_OPC_RESET_RESPONSE();

			iReturn = CID_SELECT_ALL_OFF();		// CID의 Select를 모두 Off한다
			strLogTmp.sprintf("[LIFTER] SELECT all off return : %d", iReturn);
			ADD_CID_LOG(strLogTmp);
			Sleep(DELAY_CID_COMMAND);	// 장비사양상 최소 10ms딜레이 줘야 함

			m_iLifterPrePass = VHL_ELEVETOR_PREPASS_STEP_COMPLETE;	// Lifter In 노드까지 가기 전에 투입허가 요청을 받아낸 경우
			m_IsLifterCheck = false;
			m_IsMTLCheck = false;
			return NO_ERR;
		}
		break;
	}

	return NO_ERR;
}


/**
@brief  Elevetor 타기 동작 Control
@author 김승현
@date   2016.02.15
@param  puStep 주행의 Step 변수
@return 에러 없으면 0반환, 있으면 에러 코드 반환
*/


UINT DrivingControl::executeRideEvevetor(DRIVING_HW_INFO_SET HwInfo, DRIVING_INFO_SET *pInfoSet, UINT *puStep)
{
	UINT nError = NO_ERR;
	int iReturn;

	DRIVING_CMD_INFO_OF_NODE* pNodeInfo = getNodeInfo(0);

	if(pNodeInfo==NULL)
    {
        ADD_LOG("[executeRideEvevetor]Cnt:%d/%d, ListCnt:%d"
            , HwInfo.Node.nNodeCount
            , pInfoSet->HwInfo.Node.nNodeCount
            , m_ClassifiedCmd.NodeList.getCount())
		return nError;// 에러 처리 : 명령에 없는 노드 Count 실시
	}

	// 임시 - 디버그용
		AnsiString OHTNAME;
		int Priority;
		int Turn;
		unsigned char LightGuideID;
		bool LightGuideDirectionIsLeft;

		static int iRetryCnt = 0;

		// OHTNAME = "OHT001";
		OHTNAME = m_strOhtName;
		Priority = PRIORITY_LEVEL_9;
		if(m_defualtparam->VHLLifterPassEnable == 0)
		{
			Turn = PASS_DIRECTION_REQUEST_ALL;
			if (m_nElevetorDirection == PASS_DIRECTION_REQUEST_RIGHT)	// 내가 하부에 진입하고, 상부로 가고 싶다
				LightGuideID = LIGHT_GUIDE_ID_INPUT_UP;
			else
				LightGuideID = LIGHT_GUIDE_ID_INPUT_DOWN;
		}

		else
		{
			Turn = m_nElevetorDirection; // jhoun.lim 181107
			LightGuideID = LIGHT_GUIDE_ID_NONE; // AOHC-217 VHLLifter 속도 개선 jhoun.lim 181107
		}




		if((pNodeInfo->NodeType >=MTL_SEL_ON_LEFT) && (pNodeInfo->NodeType <=MTL_STOP_RIGTH))
			LightGuideID = LIGHT_GUIDE_ID_INPUT_DOWN;

		if((pNodeInfo->NodeType == LIFTPRE_NTYPE_LEFT) ||(pNodeInfo->NodeType == MTL_SEL_ON_LEFT)  ||(pNodeInfo->NodeType == LIFTIN_NTYPE_LEFT)  ||(pNodeInfo->NodeType == MTL_STOP_LEFT))
			LightGuideDirectionIsLeft = true;
		else
			LightGuideDirectionIsLeft = false;


		AnsiString strLogTmp;
	// -----------------------------

	if(m_nElevetorRideStep >VHL_ELEVETOR_RIDE_CTRL_STEP_CID_INIT)
	{
		if(!(CID_Check_Mode_Lifter(LightGuideDirectionIsLeft)))
		{
			CID_IO_SETTING_LIFTER(LightGuideDirectionIsLeft);
			ADD_CID_LOG("[LIFTER] Lifter_Checking");
		}
	}

	if(bReqLifterCounterReset == true)
	{
		bReqLifterCounterReset = false;
		iRetryCnt = 0;
	}

	switch(m_nElevetorRideStep)
	{
		case VHL_ELEVETOR_RIDE_CTRL_STEP_CID_INIT:
		{
			ADD_CID_LOG("\n-------------------------------");
			ADD_CID_LOG("[LIFTER] CID_INIT");
			// Steering Check
			// if(pTmpDrivingInfo.BasicInfo.Steering == STEERING_LEFT

			nError = CID_SELECT_ALL_OFF();		// CID의 Select를 모두 Off한다
			strLogTmp.sprintf("[LIFTER] SELECT all off return : %d", nError);
			ADD_CID_LOG(strLogTmp);
			Sleep(DELAY_CID_COMMAND);	// 장비사양상 최소 10ms딜레이 줘야 함

			nError = CID_OPERATION_MODE_LIFTER();	// CID장치를 리프터 모드로 전환한다
			strLogTmp.sprintf("[LIFTER] OP MODE LIFTER : %d", nError);
			ADD_CID_LOG(strLogTmp);
			Sleep(DELAY_CID_COMMAND);

			// 좌,우 방향을 선택한다
			if(LightGuideDirectionIsLeft == true)
			{
				nError = CID_SELECT_DIRECTION_LEFT();
				strLogTmp.sprintf("[LIFTER] LEFT 선택 : %d", nError);
				ADD_CID_LOG(strLogTmp);
				Sleep(DELAY_CID_COMMAND);
			}
			else
			{
				nError = CID_SELECT_DIRECTION_RIGHT();
				strLogTmp.sprintf("[LIFTER] RIGHT 선택 : %d", nError);
				ADD_CID_LOG(strLogTmp);
				Sleep(DELAY_CID_COMMAND);
			}

			iRetryCnt = 0;
			m_nElevetorRideStep++;	// next step
			
			//AOHC-217 VHLLifter 속도 개선
			// if (0 : off Pass), (1 : on Pass) jhoun.lim 19.10.15
			if(m_defualtparam->VHLLifterPassEnable == 0)
			{
				m_nElevetorDirection =  PASS_DIRECTION_REQUEST_ALL;
			}
			else
			{
				m_nElevetorDirection =  PASS_DIRECTION_REQUEST_BEFORECHECK; // jhoun.lim 18.11.14
			}			
		}
		break;

// -------------------


		case VHL_ELEVETOR_RIDE_CTRL_STEP_SERIAL_INIT:
		{
			ADD_CID_LOG("\n[LIFTER RIDE(02)] - SERIAL_INIT");

		// Try Reset
			nError = VHL_OPC_RESET();

			if(nError == NO_ERR)
			{
				ADD_CID_LOG("[LIFTER] OPC RESET... Return Code is : NO_ERR");
				m_nElevetorRideStep++;
			}
			else
			{
				Sleep(DELAY_SERIAL_RESET);
				iRetryCnt = iRetryCnt + DELAY_SERIAL_READ;
				strLogTmp.sprintf("[LIFTER] OPC B/D RESET... Return Code is : %d (ERROR Exist).. ErrTime(ms) : %d", nError, iRetryCnt);
				ADD_CID_LOG(strLogTmp);

			}

			if(iRetryCnt > LIFTER_PASS_TIME_OUT_MS)
			{
				ADD_CID_LOG("[LIFTER] SERIAL_INIT retry over");
				if((pNodeInfo->NodeType >=MTL_SEL_ON_LEFT) && (pNodeInfo->NodeType <=MTL_STOP_RIGTH))
					return ERR_MTL_LG_OPC_RESET_CMD_SEND_FAIL;
				else
					return ERR_LIFTER_OPC_RESET_CMD_SEND_FAIL;
			}
		}
		break;

		case VHL_ELEVETOR_RIDE_CTRL_STEP_SERIAL_WAIT:
		{
			ADD_CID_LOG("\n[LIFTER RIDE (03)] - SERIAL_WAIT");
			Sleep(DELAY_SERIAL_RESET);

			ADD_CID_LOG("[LIFTER]  VHL_OPC_RESET_RESPONSE() - BEFORE");
			iReturn = VHL_OPC_RESET_RESPONSE();

			strLogTmp.sprintf("[LIFTER] OPC B/D RESET Response. Return Code is (HEX) : %02X  (CHAR) : %c", iReturn, iReturn);
			ADD_CID_LOG(strLogTmp);

			if(iReturn == TRANSPER_STATUS_DATA_RECEIVED_OK)
			{
				iRetryCnt = 0;
				m_nElevetorRideStep++;
				ADD_CID_LOG("[LIFTER] OPC B/D RESET Response - RECEIVED_OK");
			}
			else if(iReturn == TRANSPER_STATUS_DATA_NOT_RECEIVED)
			{
				m_nElevetorRideStep = VHL_ELEVETOR_RIDE_CTRL_STEP_SERIAL_INIT;	// retry
				iRetryCnt = iRetryCnt + DELAY_SERIAL_READ;
				strLogTmp.sprintf("[LIFTER] OPC B/D RESET Response - DATA_NOT_RECEIVED ErrTime(ms) : %d ", iRetryCnt);
				ADD_CID_LOG(strLogTmp);
			}
			else
			{
				m_nElevetorRideStep = VHL_ELEVETOR_RIDE_CTRL_STEP_SERIAL_INIT;	// retry
				iRetryCnt = iRetryCnt + DELAY_SERIAL_READ;
				strLogTmp.sprintf("[LIFTER] OPC B/D RESET Response - OTHER ERR  ErrTime(ms) : %d ", iRetryCnt);
				ADD_CID_LOG(strLogTmp);
			}

			if(iRetryCnt > LIFTER_PASS_TIME_OUT_MS)
			{
				ADD_CID_LOG("[LIFTER] SERIAL_INIT retry over");
				if((pNodeInfo->NodeType >=MTL_SEL_ON_LEFT) && (pNodeInfo->NodeType <=MTL_STOP_RIGTH))
				 	return ERR_MTL_LG_OPC_RESET_CMD_RESULT_FAIL;
				else
					return ERR_LIFTER_OPC_RESET_CMD_RESULT_FAIL;
			}
		}
		break;


// -------------------
		case VHL_ELEVETOR_RIDE_CTRL_STEP_INPUT_REQUEST:		// 투입허가 요청함
		{
			ADD_CID_LOG("\n[LIFTER RIDE (04)] - INPUT_REQUEST");
			/* strLogTmp.sprintf("[LIFTER] Pass Request - OHTNAME : %s Priority : %d Turn : %d LightGuideID : %d",
								OHTNAME, Priority, Turn, LightGuideID); */
			strLogTmp.sprintf("[LIFTER] Pass Request - OHTNAME : %s Priority : %c Turn : %c LightGuideID : %c",
								m_defualtparam->VHLName, Priority, Turn, LightGuideID);
			ADD_CID_LOG(strLogTmp);

			nError = VHL_OPC_PASS_REQUEST(m_defualtparam->VHLName, Priority, Turn, LightGuideID);

			if(nError == NO_ERR)
			{
				ADD_CID_LOG("[LIFTER] INPUT_REQUEST STEP OK...");
				m_nElevetorRideStep++;
			}
			else
			{
				Sleep(DELAY_SERIAL_READ);
				iRetryCnt = iRetryCnt + DELAY_SERIAL_READ;
				strLogTmp.sprintf("[LIFTER] VHL_OPC_PASS_REQUEST - Return : %d ErrTime(ms) : %d", nError, iRetryCnt);
				ADD_CID_LOG(strLogTmp);
			}

			if(iRetryCnt > LIFTER_PASS_TIME_OUT_MS)
			{
				ADD_CID_LOG("[LIFTER] SERIAL_INIT retry over");
				if((pNodeInfo->NodeType >=MTL_SEL_ON_LEFT) && (pNodeInfo->NodeType <=MTL_STOP_RIGTH))
					return ERR_MTL_LG_REQUEST_CMD_SEND_FAIL;
				else
					return ERR_LIFTER_INPUT_REQUEST_CMD_SEND_FAIL;
			}
		}
		break;


		case VHL_ELEVETOR_RIDE_CTRL_STEP_INPUT_CONFIRM_WAIT:	// 투입허가 승인대기
		{
			ADD_CID_LOG("\n[LIFTER RIDE (05)] - INPUT_CONFIRM_WAIT");
			Sleep(DELAY_SERIAL_WAIT_N_REQUEST_RETRY);

			iReturn = VHL_OPC_PASS_RESPONSE(LightGuideID);

			//AOHC-217 VHLLifter 속도 개선
			if(iReturn == VHL_LIFTER_TO_CID_R_ALL_PASS_OK || iReturn == VHL_LIFTER_TO_CID_R_ALL_PASS_OK_P) // jhoun.lim
			{
				AnsiString strLogTmp;
				strLogTmp.sprintf("[LIFTER] INPUT_CONFIRM_WAIT OK...%c", iReturn);
				ADD_CID_LOG(strLogTmp);
				//ADD_CID_LOG("[LIFTER] INPUT_CONFIRM_WAIT OK...");
				iRetryCnt = 0;
				m_nElevetorRideStep++;
			}
			else
			{
				iRetryCnt = iRetryCnt + DELAY_SERIAL_WAIT_N_REQUEST_RETRY;
				strLogTmp.sprintf("[LIFTER] INPUT_CONFIRM_WAIT Err. Code : %c ErrTime(ms) : %d", iReturn, iRetryCnt);
				ADD_CID_LOG(strLogTmp);
				m_nElevetorRideStep = VHL_ELEVETOR_RIDE_CTRL_STEP_INPUT_REQUEST;
			}

			if(iRetryCnt > LIFTER_PASS_TIME_OUT_MS)
			{
				ADD_CID_LOG("[LIFTER] SERIAL_INIT retry over");
				if((pNodeInfo->NodeType >=MTL_SEL_ON_LEFT) && (pNodeInfo->NodeType <=MTL_STOP_RIGTH))
						return ERR_MTL_LG_REQUEST_CONFIRM_TIME_OUT;
				else
						return ERR_LIFTER_INPUT_REQUEST_CONFIRM_TIME_OUT;
			}

		}
		break;

// -------------------

		case VHL_ELEVETOR_RIDE_CTRL_STEP_COMPLETE:		// 스테이트 머신 끝날땐 어떻게 처리해줘야 하나??
		{
			ADD_CID_LOG("\n[LIFTER RIDE (06)");
			Sleep(20);

			//초기화
			VHL_OPC_RESET();
			Sleep(DELAY_SERIAL_RESET);
			VHL_OPC_RESET_RESPONSE();

			iReturn = CID_SELECT_ALL_OFF();		// CID의 Select를 모두 Off한다
			strLogTmp.sprintf("[LIFTER] SELECT all off return : %d", iReturn);
			ADD_CID_LOG(strLogTmp);
			Sleep(DELAY_CID_COMMAND);	// 장비사양상 최소 10ms딜레이 줘야 함

			*puStep = DRIVING_CTRL_STEP_GO_INIT;

			m_IsLifterCheck = false;
			m_IsMTLCheck = false;

			return NO_ERR;
		}
		break;
	}

	return NO_ERR;
}


/**
@brief	Elevetor 내리는 동작 Control
@author 김승현
@date	2016.02.15
@param	puStep 주행의 Step 변수
@return 에러 없으면 0반환, 있으면 에러 코드 반환
*/


UINT DrivingControl::executeOffEvevetor(DRIVING_HW_INFO_SET HwInfo, DRIVING_INFO_SET *pInfoSet, UINT *puStep)
{
	int iReturn;
	static int iRetryCnt = 0;

	LList 						DRIVING_INFO_List;
	EXECUTE_DRIVING_INFO		*pEXECUTE_DRIVING_INFO	= NULL;	// List에 저장하는 구조체

	AnsiString OHTNAME;
	int Priority;
	int Turn;
	unsigned char LightGuideID;
	bool LightGuideDirectionIsLeft;

	OHTNAME = m_strOhtName;
	Priority = PRIORITY_LEVEL_9;
	Turn = m_nElevetorDirection;

	if (m_nElevetorDirection == PASS_DIRECTION_REQUEST_RIGHT)	// 내가 하부에 진입하고, 상부로 가고 싶다
		LightGuideID = LIGHT_GUIDE_ID_INPUT_UP;
	else
		LightGuideID = LIGHT_GUIDE_ID_INPUT_DOWN;


	LightGuideDirectionIsLeft = m_pParamSet->bVHLLifterDir;



	AnsiString strLogTmp;
	// -----------------------------

	if(m_nElevetorRideStep >VHL_ELEVETOR_RIDE_CTRL_STEP_CID_INIT)
	{
		if(!(CID_Check_Mode_Lifter(LightGuideDirectionIsLeft)))
		{
			CID_IO_SETTING_LIFTER(LightGuideDirectionIsLeft);
			ADD_CID_LOG("[LIFTER [off] Lifter_Checking");
		}
	}

	switch(m_nElevetorOffStep)
	{
		case VHL_ELEVETOR_OFF_CTRL_STEP_INIT:
		{
			ADD_CID_LOG("\n--------------------------------");
			ADD_CID_LOG("[LIFTER OUT (01)] - OFF_CTRL_STEP_INIT");

            CID_IO_SETTING_LIFTER(LightGuideDirectionIsLeft);

			m_iLifterPrePass = VHL_ELEVETOR_PREPASS_STEP_NONE;

			iRetryCnt = 0;
			m_nElevetorOffStep++;
		}
		break;

// -------------------

		case VHL_ELEVETOR_OFF_CTRL_STEP_OUTPUT_REQUEST_INIT:
		{
			strLogTmp.sprintf("\n[LIFTER OUT (02)] OUTPUT_REQUEST Direction : %c", Turn);
			ADD_CID_LOG(strLogTmp);

			iReturn = VHL_OPC_PASS_REQUEST(m_defualtparam->VHLName, Priority, Turn, LightGuideID);
			strLogTmp.sprintf("[LIFTER] Out Init Return : %d", iReturn);
			ADD_CID_LOG(strLogTmp);
			m_nElevetorOffStep++;
		}
		break;

		case VHL_ELEVETOR_OFF_CTRL_STEP_OUTPUT_RESPONSE:
		{
			ADD_CID_LOG("\n[LIFTER OUT (03)] - OUTPUT_RESPONSE");
			Sleep(DELAY_SERIAL_WAIT_N_REQUEST_RETRY);
			// 이 함수의 리턴값은 응답으로 온 방향 지정값이 들어오며
			// 'R', 'L', 'r', 'l' 4가지가 유효하다
			iReturn = VHL_OPC_PASS_RESPONSE(LightGuideID);

			if(Turn == iReturn)
			{
				strLogTmp.sprintf("[LIFTER] OUTPUT_CONFIRM OK! Return = (DEC)%d  (HEX)%02x  (CHAR)%c", iReturn, iReturn, iReturn);
				ADD_CID_LOG(strLogTmp);
				m_nElevetorOffStep++;
			}
			else
			{
				iRetryCnt = iRetryCnt + DELAY_SERIAL_WAIT_N_REQUEST_RETRY;
				strLogTmp.sprintf("[LIFTER] CONFIRM Wait. Retry. Result = (DEC)%d  (HEX)%02x  (CHAR)%c  ErrTime(ms) : %d",
															iReturn, iReturn, iReturn, iRetryCnt);
				ADD_CID_LOG(strLogTmp);
				m_nElevetorOffStep = VHL_ELEVETOR_OFF_CTRL_STEP_OUTPUT_REQUEST_INIT;
			}

			if(iRetryCnt > LIFTER_PASS_TIME_OUT_MS)
			{
				ADD_CID_LOG("[LIFTER] SERIAL_INIT retry over");
				return ERR_LIFTER_OUTPUT_REQUEST_CONFIRM_TIME_OUT;
			}
		}
		break;

// -------------------

		case VHL_ELEVETOR_OFF_CTRL_STEP_OUTPUT_COMPLETE:
		{
			ADD_CID_LOG("\n[LIFTER OUT (04) : OUT END]");

			VHL_OPC_RESET();
			Sleep(DELAY_SERIAL_RESET);
			VHL_OPC_RESET_RESPONSE();

			iReturn = CID_SELECT_ALL_OFF();		// CID의 Select를 모두 Off한다
			strLogTmp.sprintf("[LIFTER] SELECT all off return : %d", iReturn);
			ADD_CID_LOG(strLogTmp);
			Sleep(DELAY_CID_COMMAND);	// 장비사양상 최소 10ms딜레이 줘야 함

			ADD_CID_LOG("------------------------------------------------------------");



		  	*puStep = DRIVING_CTRL_STEP_GO_INIT;
			//CID 관련 초기화---------------------------------------------------------------------------/

			m_bsecond = false;
			m_CID_Pause = false;
			m_CIDComptFlag = false;  // cid 완료 처리 Flag
			m_CIDComptTryFlag = false;  // cid 완료 처리 시도 Flag
			m_CID_COMMON_bit_off_need = false;
			m_CIDMonitoringFlag = false;
			m_CIDLinkFlag = false;
			m_CIDStatusFlag = false;
			m_CIDStatusPauseFlag = false;
			m_CIDPauseTime = 0;
			m_CID_Status_Pause = false;
			m_Igro_CIDStatusPuaseFlag = false;
			m_bLinkFail = false;
			m_bLinkDisconnected = false;
			m_bInitialLink = false;
			m_CIDDirection = CID_DIRECTION_NOT_LINK;
			m_bCIDNotUse = false;
			m_CIDOperationStarted = false;  // 2016. 12. 23 추가
			m_job_change_flag_no_cid_area = false; //0: not change 1 : change
			m_job_change_flag_exception_CommonTag = false;
			m_CurrCIDStartnode = 0;
			m_sCIDStatus[0]=0;
			m_sCIDStatus[1]=0;
			m_sCIDStatus[2]=0;

			bCountOfCID_Delay    = 0;
			bCountOfCIDLink    = 0; 	   //링크 연결 관련
			m_job_change_without_link_complete = false;
			bCountOfCIDDualOccup	= 0;  //동시진입 관련
			bCountOfCIDComptACK    = 0;  //완료처리 응답 관련

			bDirCIDChage = false;		// 방향전환 전에 완료처리를 함을 나타내는 변수
			tmpStopID = 0;
			memset(&Info, 0, sizeof(CID_CTRL_INFO));
			memset(&CID_4WAY_CONTROL_INFO, 0, sizeof(CID_4WAY_INFO));

			m_CIDNameReadFlag = false;
			m_tmpCurrentResetNode = 0;
			m_tmpCurrentStopNode = 0;
			m_nCIDTerminateCount = 0;
			
			m_Diag_CID_index = 0;
			memset(&m_Diag_CID_R_ID[0][0],'0',sizeof(m_Diag_CID_R_ID));
			memset(&m_Diag_ResetNode[0],0,sizeof(m_Diag_ResetNode));
			memset(&m_Diag_StopNode[0],0,sizeof(m_Diag_StopNode));

			m_nCidControlStep = CID_STEP_CONNECTING;

//  			ADD_LOG("[CID] Reset!!");
			//---------------------------------------------------------------------------/
			return NO_ERR;
		}
		break;
	}

	return NO_ERR;
}



/**
@brief   주행 초기화 확인
@author  임태웅
@date    2013.7.31
@param puStep 주행의 Step 변수
@return 에러 없으면 0반환, 있으면 에러 코드 반환
*/
UINT DrivingControl::executeGoInit(DRIVING_HW_INFO_SET HwInfo, DRIVING_INFO_SET *pInfoSet, UINT *puStep)
{
    UINT nTmpError = NO_ERR;


    //2 처음 시작할 때 PreCheck가 Node 를 넘어가있는 경우:
    //2 PreCheck 가 감지 되지 않아 무언 정지가 생길 수 있다.  이 경우 PreCheckCount 를 강제로 1로 만들어 준다
    DRIVING_CMD_INFO_OF_PATH* pPathInfo = getPathInfo(pInfoSet->HwInfo.Node.nNodeCount);
    DRIVING_CMD_INFO_OF_PATH* pNextPathInfo = getPathInfo(pInfoSet->HwInfo.Node.nNodeCount+1);

	//이전 노드카운트 위치값 초기화
	m_dPreNodecount = 0;
	m_dPreNodecountPosition = 0.0;
	m_dPreNodecountSpeed =0.0;
	m_dPrePrecheckNodecountPosition = 0.0;
	m_dCheckPrecheckNodecountPosition = 0.0;
	m_bFirstNodeStep = false;
	m_bIsFirstNodeCountAdd = false;
	m_bIsAMCVHLDetectIgnore = false;

	m_dCheckAMCDecelPosition = 0.0;
	m_dPreTargetPosition = 0.0;

	double  dSpeedOfNow = HwInfo.Axis1.dSpeed;

    if( (pInfoSet->HwInfo.Node.nPreCheckCount==0)
    &&  (pNextPathInfo!=NULL)
    &&  (pInfoSet->HwInfo.Axis1.dCurrPos<ACCEPTABLE_DRIVING_POSITION_ERROR)
    )
    {
        if((pPathInfo->dLength-pInfoSet->Position.Compensation.dPreArriveOffset)<
            (m_pParamSet->Mark[0].Dist.dDistFromFirstToSecond+m_pParamSet->Mark[0].Dist.dLengthOfSecond*2))
        {
            pInfoSet->Position.bPreCheckIsOverFirstNode = true;
        }
    }

    *puStep = DRIVING_CTRL_STEP_GO_PREPARE;

	ADD_LOG("[STEP] DRIVING_CTRL_STEP_GO_PREPARE");

	ADD_MCC_LOG(",%s,DRV,DRIVING,Start,FOUP,%06d,%06d,%06d,%d,%6.1lf",
					m_defualtparam->VHLName,
					m_mccparam.uSourceNode,
					m_mccparam.uTargetNode,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					dSpeedOfNow);

	// Manual_CID()
	/*
		Manual Mode에서 사이클 명령을 보내는 경우, CID출력이 이미 나가고 있는 상태이므로
		스테이트 머신을 정상적으로 수행하지 못하는 문제를 수정함
	*/
	static int iPreMode = EXECUTE_MODE_MANUAL;	// 초기값은 manual이니까

	if ((m_pExecuteInfo->ExecuteMode == EXECUTE_MODE_MANUAL) && (iPreMode == EXECUTE_MODE_AUTO))
	{
		iPreMode = EXECUTE_MODE_MANUAL;
		pHWSet->m_pCID->CID_Output_Clear(3);
		pHWSet->m_pCID->CID_Out_Common_Tag(8, true);	// abnormal bit = on
		ADD_LOG("[CID] Now Manual Mode. executeGoInit() CID I/O Cleared. Abnormal Mode = On");
	}
	else if((m_pExecuteInfo->ExecuteMode == EXECUTE_MODE_AUTO) && (iPreMode == EXECUTE_MODE_MANUAL))
	{
		ADD_LOG("[CID] Now Auto Mode. executeGoInit()");
		iPreMode = EXECUTE_MODE_AUTO;

#if 0
		// step1
		ADD_LOG("[CID] Manual -> Auto Step executeGoInit()");
		pHWSet->m_pCID->CID_Out_Occup_Req(false);
		pHWSet->m_pCID->CID_Out_Manual(false);

		// step2
		Sleep(10);
		pHWSet->m_pCID->CID_Out_PASS_Compt(true);
#endif

	}

	CheckReadyToRunTime_ExcuteGo = timeGetTime();

    return nTmpError;
}



/**
@brief   주행의 대기 상태로 전환 및 확인
@author  임태웅
@date    2013.7.31
@param puStep 주행의 Step 변수
@return 에러檍ㅖ{"{檍ㅖ鸚?oSet, UINT *puStㅔtInfo.dOffset);
*/
UINT DrivingControl::executeGoPrepare(DRIVING_HW_INFO_SET HwInfo, DRIVING_INFO_SET *pInfoSet, UINT *puStep)
{
    UINT nTmpError = NO_ERR;
	double  dRealDistSumToTarget    = getRealPos(m_ClassifiedCmd.TargetInfo.dDistSumToNode+m_ClassifiedCmd.TargetInfo.dOffset);
    DRIVING_CTRL_INFO_SET *pCtrlInfo = &(pInfoSet->Control);

 	// Control 정보
	USER_DETECT_INFO DetectInfo;
//	memset(&DetectInfo, 0, sizeof(CTRL_INFO_OF_FRONT_DETECT));

	//작업변경 확인  puting
	if(m_bOnBackMove == false)	nTmpError = checkJobChange(pInfoSet);

	if((getFrontObservation(0, &DetectInfo)==true) && (nTmpError ==NO_ERR))
	{

		if(checkReadyToRun(HwInfo, DetectInfo, &(pCtrlInfo->Axis), &(pCtrlInfo->Steer), &(pCtrlInfo->FrontObservation))==true)
		{

            ADD_LOG("MarkType:%d/%d Offset:%6.1lf/%6.1lf SumDis :%f6.11f/%6.11f"
            , pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.MarkType, MARK_TYPE_NODE
			, pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset, OFFSET_TO_CHECK_FIRST_NODE
			, dRealDistSumToTarget,m_ClassifiedCmd.TargetInfo.dOffset
			);


		//1  명령 작성 puting
//		if(memcmp(&DetectInfo, &(pCtrlInfo->FrontObservation.Info), sizeof(USER_DETECT_INFO))!=0)
//		if((DetectInfo.UseFollowControlFlag != pCtrlInfo->FrontObservation.Info.UseFollowControlFlag) ||
//		   (DetectInfo.Type != pCtrlInfo->FrontObservation.Info.Type) ||
//		   (DetectInfo.NodeCount != pCtrlInfo->FrontObservation.Info.NodeCount)||
//		   (DetectInfo.FollowCommandType != pCtrlInfo->FrontObservation.Info.FollowCommandType) ||
//		   (DetectInfo.PBSIgnoreFlag !=pCtrlInfo->FrontObservation.Info.PBSIgnoreFlag) ||
//		   (DetectInfo.DistSumOfStraightPath != pCtrlInfo->FrontObservation.Info.DistSumOfStraightPath))
//		{
//		}

			//사후  동작 작업

			if(dRealDistSumToTarget < 800) //거리값확인해볼것
			{
				  if(m_defualtparam->PreShutter)
				  {
						if(IsInnerFoup() == true)
						{
							m_bShutterCloseFlag = true;
							nTmpError = pHWSet->m_pShutter->Close();

							if(nTmpError != NO_ERR)
							{
								nTmpError = NO_ERR;
								m_bShutterCloseMovingFlag = true;
							}
						}
				  }
			}
			else
			{
				if(m_defualtparam->PreShutter)
				{
					ExeCmdShutterClose(HwInfo.Axis1.dSpeed);
				}
			}

			//초기 패턴 값 확인
			getFrontObservationNodeCount(0);

             //현재 위치가 슬로프일경우 초기화 처리함.
			if(m_cSlopeNodeInfo == SLOPE_NTYPE) m_cSlopeNodeInfo = INIT_NTYPE;

			if(m_bOnBackMove == false)
			{
				if(dRealDistSumToTarget<DIST_TO_CHECK_MARK_NODE_MARGIN)
				{
					*puStep = DRIVING_CTRL_STEP_GO_MARK;
					ADD_LOG("[STEP] DRIVING_CTRL_STEP_GO_MARK");
				}
				else if(    (pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.MarkType!=MARK_TYPE_NODE)
						&&  (pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset<OFFSET_TO_CHECK_FIRST_NODE)
				)
				{
					*puStep = DRIVING_CTRL_STEP_GO_FIRST_NODE;
					ADD_LOG("[STEP] DRIVING_CTRL_STEP_GO_FIRST_NODE");
				}
				else
				{
					*puStep = DRIVING_CTRL_STEP_GO_RUN;
					ADD_LOG("[STEP] DRIVING_CTRL_STEP_GO_RUN");
				}
			}else
			{

			   *puStep = DRIVING_CTRL_STEP_GO_RUN;
				ADD_LOG("[STEP] DRIVING_CTRL_STEP_GO_RUN(Back)");

			}

			Sleep(100);

		}
		else
		{
			if(OHTUTILITY::PreventOverflowGetTimeMs(CheckReadyToRunTime_ExcuteGo) > 5000)
			{
				if(m_pServoControl->IsSetInnerLimitTorque_800() ==false)
				{
					nTmpError=ERR_SERVO_DRIVING_ALARM;
					CheckReadyToRunTime_ExcuteGo = timeGetTime();
					ADD_LOG("checkReadyToRun[executeGoPrepare] Fail");
				}
			}
		}

    }

    return nTmpError;
}


/**
@brief   주행 처리
@author  임태웅
@date    2013.7.31
@param puStep 주행의 Step 변수
@return 에러 없으면 0반환, 있으면 에러 코드 반환
*/
UINT DrivingControl::executeGoFirstNode(DRIVING_HW_INFO_SET HwInfo, DRIVING_INFO_SET *pInfoSet, UINT *puStep)
{
    UINT nTmpError = NO_ERR;

//  DRIVING_CTRL_INFO_SET *pCtrlInfo = &(pInfoSet->Control);

	//작업변경 확인  puting
	if(m_bOnBackMove == false)	nTmpError = checkJobChange(pInfoSet);

    pInfoSet->HwInfo = HwInfo;


	if(nTmpError==NO_ERR)   nTmpError = checkSteer(pInfoSet);
	if(nTmpError==NO_ERR)   nTmpError = checkFrontObservation(pInfoSet);
	if(nTmpError==NO_ERR)   nTmpError = checkServoTorqueFlag(pInfoSet);
	if(nTmpError==NO_ERR)   nTmpError = checkAxisFirstNode(pInfoSet);
	if(nTmpError==NO_ERR)   nTmpError = checkCID(HwInfo, pInfoSet);

    if(nTmpError==NO_ERR)
	{
		if((pInfoSet->Position.bFirstNIDIsCorrect==true)
		&&  ((HwInfo.Axis1.dCurrPos>POSITION_TO_CHECK_FIRST_NODE) ||(HwInfo.IO.NodeOn == true))
		)
		{
			*puStep = DRIVING_CTRL_STEP_GO_RUN;

		 	Sleep(10); // 컨테스트 스위칭 처리 부분
            ADD_LOG("[STEP] DRIVING_CTRL_STEP_GO_RUN, Pos:R%5.1lf,C%5.1lf"
                , pInfoSet->HwInfo.Axis1.dCurrPos
				, compensate(pInfoSet->HwInfo.Axis1.dCurrPos));
        }
    }

    return nTmpError;
}



/**
@brief   주행 처리
@author  임태웅
@date    2013.7.31
@param puStep 주행의 Step 변수
@return 에러 없으면 0반환, 있으면 에러 코드 반환
*/
UINT DrivingControl::executeGoRun(DRIVING_HW_INFO_SET HwInfo, DRIVING_INFO_SET *pInfoSet, UINT *puStep)
{
    UINT nTmpError = NO_ERR;

//  DRIVING_CTRL_INFO_SET *pCtrlInfo = &(pInfoSet->Control);
   	if(m_bOnBackMove == false)
	{
		if(nTmpError==NO_ERR)   nTmpError = checkPosition(HwInfo, pInfoSet);
		if(nTmpError==NO_ERR)   nTmpError = checkSteer(pInfoSet);
		if(nTmpError==NO_ERR)   nTmpError = checkFrontObservation(pInfoSet);
		if(nTmpError==NO_ERR)   nTmpError = checkServoTorqueFlag(pInfoSet);
		if(nTmpError==NO_ERR)   nTmpError = checkAxisRun(pInfoSet);
		if(nTmpError==NO_ERR)   nTmpError = checkCID(HwInfo, pInfoSet);
#if (FOLLOW_CONTROL != 1)
		if(nTmpError==NO_ERR)   nTmpError = checkOBSAreaforNoFollowControl(pInfoSet);
#endif
	}else
	{
		// 후진 puting
		if(nTmpError==NO_ERR)   nTmpError = checkBackPosition(HwInfo, pInfoSet);
		if(nTmpError==NO_ERR)   nTmpError = checkBackSteer(pInfoSet);
		if(nTmpError==NO_ERR)   nTmpError = checkServoTorqueFlag(pInfoSet);
		if(nTmpError==NO_ERR)   nTmpError = checkAxisRun(pInfoSet);
    }

    if(nTmpError==NO_ERR)
    {
        if(pInfoSet->EventAndState.State.MarkArea==true)
		{
			if(m_bOnBackMove == false)
			{
				if(!((HwInfo.IO.ObsStatus==DETECT_AND_STOP) || (HwInfo.IO.DetectStatus==DETECT_AND_STOP)))
				{
					*puStep = DRIVING_CTRL_STEP_GO_MARK;

					ADD_LOG("[STEP] DRIVING_CTRL_STEP_GO_MARK, Pos:R%5.1lf,C%5.1lf"
						, pInfoSet->HwInfo.Axis1.dCurrPos
						, compensate(pInfoSet->HwInfo.Axis1.dCurrPos));
				}
			}else
			{
					*puStep = DRIVING_CTRL_STEP_GO_MARK;

					ADD_LOG("[STEP] DRIVING_CTRL_STEP_GO_MARK_BACK, Pos:R%5.1lf,C%5.1lf"
						, pInfoSet->HwInfo.Axis1.dCurrPos
						, compensate(pInfoSet->HwInfo.Axis1.dCurrPos));
            }
        }
    }

    return nTmpError;
}

/**
@brief   마크 처리 및 확인
@author  임태웅
@date    2013.7.31
@param puStep 주행의 Step 변수
@return 에러 없으면 0반환, 있으면 에러 코드 반환
*/
UINT DrivingControl::executeGoMark(DRIVING_HW_INFO_SET HwInfo, DRIVING_INFO_SET* pInfoSet, UINT *puStep)
{
	UINT nTmpError = NO_ERR;

	DRIVING_CMD_INFO_OF_NODE* pNodeInfo = getNodeInfo(HwInfo.Node.nNodeCount);
	double  dSpeedOfNow = HwInfo.Axis1.dSpeed;

	 if(m_bOnBackMove == false)
	{
		if(nTmpError==NO_ERR)   nTmpError = checkPosition(HwInfo, pInfoSet);
		if(nTmpError==NO_ERR)   nTmpError = checkSteer(pInfoSet);
		if(nTmpError==NO_ERR)   nTmpError = checkFrontObservation(pInfoSet);
		if(nTmpError==NO_ERR)   nTmpError = checkServoTorqueFlag(pInfoSet);
		if(nTmpError==NO_ERR)   nTmpError = checkCID(HwInfo, pInfoSet);
		if(nTmpError==NO_ERR)   nTmpError = checkAxisMark(pInfoSet);
#if (FOLLOW_CONTROL != 1)
		if(nTmpError==NO_ERR)   nTmpError = checkOBSAreaforNoFollowControl(pInfoSet);
#endif
	}else
	{
		// 후진 puting
		if(nTmpError==NO_ERR)   nTmpError = checkBackPosition(HwInfo, pInfoSet);
		if(nTmpError==NO_ERR)   nTmpError = checkBackSteer(pInfoSet);
		if(nTmpError==NO_ERR)   nTmpError = checkServoTorqueFlag(pInfoSet);
		if(nTmpError==NO_ERR)   nTmpError = checkAxisMark(pInfoSet);
    }

    if(nTmpError==NO_ERR)
    {
		if(pInfoSet->EventAndState.MarkState.Arrived==true)
		{

			*puStep = DRIVING_CTRL_STEP_GO_CHECK_STOP;
			 CheckComplete_ExcuteGo=timeGetTime();

			ADD_LOG("[STEP] DRIVING_CTRL_STEP_GO_CHECK_STOP");

			ADD_MCC_LOG(",%s,DRV,DRIVING,End,FOUP,%06d,%06d,%06d,%d,%6.1lf,DistSum,%6.1lf,FOUP Cover Detect,%d,Inner FOUP Detect,%d,Inner FOUP Not Detect,%d,Shift Home Sensor Off,%d,Hoist Home Sensor Off,%d",
				m_defualtparam->VHLName,
						m_mccparam.uSourceNode,
						m_mccparam.uTargetNode,
				m_pOHTMainStatus->StatusCommon.CurNodeID,
				m_pOHTMainStatus->StatusCommon.CurNodeOffset,
				dSpeedOfNow,
				pNodeInfo->dDistSum,
						m_mccparam.nFoupCoverDetectCount,
						m_mccparam.nInnerFOUPDetectCount,
						m_mccparam.nInnerFOUPNotDetectCount,
						m_mccparam.nShiftHomeSenOffCount,
						m_mccparam.nHoistHomeSenOffCount);
			SEND_WARN("MCC/14/1/10/%06d/%06d/%d/%d/%06d/%d/%d/%d/%d/%d",
						m_pOHTMainStatus->StatusCommon.CurNodeID,
						m_pExecuteInfo->ExecutePositionInfo.NextNode,
						m_pOHTMainStatus->StatusCommon.CurNodeOffset,
						m_pOHTMainStatus->StatusCommon.ExistFoup,
						m_pOHTMainStatus->StatusCommon.StopStationID,
						m_mccparam.nFoupCoverDetectCount,
						m_mccparam.nInnerFOUPDetectCount,
						m_mccparam.nInnerFOUPNotDetectCount,
						m_mccparam.nShiftHomeSenOffCount,
						m_mccparam.nHoistHomeSenOffCount);
			m_mccparam.nFoupCoverDetectCount = 0;
			m_mccparam.nInnerFOUPDetectCount = 0;
			m_mccparam.nInnerFOUPNotDetectCount = 0;
			m_mccparam.nShiftHomeSenOffCount = 0;
			m_mccparam.nHoistHomeSenOffCount = 0;
		}
	}

	return nTmpError;
}

/**
@brief   주행의 완료 확인
@author  임태웅
@date    2013.7.31
@param puStep 주행의 Step 변수
@return 에러 없으면 0반환, 있으면 에러 코드 반환
*/
UINT DrivingControl::executeGoCheckStop(DRIVING_HW_INFO_SET HwInfo, DRIVING_INFO_SET *pInfoSet, UINT *puStep)
{
    UINT nTmpError = NO_ERR;
	DRIVING_CTRL_INFO_SET *pCtrlInfo = NULL;

   DWORD       dwCurrTime  = timeGetTime();
   static  DWORD   dwCIDTrigerTime  = timeGetTime();

	int TempNodeCount = 0;
   	PATH_DIVERGENCE_INFO NodeDivInfo = NULL;
	PATH_DIVERGENCE_INFO NextDivInfo = NULL;

	if(m_bOnBackMove == false)
	{
		if(nTmpError==NO_ERR)   nTmpError = checkPosition(HwInfo, pInfoSet);
		if(nTmpError==NO_ERR)   nTmpError = checkSteer(pInfoSet);
		if(nTmpError==NO_ERR)   nTmpError = checkFrontObservation(pInfoSet);
		if(nTmpError==NO_ERR)   nTmpError = checkServoTorqueFlag(pInfoSet);
		if(nTmpError==NO_ERR)   nTmpError = checkCID(HwInfo, pInfoSet);
	}
	else
	{
		// 후진 puting
		if(nTmpError==NO_ERR)   nTmpError = checkBackPosition(HwInfo, pInfoSet);
		if(nTmpError==NO_ERR)   nTmpError = checkBackSteer(pInfoSet);
		if(nTmpError==NO_ERR)   nTmpError = checkServoTorqueFlag(pInfoSet);
	}
    if(nTmpError==NO_ERR)
    {
        pCtrlInfo = &(pInfoSet->Control);
		if(checkCompletion(pInfoSet->HwInfo, &(pCtrlInfo->Axis), &(pCtrlInfo->Steer), &(pCtrlInfo->FrontObservation))==true)
		{
			// m_CID_COMMON_bit_off_need : 공용 노드 완료 처리를 마무리 하기 위한 시간 지연 목적 : 2000ms
			// executeGoCheckStop step에서 m_CIDComptTryFlag == false여야 하나 잘못 된 경우 처리
			// 
			if ((m_CIDComptTryFlag == true) || (m_CID_COMMON_bit_off_need == true))
			{
				// 작업 변경 후 m_CIDComptTryFlag == true 되어 진입
				// 2초 기다리는 동안 executeGoCheckStop 처리 안됨
				// 강제로 disconnetcion 시키면서 CID로직 이상현상 발생
				ADD_LOG("[CID] DRIVING_CTRL_STEP_GO_COMPLETE waiting.. %d, %d", m_CIDComptTryFlag, m_CID_COMMON_bit_off_need);
				if(OHTUTILITY::PreventOverflowGetTimeMs(dwCIDTrigerTime) > 2000)
				{
					ADD_LOG("[CID] DRIVING_CTRL_STEP_GO_COMPLETE Fail...ComptTryFlag: %d, COMMON_bit_off_need: %d", m_CIDComptTryFlag, m_CID_COMMON_bit_off_need);
					if(m_CID_COMMON_bit_off_need == true)
					{
						pHWSet->m_pCID->CID_Out_Common_Tag(12,ON);
					}
					pHWSet->m_pCID->CID_Out_PASS_Compt(ON);
					Sleep(20);
					pHWSet->m_pCID->CID_Output_Clear(5);
					
					m_nCidControlStep = CID_STEP_CONNECTING;
					m_CIDComptTryFlag= false;
					m_CID_COMMON_bit_off_need = false;

					//m_nCidControlStep = CID_STEP_COMPLETION; 로 변경하여 CID_STEP_COMPLETION에서 처리 하도록 수정 필요
                }

				return nTmpError;
            }
			ADD_LOG("[CID] executeGoCheckStop() %d, %d, %d, %d", Info.Safety_Level, Info.tmpCurrentStationID, Info.CMD_StationID, pHWSet->m_pCID->IsOccupying());
			if(Info.Safety_Level == 0x01 && Info.tmpCurrentStationID == Info.CMD_StationID && pHWSet->m_pCID->IsOccupying() == true)
			{
				pHWSet->m_pCID->CID_Occup_return(44);	
				m_nCidControlStep = CID_STEP_CHECKING_PATH;

				ADD_LOG("[CID] executeGoCheckStop() CID_Occup_return");
			}


		 if(m_ClassifiedCmd.TargetInfo.Type != MARK_TYPE_NODE)
		 {
		   try{
			//분기 방향 정보
				if(getDivergenceInfo(m_ClassifiedCmd.TargetInfo.nCount-1, &NodeDivInfo, &NextDivInfo,&TempNodeCount)==true)
				{
					m_pExecuteInfo->nCheckDivInfo  =   NodeDivInfo;  //분기 정보 갱신
				}

				ADD_LOG("DRIVING_CTRL_STEP_GO_COMPLETE NodeCount: %d, DIV: %d", m_ClassifiedCmd.TargetInfo.nCount, NodeDivInfo);
			}catch(...)
			{
				ADD_LOG("<<Exception8888>>");

			}
		 }

			*puStep = DRIVING_CTRL_STEP_GO_COMPLETE;

			EnterCriticalSection(&OHTMainForm->m_CS);
			m_pExecuteInfo->AccumulationData.dDrivingEncoder += pInfoSet->Position.CmdRefInfo.dDist;
			LeaveCriticalSection(&OHTMainForm->m_CS);
			ADD_LOG("[STEP] DRIVING_CTRL_STEP_GO_COMPLETE");


		}
		else
		{
		   dwCIDTrigerTime  = timeGetTime();


		   //Station Mark의 경우 CheckCompletion 500ms 대기하는 Case있음
		   if(OHTUTILITY::PreventOverflowGetTimeMs(CheckComplete_ExcuteGo) > 5000)
		   {

				nTmpError = ERR_SERVO_DRIVING_ALARM;
				CheckComplete_ExcuteGo=  timeGetTime();
				ADD_LOG("[checkCompletion_executeGoCheckStop] Fail SetInnerLimitTorque_90");
		   }
		}
	}

    return nTmpError;
}

/**
@brief   주행의 완료 확인
@author  임태웅
@date    2013.7.31
@param puStep 주행의 Step 변수
@return 에러 없으면 0반환, 있으면 에러 코드 반환
*/
UINT DrivingControl::executeGoComplete(DRIVING_HW_INFO_SET HwInfo, DRIVING_INFO_SET *pInfoSet,UINT *puStep)
{
	UINT nTmpError = NO_ERR;
//  DRIVING_CTRL_INFO_SET *pCtrlInfo = &(pInfoSet->Control);

    if(nTmpError==NO_ERR)
	{
		//진단모니터링 항목(엔코더값 차이 확인)
		double dFrontPos = pInfoSet->HwInfo.Axis1.dCurrPos;
		double dRearPos = pInfoSet->HwInfo.Axis2.dCurrPos;

		//차이값 계산
		int nEncoderDiff = (int)((fabs(dFrontPos - dRearPos) / dFrontPos) * 100);
	 //	ADD_LOG("EncoderDiff확인 : %d", (DWORD)nEncoderDiff);
		m_DiagManager->IncreasePreviosDiagMax(PREVIOS_DIAG_MO_FRGAP, nEncoderDiff);

		//차이값이 일정 범위를 초과하면 Count up
		if(nEncoderDiff > m_DiagManager->GetDiagParam().nRefAbnormDifferenceEncoderLimit)
		{
			m_DiagManager->IncreaseAbnormalDrvDiffCount();

			//Count가 일정 횟수 이상되면 Abnormal으로 판단
			if(m_DiagManager->GetAbnormalDrvDiffCount() > m_DiagManager->GetDiagParam().nRefAbnormDifferenceEncoderCount)
			{
				m_DiagManager->InsertAbnormalDiagData(DIAG_ABNORMAL_DATA_ID_DIFFERENCE_ENCODER);
				m_DiagManager->ResetAbnormalDrvDiffCount();
            }
        }


		if(m_bOnMapMake==true)
		{
			m_bOnMapMake=false;
			memset(&m_bMapMakeType, 0x00, sizeof(MAP_MAKER_TYPE));
			ADD_LOG("MapMake End:%d", m_bOnMapMake);
		}

		if(m_bOnBackMove ==true)
		{
			m_bOnBackMove = false;
			ADD_LOG("BackMove End");
        }
		m_Dectect_Dir = PATH_DIRECTION_NO_USE;
		m_Dectect_OBS_Dir = PATH_DIRECTION_NO_USE;
		*puStep = DRIVING_CTRL_STEP_NONE;

		ADD_LOG("[STEP_Complete] DRIVING_CTRL_STEP_NONE Dis:%f",dFrontPos);
	}

    return nTmpError;
}

/**
@brief   InfoLists 의 상태를 확인하고 모든 정보를 삭제
@author  ehoto
@date    2013.7.19
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
bool DrivingControl::clearCmdInfoLists()
{
    const int nCount = 6;
    bool abSuccess[nCount] ={false,};
    bool bSuccess = true;

    abSuccess[0] = clearList(&(m_ClassifiedCmd.NodeList));
    abSuccess[1] = clearList(&(m_ClassifiedCmd.SteerList));
	abSuccess[2] = clearList(&(m_ClassifiedCmd.DirectionList));
    abSuccess[3] = clearList(&(m_ClassifiedCmd.SpeedlList));
	abSuccess[4] = clearList(&(m_ClassifiedCmd.PathList));
	abSuccess[5] = clearList(&(m_ClassifiedCmd.DivList));

	memset(&m_ClassifiedCmd.TargetInfo, 0, sizeof(m_ClassifiedCmd.TargetInfo));

    for(int n=0; n<nCount; n++)
    {
		bSuccess = bSuccess & abSuccess[n];
	}

    return bSuccess;
}

/**
@brief   InfoLists 의 상태를 확인하고 nNodeCount 이전의 정보를 삭제
@author  임태웅
@date    2013.7.19
@param nNodeCount 노드 카운트
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
bool  DrivingControl::clearCmdInfoListsLessThan(int nNodeCount)
{
	const int nCount = 6;
	bool abSuccess[nCount] ={false,};
	bool bSuccess = true;

	abSuccess[0] = clearListLessThan(&(m_ClassifiedCmd.NodeList), nNodeCount);
	abSuccess[1] = clearListLessThan(&(m_ClassifiedCmd.SteerList), nNodeCount);
	abSuccess[2] = clearListLessThan(&(m_ClassifiedCmd.DirectionList), nNodeCount);
	abSuccess[3] = clearListLessThan(&(m_ClassifiedCmd.SpeedlList), nNodeCount);
	abSuccess[4] = clearListLessThan(&(m_ClassifiedCmd.PathList), nNodeCount);
	abSuccess[5] = clearListLessThan(&(m_ClassifiedCmd.DivList), nNodeCount);

    for(int n=0; n<nCount; n++)
    {
        bSuccess = bSuccess & abSuccess[n];
	}

    return bSuccess;
}

/**
@brief   InfoLists 의 상태를 확인하고 nNodeCount 이전의 정보를 삭제
@author  임태웅
@date    2013.7.19
@param nNodeCount 노드 카운트
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
bool  DrivingControl::clearCmdInfoListsLessAfter(CLASSIFIED_DRIVING_CHANGE TempDrivnigInfo)
{
    const int nCount = 6;
    bool abSuccess[nCount] ={false,};
    bool bSuccess = true;
//    TempDrivnigInfo.nCheckNodeCount
	abSuccess[0] = CancelList(&(m_ClassifiedCmd.NodeList), TempDrivnigInfo);
	abSuccess[1] = CancelList(&(m_ClassifiedCmd.SteerList), TempDrivnigInfo);
	abSuccess[2] = CancelList(&(m_ClassifiedCmd.DirectionList), TempDrivnigInfo);
	abSuccess[3] = CancelList(&(m_ClassifiedCmd.SpeedlList), TempDrivnigInfo);
	abSuccess[4] = CancelList(&(m_ClassifiedCmd.PathList), TempDrivnigInfo);
	abSuccess[5] = CancelList(&(m_ClassifiedCmd.DivList), TempDrivnigInfo);

    for(int n=0; n<nCount; n++)
    {
		bSuccess = bSuccess & abSuccess[n];
	}

	if(bSuccess == true)
	{
		m_ClassifiedCmd.TargetInfo = TempDrivnigInfo.TargetInfo;
    	//최종 타겟 변경
	}

    return bSuccess;
}
/**
@brief   m_InfoSet.Control의 명령 Flag를 초기화 함
@author  임태웅
@date    2013.08.10
@param nNodeCount 노드 카운트
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
bool DrivingControl::clearDrivingCtrlInfoSet()
{
    m_InfoSet.Control.Steer.FrontCmdOn = false;
    m_InfoSet.Control.Steer.RearCmdOn= false;
    m_InfoSet.Control.Axis.byType = AXIS_CTRL_CMD_NONE;
    m_InfoSet.Control.FrontObservation.bCmdOn = false;
    for(int n=0; n<4; n++)
    {
        m_InfoSet.Control.IdReader[n] = CTRL_INFO_OF_ID_READER_CMD_NONE;
    }

//	ADD_LOG("clearDrivingCtrlInfoSet");

    return true;
}

/**
@brief   DrivingControl HW정보 획득 함수
@author  임태웅
@date    2013.07.01
*/
DRIVING_HW_INFO_SET DrivingControl::getHWInfo()
{
    DRIVING_HW_INFO_SET TmpHwInfo;
    memset(&TmpHwInfo, 0, sizeof(DRIVING_HW_INFO_SET));

    //2 I/O 정보
    TmpHwInfo.IO.BrakeRelease       = m_pDrivingAxis->IsBrakeReleased();
    TmpHwInfo.IO.Axis1AmpOn         = m_pDrivingAxis->IsAMPEnable();
    TmpHwInfo.IO.Axis1Running       = m_pDrivingAxis->IsRunning();
    TmpHwInfo.IO.Axis1InPosition    = m_pDrivingAxis->IsInPosition();
    TmpHwInfo.IO.Axis1AxisDone      = m_pDrivingAxis->IsAxisDone();
    if(m_pDrivingAxis->IsSyncControl()==true)
    {
        TmpHwInfo.IO.Axis2AmpOn         = m_pDrivingAxis->m_pSlaveAxis->IsAMPEnable();
        TmpHwInfo.IO.Axis2Running       = m_pDrivingAxis->m_pSlaveAxis->IsRunning();
        TmpHwInfo.IO.Axis2InPosition    = m_pDrivingAxis->m_pSlaveAxis->IsInPosition();
        TmpHwInfo.IO.Axis2AxisDone      = m_pDrivingAxis->m_pSlaveAxis->IsAxisDone();
    }

    TmpHwInfo.IO.NodePreCheckOn     = m_pDrivingTag->IsPreCheckOn();
    TmpHwInfo.IO.NodeOn             = m_pDrivingTag->IsOn();
    TmpHwInfo.IO.TagStationFrontOn  = m_pTransStopTag->IsOnFrontSensor();
    TmpHwInfo.IO.TagStationRearOn   = m_pTransStopTag->IsOnRearSensor();
    TmpHwInfo.IO.ObsStatus          = m_pObstacle->GetStatus();
	TmpHwInfo.IO.DetectStatus       = m_pOHTDetect->GetStatus();

    TmpHwInfo.IO.SteerFrontLeftInOn     = m_pSteer->IsFrontLeftOn();
    TmpHwInfo.IO.SteerFrontRightInOn    = m_pSteer->IsFrontRightOn();
    TmpHwInfo.IO.SteerRearLeftInOn      = m_pSteer->IsRearLeftOn();
    TmpHwInfo.IO.SteerRearRightInOn     = m_pSteer->IsRearRightOn();
    TmpHwInfo.IO.SteerFrontTorque       = m_pSteer->GetFrontTorque();
    TmpHwInfo.IO.SteerFrontDirCmd       = (m_pSteer->GetFrontCmd()==HW_STEER_DIRECTION_LEFT)?0:1;   //< 조향 명령 ( 0:왼쪽 / 1:오른쪽 )
    TmpHwInfo.IO.SteerRearTorque        = m_pSteer->GetRearTorque();
    TmpHwInfo.IO.SteerRearDirCmd        = (m_pSteer->GetRearCmd()==HW_STEER_DIRECTION_LEFT)?0:1;


    //2  Axis 1 정보
    TmpHwInfo.Axis1.dCurrPos            = m_pDrivingAxis->GetCurrentPosition();
	TmpHwInfo.Axis1.dFinalPos           = m_pDrivingAxis->GetFinalPosition();
    TmpHwInfo.Axis1.dSpeed              = m_pDrivingAxis->GetCurrentVelocity();
    TmpHwInfo.Axis1.dFollowError        = m_pDrivingAxis->GetFollowingError();
    TmpHwInfo.Axis1.dSmallAddCheckPos   = m_pDrivingAxis->GetSmallAddCheckPosition();
    TmpHwInfo.Axis1.nError              = m_pDrivingAxis->GetError();

	//2  Axis 2 정보
    if(m_pDrivingAxis->IsSyncControl()==true)
    {
        TmpHwInfo.Axis2.dCurrPos            = m_pDrivingAxis->m_pSlaveAxis->GetCurrentPosition();
        TmpHwInfo.Axis2.dFinalPos           = m_pDrivingAxis->m_pSlaveAxis->GetFinalPosition();
        TmpHwInfo.Axis2.dSpeed              = m_pDrivingAxis->m_pSlaveAxis->GetCurrentVelocity();
		TmpHwInfo.Axis2.dFollowError        = m_pDrivingAxis->m_pSlaveAxis->GetFollowingError();
        TmpHwInfo.Axis2.dSmallAddCheckPos   = m_pDrivingAxis->m_pSlaveAxis->GetSmallAddCheckPosition();
        TmpHwInfo.Axis2.nError              = m_pDrivingAxis->m_pSlaveAxis->GetError();
    }

    //2 Node 정보
    USER_NODE_CHECK_DATA UserNodeCheckData;
    m_pDrivingAxis->GetNodeCountInfo(UserNodeCheckData);

	int nID = 0;

	if(m_pDrivingBCR->GetID(&nID) != NO_ERR)
	{
		nID = 0;
	}

    TmpHwInfo.Node.nNodeCount           = UserNodeCheckData.NodeCount;
    TmpHwInfo.Node.dNodePosition        = UserNodeCheckData.PositionOfDrivingTag;
    TmpHwInfo.Node.nPreCheckCount       = UserNodeCheckData.NodeCountOfPreCheck;
    TmpHwInfo.Node.dPreCheckPosition    = UserNodeCheckData.PositionOfDrivingTagPreCheck;
    TmpHwInfo.Node.nBcrId               = nID;

    //2 Tag Station 정보
	//AOHC-249 BCR Read Sequence 개선
	if(m_pTransBCR->GetID(&nID, &b_ReadBcr)!=NO_ERR)
	{
		nID = 0;
	}
    TmpHwInfo.TagStaion.dFrontPosition  = UserNodeCheckData.PositionOfTransTagFirst;
    TmpHwInfo.TagStaion.dRearPosition   = UserNodeCheckData.PositionOfTransTagFinal;
    TmpHwInfo.TagStaion.nBcrId          = nID;
//  if(nID!=0)
//  {
//      ADD_LOG("TmpHwInfo.TagStaion.nBcrId : %X",nID);
//  }

    //2 QR Station 정보 (Left)
    double dOffset = 0.0;
    if(m_pLeftQRR->GetIDnOffset(&nID, &dOffset)!=NO_ERR)
    {
        nID = 0;
        dOffset = 0.0;
    }
    TmpHwInfo.QrStaionLeft.nQrId        = nID;
    TmpHwInfo.QrStaionLeft.dQrOffset    = dOffset;

    //2 QR Station 정보 (Right)
    dOffset = 0.0;
    if(m_pRightQRR->GetIDnOffset(&nID, &dOffset)!=NO_ERR)
    {
        nID = 0;
        dOffset = 0.0;
    }
    TmpHwInfo.QrStaionRight.nQrId       = nID;
    TmpHwInfo.QrStaionRight.dQrOffset   = dOffset;

    return TmpHwInfo;

}


/**
@brief   DrivingControl Axis Control 함수
@author  임태웅
@date    2013.07.01
*/
int DrivingControl::controlAll(DRIVING_CTRL_INFO_SET CtrlInfo)
{
    int nTmpError = NO_ERR;
    static MARK_TYPE MarkType[5] =
    {
        MARK_TYPE_NODE,
        MARK_TYPE_TAG_STATION,
        MARK_TYPE_QR_STATION_LEFT,
		MARK_TYPE_QR_STATION_RIGHT,
        MARK_TYPE_TAG_STATION_BACK
	};
    //1 동작
    if(nTmpError==NO_ERR)   nTmpError = controlFrontObservation(CtrlInfo.FrontObservation);
	if(nTmpError==NO_ERR)   nTmpError = controlSteer(CtrlInfo.Steer);
    if(nTmpError==NO_ERR)   nTmpError = controlAxis(CtrlInfo.Axis);
    for(int n=0; n<4; n++)
    {
		if( (nTmpError==NO_ERR)
         && (CtrlInfo.IdReader[n]!=CTRL_INFO_OF_ID_READER_CMD_NONE) )
        {
			nTmpError = controlIdReader(MarkType[n], CtrlInfo.IdReader[n]);
        }
    }
    return nTmpError;
}

/**
@brief   DrivingControl Axis Control 함수
@author  임태웅
@date    2013.07.01
*/
int DrivingControl::controlAxis(CTRL_INFO_OF_SYNC_AXIS_MOVE AxisInfo)
{
    int nTmpError = NO_ERR;
	double dAccel = 0.0, dDecel = 0.0, dSpeed = 0.0, dDist = 0.0;
	USER_MOVE_DS_ADDITIONAL_INFO AdditionalInfo;
	bool bAmpOn = false;

    dAccel  = AxisInfo.Dynamic.dAccel;
    dDecel  = AxisInfo.Dynamic.dDecel;
    dSpeed  = AxisInfo.Dynamic.dSpeed;
    dDist   = AxisInfo.Dynamic.dDist;
    AdditionalInfo  = AxisInfo.Dynamic.AdditionalInfo;

    switch(AxisInfo.byType)
    {
    case AXIS_CTRL_CMD_NONE:
        break;
    case AXIS_CTRL_CMD_STATIC:
        if(AxisInfo.Static.NodeCountReset==true)
        {
		  //  ADD_LOG("controlAxis: ClearNodeCountInfo");
            m_pDrivingAxis->ClearNodeCountInfo();
        }

        if(AxisInfo.Static.Axis1ResetCmdOn==true)
        {
            ADD_LOG("controlAxis: Axis1 Reset");
            nTmpError = m_pDrivingAxis->Reset();
        }
        if(AxisInfo.Static.Axis1SetHomeCmdOn==true && nTmpError==NO_ERR)
        {
		  //	ADD_LOG("controlAxis: Axis1 Home");
            nTmpError = m_pDrivingAxis->SetHome();
        }
        if(AxisInfo.Static.Axis1AmpCmdOn==true && nTmpError==NO_ERR)
        {
            bAmpOn = AxisInfo.Static.Axis1AmpOn;
			//ADD_LOG("controlAxis: Axis1 SetAMPEnable: %d", bAmpOn);
            nTmpError = m_pDrivingAxis->SetAMPEnable(bAmpOn);
        }

        if(AxisInfo.Static.Axis2ResetCmdOn==true && nTmpError==NO_ERR)
        {
            ADD_LOG("controlAxis: Axis2 Reset");
            nTmpError = m_pDrivingAxis->m_pSlaveAxis->Reset();
        }
        if(AxisInfo.Static.Axis2SetHomeCmdOn==true && nTmpError==NO_ERR)
        {
          //  ADD_LOG("controlAxis: Axis2 Home");
            nTmpError = m_pDrivingAxis->m_pSlaveAxis->SetHome();
        }
        if(AxisInfo.Static.Axis2AmpCmdOn==true && nTmpError==NO_ERR)
        {
            bAmpOn = AxisInfo.Static.Axis2AmpOn;
			//ADD_LOG("controlAxis: Axis2 SetAMPEnable: %d", bAmpOn);
            nTmpError = m_pDrivingAxis->m_pSlaveAxis->SetAMPEnable(bAmpOn);
        }
        break;
	case AXIS_CTRL_CMD_MOVE_DS:
		if(m_pDrivingAxis->IsSlaveAMPEnable()  ==false)                  //673관련 코드 추가
			nTmpError = m_pDrivingAxis->SetSlaveAMPEnable(true);         //673관련 코드 추가
        if(nTmpError==NO_ERR)                                            //673관련 코드 추가
		nTmpError = m_pDrivingAxis->MoveDistance(dAccel, dDecel, dSpeed, dDist, AdditionalInfo);
		ADD_LOG("controlAxis: Axis MoveDistance: %f", dDist);
        break;
    case AXIS_CTRL_CMD_MOVE_S:
		nTmpError = m_pDrivingAxis->MoveStop(dDecel);
		ADD_LOG("controlAxis: Axis1 Stop: %f", dDecel);
        break;
    case AXIS_CTRL_CMD_MOVE_P:
        nTmpError = m_pDrivingAxis->MovePositive(dAccel, dSpeed);
        break;
    case AXIS_CTRL_CMD_MOVE_N:
        nTmpError = m_pDrivingAxis->MoveNegative(dAccel, dSpeed);
        break;
    }

    return nTmpError;
}

/**
@brief   DrivingControl 조향 Control 함수
@author  임태웅
@date    2013.07.01
*/
int DrivingControl::controlSteer(CTRL_INFO_OF_STEER SteerInfo)
{
	int nTmpError = NO_ERR;
	bool bCheckMoveSteer[2] = {0,};

	HW_STEER_DIRECTION_CMD SteerDirectionCmd;
    HW_STEER_TORQUE SteerTorque;

    // 명령 있을 경우 로그 작성
//    if(SteerInfo.FrontCmdOn==true || SteerInfo.RearCmdOn==true)
//	{
//		ADD_LOG("controlSteer:F(%d:%d:%d)/R(%d:%d:%d)"
//			,SteerInfo.FrontCmdOn, SteerInfo.FrontDirection, SteerInfo.FrontTorque
//            ,SteerInfo.RearCmdOn, SteerInfo.RearDirection, SteerInfo.RearTorque     );
//    }

    if(SteerInfo.FrontCmdOn==true)
    {
        if(SteerInfo.FrontDirection==0)         SteerDirectionCmd = HW_STEER_DIRECTION_CMD_LEFT;
        else if(SteerInfo.FrontDirection==1)    SteerDirectionCmd = HW_STEER_DIRECTION_CMD_RIGHT;
        switch(SteerInfo.FrontTorque)
        {
         case 0:
            SteerTorque = HW_STEER_TORQUE_FREE;
            break;
		 case 1:
            SteerTorque = HW_STEER_TORQUE_STOP;
            break;
		 case 2:
            SteerTorque = HW_STEER_TORQUE_MOVING;
            break;
         case 3:
            SteerTorque = HW_STEER_TORQUE_TRACTION;
            break;
        }

        nTmpError = m_pSteer->SetFrontTorque(SteerTorque);
        if( nTmpError== NO_ERR )
        {
			nTmpError = m_pSteer->SetFrontDirection(SteerDirectionCmd);
		}

		if(nTmpError == NO_ERR)
		{
			bCheckMoveSteer[0] = true;
		}

    }
    if(SteerInfo.RearCmdOn==true && nTmpError== NO_ERR)
    {
        if(SteerInfo.RearDirection==0)          SteerDirectionCmd = HW_STEER_DIRECTION_CMD_LEFT;
        else if(SteerInfo.RearDirection==1)     SteerDirectionCmd = HW_STEER_DIRECTION_CMD_RIGHT;
        switch(SteerInfo.RearTorque)
        {
         case 0:
            SteerTorque = HW_STEER_TORQUE_FREE;
            break;
         case 1:
            SteerTorque = HW_STEER_TORQUE_STOP;
            break;
         case 2:
            SteerTorque = HW_STEER_TORQUE_MOVING;
            break;
         case 3:
            SteerTorque = HW_STEER_TORQUE_TRACTION;
            break;
        }

        if( nTmpError== NO_ERR )
        {
            nTmpError = m_pSteer->SetRearTorque(SteerTorque);
        }
        if( nTmpError== NO_ERR )
        {
            nTmpError = m_pSteer->SetRearDirection(SteerDirectionCmd);

		}

		if(nTmpError == NO_ERR)
		{
			bCheckMoveSteer[1] = true;
		}
	}

	//진단모니터링 항목(Auto 인 경우 Steering 구동횟수 Count)
	if((bCheckMoveSteer[0] == true) && (bCheckMoveSteer[1] == true))
	{
		m_pSteer->IncreaseMovingCount();
	}

    return nTmpError;
}

/**
@brief   DrivingControl 전방 감시 Control 함수
@author  임태웅
@date    2013.07.01
*/
int DrivingControl::controlFrontObservation(CTRL_INFO_OF_FRONT_DETECT DirectionCmd)
{
    if(DirectionCmd.bCmdOn==true)
	{
#if(USE_CHANGENODE == 1)
		ADD_LOG("OBS:%d,%d,%d,%d,%d,%d,%4.1lf"
			, DirectionCmd.bCmdOn, DirectionCmd.Info.UseFollowControlFlag
            , DirectionCmd.Info.OHTDetectType, DirectionCmd.Info.NodeCount
            , DirectionCmd.Info.FollowCommandType, DirectionCmd.Info.PBSIgnoreFlag
			, DirectionCmd.Info.DistSumOfStraightPath);

		ADD_LOG("Change Node : NodeType(%d), UBG(%d), OBS(%d), Dist(%d), DistAfter(%d)"
			, DirectionCmd.Info.NodeType
			, DirectionCmd.Info.OHTDetectTypeOpt, DirectionCmd.Info.OBSDetectTypeOpt
			, DirectionCmd.Info.DistON, DirectionCmd.Info.DistAfterON);
#else
		ADD_LOG("OBS:%d,%d,%d,%d,%d,%d,%4.1lf"
			, DirectionCmd.bCmdOn, DirectionCmd.Info.UseFollowControlFlag
			, DirectionCmd.Info.Type, DirectionCmd.Info.NodeCount
			, DirectionCmd.Info.FollowCommandType, DirectionCmd.Info.PBSIgnoreFlag
			, DirectionCmd.Info.DistSumOfStraightPath);
#endif

//			ADD_LOG("Pre:  controlFront");
		return m_pDrivingAxis->SetDetectInfo(DirectionCmd.Info);
    }
    else
    {
        return 0;
    }
}

/**
@brief   DrivingControl ID Reader Control 함수 (BCR/QR)
@author  임태웅
@date    2013.07.01
*/
int DrivingControl::controlIdReader(MARK_TYPE MarkType, CTRL_INFO_OF_ID_READER_CMD_TYPE CmdType)
{
    return controlIdReader(MarkType, CmdType, NULL, NULL);
}

/**
@brief   DrivingControl ID Reader Control 함수 (BCR/QR)
@author  임태웅
@date    2013.07.01
*/
int DrivingControl::controlIdReader(MARK_TYPE MarkType, CTRL_INFO_OF_ID_READER_CMD_TYPE CmdType, int* pnResultID)
{
    return controlIdReader(MarkType, CmdType, pnResultID, NULL);
}

/**
@brief   DrivingControl ID Reader Control 함수 (BCR/QR)
@author  임태웅
@date    2013.07.01
*/
int DrivingControl::controlIdReader(MARK_TYPE MarkType, CTRL_INFO_OF_ID_READER_CMD_TYPE CmdType, int* pnResultID, double* pdResultOffset)
{
	VirtualIdReader *pIdReader = NULL;

    // Return 을 위한 변수 추가 2016.05.01 by soo583
	int nTmpError = NO_ERR;


//    if(CmdType!=CTRL_INFO_OF_ID_READER_CMD_NONE)
//    {
//        ADD_LOG("ID Cmd:%X:%X",MarkType, CmdType);
//    }

    // ID Reader Type 선택
    switch(MarkType)
    {
    case MARK_TYPE_NODE:
        pIdReader = m_pDrivingBCR;
        pIdReader->SetResultPointer(pnResultID);
        break;

	case MARK_TYPE_TAG_STATION:
	case MARK_TYPE_TAG_STATION_BACK:
        pIdReader = m_pTransBCR;
        pIdReader->SetResultPointer(pnResultID);
        break;

    case MARK_TYPE_QR_STATION_LEFT:
        pIdReader = m_pLeftQRR;
        pIdReader->SetResultPointer(pnResultID, pdResultOffset);
        break;

    case MARK_TYPE_QR_STATION_RIGHT:
        pIdReader = m_pRightQRR;
        pIdReader->SetResultPointer(pnResultID, pdResultOffset);
        break;
    }

    // 명령 수행
    switch(CmdType)
    {
    case CTRL_INFO_OF_ID_READER_CMD_NONE:
        break;

    case CTRL_INFO_OF_ID_READER_CMD_ENABLE:
		nTmpError = pIdReader->Enable();
        break;

    case CTRL_INFO_OF_ID_READER_CMD_DISABLE:
		pIdReader->Disable();
        break;

    case CTRL_INFO_OF_ID_READER_CMD_RESTART:
		nTmpError = pIdReader->ReStart();
        break;

    case CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON:
		nTmpError = pIdReader->SendTriggerOn();
        break;

    case CTRL_INFO_OF_ID_READER_CMD_READ_DATA:
		nTmpError = pIdReader->ReadBuffer();
        break;

	case CTRL_INFO_OF_ID_READER_CMD_TRIGGER_OFF:
		nTmpError = pIdReader->SendTriggerOff();
		break;

    case CTRL_INFO_OF_ID_READER_CMD_READ_SEQUENTIALLY:
        nTmpError = pIdReader->SendTriggerOn();
        Sleep(100); // 시간은 확인 할 것
        if(nTmpError == NO_ERR)    { nTmpError = pIdReader->ReadBuffer(); }
        if(nTmpError == NO_ERR)    { nTmpError = pIdReader->SendTriggerOff(); }
        break;

    }
     return nTmpError;
}

#define RecoveryLimitCountForMarkOnNode				2
#define RecoveryLimitCountForMarkOnTagStation		7

/**
@brief   DrivingControl Mark 구동 정보 획득 함수(Node)
@author  임태웅
@date    2013.07.01
*/
int DrivingControl::markOnNode(DRIVING_HW_INFO_SET HwInfo, double dRealDistSumToTarget, double dSpeedLimit, int nTargetID, int nNodeCount, DRIVING_MARK_STATE* pMarkState, CTRL_INFO_OF_SYNC_AXIS_MOVE* pCtrlInfo, CTRL_INFO_OF_ID_READER_CMD_TYPE *pIdReaderCmdType, int* pnID)
{
	int     nTmpID = 0;
    static int nReadedID = 0;
    static int nTmpTargetID =0;
    static bool bIdReaded = false;
	static DWORD dwCheckTime = 0;
	static DWORD dwTriggerTime = 0;
	double MarkInPosition_OnNode = 0.0;
	double FirstMetSpeed_OnNode = 0.0;
	static int nRecoveryLimitCount = 0;
	static bool IsManual = false;

	static DWORD dwRecoveryTime = timeGetTime();

    DWORD   dwCurrTime = timeGetTime();

    int     nTmpError = NO_ERR;

    memset(pCtrlInfo, 0x00, sizeof(CTRL_INFO_OF_SYNC_AXIS_MOVE));
    *pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_NONE;

    DRIVING_MARK_STATE PreMarkState = *pMarkState;

	DRIVING_MARK_PARAM MarkParam = m_pParamSet->Mark[0];

//	if(m_ClassifiedCmd.TargetInfo.PassBoxIn)
//	{
		// Passbox marking시 진입 속도 및 In-Position limit 변경 가능하도록 준비함
		// 우선 동일한 값 사용하도록 설정
	MarkInPosition_OnNode = MarkParam.Dist.dMarkInPosLimit;
	FirstMetSpeed_OnNode = MarkParam.Speed.dOfFirstMet;
//	}
//	else
//	{
//		MarkInPosition_OnNode = MarkParam.Dist.dMarkInPosLimit;
//		FirstMetSpeed_OnNode = MarkParam.Speed.dOfFirstMet;
//	}

    static bool bFirstMetTriggerWithFirstDetect = false;    // First Trigger On 되었을 때 FirstSensor 가 On 인 경우
    static double dRealPositionOfFirstMetTriggerOnWithFirstDetect = 0.0;
    static bool bFirstPassedState = false;  // Target이 dRealDistSumToTarget 근처에 있는 경우로 nTargetID 이 0이 아닐 경우 true로 설정
    bool bFirstMetMoveDist = false;

    double  dStartDistToSecond = 0.0;

    // --------------------------------------------------------------------------------------------------------------------------------------
    //1 0. 정보 획득
	// --------------------------------------------------------------------------------------------------------------------------------------
	nTmpID = HwInfo.Node.nBcrId;


	int     nFirstCount     = HwInfo.Node.nPreCheckCount;
    int     nSecondCount        = HwInfo.Node.nNodeCount;
    bool    bDetectFirst        = HwInfo.IO.NodePreCheckOn;
    bool    bDetectSecond       = HwInfo.IO.NodeOn;
	bool    bFirstPassed        = (nFirstCount>=nNodeCount)?true:false;
	bool    bSecondPassed       = (nSecondCount==nNodeCount)?true:false;

    bool    bRoutineInTrigger   = !(PreMarkState.OnRoutineIn);
	bool    bRoutineInWithFirstPassed = false;
	bool    bFirstMetTrigger    = (PreMarkState.FirstMet==false && bFirstPassed==true)?true:false;
    bool    bSecondMetTrigger   = (PreMarkState.SecondMet==false && bSecondPassed==true)?true:false;

    // 짧은 거리에서 Node 가 감지되는 경우
    if( (dRealDistSumToTarget<MAX(MarkParam.Dist.dLengthOfSecond*3, 110))//100mm 이상
    &&  (bSecondMetTrigger==false) && (bDetectSecond==true) )
    {
        bSecondMetTrigger = true;
    }

	static bool bPreOverRunTrigger = false;
    bool    bOverRunTrigger = false;

    bool    bAxis1InPosition            = HwInfo.IO.Axis1InPosition;
    bool    bAxis1Running               = HwInfo.IO.Axis1Running;
    static  TIME_CHECK  StopWithoutFrontDetect;
    bool    bStopWithoutFrontDetect = false;
#if(UBG_SENSOR_ENABLE == ON)
//	if(bAxis1Running==false && HwInfo.IO.ObsStatus!=DETECT_AND_STOP && HwInfo.IO.DetectStatus!=DETECT_AND_STOP)
	if((HwInfo.IO.Axis1Running==false)
	&& ((HwInfo.IO.DetectStatus!=DETECT_AND_STOP)||(pHWSet->GetAMCVHLDetectStatus() ==0)))
#else
	if(HwInfo.IO.Axis1Running==false
	&& ((HwInfo.IO.DetectStatus!=DETECT_AND_STOP) || (pHWSet->GetAMCVHLDetectStatus() ==0)))
#endif
	{
        if(StopWithoutFrontDetect.bFlag==false)
        {
			StopWithoutFrontDetect.dwTime = dwCurrTime;
            StopWithoutFrontDetect.bFlag = true;
        }
        else if(OHTUTILITY::PreventOverflowGetTimeMs(StopWithoutFrontDetect.dwTime)>200)
        {
            bStopWithoutFrontDetect = true;
        }
    }
    else
    {
        StopWithoutFrontDetect.bFlag = false;
        bStopWithoutFrontDetect = false;
    }


	double  dSpeedOfNow                 = HwInfo.Axis1.dSpeed;              //m_pDrivingAxis->GetCurrentPosition(); //미보정 현재 위치
    double  dRealPositionOfNow          = HwInfo.Axis1.dCurrPos;            //m_pDrivingAxis->GetCurrentPosition(); //미보정 현재 위치
    double  dRealPositionOfFirstDetect  = HwInfo.Node.dPreCheckPosition;    // First Sensor 감지 미보정 엔코더 값
    double  dRealPositionOfSecondDetect = HwInfo.Node.dNodePosition;        // Final Sensor 감지 미보정 엔코더 값
    double  dRealPositionOfSmallAddCheck = HwInfo.Axis1.dSmallAddCheckPos;  // SmallAddCheck 위치
    static  double  dRealPositionOfMostPositive = 0.0;                      // 최대로 멀리갔을 때의 거리
    static  double  dRealPositionOfIdReaded     = 0.0;                      // 최대로 멀리갔을 때의 거리
	static  double dRefSpeedOnSecondMeet = 0.2;

	bool bStartMarking = false;

//	 ADD_LOG("markOnNode: Test %d %d %d %d:%d:%d ",
//	 bFirstMetTrigger,
//	 PreMarkState.FirstMet,
//	 bFirstPassed,
//	 nFirstCount,
//	 nSecondCount,
//	 nNodeCount);
    //2 Manual 상태 에서 초근접하여 마크 하는 경우 (임시) : 초근접인 경우 넘어가서 다음 노드에 마크하고 이전 ID를 올림
    //2 직후 Node 에 마크 하도록 함
    if( (nTargetID==0) && (dRealPositionOfNow<MarkParam.Dist.dAddDistAfterSecondMet)
    &&  (bSecondMetTrigger==false) && (bDetectSecond==true)
    )
    {
        bSecondMetTrigger = true;
    }

    if(PreMarkState.OnRoutineIn==false)
	{
        StopWithoutFrontDetect.bFlag = false;
        StopWithoutFrontDetect.dwTime = dwCurrTime;
		dwCheckTime = dwCurrTime;
		dwTriggerTime = dwCurrTime;
        nReadedID = 0;
		nTmpTargetID = nTargetID;

		if(nTargetID ==0)
			IsManual = true;
		else
			IsManual = false;

        bFirstPassedState = false;
        bIdReaded = false;
        dRealPositionOfMostPositive = dRealPositionOfNow;
        dRealPositionOfIdReaded     = 0.0;
        bFirstMetTriggerWithFirstDetect = false;
        dRealPositionOfFirstMetTriggerOnWithFirstDetect = 0.0;
        dRefSpeedOnSecondMeet = sqrt(2*MarkParam.Accel.dOfFirstMet*MarkParam.Dist.dAddDistAfterSecondMet);  // v = sqrt( 2 * a * S) : 감속 거리의 최대 진입 속도
        dRefSpeedOnSecondMeet = MAX(MarkParam.Speed.dOfSecondMet, dRefSpeedOnSecondMeet);

        bPreOverRunTrigger = false;
		nRecoveryLimitCount = 0;

		ADD_MCC_LOG(",%s,DRV,NODE MARK,Start,FOUP,%06d,%06d,%06d,%d,%6.1lf,Mark Type,%d",
					m_defualtparam->VHLName,
					m_mccparam.uSourceNode,
					m_mccparam.uTargetNode,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					dSpeedOfNow,
					m_InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType);
		m_mccparam.bMarkStartFlag = true;
		m_mccparam.dMarkStartSpeed = dSpeedOfNow;
		m_mccparam.dMarkStartDist = dRealPositionOfNow;
		m_mccparam.nBCRTriggerCount = 0;
    }
    else
    {
		dRealPositionOfMostPositive = (dRealPositionOfNow>dRealPositionOfMostPositive)?dRealPositionOfNow:dRealPositionOfMostPositive;

		if((IsManual == true) && ((nTmpID!=0) || (nTmpTargetID !=0)))
		{
			nFirstCount = 1;
			bFirstPassed = true;
			bFirstMetTrigger    = (PreMarkState.FirstMet==false)?true:false;
		}

		if((IsManual == true) && (bDetectSecond == true))
		{
			nSecondCount = 1;
			bSecondPassed = true;

			bSecondMetTrigger   = (PreMarkState.SecondMet==false)?true:false;
		}
	}

	if(IsManual==true && nTmpID!=0)
    {
        nTmpTargetID = nTmpID;
        ADD_LOG("markOnNode:  nTmpID=%d:%d, Pos:%6.1lf(%6.1lf,%6.1lf,%6.1lf)", nTmpID, nTmpTargetID
            , dRealPositionOfNow, dRealPositionOfFirstDetect, dRealPositionOfSecondDetect, dRealPositionOfSmallAddCheck);
    }

	if(nTmpID!=0 &&nTmpTargetID!=0)
	{
		if(nTmpID==nTmpTargetID)
		{
        	bIdReaded = true;
			dRealPositionOfIdReaded = dRealPositionOfNow;
		}

		if(nReadedID != nTmpID)
		{
			ADD_LOG("markOnNode: nTmpID=%d:%d, Pos=%6.1lf, bIdReaded=%d, ID=%d, Pos:%6.1lf(%6.1lf,%6.1lf,%6.1lf)", nTmpID, bIdReaded, dRealPositionOfIdReaded, nReadedID, nTmpID
				, dRealPositionOfNow, dRealPositionOfFirstDetect, dRealPositionOfSecondDetect, dRealPositionOfSmallAddCheck);
		}
		nReadedID = nTmpID;
	}
	else if(((dRealPositionOfNow - dRealPositionOfIdReaded) > MarkParam.Dist.dDistFromFirstToSecond) && (bIdReaded ==true))
	{
		ADD_LOG("markOnNode_Init: nTmpID = %d, bIdReaded=%d, Pos=%6.1lf, ID=%d, Pos:%6.1lf(%6.1lf,%6.1lf,%6.1lf)",nTmpID, bIdReaded, dRealPositionOfIdReaded, nReadedID
			, dRealPositionOfNow, dRealPositionOfFirstDetect, dRealPositionOfSecondDetect, dRealPositionOfSmallAddCheck);

		bIdReaded = false;
		nReadedID = 0;

		if(IsManual == true)
        	nTmpTargetID = 0;

	}

	if( (bFirstMetTrigger==true)
	&&  (bFirstPassedState==false)
	&&  (nTmpTargetID!=0)
	&&  (((dRealPositionOfFirstDetect + MarkParam.Dist.dAddDistAfetrFirstMet + MarkParam.Dist.dLengthOfSecond) - dRealPositionOfNow) > 100.0)
    &&  (dRealDistSumToTarget>MarkParam.Dist.dAddDistAfetrFirstMet)
	)
	{
		bFirstPassedState = true;
		bFirstMetMoveDist = true;
        dStartDistToSecond  = dRealPositionOfFirstDetect
                                + MarkParam.Dist.dAddDistAfetrFirstMet
                                + MarkParam.Dist.dLengthOfSecond;   // Falling Edge
        ADD_LOG("bFirstMetMoveDist = true, Pos:%6.1lf(%6.1lf,%6.1lf,%6.1lf)"
			, dRealPositionOfNow, dRealPositionOfFirstDetect, dRealPositionOfSecondDetect, dRealPositionOfSmallAddCheck);
    }

	if(bFirstMetTrigger)
    {

		 // 로그 중복 방지 코드 3000ms
		 static DWORD dwPrevTick = 0;
		 if(OHTUTILITY::PreventOverflowGetTimeMs(dwPrevTick) > 3000)       //20191104 KDS
		 {
			ADD_LOG("markOnNode [bFirstMetTrigger] : 1st:%d,2nd:%d,NC:%d", nFirstCount, nSecondCount, nNodeCount);
			dwPrevTick = timeGetTime();
		 }


	}
    if(bSecondMetTrigger)
    {
        ADD_LOG("markOnNode [bSecondMetTrigger] : 1st:%d,2nd:%d,NC:%d", nFirstCount, nSecondCount, nNodeCount);
    }

    //2 First 만나고 일정 거리 경과 및 감속 후, 두번째 Small Add(저속) 지연해서 실시 하기 위해
    if(bFirstMetTrigger==true && bDetectFirst==true && bFirstMetTriggerWithFirstDetect==false)
    {
        bFirstMetTriggerWithFirstDetect = true;
        dRealPositionOfFirstMetTriggerOnWithFirstDetect = dRealPositionOfNow;
        ADD_LOG("markOnNode [bFirstMetTriggerWithFirstDetect] : %d:%6.1lf, Pos:%6.1lf(%6.1lf,%6.1lf,%6.1lf)", bFirstMetTriggerWithFirstDetect, dRealPositionOfFirstMetTriggerOnWithFirstDetect
            , dRealPositionOfNow, dRealPositionOfFirstDetect, dRealPositionOfSecondDetect, dRealPositionOfSmallAddCheck);
    }
    if(bFirstMetTrigger==true && bFirstMetTriggerWithFirstDetect == true)
    {
        if(((dRealPositionOfNow-dRealPositionOfFirstMetTriggerOnWithFirstDetect)<(MarkParam.Dist.dAddDistAfetrFirstMet/2))||
            (dSpeedOfNow>(dRefSpeedOnSecondMeet+2.0)))  //2.0 은 안전율 ( 1.0m/s2 감속 시 0.2초동안 감속되는 속도 )
        {
            bFirstMetTrigger=false;
        }
        else
        {
            ADD_LOG("markOnNode [bFirstMetTriggerWithFirstDetect] Dist[%d]: %6.1lf:%6.1lf < %6.1lf  / Speed[%d]: %6.1lf > %6.1lf +2.0, Pos:%6.1lf(%6.1lf,%6.1lf,%6.1lf)",
                ((dRealPositionOfNow-dRealPositionOfFirstMetTriggerOnWithFirstDetect)<(MarkParam.Dist.dAddDistAfetrFirstMet/2)),
                dRealPositionOfNow, dRealPositionOfFirstMetTriggerOnWithFirstDetect, MarkParam.Dist.dAddDistAfetrFirstMet,
                (dSpeedOfNow>(dRefSpeedOnSecondMeet+2.0)),
                dSpeedOfNow, dRefSpeedOnSecondMeet
                , dRealPositionOfNow, dRealPositionOfFirstDetect, dRealPositionOfSecondDetect, dRealPositionOfSmallAddCheck);
        }
    }

    //2 근접 제어 센서를 Off 시키는 조건
//	if(pMarkState->FollowCtrlOffArea==false)
	if(pHWSet->GetAMCVHLDetectStatus() ==1)
	{
//      if( (bFirstMetTrigger==true)
//      ||  (bSecondMetTrigger==true)
//      ||  (dRealDistSumToTarget-dRealPositionOfNow<100)
//      ||  (pMarkState->FirstMet==true)
//      ||  (pMarkState->SecondMet==true)
//      ||  (pMarkState->IdCheck==true)
//      ||  (pMarkState->Arrived==true)
//      ||  (pMarkState->OverRun==true)
//      ||  (pMarkState->Recovery==true)
//      ||  (pMarkState->OnMoveCmd==true)
//      )

		if( (bSecondMetTrigger==true)
		||  (bIdReaded==true)
		||  (pMarkState->SecondMet==true)
		||  (pMarkState->IdCheck==true)
		||  (pMarkState->Arrived==true)
		||  (pMarkState->OverRun==true)
		||  (pMarkState->Recovery==true)
		)
//		if(pMarkState->Arrived==true)
		{

			m_pDrivingAxis->SetVHLDetectIgnor();
			m_bIsAMCVHLDetectIgnore = true;
//			pMarkState->FollowCtrlOffArea=true;
			ADD_LOG("[OBS1] Ignor : dRealDistSumToTarget(%6.1lf)-dRealPositionOfNow(%6.1lf)", dRealDistSumToTarget, dRealPositionOfNow);
		}
		else if(bFirstPassed==true || dRealDistSumToTarget<MarkParam.Dist.dDistFromFirstToSecond)
		{
			// PreCheck를 만났거나(bFirstPassed==true),
            // Target이 PreCheck와 StopSensor 사이인 경우(dRealDistSumToTarget<MarkParam.Dist.dDistFromFirstToSecond)
			// 도착 100mm 전에 장애물을 off한다.
			// Precheck 센서 만나고나서 일정거리 이후로 조건 변경
			if((dRealPositionOfFirstDetect + MarkParam.Dist.dDistFromFirstToSecond) - dRealPositionOfNow  < 50)
//			if(dRealDistSumToTarget-dRealPositionOfNow<50)
			{

				m_pDrivingAxis->SetVHLDetectIgnor();
				m_bIsAMCVHLDetectIgnore = true;

//				pMarkState->FollowCtrlOffArea=true;
				ADD_LOG("[OBS2] Ignor : dRealPositionOfFirstDetect(%6.1lf)(RDUT%6.1lf)-dRealPositionOfNow(%6.1lf)<50", dRealPositionOfFirstDetect,dRealDistSumToTarget, dRealPositionOfNow);
			}
		}
	}
	else
	{
		*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
		m_mccparam.nBCRTriggerCount ++;
	}

	if(pMarkState->FollowCtrlOffArea==false)
	{
		if(pMarkState->Arrived==true)
		{
			pMarkState->FollowCtrlOffArea=true;
			ADD_LOG("[OBS1] Off : dRealDistSumToTarget(%6.1lf)-dRealPositionOfNow(%6.1lf)", dRealDistSumToTarget, dRealPositionOfNow);
		}
	}


    // --------------------------------------------------------------------------------------------------------------------------------------
    //1 0. 에러 처리
    // --------------------------------------------------------------------------------------------------------------------------------------
    if(dRealPositionOfNow>(dRealDistSumToTarget+MarkParam.Dist.dForwardMoveDistLimit))
    {
        pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
        pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
		nTmpError = ERR_NOTMATCH_TAGLENGTH_FINALNODE_MET_LATE;

//		//오버런 처리
//		m_pExecuteInfo->FlagOverRunInfo.bCheck = true;
//		m_pExecuteInfo->FlagOverRunInfo.OverrunType = 0x01; //주행
//		m_pExecuteInfo->FlagOverRunInfo.nFinalNode = nTmpTargetID;    //주행은 주행, 이적재는 이적재
//		m_pExecuteInfo->FlagOverRunInfo.dDrivingInitPosition = MarkParam.Dist.dForwardMoveDistLimit;

        ADD_LOG("[Error][ERR_NOTMATCH_TAGLENGTH_FINALNODE_NODE_MET_LATE] dRealPositionOfNow(%6.1lf)>(dRealDistSumToTarget(%6.1lf)+MarkParam.Dist.dForwardMoveDistLimit(%6.1lf)), Pos:%6.1lf(%6.1lf,%6.1lf,%6.1lf)"
            , dRealPositionOfNow, dRealDistSumToTarget, MarkParam.Dist.dForwardMoveDistLimit
            , dRealPositionOfNow, dRealPositionOfFirstDetect, dRealPositionOfSecondDetect, dRealPositionOfSmallAddCheck);
		ADD_FDC_LOG("ERR/%d/2/6/%06d/%06d/%d/%d/%06d/%6.1lf",
					ERR_NOTMATCH_TAGLENGTH_FINALNODE_MET_LATE,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pExecuteInfo->ExecutePositionInfo.NextNode,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					m_pOHTMainStatus->StatusCommon.ExistFoup,
					m_pOHTMainStatus->StatusCommon.StopStationID,
					dRealPositionOfNow - (dRealDistSumToTarget+MarkParam.Dist.dForwardMoveDistLimit));
        return nTmpError;
    }
    else if(dRealPositionOfNow<(dRealPositionOfMostPositive-MarkParam.Dist.dBackMoveDistLimit))
	{
        pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
        pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
        nTmpError = ERR_NOTMATCH_TAGLENGTH_FINALNODE_MOVE_BACK_LIMIT;
        ADD_LOG("[Error][ERR_NOTMATCH_TAGLENGTH_FINALNODE_MOVE_BACK_LIMIT] dRealPositionOfNow(%6.1lf)<(dRealPositionOfMostPositive(%6.1lf)-MarkParam.Dist.dBackMoveDistLimit(%6.1lf), Pos:%6.1lf(%6.1lf,%6.1lf,%6.1lf)"
            , dRealPositionOfNow, dRealPositionOfMostPositive, MarkParam.Dist.dBackMoveDistLimit
            , dRealPositionOfNow, dRealPositionOfFirstDetect, dRealPositionOfSecondDetect, dRealPositionOfSmallAddCheck);
		ADD_FDC_LOG("ERR/%d/1/8/%06d/%06d/%d/%d/%06d/%f/%f/%f",
					ERR_NOTMATCH_TAGLENGTH_FINALNODE_MOVE_BACK_LIMIT,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pExecuteInfo->ExecutePositionInfo.NextNode,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					m_pOHTMainStatus->StatusCommon.ExistFoup,
					m_pOHTMainStatus->StatusCommon.StopStationID,
					dRealPositionOfNow,
					dRealPositionOfMostPositive,
					MarkParam.Dist.dBackMoveDistLimit);
        return nTmpError;
    }

    // --------------------------------------------------------------------------------------------------------------------------------------
    //1 1. Status 처리
    // --------------------------------------------------------------------------------------------------------------------------------------
    //2 0) 이상 처리
    if(PreMarkState.OverRun==false)
    {
        if(nSecondCount>nNodeCount)
        {
            // by zzang9un 2013.11.27 : 검증을 위한 로그 생성
            ADD_LOG("[Error][OverRunTrigger] nSecondCount>nNodeCount");
            bPreOverRunTrigger = true;
        }

        if(bFirstPassed==true && bSecondPassed==true && bDetectFirst==false && bDetectSecond==false &&
            nNodeCount>0 && dRealPositionOfNow>dRealPositionOfSecondDetect)
        {
            // by zzang9un 2013.11.27 : 검증을 위한 로그 생성
            ADD_LOG("[Error][OverRunTrigger] bFirstPassed==true && bSecondPassed==true && bDetectFirst==false && bDetectSecond==false");
            bPreOverRunTrigger = true;
        }
    }
    //2 1) First, Second 모두 미감지: 처리 사항 특별히 없음

    //2 2) First 감지 상태로 시작 : FirstMet 하지 않고 RoutineIn하도록 함 --> 다음 주기에 FisrtMet처리함
    if(PreMarkState.OnRoutineIn==false && bDetectFirst==true && bFirstMetTrigger==true)
    {
        bFirstMetTrigger=false;
    }
    //2 3) First와 Second 사이 Node 존재: 이전 Status에는 First/SecondMet이 전부 Off였으나 동시에 ON된 경우 OverRun 처리
    if(bFirstMetTrigger==true && bSecondMetTrigger==true)
    {
        // by zzang9un 2013.11.27 : 검증을 위한 로그 생성
        ADD_LOG("[Error][OverRunTrigger] bFirstMetTrigger==true && bSecondMetTrigger==true");
        bPreOverRunTrigger = true;
    }
    //2 4) Second 감지 상태로 시작 : OverRun 처리
    if(PreMarkState.OnRoutineIn==false && bDetectSecond==true && bSecondMetTrigger==true)
    {
        // by zzang9un 2013.11.27 : 검증을 위한 로그 생성
        ADD_LOG("[Error][OverRunTrigger] PreMarkState.OnRoutineIn==false && bDetectSecond==true && bSecondMetTrigger==true");
		bStartMarking = true;
        bPreOverRunTrigger = true;
    }

    // by zzang9un 2013.11.25 : 3), 4) 결과에 따라 OverRun 처리
    // OverRun을 10mm 여유를 두고 판단하도록 수정(E2303 관련 에러 수정 조치)
    if(bPreOverRunTrigger == true && ((dRealPositionOfNow>dRealPositionOfSecondDetect+20) || bStartMarking))
    {
        ADD_LOG("[Error][OverRunTrigger] (dRealPositionOfNow=%f) > (dRealPositionOfSecondDetect=%f) + 20",
                dRealPositionOfNow,
                dRealPositionOfSecondDetect);
        bOverRunTrigger = true;
    }

    //2 5) RoutineIn 전에 거리 리밋이 First~Second 센서 감지 거리 보다 적을 경우
    if( PreMarkState.OnRoutineIn==false && bDetectFirst==false && bDetectSecond==false
    &&  ((dRealDistSumToTarget-dRealPositionOfNow)<MarkParam.Dist.dDistFromFirstToSecond)
    )
    {
        bFirstMetTrigger = true;
	}

    //2 6) RoutineIn 전에 거리 리밋이 First~Second 센서 감지 거리 보다 적을 경우
    if( PreMarkState.OnRoutineIn==false && bDetectFirst==false && nTargetID!=0
    &&  ((dRealDistSumToTarget-dRealPositionOfNow)<MarkParam.Dist.dDistFromFirstToSecond)
    &&  ((dRealDistSumToTarget-dRealPositionOfNow)>MAX(MarkParam.Dist.dLengthOfSecond*3, 110))
    )
    {
        bFirstMetTrigger = true;
    }
    //2 7) FirstMet 한 경우 Node 만난 위치 값이 사용 가능한 경우
    if( (bFirstMetMoveDist==true)
    &&  (bFirstMetTrigger==true)
    &&  (nFirstCount>0)
    )
	{
        bFirstMetTrigger=false;
    }

    // --------------------------------------------------------------------------------------------------------------------------------------
    //1 2. 명령 처리
    // --------------------------------------------------------------------------------------------------------------------------------------
    //2 0) ID 확인: 마크 루틴 완료 후 id를 확인하는 절차
    if(PreMarkState.IdCheck==true)
    {
        //1 ID 확인 하는 부분 처리

        if(pnID==NULL)
		{
            *pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_NONE;
            pMarkState->Arrived = true;
        }
        else
        {
            if(bIdReaded==true)
            {
				*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_NONE;
                ADD_LOG("markOnNode: pMarkState->Arrived=true, Pos:%6.1lf(%6.1lf,%6.1lf,%6.1lf)"
                    , dRealPositionOfNow, dRealPositionOfFirstDetect, dRealPositionOfSecondDetect, dRealPositionOfSmallAddCheck);
                pMarkState->Arrived = true;
                *pnID = nReadedID;
            }
			else if(OHTUTILITY::PreventOverflowGetTimeMs(dwTriggerTime) > 200)
            {
				if(OHTUTILITY::PreventOverflowGetTimeMs(dwCheckTime) > 2000)
				{
					if(m_pExecuteInfo->nFinishOfNode == nTmpTargetID)
					{
						m_pExecuteInfo->FlagOverRunInfo.OverrunType = 0x01; //주행
						m_pExecuteInfo->ExecutePositionInfo.CurrNode = nTmpTargetID;
						m_pExecuteInfo->FlagOverRunInfo.nFinalNode = nTmpTargetID;    //주행은 주행, 이적재는 이적재
						m_PositionInfo.CurrNode = nTmpTargetID;
						m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode = nTmpTargetID;
					}

					if(OHTUTILITY::PreventOverflowGetTimeMs(dwCheckTime) > 3500)
					{
						*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_NONE;
						pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
						pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;

						if(m_pExecuteInfo->nFinishOfNode == nTmpTargetID)
						{
							m_DiagManager->IncreasePreviosDiagCount(PREVIOS_DIAG_DBT);
							ADD_MD_LOG("DBT Cur Node 2 : %d",m_pExecuteInfo->nFinishOfNode);
							nTmpError = ERR_BCR_READTIMEOUT;
							m_mccparam.bBCRReadFail = true;
							ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d/1",
										ERR_BCR_READTIMEOUT,
										m_pOHTMainStatus->StatusCommon.CurNodeID,
										m_pExecuteInfo->ExecutePositionInfo.NextNode,
										m_pOHTMainStatus->StatusCommon.CurNodeOffset,
										m_pOHTMainStatus->StatusCommon.ExistFoup,
										m_pOHTMainStatus->StatusCommon.StopStationID);
						}
						else
						{
							m_DiagManager->IncreasePreviosDiagCount(PREVIOS_DIAG_DBT);
							m_mccparam.bBCRReadFail = true;
							ADD_MD_LOG("DBT Cur Node 3 : %d",m_pExecuteInfo->nFinishOfNode);
							if(IsManual == true)
							{
								nTmpError = ERR_BCR_READTIMEOUT;
								ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d/1",
										ERR_BCR_READTIMEOUT,
										m_pOHTMainStatus->StatusCommon.CurNodeID,
										m_pExecuteInfo->ExecutePositionInfo.NextNode,
										m_pOHTMainStatus->StatusCommon.CurNodeOffset,
										m_pOHTMainStatus->StatusCommon.ExistFoup,
										m_pOHTMainStatus->StatusCommon.StopStationID);
							}
							else
								pMarkState->Arrived = true;
						}

						*pnID = nTmpTargetID;//ID_NONE;

						//오버런 처리
						m_pExecuteInfo->FlagOverRunInfo.bCheck = true;
						m_pExecuteInfo->FlagOverRunInfo.OverrunType = 0x01; //주행
						m_pExecuteInfo->FlagOverRunInfo.dDrivingInitPosition = OFFSET_TO_CHECK_FIRST_NODE;

						ERR_LOG("markOnNode: ERR_BCR_READTIMEOUT, %d Pos:%6.1lf(%6.1lf,%6.1lf,%6.1lf)"
							,nTmpTargetID, dRealPositionOfNow, dRealPositionOfFirstDetect, dRealPositionOfSecondDetect, dRealPositionOfSmallAddCheck);
                	}
				}
				else
				{
					dwTriggerTime = timeGetTime();
					*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
					m_mccparam.nBCRTriggerCount++;
                }
            }
        }

    }
    //2 1) Recovery 후 멈춤
    else if(PreMarkState.Recovery==true)
    {
        if(bStopWithoutFrontDetect==true)
        {
            // 정위치 센서 미감지
            if(bDetectSecond==false)
            {
                // 정위치 위해 전진
                if(PreMarkState.OnMoveCmd==false)
                {
                    pMarkState->OnMoveCmd=true;

                    pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet;
                    pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;
                    pCtrlInfo->Dynamic.dSpeed   = MarkParam.Speed.dOfSecondMet;
                    pCtrlInfo->Dynamic.dDist    = dRealPositionOfNow + MarkParam.Dist.dForwardMoveDistLimit;
                    memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
//                  pCtrlInfo->Dynamic.AdditionalInfo.bStartOnSpeedDown         = true;
                    pCtrlInfo->Dynamic.AdditionalInfo.bUseSmallAdd              = true;
#if((OHT_NAME == OHT_NAME_STD_V80)||(OHT_NAME == OHT_NAME_STD_V81)|| (OHT_NAME == OHT_NAME_STD_V80_RETICLE))
					pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 51;
#elif((OHT_NAME == OHT_NAME_STD_V85) || (OHT_NAME == OHT_NAME_STD_V81S))
                    pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 54;
#else
                    pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 52;
#endif
                    pCtrlInfo->Dynamic.AdditionalInfo.bIsTriggerOnRisingEdge    = false;// Second Sensor 통과해서 정지  //  B접점
                    pCtrlInfo->Dynamic.AdditionalInfo.dSmallDistance            = MarkParam.Dist.dAddDistAfterSecondMet;
                    pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;

                    ADD_LOG("markOnNode: Recovery - OnMoveCmd = true, Pos:%6.1lf(%6.1lf,%6.1lf,%6.1lf)"
                        , dRealPositionOfNow, dRealPositionOfFirstDetect, dRealPositionOfSecondDetect, dRealPositionOfSmallAddCheck);

                }
            }
            // 정위치 센서 감지
            else
            {
//              pMarkState->OnMoveCmd=false;
                // 정위치 확인
                if( (fabs(dRealPositionOfNow-dRealPositionOfSmallAddCheck)<(MarkParam.Dist.dAddDistAfterSecondMet+MarkInPosition_OnNode)) &&
					(fabs(dRealPositionOfNow-dRealPositionOfSmallAddCheck)>(MarkParam.Dist.dAddDistAfterSecondMet-MarkInPosition_OnNode)) &&
                    (dRealPositionOfSmallAddCheck!=0.0) && ( bAxis1InPosition==true))
                {
                    if(pnID==NULL)
                    {
                        pMarkState->Arrived=true;
                        ADD_LOG("markOnNode: Recovery - Arrived = true, Pos:%6.1lf(%6.1lf,%6.1lf,%6.1lf)"
                            , dRealPositionOfNow, dRealPositionOfFirstDetect, dRealPositionOfSecondDetect, dRealPositionOfSmallAddCheck);
                    }
                    else
                    {
                        pMarkState->IdCheck=true;
                        *pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
						m_mccparam.nBCRTriggerCount++;
						dwCheckTime = dwCurrTime;   // ID 확인 되지 않을 때에 대한 TimeOut 처리 목적
						dwTriggerTime = dwCurrTime;
                        ADD_LOG("markOnNode: Recovery - IdCheck = true, Pos:%6.1lf(%6.1lf,%6.1lf,%6.1lf)"
                            , dRealPositionOfNow, dRealPositionOfFirstDetect, dRealPositionOfSecondDetect, dRealPositionOfSmallAddCheck);
                    }
                }
                // 정위치 아닐 경우 OverRun 처리 재 시도
                else
				{
					if(OHTUTILITY::PreventOverflowGetTimeMs(dwCheckTime) > 1500) // 정지 후 정위치 되지 않을 때에 대한 TimeOut 처리 목적
					{
						if(nRecoveryLimitCount < RecoveryLimitCountForMarkOnNode)
						{
							nRecoveryLimitCount++;
							pMarkState->Recovery = false;

							ADD_LOG("markOnNode: Recovery - Recovery = false, Recovery Cnt : %d ,Pos:%6.1lf(%6.1lf,%6.1lf,%6.1lf)",
								nRecoveryLimitCount,
								dRealPositionOfNow,
								dRealPositionOfFirstDetect,
								dRealPositionOfSecondDetect,
								dRealPositionOfSmallAddCheck);
						}
						else
						{
							nRecoveryLimitCount = 0;

							pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
							pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
							nTmpError = ERR_NOTMATCH_TAGLENGTH_FINALNODE_IN_POSITION_ERROR;

							ADD_LOG("[Error][ERR_NOTMATCH_TAGLENGTH_FINALNODE_IN_POSITION_ERROR] dRealPositionOfNow(%6.1lf), dRealPositionOfSmallAddCheck(%6.1lf), dAddDistAfterSecondMet(%6.1lf), MarkInPosition_OnNode(%6.1lf), dRealPositionOfSmallAddCheck(%6.1lf), bAxis1InPosition(%d)",
								dRealPositionOfNow,
								dRealPositionOfSmallAddCheck,
								MarkParam.Dist.dAddDistAfterSecondMet,
								MarkInPosition_OnNode,
								dRealPositionOfSmallAddCheck,
								bAxis1InPosition);
							ADD_FDC_LOG("ERR/%d/1/10/%06d/%06d/%d/%d/%06d/%6.1lf/%6.1lf/%6.1lf/%6.1lf/%d",
										ERR_NOTMATCH_TAGLENGTH_FINALNODE_IN_POSITION_ERROR,
										m_pOHTMainStatus->StatusCommon.CurNodeID,
										m_pExecuteInfo->ExecutePositionInfo.NextNode,
										m_pOHTMainStatus->StatusCommon.CurNodeOffset,
										m_pOHTMainStatus->StatusCommon.ExistFoup,
										m_pOHTMainStatus->StatusCommon.StopStationID,
										dRealPositionOfNow,
										dRealPositionOfSmallAddCheck,
										MarkParam.Dist.dAddDistAfterSecondMet,
										MarkInPosition_OnNode,
										bAxis1InPosition);

							return nTmpError;
						}
					}

					ADD_LOG("markOnNode: Recovery Not InPos: ( %6.1lf - %6.1lf ) < %6.1lf + %6.1lf ,  (%6.1lf , %d), Pos:%6.1lf(%6.1lf,%6.1lf,%6.1lf)" ,
                        dRealPositionOfNow, dRealPositionOfSmallAddCheck, MarkParam.Dist.dAddDistAfterSecondMet, MarkInPosition_OnNode,
                        dRealPositionOfSmallAddCheck, bAxis1InPosition
                        , dRealPositionOfNow, dRealPositionOfFirstDetect, dRealPositionOfSecondDetect, dRealPositionOfSmallAddCheck);
                }
            }
        }
        else if(bAxis1Running==true)
        {
            dwCheckTime = dwCurrTime;   // 정지 후 정위치 되지 않을 때에 대한 TimeOut 처리 목적
            if(pMarkState->OnMoveCmd==true)
            {
                pMarkState->OnMoveCmd=false;
                ADD_LOG("markOnNode: Recovery - OnMoveCmd = false, Pos:%6.1lf(%6.1lf,%6.1lf,%6.1lf)"
                    , dRealPositionOfNow, dRealPositionOfFirstDetect, dRealPositionOfSecondDetect, dRealPositionOfSmallAddCheck);
            }
        }
    }
    //2 2) OverRun 후 멈춤
    else if(PreMarkState.OverRun==true)
    {
        if(bStopWithoutFrontDetect==true)
        {
            if(PreMarkState.OnMoveCmd==false) // OverRun 인 경우 뒤로 이동이 필수이다.(움직이면 OnMoveCmd이 false가 된다)
            {
                //반사판 사이즈보다 작을 경우, 해당 위치로 MoveDS 이동처리
				if(fabs(dRealPositionOfNow-dRealPositionOfSecondDetect) < (MarkParam.Dist.dAddDistAfterSecondMet) && (dRealPositionOfSecondDetect !=0.0))
				{
					pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet;
					pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;
					pCtrlInfo->Dynamic.dSpeed   = MarkParam.Speed.dOfSecondMet;
					pCtrlInfo->Dynamic.dDist    = dRealPositionOfSecondDetect + MarkParam.Dist.dAddDistAfterSecondMet;
					memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));

					pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;

				}
				else
				{

					pMarkState->OnMoveCmd=true;

					pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet;
					pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;
					pCtrlInfo->Dynamic.dSpeed   = MarkParam.Speed.dOfSecondMet;
					pCtrlInfo->Dynamic.dDist    = dRealPositionOfNow - 250;//MarkParam.Dist.dBackMoveDistLimit;
					memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
	//              pCtrlInfo->Dynamic.AdditionalInfo.bStartOnSpeedDown         = true;
					pCtrlInfo->Dynamic.AdditionalInfo.bUseSmallAdd              = true;
#if((OHT_NAME == OHT_NAME_STD_V80) ||(OHT_NAME == OHT_NAME_STD_V81)|| (OHT_NAME == OHT_NAME_STD_V80_RETICLE))
					pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 51;
#elif((OHT_NAME == OHT_NAME_STD_V85) || (OHT_NAME == OHT_NAME_STD_V81S))
                    pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 54;
#else
					pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 52;
#endif
					pCtrlInfo->Dynamic.AdditionalInfo.bIsTriggerOnRisingEdge    = true;// Second Sensor 통과해서 정지  //  B접점
					pCtrlInfo->Dynamic.AdditionalInfo.dSmallDistance            = MarkParam.Dist.dAddDistAfterSecondMet;

					pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;
				}

				ADD_LOG("markOnNode: OverRun - OnMoveCmd = true, Pos:%6.1lf(%6.1lf,%6.1lf,%6.1lf)"
					, dRealPositionOfNow, dRealPositionOfFirstDetect, dRealPositionOfSecondDetect, dRealPositionOfSmallAddCheck);
			}
//          else    // OverRun 인 경우 뒤로 이동이 필수이다.
//          {
//              pMarkState->OnMoveCmd=false;
//              pMarkState->Recovery=true;
//              ADD_LOG("markOnNode: OverRun - Recovery = true");
//          }

		}
		else if(bAxis1Running==true)
		{
			if(pMarkState->OnMoveCmd==true)
            {
                pMarkState->OnMoveCmd=false;
                pMarkState->Recovery=true;
                dwCheckTime = dwCurrTime;   // 정지 후 정위치 되지 않을 때에 대한 TimeOut 처리 목적
                ADD_LOG("markOnNode: OverRun - OnMoveCmd = false, Pos:%6.1lf(%6.1lf,%6.1lf,%6.1lf)"
                    , dRealPositionOfNow, dRealPositionOfFirstDetect, dRealPositionOfSecondDetect, dRealPositionOfSmallAddCheck);
            }
        }
    }
    //2 3) OverRun 진입 시
    else if(PreMarkState.OverRun==false && bOverRunTrigger==true)
    {
        pMarkState->OverRun=true;

        if(bStopWithoutFrontDetect==false)
        {
            pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
            pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
            ADD_LOG("markOnNode: OverRun - AXIS_CTRL_CMD_MOVE_S, Pos:%6.1lf(%6.1lf,%6.1lf,%6.1lf)"
                , dRealPositionOfNow, dRealPositionOfFirstDetect, dRealPositionOfSecondDetect, dRealPositionOfSmallAddCheck);
        }
    }
    //2 4) SecondMet 후 멈춤
    else if(PreMarkState.SecondMet==true)
    {
        if(bStopWithoutFrontDetect==true)
        {

			if( (fabs(dRealPositionOfNow-dRealPositionOfSecondDetect)<(MarkParam.Dist.dAddDistAfterSecondMet+MarkInPosition_OnNode)) &&
				(fabs(dRealPositionOfNow-dRealPositionOfSecondDetect)>(MarkParam.Dist.dAddDistAfterSecondMet-MarkInPosition_OnNode)) &&
                (dRealPositionOfSmallAddCheck!=0.0) && ( bAxis1InPosition==true))
            {
                if(pnID==NULL)
                {
                    pMarkState->Arrived=true;
                    ADD_LOG("markOnNode: SecondMet - Arrived=true, Pos:%6.1lf(%6.1lf,%6.1lf,%6.1lf,T:%6.1lf)"
                        , dRealPositionOfNow, dRealPositionOfFirstDetect, dRealPositionOfSecondDetect, dRealPositionOfSmallAddCheck,dRealDistSumToTarget);
                }
                else
                {
                    pMarkState->IdCheck=true;
                    *pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
					m_mccparam.nBCRTriggerCount++;
					dwCheckTime = dwCurrTime;   // ID 확인 되지 않을 때에 대한 TimeOut 처리 목적
					dwTriggerTime = dwCurrTime;
                    ADD_LOG("markOnNode: SecondMet - IdCheck=true, Pos:%6.1lf(%6.1lf,%6.1lf,%6.1lf)"
                        , dRealPositionOfNow, dRealPositionOfFirstDetect, dRealPositionOfSecondDetect, dRealPositionOfSmallAddCheck);
                }
            }
            else
            {
                if(OHTUTILITY::PreventOverflowGetTimeMs(dwCheckTime) > 500) // 정지 후 정위치 되지 않을 때에 대한 TimeOut 처리 목적
                {
                    pMarkState->OverRun=true;
                    ADD_LOG("markOnNode: SecondMet - OverRun = true, Pos:%6.1lf(%6.1lf,%6.1lf,%6.1lf)"
                        , dRealPositionOfNow, dRealPositionOfFirstDetect, dRealPositionOfSecondDetect, dRealPositionOfSmallAddCheck);
                }

                ADD_LOG("markOnNode: SecondMet Not InPos: fabs( %6.1lf - %6.1lf = %6.1lf )≒%6.1lf±%6.1lf ,  (%6.1lf , %d), Pos:%6.1lf(%6.1lf,%6.1lf,%6.1lf)"
                    , dRealPositionOfNow
                    , dRealPositionOfSmallAddCheck
                    , (dRealPositionOfNow-dRealPositionOfSmallAddCheck)
                    , MarkParam.Dist.dAddDistAfterSecondMet
                    , MarkInPosition_OnNode
                    , dRealPositionOfSmallAddCheck
                    , bAxis1InPosition
                    , dRealPositionOfNow
                    , dRealPositionOfFirstDetect
                    , dRealPositionOfSecondDetect
                    , dRealPositionOfSmallAddCheck);

            }
        }
        else
        {
            dwCheckTime = dwCurrTime;   // 정지 후 정위치 되지 않을 때에 대한 TimeOut 처리 목적
        }
    }
    //2 5) SecondMet 진입 시
    else if(PreMarkState.SecondMet==false && bSecondMetTrigger==true)
    {
        pMarkState->SecondMet=true;
        dwCheckTime = dwCurrTime;   // 정지 후 정위치 되지 않을 때에 대한 TimeOut 처리 목적
    }
    //2 6) FirstMet 후 멈춤
    else if(PreMarkState.FirstMet==true)
    {
        if(bStopWithoutFrontDetect==true)
        {
            if(dRealPositionOfNow<(dRealDistSumToTarget+MarkParam.Dist.dForwardMoveDistLimit))
            {
                pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet;
                pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;
                pCtrlInfo->Dynamic.dSpeed   = MarkParam.Speed.dOfSecondMet;
                pCtrlInfo->Dynamic.dDist    = dRealDistSumToTarget+MarkParam.Dist.dForwardMoveDistLimit;
                memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
    //          pCtrlInfo->Dynamic.AdditionalInfo.bStartOnSpeedDown         = true;
                pCtrlInfo->Dynamic.AdditionalInfo.bUseSmallAdd              = true;
#if((OHT_NAME == OHT_NAME_STD_V80)||(OHT_NAME == OHT_NAME_STD_V81)|| (OHT_NAME == OHT_NAME_STD_V80_RETICLE))
				pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 51;
#elif((OHT_NAME == OHT_NAME_STD_V85) || (OHT_NAME == OHT_NAME_STD_V81S))
				pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 54;
#else
				pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 52;
#endif
                pCtrlInfo->Dynamic.AdditionalInfo.bIsTriggerOnRisingEdge    = false;// B접점
                pCtrlInfo->Dynamic.AdditionalInfo.dSmallDistance            = MarkParam.Dist.dAddDistAfterSecondMet;
                pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;
                ADD_LOG("markOnNode: FirstMet==true - AXIS_CTRL_CMD_MOVE_DS, Pos:%6.1lf(%6.1lf,%6.1lf,%6.1lf)"
                    , dRealPositionOfNow, dRealPositionOfFirstDetect, dRealPositionOfSecondDetect, dRealPositionOfSmallAddCheck);
            }
            else
            {
                nTmpError = 10000;// 에러 처리
                ERR_LOG("markOnNode: OverRun Err, Pos:%6.1lf(%6.1lf,%6.1lf,%6.1lf)"
                    , dRealPositionOfNow, dRealPositionOfFirstDetect, dRealPositionOfSecondDetect, dRealPositionOfSmallAddCheck);
            }
        }
    }
    //2 7) FirstMet 진입 시
    else if(PreMarkState.FirstMet==false && bFirstMetTrigger==true)
    {
        pMarkState->FirstMet=true;

        pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet;
        pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;
        pCtrlInfo->Dynamic.dSpeed   = MarkParam.Speed.dOfSecondMet;
        pCtrlInfo->Dynamic.dDist    = dRealDistSumToTarget+MarkParam.Dist.dForwardMoveDistLimit;
        memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
//      pCtrlInfo->Dynamic.AdditionalInfo.bStartOnSpeedDown         = true;
        pCtrlInfo->Dynamic.AdditionalInfo.bUseSmallAdd              = true;
#if((OHT_NAME == OHT_NAME_STD_V80)||(OHT_NAME == OHT_NAME_STD_V81)|| (OHT_NAME == OHT_NAME_STD_V80_RETICLE))
		pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 51;
#elif((OHT_NAME == OHT_NAME_STD_V85) || (OHT_NAME == OHT_NAME_STD_V81S))
		pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 54;
#else
        pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 52;
#endif
        pCtrlInfo->Dynamic.AdditionalInfo.bIsTriggerOnRisingEdge    = false;// B접점
        pCtrlInfo->Dynamic.AdditionalInfo.dSmallDistance            = MarkParam.Dist.dAddDistAfterSecondMet;
        pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;
        ADD_LOG("markOnNode: FirstMet==false - AXIS_CTRL_CMD_MOVE_DS, Pos:%6.1lf(%6.1lf,%6.1lf,%6.1lf)"
            , dRealPositionOfNow, dRealPositionOfFirstDetect, dRealPositionOfSecondDetect, dRealPositionOfSmallAddCheck);
    }
    //2 8) PreCheck 만난 직후 처리
    else if(bFirstMetMoveDist==true)
    {
        pMarkState->OnRoutineIn=true;

        pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfFirstMet;	//dOfSecondMet;
        pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfFirstMet;	//dOfSecondMet;
        pCtrlInfo->Dynamic.dSpeed   = FirstMetSpeed_OnNode;			//dOfSecondMet;
        pCtrlInfo->Dynamic.dDist    = dStartDistToSecond;
        memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
        pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;

        ADD_LOG("markOnNode: bFirstMetMoveDist==true - AXIS_CTRL_CMD_MOVE_DS, Target:%6.1lf Pos:%6.1lf(%6.1lf,%6.1lf,%6.1lf)"
            ,dStartDistToSecond , dRealPositionOfNow, dRealPositionOfFirstDetect, dRealPositionOfSecondDetect, dRealPositionOfSmallAddCheck);
    }
    //2 9) RoutineIn 진입 처리
    else if(PreMarkState.OnRoutineIn==false && bRoutineInTrigger==true)
    {
        pMarkState->OnRoutineIn=true;

        pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfFirstMet;	//dOfSecondMet;
        pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfFirstMet;	//dOfSecondMet;
        pCtrlInfo->Dynamic.dSpeed   = FirstMetSpeed_OnNode;			//dOfSecondMet;
        pCtrlInfo->Dynamic.dDist    = dRealDistSumToTarget+MarkParam.Dist.dForwardMoveDistLimit;
        memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
//      pCtrlInfo->Dynamic.AdditionalInfo.bStartOnSpeedDown         = true;
		pCtrlInfo->Dynamic.AdditionalInfo.bUseSmallAdd              = true;
#if((OHT_NAME == OHT_NAME_STD_V80)||(OHT_NAME == OHT_NAME_STD_V81)|| (OHT_NAME == OHT_NAME_STD_V80_RETICLE))
		pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 52;//52
#elif((OHT_NAME == OHT_NAME_STD_V85) || (OHT_NAME == OHT_NAME_STD_V81S))
		pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 55;
#else
        pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 50;//52
#endif
        pCtrlInfo->Dynamic.AdditionalInfo.bIsTriggerOnRisingEdge    = true;//1      true로 하면 안됨// B접점
        pCtrlInfo->Dynamic.AdditionalInfo.dSmallDistance            = MarkParam.Dist.dAddDistAfetrFirstMet;//dAddDistAfterSecondMet;
        pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;

		ADD_LOG("markOnNode: OnRoutineIn==false - AXIS_CTRL_CMD_MOVE_DS, [%d] Pos:%6.1lf(%6.1lf,%6.1lf,%6.1lf)"
            , bFirstPassedState
            , dRealPositionOfNow, dRealPositionOfFirstDetect, dRealPositionOfSecondDetect, dRealPositionOfSmallAddCheck);
    }

    //2 10) Flag 정리
    if(bRoutineInTrigger==true)pMarkState->OnRoutineIn=true;
    if(bFirstMetTrigger==true)pMarkState->FirstMet=true;
    if(bSecondMetTrigger==true)pMarkState->SecondMet=true;
    if(bOverRunTrigger==true)pMarkState->OverRun=true;

	//2 11) 최저속도 처리
    pCtrlInfo->Dynamic.dSpeed = MIN(pCtrlInfo->Dynamic.dSpeed, dSpeedLimit);

	if((pMarkState->Arrived == true) && (m_mccparam.bMarkStartFlag == true))
	{
		ADD_MCC_LOG(",%s,DRV,NODE MARK,End,FOUP,%06d,%06d,%06d,%d,%6.1lf,Mark Type,%d,Node Mark Dist,%6.1lf,Node Sensor Dist,%6.1lf,Node Mark Start Speed,%6.1lf,Driving BCR Read Fail,%d,Driving BCR Trigger Count,%d",
					m_defualtparam->VHLName,
					m_mccparam.uSourceNode,
					m_mccparam.uTargetNode,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					dSpeedOfNow,
					m_InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType,
					dRealPositionOfFirstDetect - m_mccparam.dMarkStartDist,
					dRealPositionOfSecondDetect - dRealPositionOfFirstDetect,
					m_mccparam.dMarkStartSpeed,
					m_mccparam.bBCRReadFail,
					m_mccparam.nBCRTriggerCount);
		m_mccparam.bMarkStartFlag = false;
		m_mccparam.dMarkStartSpeed = 0.0;
		m_mccparam.dMarkStartDist = 0.0;
		m_mccparam.bBCRReadFail = false;
		m_mccparam.nBCRTriggerCount = 0;
	}

    return nTmpError;

}

/**
@brief   DrivingControl Mark 구동 정보 획득 함수(TagStation)
@author  임태웅
@date    2013.07.01
*/
int DrivingControl::markOnTagStation(DRIVING_HW_INFO_SET HwInfo, double dRealDistSumToTarget, double dSpeedLimit, int nTargetID, DRIVING_MARK_STATE* pMarkState, CTRL_INFO_OF_SYNC_AXIS_MOVE* pCtrlInfo, CTRL_INFO_OF_ID_READER_CMD_TYPE *pIdReaderCmdType, int* pnID,bool bOverrunIngn)
{
	int     nTmpID = 0;
    static int nReadedID = 0;
    static int nTmpTargetID =0;
	static bool bIdReaded = false;
	static bool bIsOHTDetectIngnore = false;
	static DWORD dwCheckTime = 0;
	static DWORD dwTriggerTime = 0;
	static DWORD dwWaitHwBCRTrgTime = 0; //BCR READ TRIGGER CHECK TIME
	static bool IsManual = false;

	static DWORD dwSecendCheckTime = 0;

	DWORD   dwCurrTime = timeGetTime();


    int     nTmpError = NO_ERR;

    memset(pCtrlInfo, 0x00, sizeof(CTRL_INFO_OF_SYNC_AXIS_MOVE));
    *pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_NONE;

	DRIVING_MARK_STATE PreMarkState = *pMarkState;
    DRIVING_MARK_PARAM MarkParam = m_pParamSet->Mark[1];

    static bool bNoSensorDetected = false;  // Mark Routine 시작 할 때 Front/Rear가 모두 Off 되었을 때 True
    static bool bPauseSecondSmallMove = false;  // bNoSensorDetected 사 true 인 경우 Second Small Move를 정위치 근처까지 지연 시키는 Flag
    static double dRealPositionOfFirstMetWithNoDetectStart = 0.0;   // Front 감지 되지 않은 상태에서 Mark 시작하여 처음 감지된 때, Front 감지된 위치
    static double dRealPositionOfSecondMet = 0.0;   // Front 감지 되지 않은 상태에서 Mark 시작하여 처음 감지된 때, Front 감지된 위치
    static bool bCheckTargetIsNearTargetDist = false;   // Target이 dRealDistSumToTarget 근처에 있는 경우로 nTargetID 이 0이 아닐 경우 true로 설정
    static bool bIgnoreFrontRearDetect = false; // Target이 dRealDistSumToTarget 근처에 있는 경우 Target 근처 이외에에서의 Front 센서 감지 무시

    // --------------------------------------------------------------------------------------------------------------------------------------
    //1 0. 정보 획득
    // --------------------------------------------------------------------------------------------------------------------------------------
	nTmpID = HwInfo.TagStaion.nBcrId;


    bool    bDetectFirst                = HwInfo.IO.TagStationFrontOn;
    bool    bDetectSecond               = HwInfo.IO.TagStationRearOn;

	bool    bAxis1InPosition            = HwInfo.IO.Axis1InPosition;
	bool	bAxis1Running				= HwInfo.IO.Axis1Running;

	static  TIME_CHECK  StopWithoutFrontDetect;

	static	int			nRecoveryLimitCount4TagStation = 0;
	static	int			nRecoveryCountTagStation2 = 0;    //puting 1069에 의한 리트라이 추가.
   static	int			nRecoveryCountTagStationOverrun = 0;    //puting 1069에 의한 리트라이 추가.

	bool    bStopWithoutFrontDetect = false;

	double dForwardLimit = 0.0;

	if(bOverrunIngn ==false)
		dForwardLimit = MarkParam.Dist.dForwardMoveDistLimit;
	else
		dForwardLimit = 100.0;


#if(UBG_SENSOR_ENABLE == ON)
//	if(bAxis1Running==false && HwInfo.IO.ObsStatus!=DETECT_AND_STOP && HwInfo.IO.DetectStatus!=DETECT_AND_STOP)
	if(bAxis1Running==false
	&& ((HwInfo.IO.DetectStatus!=DETECT_AND_STOP && HwInfo.IO.ObsStatus!=DETECT_AND_STOP)
	   ||(pHWSet->GetAMCVHLDetectStatus() ==0)))
#else
	if(HwInfo.IO.Axis1Running===false
	&& ((HwInfo.IO.DetectStatus!=DETECT_AND_STOP) || (pHWSet->GetAMCVHLDetectStatus() ==0)))
#endif
	{
        if(StopWithoutFrontDetect.bFlag==false)
        {
            StopWithoutFrontDetect.dwTime = dwCurrTime;
            StopWithoutFrontDetect.bFlag = true;
        }
        else if(OHTUTILITY::PreventOverflowGetTimeMs(StopWithoutFrontDetect.dwTime)>200)
        {
			bStopWithoutFrontDetect = true;   //일반 정지일때
		}
	}
	else
	{
		StopWithoutFrontDetect.bFlag = false;
		bStopWithoutFrontDetect = false;     //대차감지 멈춤
	}


    double  dRealDistSumToLimit             = (dRealDistSumToTarget+MarkParam.Dist.dForwardMoveDistLimit);  ///< 전지 거리
	double  dSpeedOfNow                     = HwInfo.Axis1.dSpeed;              //m_pDrivingAxis->GetCurrentPosition(); //미보정 현재 위치
    double  dRealPositionOfNow              = HwInfo.Axis1.dCurrPos;            //m_pDrivingAxis->GetCurrentPosition(); //미보정 현재 위치
    double  dRealPositionOfFirstDetect      = HwInfo.TagStaion.dFrontPosition;  // First Sensor 감지 미보정 엔코더 값
    double  dRealPositionOfSecondDetect     = HwInfo.TagStaion.dRearPosition;   // Final Sensor 감지 미보정 엔코더 값
    double  dRealPositionOfSmallAddCheck    = HwInfo.Axis1.dSmallAddCheckPos;   // SmallAddCheck 위치
    static  double  dRealPositionOfMostPositive = 0.0;                      // 최대로 멀리갔을 때의 거리
	static  double  dRealPositionOfIdReaded     = 0.0;                      // 최대로 멀리갔을 때의 거리
	static  double  dRealPositionOfIdReadedCheckingPoint     = 0.0;                      // 최대로 멀리갔을 때의 거리
	static  double dRefSpeedOnSecondMeet = 0.2;
	//// 300mm 대응 무시 구간 추가 코드 puting
	static  bool  bCheckInit = false;
	static  bool  bCheckInitStop = false;

	///E2312 관련 플래그 추가 2018 01 28
	static  bool  bCheckFrontBackStep = false;
	static double dRealCheckFrontBackPoint = 0.0;
	static int nCountFrontDetect = 0;

	static double  dCheckRealPositionOfFirstDetect      = 0.0;
	static int nCheckCountFirstDetect = 0;
	static bool bCheckFirstDetectInterlock = false;
	static double dRealPositionOfFirstDetectCheck = 0.0;
	static double dFirstDetectPercent = 1.0;

	if(PreMarkState.OnRoutineIn==false)
    {
		StopWithoutFrontDetect.bFlag = false;
		StopWithoutFrontDetect.dwTime = dwCurrTime;
		dwCheckTime = dwCurrTime;
		dwTriggerTime = dwCurrTime;
		dwSecendCheckTime = dwCurrTime;
		nReadedID = 0;
		bIdReaded = false;
		b_ReadBcr = false;
		b_WaitTrg = false;

		if(nTargetID ==0)
			IsManual = true;
		else
			IsManual = false;

		nTmpTargetID = nTargetID;
		//// 300mm 대응 무시 구간 추가 코드 puting
		bIsOHTDetectIngnore = false;
		bCheckInit = false;
		bCheckInitStop = false;
		bCheckFrontBackStep = false;
		dRealCheckFrontBackPoint = 0.0;
		nCountFrontDetect = 0;
		bCheckTargetIsNearTargetDist = (nTargetID==0)?false:true;
		bIgnoreFrontRearDetect = (bCheckTargetIsNearTargetDist==true)?true:false;
		dRealPositionOfMostPositive = dRealPositionOfNow;
		dRealPositionOfIdReaded     = dRealPositionOfNow;//0.0;
		bCheckFirstDetectInterlock = false;

		dCheckRealPositionOfFirstDetect = 0.0;
		nCheckCountFirstDetect = 0;
		dRealPositionOfFirstDetectCheck = dRealPositionOfNow;
		dFirstDetectPercent = 1.0;

		if((dRealDistSumToTarget < 400) && (dRealDistSumToTarget > 200))    //이적재 -> 이적재 이슈내용 적용
		   dRealPositionOfIdReaded = dRealPositionOfNow+80;

		dRealPositionOfIdReadedCheckingPoint = dRealPositionOfNow;//0.0;
		bNoSensorDetected = (bDetectFirst==false&&bDetectSecond==false)?true:false;
		bPauseSecondSmallMove = (bNoSensorDetected==true)?true:false;
		dRealPositionOfFirstMetWithNoDetectStart = 0.0;
        dRealPositionOfSecondMet = 0.0;
        dRefSpeedOnSecondMeet = sqrt(2*MarkParam.Accel.dOfFirstMet*MarkParam.Dist.dAddDistAfterSecondMet);  // v = sqrt( 2 * a * S) : 감속 거리의 최대 진입 속도
		dRefSpeedOnSecondMeet = MAX(MarkParam.Speed.dOfSecondMet, dRefSpeedOnSecondMeet);
		nRecoveryLimitCount4TagStation = 0;
		nRecoveryCountTagStation2 = 0;
		nRecoveryCountTagStationOverrun = 0;
		ADD_LOG("markOnTagStation Init: Sensor[%d:%d-->%d] Target:%6d"
			, bDetectFirst, bDetectSecond, bNoSensorDetected, nTmpTargetID);

		ADD_MCC_LOG(",%s,DRV,STATION MARK,Start,FOUP,%06d,%06d,%06d,%d,%6.1lf,Mark Type,%d",
					m_defualtparam->VHLName,
					m_mccparam.uSourceNode,
					m_mccparam.uTargetNode,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					dSpeedOfNow,
					m_InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType);
		m_mccparam.bMarkStartFlag = true;
		m_mccparam.dMarkStartSpeed = dSpeedOfNow;
		m_mccparam.dMarkStartDist = dRealPositionOfNow;
		m_mccparam.nBCRTriggerCount = 0;
    }
    else
	{
		if((dCheckRealPositionOfFirstDetect != HwInfo.TagStaion.dFrontPosition) &&
			(bCheckFirstDetectInterlock ==false)   &&
			(bDetectFirst == true) &&
			(dRealPositionOfFirstDetectCheck <  HwInfo.TagStaion.dFrontPosition))
		{
			nCheckCountFirstDetect++;

			if(dSpeedOfNow > 0.5)//속도가 0.5m/s 이하일 경우에만 사용
				dFirstDetectPercent = 0.625;

			//Rear 반사판 크기 보다 클때 사용함.
			if((nCheckCountFirstDetect >3)  && (dRealPositionOfNow - HwInfo.TagStaion.dFrontPosition > 5.0))
			{
				bCheckFirstDetectInterlock = true;
				dCheckRealPositionOfFirstDetect  =  HwInfo.TagStaion.dFrontPosition;
				ADD_LOG("markOnTagStation bCheckFirstDetectInterlock [%f:%f:%f]",dCheckRealPositionOfFirstDetect, dSpeedOfNow,dFirstDetectPercent);

			}
		}
		else
		{
			nCheckCountFirstDetect = 0;
		}

        dRealPositionOfMostPositive = (dRealPositionOfNow>dRealPositionOfMostPositive)?dRealPositionOfNow:dRealPositionOfMostPositive;
    }

	// Read ID
	if(IsManual==true && nTmpID!=0)
    {
        nTmpTargetID = nTmpID;
		ADD_LOG("markOnTagStation:  nTmpID=%d:%d", nTmpID, nTmpTargetID);
    }

	if((nTmpID!=0)&& (nTmpTargetID!=0))
    {
		bIdReaded = true;

		//// 300mm 대응 무시 구간 추가 코드 puting
		if((nReadedID != nTmpID)  && (nTmpTargetID != nTmpID))
		{
			dRealPositionOfIdReaded = dRealPositionOfNow+180;
			dRealPositionOfFirstDetectCheck = dRealPositionOfNow+100;  //E250로직으로인해추가됨.
			bCheckFirstDetectInterlock = false;
			bCheckInit  = true;
			bCheckInitStop = true;
		}


		if(nReadedID != nTmpID)
		{
			ADD_LOG("markOnTagStation:  bIdReaded=%d, Pos=%6.1lf(Real:%6.11f)(F:%6.1lf,R:%6.1lf,S:%6.1lf), ID=%d:%d"
				, bIdReaded
				, dRealPositionOfIdReaded
				, dRealPositionOfNow
				, dRealPositionOfFirstDetect
				, dRealPositionOfSecondDetect
				, dRealPositionOfSmallAddCheck
				, nReadedID
				, nTmpID);
		}

		nReadedID = nTmpID;
    }


	//2 주행 중 이전 Tag 만난 경우 채터링
#if 1
    if(bIgnoreFrontRearDetect==true)
	{
//		ADD_LOG("Test 1 %f %f",dRealPositionOfNow,dRealPositionOfIdReaded);
		//// 300mm 대응 무시 구간 추가 코드 puting
		if(((dRealPositionOfNow<(dRealDistSumToTarget-280)) && (dRealDistSumToTarget > 280)) ||
			(dRealPositionOfNow < dRealPositionOfIdReaded))
		{

//			memset(&PreMarkState, 0x00, sizeof(DRIVING_MARK_STATE));
//			memset(pMarkState, 0x00, sizeof(DRIVING_MARK_STATE));

			if((bDetectFirst==true) || (bDetectSecond==true))
			{
				bDetectFirst = false;
				bDetectSecond = false;
				bNoSensorDetected = true;
				bPauseSecondSmallMove=false;
			}
		}
		else
		{
			dRealPositionOfIdReadedCheckingPoint = dRealPositionOfNow;

			bIgnoreFrontRearDetect=false;// 무시 구간 지나가면 동일 처리
			if(bDetectFirst==true)
			{
				bNoSensorDetected = (bDetectFirst==false&&bDetectSecond==false)?true:false;
				bPauseSecondSmallMove = (bNoSensorDetected==true)?true:false;
//				PreMarkState.OnRoutineIn = false;
			}
			//// 300mm 대응 무시 구간 추가 코드 puting
			memset(&PreMarkState, 0x00, sizeof(DRIVING_MARK_STATE));
			memset(pMarkState, 0x00, sizeof(DRIVING_MARK_STATE));
		}
	}else
	{
		//특수구간 지난 이후에 Front 센서 감지유무 확인 puting
		if((bDetectFirst) && (bCheckFrontBackStep ==false))
		{
			nCountFrontDetect++;
			if(nCountFrontDetect >1)
			{
				bCheckFrontBackStep = true;
				if(dRealDistSumToTarget >150.0)
					dRealCheckFrontBackPoint = dRealPositionOfNow+180.0; //front감지된 최초 위치 설정.
				else
				   	dRealCheckFrontBackPoint = dRealDistSumToTarget+30.0;

				ADD_LOG("dRealCheckFrontBackPoint:%6.11f/Target%6.11f",dRealCheckFrontBackPoint,dRealDistSumToTarget);
			}
		}
	}
#endif

    //2 First 만나고 일정 거리 경과 및 감속 후, 두번째 Small Add(저속) 지연해서 실시 하기 위해
    if((bNoSensorDetected==true) && ((bDetectFirst==true)||(bDetectSecond==true)) )
    {
        bNoSensorDetected=false;
        dRealPositionOfFirstMetWithNoDetectStart = dRealPositionOfNow;
    }
    if((bNoSensorDetected==false)&&(bPauseSecondSmallMove==true))
    {
        if(((dRealPositionOfNow-dRealPositionOfFirstMetWithNoDetectStart)<(MarkParam.Dist.dAddDistAfetrFirstMet/2))||
            (dSpeedOfNow>(dRefSpeedOnSecondMeet+2.0)))  //2.0 은 안전율 ( 1.0m/s2 감속 시 0.2초동안 감속되는 속도 )
        {
            bPauseSecondSmallMove=false;
        }
        else
        {
			ADD_LOG("markOnTagStation [bPauseSecondSmallMove] Dist[%d]: %6.1lf:%6.1lf < %6.1lf  / Speed[%d]: %6.1lf > %6.1lf+2.0",
                ((dRealPositionOfNow-dRealPositionOfFirstMetWithNoDetectStart)<(MarkParam.Dist.dAddDistAfetrFirstMet/2)),
                dRealPositionOfNow, dRealPositionOfFirstMetWithNoDetectStart, MarkParam.Dist.dAddDistAfetrFirstMet,
                (dSpeedOfNow>(dRefSpeedOnSecondMeet+2.0)),
                dSpeedOfNow, dRefSpeedOnSecondMeet);
        }
    }


	//2 근접 제어 센서를 Off 및 무시 시키는 조건
	//if(pMarkState->FollowCtrlOffArea==false)	
	if(pHWSet->GetAMCVHLDetectStatus() == 1)
	{
		if(bDetectFirst==true)
		{
			//대차 무시설정
			if((bIsOHTDetectIngnore == true) || (PreMarkState.SecondMet==true))
			{
				m_pDrivingAxis->SetVHLDetectIgnor();
				m_bIsAMCVHLDetectIgnore = true;
				ADD_LOG("[MARK] SetVHLDetectIgnor : %6.1lf", dRealPositionOfNow - dRealPositionOfFirstDetect);
			}
		}
	}
	else
	{

    }
	
	//AOHC-249 BCR READ TRIGGER SEQUENCE 개선
	//AS_IS : Trans_F Met이후 80mm 지점부터 Trigger On #Jrespect.im 2019.08.26
	//TO_BE : Trans_F Met이후 Data Readed인(길이 1이상)경우 바로 S/W Trigger On, Data Read Fail인 경우(아무것도 없는 경우) 200ms 주기로 S/W Trigger On
    if(bDetectFirst==true)
	{
		/*
		//Trans First Met 만난 이후 80mm동안(50%) 읽히지 않으면 BCR BUFFER RESET 시도
		if((nReadedID == false) && (m_bIsAMCVHLDetectIgnore = true))
		{
			*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_RESTART;
			ADD_LOG("[MARK] BCR READ Restart : %6.1lf", dRealPositionOfNow - dRealPositionOfFirstDetect);
		}
        //Restart 된 이후 사용
		if(m_pTransBCR->isEnable()== false)
		{
			ADD_LOG("[MARK] TRANS BCR Restart Time Check : %6.1lf", dRealPositionOfNow - dRealPositionOfFirstDetect);
		}
		*/

		//1-2 H/W Trigger로 읽힌 Data가 Error인 경우 S/W BCR READ TRIGGER ON (200ms주기)
		//BCR DATA가 읽히지 않은 경우 200ms대기 후 Trigger On
		if(nReadedID == false)
		{
			if(OHTUTILITY::PreventOverflowGetTimeMs( dwWaitHwBCRTrgTime) > 200)    //20191104 KDS
			{
				*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON; //DrivingControl::markOnTagStation
				dwWaitHwBCRTrgTime = timeGetTime();
				ADD_LOG("[MARK] S/W TRANS BCR READ TRIGGER ON2 : %6.1lf", dRealPositionOfNow - dRealPositionOfFirstDetect);
                                m_mccparam.nBCRTriggerCount++;
			}
		}
	   /*
		if((nReadedID == false) && (b_ReadBcr == false))
		{
			*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON; //DrivingControl::markOnTagStation
			dwWaitHwBCRTrgTime = timeGetTime();
			ADD_LOG("[MARK] S/W TRANS BCR READ TRIGGER ON1 : %6.1lf", dRealPositionOfNow - dRealPositionOfFirstDetect);

		}
		//BCR DATA가 읽히지 않은 경우 200ms대기 후 Trigger On
		else if((nReadedID == false) && (b_ReadBcr == true))
		{
			if(OHTUTILITY::PreventOverflowGetTimeMs( dwWaitHwBCRTrgTime) > 200)    //20191104 KDS
			{
				*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON; //DrivingControl::markOnTagStation
				dwWaitHwBCRTrgTime = timeGetTime();
				ADD_LOG("[MARK] S/W TRANS BCR READ TRIGGER ON2 : %6.1lf", dRealPositionOfNow - dRealPositionOfFirstDetect);
			}
		}
		else
		{
			//ADD_LOG("[MARK] H/W Trans BCR Read Success : %6.1lf", dRealPositionOfNow - dRealPositionOfFirstDetect);
		}
		//Readed 여부를 초기화해줌
		b_ReadBcr = false;
		*/
	}
	else
	{
		dwWaitHwBCRTrgTime = timeGetTime();
	}


	if(pMarkState->FollowCtrlOffArea==false)
	{
		if(PreMarkState.Arrived==true)
			pMarkState->FollowCtrlOffArea=true;
    }
//////////////////////////////////////////////////////////////////////////////

	if(pMarkState->FollowCtrlOffArea==false)
	{
		if(PreMarkState.Arrived==true)
		{
			pMarkState->FollowCtrlOffArea=true;
		}
	}

    // --------------------------------------------------------------------------------------------------------------------------------------
    //1 0. 에러 처리
    // --------------------------------------------------------------------------------------------------------------------------------------
	if(dRealPositionOfNow > dRealDistSumToTarget + dForwardLimit)
	{
        pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
		pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
		nTmpError = ERR_NOTMATCH_TAGLENGTH_FINALSTATION_TAG_MET_LATE;

//		//오버런 처리
//		m_pExecuteInfo->FlagOverRunInfo.bCheck = true;
//		m_pExecuteInfo->FlagOverRunInfo.OverrunType = 0x02; //이적재
//		m_pExecuteInfo->FlagOverRunInfo.nFinalNode = nTmpTargetID;    //주행은 주행, 이적재는 이적재
//		m_pExecuteInfo->FlagOverRunInfo.dDrivingInitPosition = MarkParam.Dist.dForwardMoveDistLimit;

		ERR_LOG("[Tag] ERR_NOTMATCH_TAGLENGTH_FINALSTATION_TAG_MET_LATE : %6.1lf > %6.1lf (%6.1lf + %6.1lf) Pos=%6.1lf(F:%6.1lf,R:%6.1lf,S:%6.1lf)"
            , dRealPositionOfNow, dRealDistSumToLimit, dRealDistSumToTarget, dForwardLimit
            , dRealPositionOfNow
            , dRealPositionOfFirstDetect
			, dRealPositionOfSecondDetect
            , dRealPositionOfSmallAddCheck
            );
		ADD_FDC_LOG("ERR/%d/2/6/%06d/%06d/%d/%d/%06d/%f",
					ERR_NOTMATCH_TAGLENGTH_FINALSTATION_TAG_MET_LATE,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pExecuteInfo->ExecutePositionInfo.NextNode,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					m_pOHTMainStatus->StatusCommon.ExistFoup,
					m_pOHTMainStatus->StatusCommon.StopStationID,
					dRealPositionOfNow - (dRealDistSumToTarget + dForwardLimit));
        return nTmpError;
	}
	else if(dRealPositionOfNow<(dRealPositionOfMostPositive-MarkParam.Dist.dBackMoveDistLimit))
    {
        pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
		pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;

		if(((fabs(dRealPositionOfNow - dRealPositionOfSecondDetect)) > 40.0) ||
		   (m_ClassifiedCmd.TargetInfo.dOffset < 250) ||
		   ((m_ClassifiedCmd.TargetInfo.dLength - m_ClassifiedCmd.TargetInfo.dOffset) < 250))
		{
		  nTmpError = ERR_NOTMATCH_TAGLENGTH_FINALSTATION_TAG_MOVE_BACK_LIMIT;

		  	ERR_LOG("[Tag] ERR_NOTMATCH_TAGLENGTH_FINALSTATION_TAG_MOVE_BACK_LIMIT : %6.1lf < %6.1lf (%6.1lf - %6.1lf) Pos=%6.1lf(F:%6.1lf,R:%6.1lf,S:%6.1lf)"
            , dRealPositionOfNow, (dRealPositionOfMostPositive-MarkParam.Dist.dBackMoveDistLimit)
            , dRealPositionOfMostPositive, MarkParam.Dist.dBackMoveDistLimit
			, dRealPositionOfNow
            , dRealPositionOfFirstDetect
			, dRealPositionOfSecondDetect
			, dRealPositionOfSmallAddCheck
			);
			ADD_FDC_LOG("ERR/%d/1/8/%06d/%06d/%d/%d/%06d/%f/%f/%f",
					ERR_NOTMATCH_TAGLENGTH_FINALSTATION_TAG_MOVE_BACK_LIMIT,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pExecuteInfo->ExecutePositionInfo.NextNode,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					m_pOHTMainStatus->StatusCommon.ExistFoup,
					m_pOHTMainStatus->StatusCommon.StopStationID,
					dRealPositionOfNow,
					dRealPositionOfMostPositive,
					MarkParam.Dist.dBackMoveDistLimit);
		}
		else //OverRun 1회 실시 후 Error처리
		{
			if(m_OverRunCount >= 1)
			{
			   m_OverRunCount = 0;
			   nTmpError = ERR_NOTMATCH_TAGLENGTH_FINALSTATION_TAG_MOVE_BACK_LIMIT;
               ERR_LOG("[OverRun Retry] ERR_NOTMATCH_TAGLENGTH_FINALSTATION_TAG_MOVE_BACK_LIMIT : %6.1lf < %6.1lf (%6.1lf - %6.1lf) Pos=%6.1lf(F:%6.1lf,R:%6.1lf,S:%6.1lf)"
				, dRealPositionOfNow, (dRealPositionOfMostPositive-MarkParam.Dist.dBackMoveDistLimit)
				, dRealPositionOfMostPositive, MarkParam.Dist.dBackMoveDistLimit
				, dRealPositionOfNow
				, dRealPositionOfFirstDetect
				, dRealPositionOfSecondDetect
				, dRealPositionOfSmallAddCheck
				);
				ADD_FDC_LOG("ERR/%d/2/8/%06d/%06d/%d/%d/%06d/%f/%f/%f",
					ERR_NOTMATCH_TAGLENGTH_FINALSTATION_TAG_MOVE_BACK_LIMIT,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pExecuteInfo->ExecutePositionInfo.NextNode,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					m_pOHTMainStatus->StatusCommon.ExistFoup,
					m_pOHTMainStatus->StatusCommon.StopStationID,
					dRealPositionOfNow,
					dRealPositionOfMostPositive,
					MarkParam.Dist.dBackMoveDistLimit);
			}
			else
			{
				m_OverRunCount++;
				m_DiagManager->IncreasePreviosDiagCount(PREVIOS_DIAG_TBT);
				m_mccparam.bBCRReadFail = true;
				ADD_MD_LOG("TBT Cur Station 4 : %d",nTmpTargetID);
				nTmpError = ERR_BCR_READTIMEOUT;       //오버런을 위해 E402로 발생함..
				*pnID = nTmpTargetID;//nTmpTargetID;//ID_NONE;/ID_NONE;

				//오버런 처리
				m_pExecuteInfo->FlagOverRunInfo.bCheck = true;
				m_pExecuteInfo->FlagOverRunInfo.OverrunType = 0x02; //이적재
				m_pExecuteInfo->FlagOverRunInfo.nFinalNode = nTmpTargetID;    //주행은 주행, 이적재는 이적재
				m_PositionInfo.CurrStation = nTmpTargetID;
				m_pExecuteInfo->FlagOverRunInfo.dDrivingInitPosition = 0.0;

				m_PositionInfo.CurrStation = nTmpTargetID;

				ERR_LOG("[OverRun] ERR_NOTMATCH_TAGLENGTH_FINALSTATION_TAG_MOVE_BACK_LIMIT : %6.1lf < %6.1lf (%6.1lf - %6.1lf) Pos=%6.1lf(F:%6.1lf,R:%6.1lf,S:%6.1lf)"
				, dRealPositionOfNow, (dRealPositionOfMostPositive-MarkParam.Dist.dBackMoveDistLimit)
				, dRealPositionOfMostPositive, MarkParam.Dist.dBackMoveDistLimit
				, dRealPositionOfNow
				, dRealPositionOfFirstDetect
				, dRealPositionOfSecondDetect
				, dRealPositionOfSmallAddCheck
				);
			}
		}



        return nTmpError;
    }

    // --------------------------------------------------------------------------------------------------------------------------------------
    //1 1. Second 감지된 경우
    // --------------------------------------------------------------------------------------------------------------------------------------
    if( bDetectSecond==true )
	{
		bIsOHTDetectIngnore = true;
        //2 1) 마크 루틴 완료 후 id를 확인하는 절차
		if( PreMarkState.IdCheck==true)
		{
            if(pnID==NULL)
            {
                *pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_NONE;
                pMarkState->Arrived = true;
            }
            else
            {
                if(bIdReaded==true)
				{
					if(nTmpTargetID == nReadedID)
					{
						*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_NONE;
						ADD_LOG("markOnTagStation: pMarkState->Arrived=true, Pos=%6.1lf(F:%6.1lf,R:%6.1lf,S:%6.1lf T:%6.1lf)%d"
							, dRealPositionOfNow
							, dRealPositionOfFirstDetect
							, dRealPositionOfSecondDetect
							, dRealPositionOfSmallAddCheck
							, dRealDistSumToTarget
							, nTmpTargetID
							);

					   if((dCheckRealPositionOfFirstDetect !=0.0) &&      //처음위치가 Front on인 경우 무시
//						  (bCheckFirstDetectInterlock==true) &&
						  (dRealPositionOfSecondDetect > m_pParamSet->ScatteredReflection) &&  //처음위치가 Front On인 경우 무시
					   ((dRealPositionOfSecondDetect - dCheckRealPositionOfFirstDetect) <  (m_pParamSet->ScatteredReflection*dFirstDetectPercent)))// ||((dRealPositionOfSecondDetect - dCheckRealPositionOfFirstDetect) >  m_pParamSet->ScatteredReflectionMax)))
					   {
					   		if(((fabs(dRealPositionOfNow - dRealPositionOfSecondDetect)) > 40.0) ||
							(m_ClassifiedCmd.TargetInfo.dOffset < 250) ||
							((m_ClassifiedCmd.TargetInfo.dLength - m_ClassifiedCmd.TargetInfo.dOffset) < 250))
							{
								pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
								pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
								nTmpError = ERR_MARK_RSTOPSEN_OFF;
								ADD_FDC_LOG("ERR/%d/1/8/%06d/%06d/%d/%d/%06d/%d/%6.1lf/%6.1lf",
											ERR_MARK_RSTOPSEN_OFF,
											m_pOHTMainStatus->StatusCommon.CurNodeID,
											m_pExecuteInfo->ExecutePositionInfo.NextNode,
											m_pOHTMainStatus->StatusCommon.CurNodeOffset,
											m_pOHTMainStatus->StatusCommon.ExistFoup,
											m_pOHTMainStatus->StatusCommon.StopStationID,
											bAxis1InPosition,
											dRealPositionOfNow,
											dRealPositionOfSmallAddCheck);
							}
							else
							{
								if(m_OverRunCount >= 1)
								{
								   m_OverRunCount = 0;
								   nTmpError = ERR_MARK_RSTOPSEN_OFF;
								   ADD_LOG("[OverRun Retry][ERR_MARK_RSTOPSEN_OFF]");
								   ADD_FDC_LOG("ERR/%d/1/8/%06d/%06d/%d/%d/%06d/%d/%6.1lf/%6.1lf",
											ERR_MARK_RSTOPSEN_OFF,
											m_pOHTMainStatus->StatusCommon.CurNodeID,
											m_pExecuteInfo->ExecutePositionInfo.NextNode,
											m_pOHTMainStatus->StatusCommon.CurNodeOffset,
											m_pOHTMainStatus->StatusCommon.ExistFoup,
											m_pOHTMainStatus->StatusCommon.StopStationID,
											bAxis1InPosition,
											dRealPositionOfNow,
											dRealPositionOfSmallAddCheck);
								}
								else
								{
									m_OverRunCount++;
									nTmpError = ERR_BCR_READTIMEOUT;       //오버런을 위해 E402로 발생함..
									*pnID = nTmpTargetID;//nTmpTargetID;//ID_NONE;/ID_NONE;

									//오버런 처리
									m_pExecuteInfo->FlagOverRunInfo.bCheck = true;
									m_pExecuteInfo->FlagOverRunInfo.OverrunType = 0x02; //이적재
									m_pExecuteInfo->FlagOverRunInfo.nFinalNode = nTmpTargetID;    //주행은 주행, 이적재는 이적재
									m_PositionInfo.CurrStation = nTmpTargetID;
									m_pExecuteInfo->FlagOverRunInfo.dDrivingInitPosition =0.0;

									m_PositionInfo.CurrStation = nTmpTargetID;
									ADD_LOG("[OverRun][ERR_MARK_RSTOPSEN_OFF]");
								}
							}
					   }
					   else
					   {
							m_dStationMarkInpos =dRealPositionOfNow; //최종 현재 위치 저장

							pMarkState->Arrived = true;
							m_OverRunCount = 0;
//							m_OverRunCount_E250 = 0;
//							m_OverRunCount_E2314 = 0;
//							m_OverRunCount_E2313 = 0;
					   }

					}
					else
					{
						*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_NONE;
						pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
						pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
						m_DiagManager->IncreasePreviosDiagCount(PREVIOS_DIAG_TBT);
						m_mccparam.bBCRReadFail = true;
						ADD_MD_LOG("TBT Cur Station 5 : %d",nTmpTargetID);
						nTmpError = ERR_BCR_READTIMEOUT;
						*pnID = nReadedID;//nTmpTargetID;//ID_NONE;/ID_NONE;
												//오버런 처리
						m_pExecuteInfo->FlagOverRunInfo.bCheck = true;
						m_pExecuteInfo->FlagOverRunInfo.OverrunType = 0x02; //이적재
						m_pExecuteInfo->FlagOverRunInfo.nFinalNode = nTmpTargetID;    //주행은 주행, 이적재는 이적재
						m_PositionInfo.CurrStation = nTmpTargetID;
						m_pExecuteInfo->FlagOverRunInfo.dDrivingInitPosition =0.0;

						ADD_FDC_LOG("ERR/%d/2/6/%06d/%06d/%d/%d/%06d/2",
										ERR_BCR_READTIMEOUT,
										m_pOHTMainStatus->StatusCommon.CurNodeID,
										m_pExecuteInfo->ExecutePositionInfo.NextNode,
										m_pOHTMainStatus->StatusCommon.CurNodeOffset,
										m_pOHTMainStatus->StatusCommon.ExistFoup,
										m_pOHTMainStatus->StatusCommon.StopStationID);

					}

					*pnID = nReadedID;
				}
				else if(OHTUTILITY::PreventOverflowGetTimeMs(dwTriggerTime) > 200)
                {
					if(OHTUTILITY::PreventOverflowGetTimeMs(dwCheckTime) > 3500)// Time Over
					{
                        *pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_NONE;
                        pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
						pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
						m_DiagManager->IncreasePreviosDiagCount(PREVIOS_DIAG_TBT);
						m_mccparam.bBCRReadFail = true;
						ADD_MD_LOG("TBT Cur Station 6 : %d",nTmpTargetID);
						nTmpError = ERR_BCR_READTIMEOUT;
						*pnID = nTmpTargetID;//nTmpTargetID;//ID_NONE;/ID_NONE;

						//오버런 처리
						m_pExecuteInfo->FlagOverRunInfo.bCheck = true;
						m_pExecuteInfo->FlagOverRunInfo.OverrunType = 0x02; //이적재
						m_pExecuteInfo->FlagOverRunInfo.nFinalNode = nTmpTargetID;    //주행은 주행, 이적재는 이적재
						m_PositionInfo.CurrStation = nTmpTargetID;
						m_pExecuteInfo->FlagOverRunInfo.dDrivingInitPosition =0.0;

						m_PositionInfo.CurrStation = nTmpTargetID;

                        ADD_LOG("markOnTagStation: ERR_BCR_READTIMEOUT, Pos=%6.1lf(F:%6.1lf,R:%6.1lf,S:%6.1lf)"
                            , dRealPositionOfNow
							, dRealPositionOfFirstDetect
							, dRealPositionOfSecondDetect
							, dRealPositionOfSmallAddCheck );
						ADD_FDC_LOG("ERR/%d/2/6/%06d/%06d/%d/%d/%06d/2",
										ERR_BCR_READTIMEOUT,
										m_pOHTMainStatus->StatusCommon.CurNodeID,
										m_pExecuteInfo->ExecutePositionInfo.NextNode,
										m_pOHTMainStatus->StatusCommon.CurNodeOffset,
										m_pOHTMainStatus->StatusCommon.ExistFoup,
										m_pOHTMainStatus->StatusCommon.StopStationID);
					}
					else
					{
						dwTriggerTime = timeGetTime();
                        *pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
						m_mccparam.nBCRTriggerCount++;
                    }
                }
            }
        }
        //2 2)  마크 루틴 처음 들어왔을 때 Rear 감지된 경우: 뒤로 5mm 이동 후 2. Front 감지 처리로 처리
        else if( PreMarkState.FirstMet == false )
        {

            // Second Met을 활성화 하지 않은 이유:  First 만나고 아래 정상 루틴으로 들어가게 하려함
            // First Met을 활성화 하지 않은 이유:       5mm 이동 완료 시 까지 이부분 계속 호출 시키려고
            pMarkState->OnRoutineIn = true;

            if( bStopWithoutFrontDetect==true && PreMarkState.OnMoveCmd==false) // 정지 시 뒤로 이동
            {
                pMarkState->OnMoveCmd=true;

                //1 >>>엔코더 값이 -10mm이하일 경우 에러 처리
                //1 >>>Small Add Move -2.5mm(Second 벗어날때까지)
                pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet; //Tag.AccelOfSecond;
                pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet; //Tag.AccelOfSecond;
                pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfSecondMet);   //Tag.SpeedOfSecond;
                pCtrlInfo->Dynamic.dDist    = dRealPositionOfNow - (2*MarkParam.Dist.dLengthOfSecond);//.LengthOfSecond);   // 현재 위치에서 Second 길이의 2배 위치까지

                memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
//              pCtrlInfo->Dynamic.AdditionalInfo.bStartOnSpeedDown     = true;
				pCtrlInfo->Dynamic.AdditionalInfo.bUseSmallAdd              = true;

#if((OHT_NAME == OHT_NAME_STD_V85) || (OHT_NAME == OHT_NAME_STD_V81S))
				pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 57;
#else
				pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 54;
#endif

                pCtrlInfo->Dynamic.AdditionalInfo.bIsTriggerOnRisingEdge    = true;
                pCtrlInfo->Dynamic.AdditionalInfo.dSmallDistance            = MarkParam.Dist.dAddDistAfterSecondMet;//Tag.AddLengthForSecond;

                pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;//Event.Flag.MarkEvent_SecondMet = true;
                ADD_LOG("Small Add: Abnormal SecondMet & Move Back 10, Pos=%6.1lf(F:%6.1lf,R:%6.1lf,S:%6.1lf)"
                    , dRealPositionOfNow
                    , dRealPositionOfFirstDetect
                    , dRealPositionOfSecondDetect
                    , dRealPositionOfSmallAddCheck
                    );
            }
        }
        //2 3)  정상 Routine으로 Rear 센서가 처음 들어온 경우: 정지 대기
        else if( PreMarkState.SecondMet==false)//pMarkStatus->StateOnSecondMet == false)
        {
            pMarkState->SecondMet = true;   //pMarkStatus->StateOnSecondMet = true;
            dRealPositionOfSecondMet = dRealPositionOfNow;
            ADD_LOG("Small Add: SecondMet %7.1lf, Pos=%6.1lf(F:%6.1lf,R:%6.1lf,S:%6.1lf)"
                , HwInfo.Axis1.dCurrPos
                , dRealPositionOfNow
                , dRealPositionOfFirstDetect
                , dRealPositionOfSecondDetect
                , dRealPositionOfSmallAddCheck
                );
		}
        //2 4)  정지 한 경우: 정위치 확인 및 완료 처리
        else if( bStopWithoutFrontDetect == true )
		{

            ADD_LOG("Small Add: Stop (%6.1lf - %6.1lf = %6.1lf, Pos=%6.1lf(F:%6.1lf,R:%6.1lf,S:%6.1lf))"
                , dRealPositionOfNow, dRealPositionOfSmallAddCheck
                , (dRealPositionOfNow-dRealPositionOfSmallAddCheck)
                , dRealPositionOfNow
                , dRealPositionOfFirstDetect
                , dRealPositionOfSecondDetect
                , dRealPositionOfSmallAddCheck
                );


            //1 >>>Arrived
            // 도착위치와 센서 감지 위치를 비교하여 차가 2.5mm ±0.5 이면 정상 처리함 (전진 후진에 대해 모두 처리)
			if( (fabs(dRealPositionOfNow-dRealPositionOfSmallAddCheck)<(MarkParam.Dist.dAddDistAfterSecondMet+MarkParam.Dist.dMarkInPosLimit)) &&
				(fabs(dRealPositionOfNow-dRealPositionOfSmallAddCheck)>(MarkParam.Dist.dAddDistAfterSecondMet-MarkParam.Dist.dMarkInPosLimit)) &&
				(dRealPositionOfSmallAddCheck!=0.0) && (bAxis1InPosition == true) )
			{
                if( bDetectFirst==true && bDetectSecond==true )//m_pTransStopTag->IsOnFrontSensor()==true )
                {
                    pMarkState->IdCheck=true;
                    *pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
					m_mccparam.nBCRTriggerCount++;
					dwCheckTime = dwCurrTime;   // ID 확인 되지 않을 때에 대한 TimeOut 처리 목적
					dwTriggerTime = dwCurrTime;
                }
			}
			else if( (fabs(dRealPositionOfNow-dRealPositionOfSecondDetect)<(MarkParam.Dist.dAddDistAfterSecondMet+MarkParam.Dist.dMarkInPosLimit)) &&
					(fabs(dRealPositionOfNow-dRealPositionOfSecondDetect)>(MarkParam.Dist.dAddDistAfterSecondMet-MarkParam.Dist.dMarkInPosLimit)) &&
					(dRealPositionOfSecondDetect!=0.0) && (bAxis1InPosition == true) )
			{
				if( bDetectFirst==true && bDetectSecond==true )//m_pTransStopTag->IsOnFrontSensor()==true )
				{
					pMarkState->IdCheck=true;
					*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
					m_mccparam.nBCRTriggerCount++;
					dwCheckTime = dwCurrTime;   // ID 확인 되지 않을 때에 대한 TimeOut 처리 목적
					dwTriggerTime = dwCurrTime;
				}
			}
            else    // 멈췄으나 정위치 되지 않을 때에 대한 처리
			{

				if(OHTUTILITY::PreventOverflowGetTimeMs(dwSecendCheckTime)> 300)
				{
					if(nRecoveryLimitCount4TagStation < RecoveryLimitCountForMarkOnTagStation)
					{
						if(bStopWithoutFrontDetect==true)
						{
							nRecoveryLimitCount4TagStation++;

							dwSecendCheckTime = dwCurrTime;

							pMarkState->Recovery=true;

							pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet;
							pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;
							pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfSecondMet);

							pCtrlInfo->Dynamic.dDist    = dRealPositionOfNow - 1.0;

						   //	pCtrlInfo->Dynamic.dDist    = dRealPositionOfSecondDetect+MarkParam.Dist.dAddDistAfterSecondMet;

							memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));

	//						pCtrlInfo->Dynamic.AdditionalInfo.bUseSmallAdd              = true;
	//
	//						pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 54;
	//
	//						pCtrlInfo->Dynamic.AdditionalInfo.bIsTriggerOnRisingEdge    = true;
	//						pCtrlInfo->Dynamic.AdditionalInfo.dSmallDistance            = MarkParam.Dist.dAddDistAfterSecondMet;

							pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;

							ADD_LOG("Small Add: SecondMet Not In Pos, bAxis1InPosition(%d), dRealPositionOfNow(%6.1lf), dRealPositionOfSmallAddCheck(%6.1lf), MarkParam.Dist.dAddDistAfterSecondMet(%6.1lf), MarkParam.Dist.dMarkInPosLimit(%6.1lf)"
								, bAxis1InPosition
								, dRealPositionOfNow
								, dRealPositionOfSmallAddCheck
								, MarkParam.Dist.dAddDistAfterSecondMet
								, MarkParam.Dist.dMarkInPosLimit );
						}
					}
					else
					{
						nRecoveryLimitCount4TagStation = 0;

						pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
						pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
						//E2314 Overrun 조건 추가 2018.07.18 JRESPECT.IM
						if(((fabs(dRealPositionOfNow - dRealPositionOfSecondDetect)) > 40.0) ||
							(m_ClassifiedCmd.TargetInfo.dOffset < 250) ||
							((m_ClassifiedCmd.TargetInfo.dLength - m_ClassifiedCmd.TargetInfo.dOffset) < 250))
						{
							nTmpError = ERR_NOTMATCH_TAGLENGTH_FINALSTATION_IN_POSITION_ERROR;

							ADD_LOG("[Error][ERR_NOTMATCH_TAGLENGTH_FINALSTATION_IN_POSITION_ERROR] bAxis1InPosition(%d), dRealPositionOfNow(%6.1lf), dRealPositionOfSmallAddCheck(%6.1lf), MarkParam.Dist.dAddDistAfterSecondMet(%6.1lf), MarkParam.Dist.dMarkInPosLimit(%6.1lf)"
									, bAxis1InPosition
									, dRealPositionOfNow
									, dRealPositionOfSmallAddCheck
									, MarkParam.Dist.dAddDistAfterSecondMet
									, MarkParam.Dist.dMarkInPosLimit);
							ADD_FDC_LOG("ERR/%d/1/10/%06d/%06d/%d/%d/%06d/%%6.1lf/%%6.1lf/%%6.1lf/%%6.1lf/%d",
										ERR_NOTMATCH_TAGLENGTH_FINALSTATION_IN_POSITION_ERROR,
										m_pOHTMainStatus->StatusCommon.CurNodeID,
										m_pExecuteInfo->ExecutePositionInfo.NextNode,
										m_pOHTMainStatus->StatusCommon.CurNodeOffset,
										m_pOHTMainStatus->StatusCommon.ExistFoup,
										m_pOHTMainStatus->StatusCommon.StopStationID,
										dRealPositionOfNow,
										dRealPositionOfSmallAddCheck,
										MarkParam.Dist.dAddDistAfterSecondMet,
										MarkParam.Dist.dMarkInPosLimit,
										bAxis1InPosition);

							return nTmpError;
						}
						else
						{
							if(m_OverRunCount >= 1)
							{
								m_OverRunCount = 0;
								nTmpError = ERR_NOTMATCH_TAGLENGTH_FINALSTATION_IN_POSITION_ERROR;
								ADD_LOG("[OverRun Retry][ERR_NOTMATCH_TAGLENGTH_FINALSTATION_IN_POSITION_ERROR] bAxis1InPosition(%d), dRealPositionOfNow(%6.1lf), dRealPositionOfSmallAddCheck(%6.1lf), MarkParam.Dist.dAddDistAfterSecondMet(%6.1lf), MarkParam.Dist.dMarkInPosLimit(%6.1lf)"
										, bAxis1InPosition
										, dRealPositionOfNow
										, dRealPositionOfSmallAddCheck
										, MarkParam.Dist.dAddDistAfterSecondMet
										, MarkParam.Dist.dMarkInPosLimit);
								ADD_FDC_LOG("ERR/%d/2/10/%06d/%06d/%d/%d/%06d/%%6.1lf/%%6.1lf/%%6.1lf/%%6.1lf/%d",
										ERR_NOTMATCH_TAGLENGTH_FINALSTATION_IN_POSITION_ERROR,
										m_pOHTMainStatus->StatusCommon.CurNodeID,
										m_pExecuteInfo->ExecutePositionInfo.NextNode,
										m_pOHTMainStatus->StatusCommon.CurNodeOffset,
										m_pOHTMainStatus->StatusCommon.ExistFoup,
										m_pOHTMainStatus->StatusCommon.StopStationID,
										dRealPositionOfNow,
										dRealPositionOfSmallAddCheck,
										MarkParam.Dist.dAddDistAfterSecondMet,
										MarkParam.Dist.dMarkInPosLimit,
										bAxis1InPosition);
							}
							else
							{
								m_OverRunCount++;
								nTmpError = ERR_BCR_READTIMEOUT;       //오버런을 위해 E402로 발생함..
								*pnID = nTmpTargetID;//nTmpTargetID;//ID_NONE;/ID_NONE;

								//오버런 처리
								m_pExecuteInfo->FlagOverRunInfo.bCheck = true;
								m_pExecuteInfo->FlagOverRunInfo.OverrunType = 0x02; //이적재
								m_pExecuteInfo->FlagOverRunInfo.nFinalNode = nTmpTargetID;    //주행은 주행, 이적재는 이적재
								m_PositionInfo.CurrStation = nTmpTargetID;
								m_pExecuteInfo->FlagOverRunInfo.dDrivingInitPosition =0.0;

								m_PositionInfo.CurrStation = nTmpTargetID;
								ADD_LOG("[OverRun][ERR_NOTMATCH_TAGLENGTH_FINALSTATION_IN_POSITION_ERROR] bAxis1InPosition(%d), dRealPositionOfNow(%6.1lf), dRealPositionOfSmallAddCheck(%6.1lf), MarkParam.Dist.dAddDistAfterSecondMet(%6.1lf), MarkParam.Dist.dMarkInPosLimit(%6.1lf)"
										, bAxis1InPosition
										, dRealPositionOfNow
										, dRealPositionOfSmallAddCheck
										, MarkParam.Dist.dAddDistAfterSecondMet
										, MarkParam.Dist.dMarkInPosLimit );
							}
						}
					}
				}
			}
		}else
		{
			dwSecendCheckTime = timeGetTime();
		}

		if((pMarkState->Arrived == true) && (m_mccparam.bMarkStartFlag == true))
		{
			ADD_MCC_LOG(",%s,DRV,STATION MARK,End,FOUP,%06d,%06d,%06d,%d,%6.1lf,Mark Type,%d,Station Mark Dist,%6.1lf,Station Sensor Dist,%6.1lf,Station Mark Start Speed,%6.1lf,Front Sensor Hunting Count,%d,ParentNode Offset Difference,%6.1lf,Trans BCR Read Fail,%d,Trans BCR Trigger Count,%d",
						m_defualtparam->VHLName,
						m_mccparam.uSourceNode,
						m_mccparam.uTargetNode,
						m_pOHTMainStatus->StatusCommon.CurNodeID,
						m_pOHTMainStatus->StatusCommon.CurNodeOffset,
						dSpeedOfNow,
						m_InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType,
						dRealPositionOfFirstDetect - m_mccparam.dMarkStartDist,
						dRealPositionOfSecondDetect - dRealPositionOfFirstDetect,
						m_mccparam.dMarkStartSpeed,
						m_mccparam.nFrontSensorHuntingCount,
						m_ClassifiedCmd.TargetInfo.dOffset - m_pOHTMainStatus->StatusCommon.CurNodeOffset,
						m_mccparam.bBCRReadFail,
						m_mccparam.nBCRTriggerCount);
			m_mccparam.bMarkStartFlag = false;
			m_mccparam.dMarkStartSpeed = 0.0;
			m_mccparam.dMarkStartDist = 0.0;
			m_mccparam.nFrontSensorHuntingCount = 0;
			m_mccparam.bBCRReadFail = false;
			m_mccparam.nBCRTriggerCount = 0;
		}

		return nTmpError;
	}

	// --------------------------------------------------------------------------------------------------------------------------------------
    //1 2. First 감지 된 경우
    // --------------------------------------------------------------------------------------------------------------------------------------
    else if( bDetectFirst==true )
    {
        if(PreMarkState.Recovery==true) //pMarkStatus->StateOnOverRunBack==true)
        {
			if(bStopWithoutFrontDetect == true)
			{
				bIsOHTDetectIngnore = true;
			   //	nRecoveryCountTagStationOverrun = 0;
				//1 >>>에러 처리
				if(nRecoveryCountTagStationOverrun <50)
				{
					pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet;//Tag.AccelOfSecond;
					pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;//Tag.AccelOfSecond;
					pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfSecondMet);//Tag.SpeedOfSecond;

					memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));


					if((((dRealPositionOfSecondDetect - MarkParam.Dist.dAddDistAfterSecondMet-MarkParam.Dist.dMarkInPosLimit)> dRealPositionOfNow) && ( dRealPositionOfSecondDetect < dRealDistSumToLimit)) ||   //Sensor감지된 위치가 현재보다 전방에 있고, Limit거리가 안넘었을 경우는 전방으로 탐색
						((dRealPositionOfIdReadedCheckingPoint < dRealPositionOfNow) && (dRealPositionOfSecondDetect < dRealPositionOfFirstDetect)) ||   //Front가 SecondDetect보다 클경우는 전방으로 탐색
						(dRealPositionOfSecondDetect ==0)) //Front or RearDectect가 하나라도 0일 경우는 전방으로 탐색
						pCtrlInfo->Dynamic.dDist    = dRealDistSumToLimit;      // 현재 위치에서 Second 길이의 2배 위치까지
					else
						pCtrlInfo->Dynamic.dDist    = dRealPositionOfNow -35.0;     // 현재 위치에서 Second 감지 거리의 2배 위치까지


					pCtrlInfo->Dynamic.AdditionalInfo.bUseSmallAdd              = true;

#if((OHT_NAME == OHT_NAME_STD_V85) || (OHT_NAME == OHT_NAME_STD_V81S))
					pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 57;
#else
					pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 54;
#endif

					pCtrlInfo->Dynamic.AdditionalInfo.bIsTriggerOnRisingEdge    = false;
					pCtrlInfo->Dynamic.AdditionalInfo.dSmallDistance            = MarkParam.Dist.dAddDistAfterSecondMet;//Tag.AddLengthForSecond;


					pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;//Event.Flag.MarkEvent_BackFromOverRun= true;

					ADD_LOG("Recoverry: FirstMet %7.1lf, Pos=%6.1lf(F:%6.1lf,R:%6.1lf,S:%6.1lf)"
					, HwInfo.Axis1.dCurrPos
					, dRealPositionOfNow
					, dRealPositionOfFirstDetect
					, dRealPositionOfSecondDetect
					, dRealPositionOfSmallAddCheck
					);
				}
				else
				{
					nRecoveryCountTagStationOverrun++;
				 	if(nRecoveryCountTagStationOverrun >=20)  //무한반복 제거.
					{
						nRecoveryCountTagStationOverrun = 0;

						pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
						pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
						nTmpError = ERR_MARK_FSTOPSEN_OFF;

						ADD_LOG("[Error][ERR_MARK_FSTOPSEN_OFF] bAxis1InPosition(%d), dRealPositionOfNow(%6.1lf), dRealPositionOfSmallAddCheck(%6.1lf), MarkParam.Dist.dAddDistAfterSecondMet(%6.1lf), MarkParam.Dist.dMarkInPosLimit(%6.1lf)"
								, bAxis1InPosition
								, dRealPositionOfNow
								, dRealPositionOfSmallAddCheck
								, MarkParam.Dist.dAddDistAfterSecondMet
								, MarkParam.Dist.dMarkInPosLimit );

						ADD_FDC_LOG("ERR/%d/1/8/%06d/%06d/%d/%d/%06d/%d/%6.1lf/%6.1lf",
									ERR_MARK_FSTOPSEN_OFF,
									m_pOHTMainStatus->StatusCommon.CurNodeID,
									m_pExecuteInfo->ExecutePositionInfo.NextNode,
									m_pOHTMainStatus->StatusCommon.CurNodeOffset,
									m_pOHTMainStatus->StatusCommon.ExistFoup,
									m_pOHTMainStatus->StatusCommon.StopStationID,
									bAxis1InPosition,
									dRealPositionOfNow,
									dRealPositionOfSmallAddCheck);

						return nTmpError;
					}

				}

			}
        }
        //2 1)  마크 루틴 처음 들어왔을 때 Front 감지된 경우: small add move 시작(2.5mm : 0.05mm/msec : 0.0005 mm/msec2 )
        else if( PreMarkState.OnRoutineIn==false )//pMarkStatus->StateOnStopRoutineIn == false)
		{
            pMarkState->FirstMet = true;        //pMarkStatus->StateOnFirstMet = true;
            pMarkState->OnRoutineIn = true; //pMarkStatus->StateOnStopRoutineIn = true;

            //1 >>>Small Add Move 2.5mm
            pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet;//Tag.AccelOfSecond;
            pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;//Tag.AccelOfSecond;
            pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfSecondMet);//Tag.SpeedOfSecond;
            pCtrlInfo->Dynamic.dDist    = dRealDistSumToLimit;      // 현재 위치에서 Second 길이의 2배 위치까지

            memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
//          pCtrlInfo->Dynamic.AdditionalInfo.bStartOnSpeedDown     = true;
            pCtrlInfo->Dynamic.AdditionalInfo.bUseSmallAdd              = true;

#if((OHT_NAME == OHT_NAME_STD_V85) || (OHT_NAME == OHT_NAME_STD_V81S))
			pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 57;
#else
			pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 54;
#endif

            pCtrlInfo->Dynamic.AdditionalInfo.bIsTriggerOnRisingEdge    = false;
            pCtrlInfo->Dynamic.AdditionalInfo.dSmallDistance            = MarkParam.Dist.dAddDistAfterSecondMet;//Tag.AddLengthForSecond;

            pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;//Event.Flag.MarkEvent_FirstMet = true;

            ADD_LOG("Small Add Move 2.5mm 2-1, Pos=%6.1lf(F:%6.1lf,R:%6.1lf,S:%6.1lf)"
                , dRealPositionOfNow
                , dRealPositionOfFirstDetect
                , dRealPositionOfSecondDetect
                , dRealPositionOfSmallAddCheck
                );


        }
        //2 2)  정상 Routine으로 Rear 센서가 처음 들어온 경우: small add move 시작(2.5mm : 0.05mm/msec : 0.0005 mm/msec2 )
        else if( PreMarkState.FirstMet == false )//pMarkStatus->StateOnFirstMet == false)
        {
            //1 정상 루틴으로 들어온 경우 지연 처리
            if(bPauseSecondSmallMove==false)
            {
                pMarkState->FirstMet = true;  //pMarkStatus->StateOnFirstMet = true;

                //1 >>>Small Add Move 2.5mm
                pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet;//Tag.AccelOfSecond;
                pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;//Tag.AccelOfSecond;
                pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfSecondMet);//Tag.SpeedOfSecond;
                pCtrlInfo->Dynamic.dDist    = dRealDistSumToLimit;      // 현재 위치에서 Second 길이의 2배 위치까지

                memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
//              pCtrlInfo->Dynamic.AdditionalInfo.bStartOnSpeedDown     = true;
                pCtrlInfo->Dynamic.AdditionalInfo.bUseSmallAdd              = true;

#if((OHT_NAME == OHT_NAME_STD_V85) || (OHT_NAME == OHT_NAME_STD_V81S))
				pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 57;
#else
				pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 54;
#endif

                pCtrlInfo->Dynamic.AdditionalInfo.bIsTriggerOnRisingEdge    = false;
                pCtrlInfo->Dynamic.AdditionalInfo.dSmallDistance            = MarkParam.Dist.dAddDistAfterSecondMet;//Tag.AddLengthForSecond;

                pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;//Event.Flag.MarkEvent_FirstMet = true;
                //BCR H/W Trigger ON
				ADD_LOG("[MARK] First Met! H/W TRANS BCR READ TRIGGER ON : %6.1lf", dRealPositionOfNow - dRealPositionOfFirstDetect);
                ADD_LOG("Small Add Move 2.5mm 2-2, Pos=%6.1lf(F:%6.1lf,R:%6.1lf,S:%6.1lf)"
                    , dRealPositionOfNow
                    , dRealPositionOfFirstDetect
                    , dRealPositionOfSecondDetect
                    , dRealPositionOfSmallAddCheck
                    );
            }

        }
        //2 3)  정지 한 경우: 현재 위치 확인 후 에러  혹은 small add move
        else if( bStopWithoutFrontDetect == true )
        {
            //1 >>>Small Add Move 2.5mm
			if(PreMarkState.OverRun==true)
			{
				bIsOHTDetectIngnore = true;
				pMarkState->Recovery=true;
				// Second Met을 활성화 하는 이유:   Second 만나고 아래 완료 루틴으로 들어가게 하려함
//                  pMarkState->OverRun = true; //pMarkStatus->StateOnOverRunBack = true;
				//1     >>>Second 넘어간 경우:  Small Add Move -2.5mm
				pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet;//Tag.AccelOfSecond;
				pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;//Tag.AccelOfSecond;
				pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfSecondMet);//Tag.SpeedOfSecond;


				if(((dRealPositionOfSecondDetect > dRealPositionOfNow) && ( dRealPositionOfSecondDetect < dRealDistSumToLimit)) ||   //Sensor감지된 위치가 현재보다 전방에 있고, Limit거리가 안넘었을 경우는 전방으로 탐색
					((dRealPositionOfIdReadedCheckingPoint <dRealPositionOfNow) && (dRealPositionOfSecondDetect < dRealPositionOfFirstDetect)) ||   //Front가 SecondDetect보다 클경우는 전방으로 탐색
					(dRealPositionOfSecondDetect ==0)) //Front or RearDectect가 하나라도 0일 경우는 전방으로 탐색
//				if((dRealPositionOfSecondDetect > dRealPositionOfNow) && ( dRealPositionOfSecondDetect < dRealDistSumToLimit))
				{
					pCtrlInfo->Dynamic.dDist    = dRealDistSumToLimit;      // 현재 위치에서 Second 길이의 2배 위치까지
                          //프론트가 감지된상태에서는 안함.
//					if((bCheckFrontBackStep == true) &&	(dRealPositionOfNow > dRealCheckFrontBackPoint + 180.0))
//					{
//						pCtrlInfo->Dynamic.dDist = dRealPositionOfNow - 60.0;//
//					}

					memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
		//          pCtrlInfo->Dynamic.AdditionalInfo.bStartOnSpeedDown     = true;
					pCtrlInfo->Dynamic.AdditionalInfo.bUseSmallAdd              = true;

#if((OHT_NAME == OHT_NAME_STD_V85) || (OHT_NAME == OHT_NAME_STD_V81S))
					pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 57;
#else
					pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 54;
#endif

					pCtrlInfo->Dynamic.AdditionalInfo.bIsTriggerOnRisingEdge    = false;
					pCtrlInfo->Dynamic.AdditionalInfo.dSmallDistance            = MarkParam.Dist.dAddDistAfterSecondMet;//Tag.AddLengthForSecond;

				}
				else
				{


					pCtrlInfo->Dynamic.dDist    = dRealPositionOfNow-35.0;     // 현재 위치에서 Second 감지 거리의 2배 위치까지
//					pCtrlInfo->Dynamic.dDist    = dRealPositionOfSecondDetect+MarkParam.Dist.dAddDistAfterSecondMet;
//					if((bCheckFrontBackStep == true) &&	(dRealPositionOfNow > dRealCheckFrontBackPoint + 180.0))
//					{
//						pCtrlInfo->Dynamic.dDist = dRealPositionOfNow - 60.0;//
//					}
					memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
	//                  pCtrlInfo->Dynamic.AdditionalInfo.bStartOnSpeedDown     = true;
					pCtrlInfo->Dynamic.AdditionalInfo.bUseSmallAdd              = true;

#if((OHT_NAME == OHT_NAME_STD_V85) || (OHT_NAME == OHT_NAME_STD_V81S))
					pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 57;
#else
					pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 54;
#endif
					pCtrlInfo->Dynamic.AdditionalInfo.bIsTriggerOnRisingEdge    = false;
					pCtrlInfo->Dynamic.AdditionalInfo.dSmallDistance            = MarkParam.Dist.dAddDistAfterSecondMet;//Tag.AddLengthForSecond;
				}

				pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;//Event.Flag.MarkEvent_BackFromOverRun= true;

				ADD_LOG("Small Add Move -2.5mm 2-4, Pos=%6.1lf(F:%6.1lf,R:%6.1lf,S:%6.1lf)"
					, dRealPositionOfNow
					, dRealPositionOfFirstDetect
					, dRealPositionOfSecondDetect
					, dRealPositionOfSmallAddCheck
					);


			}
			else
			{

				pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet;//Tag.AccelOfSecond;
				pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;//Tag.AccelOfSecond;
				pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfSecondMet);//Tag.SpeedOfSecond;
				pCtrlInfo->Dynamic.dDist    = dRealDistSumToLimit;      // 현재 위치에서 Second 길이의 2배 위치까지

				memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
	//          pCtrlInfo->Dynamic.AdditionalInfo.bStartOnSpeedDown     = true;
				pCtrlInfo->Dynamic.AdditionalInfo.bUseSmallAdd              = true;

#if((OHT_NAME == OHT_NAME_STD_V85) || (OHT_NAME == OHT_NAME_STD_V81S))
				pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 57;
#else
				pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 54;
#endif

				pCtrlInfo->Dynamic.AdditionalInfo.bIsTriggerOnRisingEdge    = false;
				pCtrlInfo->Dynamic.AdditionalInfo.dSmallDistance            = MarkParam.Dist.dAddDistAfterSecondMet;//Tag.AddLengthForSecond;

				pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;//Event.Flag.MarkEvent_FirstMet = true;

				ADD_LOG("Small Add Move 2.5mm 2-3, Pos=%6.1lf(F:%6.1lf,R:%6.1lf,S:%6.1lf)"
					, dRealPositionOfNow
					, dRealPositionOfFirstDetect
					, dRealPositionOfSecondDetect
					, dRealPositionOfSmallAddCheck
					);
			}

		}
		//2 4)  기타 이동 중 처리
		else
		{

		}


		//추가된 부분
		if((pMarkState->FirstMet == true) && (bIsOHTDetectIngnore ==false))
		{
			double dTempDistance = dRealPositionOfNow - dRealPositionOfFirstDetect;

			if((dTempDistance >80) &&(dTempDistance < 300))
				bIsOHTDetectIngnore = true;
		}
        return nTmpError;
    }
    // --------------------------------------------------------------------------------------------------------------------------------------
    //1 3. Rear/Front 미감지 된 경우
    // --------------------------------------------------------------------------------------------------------------------------------------
    else
	{
		if((PreMarkState.FirstMet == true) && ( PreMarkState.SecondMet == false ))
		{
			  if(bDetectFirst==false)
			  {
				m_DiagManager->IncreasePreviosDiagCount(PREVIOS_DIAG_TR);
					m_mccparam.nFrontSensorHuntingCount++;
				ADD_MD_LOG("TR Cur Station : %6d", nTmpTargetID);
			  }
        }

        //2 1)  Front 감지되었다가 넘어간 경우
		if(( PreMarkState.FirstMet == true ) || ( PreMarkState.SecondMet == true ))//pMarkStatus->StateOnFirstMet == true )
        {

            if( PreMarkState.OverRun==false)//pMarkStatus->StateOnOverRunBack==false && CurrStatus->StopWithoutFrontDetect == false )
            {
                if( bStopWithoutFrontDetect == false )
                {
					if( (bCheckTargetIsNearTargetDist==false)   // Manual 명령 처리
					||  (dRealPositionOfNow>dRealDistSumToTarget+120)    // 타겟 거리보다 20mm 더 먼 곳
					||  (   (dRealPositionOfFirstMetWithNoDetectStart!=0.0) // Front 시작 점 부터 거리
						&&	(dRealPositionOfFirstMetWithNoDetectStart > dRealPositionOfIdReadedCheckingPoint)
						&&  (dRealPositionOfNow>dRealPositionOfFirstMetWithNoDetectStart
												+MarkParam.Dist.dDistFromFirstToSecond
												+MarkParam.Dist.dLengthOfSecond+80)
						)
					||  (   (dRealPositionOfSecondMet!=0.0) // Rear 만난 경우 그 위치에서 Rear 감지거리 만큼 더
						&&  (dRealPositionOfSecondMet > dRealPositionOfIdReadedCheckingPoint)
					    &&  (dRealPositionOfSecondDetect > dRealPositionOfFirstDetect)
						&&  (dRealPositionOfNow>dRealPositionOfSecondMet
												+MarkParam.Dist.dLengthOfSecond)
						)
					||  ( 	(bCheckFrontBackStep == true)
						&&	(dRealPositionOfNow > dRealCheckFrontBackPoint)
					)
					)
					{
                        pMarkState->OverRun = true;
                        //1 >>>MoveStop
						pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfFirstMet*2;//Tag.AccelOfSecond;
                        pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;

                        ADD_LOG("MoveStop(OverRun) 3, Pos=%6.1lf(F:%6.1lf,R:%6.1lf,S:%6.1lf) (%6.1lf:%6.1lf:%6.1lf:%6.11f)"
                            , dRealPositionOfNow
                            , dRealPositionOfFirstDetect
                            , dRealPositionOfSecondDetect
							, dRealPositionOfSmallAddCheck
                            , dRealDistSumToTarget
                            , dRealPositionOfFirstMetWithNoDetectStart
							, dRealPositionOfSecondMet
							, dRealCheckFrontBackPoint
							);


					}

				}
				else
				{
					//Auto Manual 모두 동일하게 처리 mark 동작 Test 진행해볼 것
					if(//(bCheckTargetIsNearTargetDist==true) &&  //메뉴얼 명령이 아닐때만
						(dRealPositionOfSecondDetect==0.0) // Front만 감지되고 멈춘경우
						||((dRealPositionOfSecondDetect!=0.0) // Rear 만난 경우 그 위치에서 Rear 감지거리 만큼 더
						&&  (dRealPositionOfSecondDetect > dRealPositionOfIdReadedCheckingPoint)
						&&  (dRealPositionOfSecondDetect > dRealPositionOfFirstDetect)
						&&  (dRealPositionOfNow>dRealPositionOfSecondDetect)))
						{
							pMarkState->OverRun = true;
							//1 >>>MoveStop
							pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfFirstMet*2;//Tag.AccelOfSecond;
							pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;

							ADD_LOG("MoveStop_2(OverRun) 4, Pos=%6.1lf(F:%6.1lf,R:%6.1lf,S:%6.1lf) (%6.1lf:%6.1lf:%6.1lf)"
								, dRealPositionOfNow
								, dRealPositionOfFirstDetect
								, dRealPositionOfSecondDetect
								, dRealPositionOfSmallAddCheck
								, dRealDistSumToTarget
								, dRealPositionOfFirstMetWithNoDetectStart
								, dRealPositionOfSecondMet
								);
						}

						ADD_LOG("Eeception:MoveStop_2(OverRun) 3, Pos=%6.1lf(F:%6.1lf,R:%6.1lf,S:%6.1lf) (%6.1lf:%6.1lf:%6.1lf)"
                            , dRealPositionOfNow
                            , dRealPositionOfFirstDetect
                            , dRealPositionOfSecondDetect
							, dRealPositionOfSmallAddCheck
                            , dRealDistSumToTarget
                            , dRealPositionOfFirstMetWithNoDetectStart
                            , dRealPositionOfSecondMet
							);

				}
			}
			else if(PreMarkState.OverRun==true)
			{
				if( bStopWithoutFrontDetect == true)
				{
					pMarkState->Recovery=true;

					if(nRecoveryCountTagStation2 < 7)
					{
						Sleep(50);
						nRecoveryCountTagStation2++;
						// Second Met을 활성화 하는 이유:   Second 만나고 아래 완료 루틴으로 들어가게 하려함
	//                  pMarkState->OverRun = true; //pMarkStatus->StateOnOverRunBack = true;
						//1     >>>Second 넘어간 경우:  Small Add Move -2.5mm
						pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet;//Tag.AccelOfSecond;                        123123
						pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;//Tag.AccelOfSecond;
						pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfSecondMet);//Tag.SpeedOfSecond;

						if(((dRealPositionOfSecondDetect > dRealPositionOfNow) && ( dRealPositionOfSecondDetect < dRealDistSumToLimit)) ||   //Sensor감지된 위치가 현재보다 전방에 있고, Limit거리가 안넘었을 경우는 전방으로 탐색
							((dRealPositionOfIdReadedCheckingPoint <dRealPositionOfNow) && (dRealPositionOfSecondDetect < dRealPositionOfFirstDetect)) ||   //Front가 SecondDetect보다 클경우는 전방으로 탐색
							((dRealPositionOfFirstDetect ==0) || (dRealPositionOfSecondDetect ==0))) //Front or RearDectect가 하나라도 0일 경우는 전방으로 탐색
							pCtrlInfo->Dynamic.dDist    = dRealDistSumToLimit;      // 현재 위치에서 Second 길이의 2배 위치까지
						else
							pCtrlInfo->Dynamic.dDist = dRealPositionOfNow - 50.0;     // 현재 위치에서 Second 감지 거리의 2배 위치까지

						if((bCheckFrontBackStep == true) &&	(dRealPositionOfNow > dRealCheckFrontBackPoint))
						{
							pCtrlInfo->Dynamic.dDist = dRealPositionOfNow - 60.0;//
						}
						memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));

						pCtrlInfo->Dynamic.AdditionalInfo.bUseSmallAdd              = true;
#if((OHT_NAME == OHT_NAME_STD_V85) || (OHT_NAME == OHT_NAME_STD_V81S))
						pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 57;
#else
						pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 54;
#endif

						pCtrlInfo->Dynamic.AdditionalInfo.bIsTriggerOnRisingEdge    = false;
						pCtrlInfo->Dynamic.AdditionalInfo.dSmallDistance            = MarkParam.Dist.dAddDistAfterSecondMet;//Tag.AddLengthForSecond;


						pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;//Event.Flag.MarkEvent_BackFromOverRun= true;

						ADD_LOG("Small Add Move -2.5mm 3-1, Pos=%6.1lf(F:%6.1lf,R:%6.1lf,S:%6.1lf)"
							, dRealPositionOfNow
							, dRealPositionOfFirstDetect
							, dRealPositionOfSecondDetect
							, dRealPositionOfSmallAddCheck
							);
					}
					else
					{
						nRecoveryCountTagStation2 = 0;

						pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
						pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
						nTmpError = ERR_NOTMATCH_TAGLENGTH_FINALSTATION_IN_POSITION_ERROR;
						ADD_FDC_LOG("ERR/%d/3/10/%06d/%06d/%d/%d/%06d/%%6.1lf/%%6.1lf/%%6.1lf/%%6.1lf/%d",
										ERR_NOTMATCH_TAGLENGTH_FINALSTATION_IN_POSITION_ERROR,
										m_pOHTMainStatus->StatusCommon.CurNodeID,
										m_pExecuteInfo->ExecutePositionInfo.NextNode,
										m_pOHTMainStatus->StatusCommon.CurNodeOffset,
										m_pOHTMainStatus->StatusCommon.ExistFoup,
										m_pOHTMainStatus->StatusCommon.StopStationID,
										dRealPositionOfNow,
										dRealPositionOfSmallAddCheck,
										MarkParam.Dist.dAddDistAfterSecondMet,
										MarkParam.Dist.dMarkInPosLimit,
										bAxis1InPosition);
					}
                }

			}
        }
        //2 2)  정상 Routine으로 센서가 아직 감지되지 않은 경우: small add move 시작(125mm : 0.50mm/msec : 0.0010 mm/msec2 )
        else if( PreMarkState.OnRoutineIn == false )//pMarkStatus->StateOnStopRoutineIn== false)
		{

				pMarkState->OnRoutineIn = true; //pMarkStatus->StateOnStopRoutineIn = true;

				//1 >>>Small Add Move 125mm
				pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfFirstMet;//Tag.AccelOfFirst;
				pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfFirstMet;//Tag.AccelOfFirst;
				pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfFirstMet);//Tag.SpeedOfFirst;
				pCtrlInfo->Dynamic.dDist    = dRealDistSumToLimit;      // 현재 위치에서 Second 길이의 2배 위치까지

				memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
	//          pCtrlInfo->Dynamic.AdditionalInfo.bStartOnSpeedDown     = true;
				pCtrlInfo->Dynamic.AdditionalInfo.bUseSmallAdd              = true;
#if((OHT_NAME == OHT_NAME_STD_V85) || (OHT_NAME == OHT_NAME_STD_V81S))
				pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 56;
#else
				pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 53;
#endif
				pCtrlInfo->Dynamic.AdditionalInfo.bIsTriggerOnRisingEdge    = false;
				pCtrlInfo->Dynamic.AdditionalInfo.dSmallDistance            = MarkParam.Dist.dAddDistAfetrFirstMet;//125;//Tag.AddLengthForFirst;

				pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;//Event.Flag.MarkEvent_NextIsStop_and_SpeedDown   = true;

				ADD_LOG("Small Add Move 125mm 3-2, Pos=%6.1lf(F:%6.1lf,R:%6.1lf,S:%6.1lf)"
					, dRealPositionOfNow
					, dRealPositionOfFirstDetect
					, dRealPositionOfSecondDetect
					, dRealPositionOfSmallAddCheck
					);

		}
        //// 300mm 대응 무시 구간 추가 코드 puting
		else if(bCheckInit == true)
		{
			////// 300mm 대응 무시 구간 추가 코드 puting
			if(bCheckInitStop == true)
			{
				bCheckInitStop = false;
				pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;//Tag.AccelOfSecond;
				pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;

				return nTmpError;
			}
			bCheckInit = false;

			pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfFirstMet;//Tag.AccelOfFirst;
			pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfFirstMet;//Tag.AccelOfFirst;
			pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfFirstMet);//Tag.SpeedOfFirst;
			pCtrlInfo->Dynamic.dDist    = dRealDistSumToLimit;      // 현재 위치에서 Second 길이의 2배 위치까지

			memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));

			pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;//Event.Flag.MarkEvent_NextIsStop_and_SpeedDown   = true;

			ADD_LOG("Small Add Move 125mm 3-2-1, Pos=%6.1lf(F:%6.1lf,R:%6.1lf,S:%6.1lf)"
				, dRealPositionOfNow
				, dRealPositionOfFirstDetect
				, dRealPositionOfSecondDetect
				, dRealPositionOfSmallAddCheck
				);

		}
		//2 3)  정지 한 경우: 현재 위치 확인 후 에러  혹은 small add move
        else if( bStopWithoutFrontDetect == true )
        {
            //1 >>>Small Add Move 125mm
            pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfFirstMet;//Tag.AccelOfFirst;
            pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfFirstMet;//Tag.AccelOfFirst;
            pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfFirstMet);//Tag.SpeedOfFirst;
            pCtrlInfo->Dynamic.dDist    = dRealDistSumToLimit;      // 현재 위치에서 Second 길이의 2배 위치까지

            memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
//          pCtrlInfo->Dynamic.AdditionalInfo.bStartOnSpeedDown     = true;
            pCtrlInfo->Dynamic.AdditionalInfo.bUseSmallAdd              = true;

#if((OHT_NAME == OHT_NAME_STD_V85) || (OHT_NAME == OHT_NAME_STD_V81S))
			pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 56;
#else
			pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 53;
#endif

            pCtrlInfo->Dynamic.AdditionalInfo.bIsTriggerOnRisingEdge    = false;
            pCtrlInfo->Dynamic.AdditionalInfo.dSmallDistance            = MarkParam.Dist.dAddDistAfetrFirstMet;//125;//Tag.AddLengthForFirst;

            pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;//Event.Flag.MarkEvent_NextIsStop_and_SpeedDown   = true;

            ADD_LOG("Small Add Move 125mm 3-3, Pos=%6.1lf(F:%6.1lf,R:%6.1lf,S:%6.1lf)"
                , dRealPositionOfNow
                , dRealPositionOfFirstDetect
                , dRealPositionOfSecondDetect
                , dRealPositionOfSmallAddCheck
                );
        }
        //2 4)  기타 이동 중 처리
        else
        {

        }
        return nTmpError;
    }

    return nTmpError;

}

/**
@brief   DrivingControl Mark 구동 정보 획득 함수(TagStation_Back)
@author  puting
@date    2013.07.01
*/
int DrivingControl::markOnTagStationBack(DRIVING_HW_INFO_SET HwInfo, double dRealDistSumToTarget, double dSpeedLimit, int nTargetID, DRIVING_MARK_STATE* pMarkState, CTRL_INFO_OF_SYNC_AXIS_MOVE* pCtrlInfo, CTRL_INFO_OF_ID_READER_CMD_TYPE *pIdReaderCmdType, int* pnID)
{
	int     nTmpID = 0;
    static int nReadedID = 0;
    static int nTmpTargetID =0;
    static bool bIdReaded = false;
	static DWORD dwCheckTime = 0;
	static DWORD dwTriggerTime = 0;
	DWORD   dwCurrTime = timeGetTime();


    int     nTmpError = NO_ERR;

    memset(pCtrlInfo, 0x00, sizeof(CTRL_INFO_OF_SYNC_AXIS_MOVE));
    *pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_NONE;

    DRIVING_MARK_STATE PreMarkState = *pMarkState;
    DRIVING_MARK_PARAM MarkParam = m_pParamSet->Mark[1];

    static bool bNoSensorDetected = false;  // Mark Routine 시작 할 때 Front/Rear가 모두 Off 되었을 때 True
    static bool bPauseSecondSmallMove = false;  // bNoSensorDetected 사 true 인 경우 Second Small Move를 정위치 근처까지 지연 시키는 Flag
    static double dRealPositionOfFirstMetWithNoDetectStart = 0.0;   // Front 감지 되지 않은 상태에서 Mark 시작하여 처음 감지된 때, Front 감지된 위치
    static double dRealPositionOfSecondMet = 0.0;   // Front 감지 되지 않은 상태에서 Mark 시작하여 처음 감지된 때, Front 감지된 위치
    static bool bCheckTargetIsNearTargetDist = false;   // Target이 dRealDistSumToTarget 근처에 있는 경우로 nTargetID 이 0이 아닐 경우 true로 설정
    static bool bIgnoreFrontRearDetect = false; // Target이 dRealDistSumToTarget 근처에 있는 경우 Target 근처 이외에에서의 Front 센서 감지 무시

    // --------------------------------------------------------------------------------------------------------------------------------------
    //1 0. 정보 획득
    // --------------------------------------------------------------------------------------------------------------------------------------
    nTmpID = HwInfo.TagStaion.nBcrId;

    bool    bDetectFirst                = HwInfo.IO.TagStationFrontOn;
    bool    bDetectSecond               = HwInfo.IO.TagStationRearOn;

	bool    bAxis1InPosition            = HwInfo.IO.Axis1InPosition;
	bool	bAxis1Running				= HwInfo.IO.Axis1Running;

    static  TIME_CHECK  StopWithoutFrontDetect;

	static	int			nRecoveryLimitCount4TagStation = 0;

	bool    bStopWithoutFrontDetect = false;

#if(UBG_SENSOR_ENABLE == ON)
//   if(bAxis1Running==false && HwInfo.IO.ObsStatus!=DETECT_AND_STOP && HwInfo.IO.DetectStatus!=DETECT_AND_STOP)
 		if(bAxis1Running==false
	&& ((HwInfo.IO.DetectStatus!=DETECT_AND_STOP) || (pHWSet->GetAMCVHLDetectStatus() ==0)))
#else
    if(bAxis1Running==false && HwInfo.IO.ObsStatus!=DETECT_AND_STOP)
#endif
	{
        if(StopWithoutFrontDetect.bFlag==false)
        {
            StopWithoutFrontDetect.dwTime = dwCurrTime;
            StopWithoutFrontDetect.bFlag = true;
        }
		else if(OHTUTILITY::PreventOverflowGetTimeMs(StopWithoutFrontDetect.dwTime)>200)
        {
			bStopWithoutFrontDetect = true;
		}
    }
    else
    {
        StopWithoutFrontDetect.bFlag = false;
        bStopWithoutFrontDetect = false;
    }


	double  dRealDistSumToLimit             = (dRealDistSumToTarget-(MarkParam.Dist.dForwardMoveDistLimit));  ///< 전지 거리
	double  dSpeedOfNow                     = HwInfo.Axis1.dSpeed;              //m_pDrivingAxis->GetCurrentPosition(); //미보정 현재 위치
    double  dRealPositionOfNow              = HwInfo.Axis1.dCurrPos;            //m_pDrivingAxis->GetCurrentPosition(); //미보정 현재 위치
    double  dRealPositionOfFirstDetect      = HwInfo.TagStaion.dFrontPosition;  // First Sensor 감지 미보정 엔코더 값
    double  dRealPositionOfSecondDetect     = HwInfo.TagStaion.dRearPosition;   // Final Sensor 감지 미보정 엔코더 값
    double  dRealPositionOfSmallAddCheck    = HwInfo.Axis1.dSmallAddCheckPos;   // SmallAddCheck 위치
    static  double  dRealPositionOfMostPositive = 0.0;                      // 최대로 멀리갔을 때의 거리
    static  double  dRealPositionOfIdReaded     = 0.0;                      // 최대로 멀리갔을 때의 거리
	static  double dRefSpeedOnSecondMeet = 0.2;

    if(PreMarkState.OnRoutineIn==false)
    {
        StopWithoutFrontDetect.bFlag = false;
        StopWithoutFrontDetect.dwTime = dwCurrTime;
		dwCheckTime = dwCurrTime;
		dwTriggerTime = dwCurrTime;
        nReadedID = 0;
        nTmpTargetID = nTargetID;
        bCheckTargetIsNearTargetDist = (nTargetID==0)?false:true;
        bIgnoreFrontRearDetect = (bCheckTargetIsNearTargetDist==true)?true:false;
        bIdReaded = false;
        dRealPositionOfMostPositive = dRealPositionOfNow;
        dRealPositionOfIdReaded     = 0.0;
        bNoSensorDetected = (bDetectFirst==false&&bDetectSecond==false)?true:false;
        bPauseSecondSmallMove = (bNoSensorDetected==true)?true:false;
        dRealPositionOfFirstMetWithNoDetectStart = 0.0;
        dRealPositionOfSecondMet = 0.0;
        dRefSpeedOnSecondMeet = sqrt(2*MarkParam.Accel.dOfFirstMet*MarkParam.Dist.dAddDistAfterSecondMet);  // v = sqrt( 2 * a * S) : 감속 거리의 최대 진입 속도
		dRefSpeedOnSecondMeet = MAX(MarkParam.Speed.dOfSecondMet, dRefSpeedOnSecondMeet);
		nRecoveryLimitCount4TagStation = 0;
		ADD_LOG("markOnTagStation Back Init: Sensor[%d:%d-->%d] Target:%6d %f"
			, bDetectFirst, bDetectSecond, bNoSensorDetected, nTmpTargetID,dRealDistSumToLimit);
    }
    else
    {
        dRealPositionOfMostPositive = (dRealPositionOfNow<dRealPositionOfMostPositive)?dRealPositionOfNow:dRealPositionOfMostPositive;
		//ADD_LOG("dRealPositionOfMostPositive Back %6.11f",dRealPositionOfMostPositive);
	}


    //2 주행 중 이전 Tag 만난 경우 채터링
#if 0
    if(bIgnoreFrontRearDetect==true)
	{
//		ADD_LOG("Test KKS1");
		if(dRealPositionOfNow>(dRealDistSumToTarget+300))
		{
//			ADD_LOG("Test KKS2");

			if(bDetectFirst==true)
			{
				bDetectFirst = false;
				bDetectSecond = false;
				bNoSensorDetected = true;
				bPauseSecondSmallMove=false;
//				ADD_LOG("Test KKS3");
			}
		}
		else
		{
//			ADD_LOG("Test KKS4");

			bIgnoreFrontRearDetect=false;// 무시 구간 지나가면 동일 처리
			if(bDetectFirst==true)
			{
				bNoSensorDetected = (bDetectFirst==false&&bDetectSecond==false)?true:false;
				bPauseSecondSmallMove = (bNoSensorDetected==true)?true:false;
				PreMarkState.OnRoutineIn = false;
//				ADD_LOG("Test KKS5");
            }
        }
    }
#endif

    //2 First 만나고 일정 거리 경과 및 감속 후, 두번째 Small Add(저속) 지연해서 실시 하기 위해
    if((bNoSensorDetected==true) && ((bDetectFirst==true)||(bDetectSecond==true)) )
    {
        bNoSensorDetected=false;
        dRealPositionOfFirstMetWithNoDetectStart = dRealPositionOfNow;
    }
	if((bNoSensorDetected==false)&&(bPauseSecondSmallMove==true))
    {
        if(((dRealPositionOfNow-dRealPositionOfFirstMetWithNoDetectStart)<(MarkParam.Dist.dAddDistAfetrFirstMet/2))||
            (dSpeedOfNow>(dRefSpeedOnSecondMeet+2.0)))  //2.0 은 안전율 ( 1.0m/s2 감속 시 0.2초동안 감속되는 속도 )
        {
            bPauseSecondSmallMove=false;
        }
        else
        {
			ADD_LOG("markOnTagStation Back [bPauseSecondSmallMove] Dist[%d]: %6.1lf:%6.1lf < %6.1lf  / Speed[%d]: %6.1lf > %6.1lf+2.0",
                ((dRealPositionOfNow-dRealPositionOfFirstMetWithNoDetectStart)<(MarkParam.Dist.dAddDistAfetrFirstMet/2)),
                dRealPositionOfNow, dRealPositionOfFirstMetWithNoDetectStart, MarkParam.Dist.dAddDistAfetrFirstMet,
                (dSpeedOfNow>(dRefSpeedOnSecondMeet+2.0)),
                dSpeedOfNow, dRefSpeedOnSecondMeet);
        }
	}

    if(nTmpTargetID==0 && nTmpID!=0)
    {
        nTmpTargetID = nTmpID;
		ADD_LOG("markOnTagStation Back:  nTmpID=%d:%d", nTmpID, nTmpTargetID);
	}

	if(nTmpID==nTmpTargetID&&nTmpTargetID!=0)
	{
		bIdReaded = true;
		dRealPositionOfIdReaded = dRealPositionOfNow;
		nReadedID = nTmpID;
		ADD_LOG("markOnTagStation Back:  bIdReaded=%d, Pos=%6.1lf(F:%6.1lf,R:%6.1lf,S:%6.1lf), ID=%d"
            , bIdReaded
            , dRealPositionOfIdReaded
            , dRealPositionOfFirstDetect
            , dRealPositionOfSecondDetect
            , dRealPositionOfSmallAddCheck
            , nReadedID);
    }
	else if(nTmpID!=0)
	{
     	ADD_LOG("markOnTagStation Back:  bIdReaded=%d, nTmpID=%d"
            , bIdReaded,nTmpID);
    }


    //2 근접 제어 센서를 Off 시키는 조건
    if(pMarkState->FollowCtrlOffArea==false)
    {
		pMarkState->FollowCtrlOffArea=true;
    }

	if(pHWSet->GetAMCVHLDetectStatus() ==1)
	{
		m_pDrivingAxis->SetVHLDetectIgnor();
		m_bIsAMCVHLDetectIgnore = true;
	}

	// --------------------------------------------------------------------------------------------------------------------------------------
    //1 0. 에러 처리
    // --------------------------------------------------------------------------------------------------------------------------------------
    if(dRealPositionOfNow < dRealDistSumToLimit)
    {
        pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
        pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
		nTmpError = ERR_NOTMATCH_TAGLENGTH_FINALSTATION_TAG_MET_LATE;

		ERR_LOG("[Tag Back] ERR_NOTMATCH_TAGLENGTH_FINALSTATION_TAG_MET_LATE : %6.1lf > %6.1lf (%6.1lf + %6.1lf) Pos=%6.1lf(F:%6.1lf,R:%6.1lf,S:%6.1lf)"
			, dRealPositionOfNow, dRealDistSumToLimit, dRealDistSumToTarget, MarkParam.Dist.dForwardMoveDistLimit
			, dRealPositionOfNow
			, dRealPositionOfFirstDetect
			, dRealPositionOfSecondDetect
			, dRealPositionOfSmallAddCheck
			);
		return nTmpError;
	}
	else if(dRealPositionOfNow>(dRealPositionOfMostPositive+(MarkParam.Dist.dBackMoveDistLimit*200)))
	{
		pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
		pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
		nTmpError = ERR_NOTMATCH_TAGLENGTH_FINALSTATION_TAG_MOVE_BACK_LIMIT;
        ERR_LOG("[Tag Back] ERR_NOTMATCH_TAGLENGTH_FINALSTATION_TAG_MOVE_BACK_LIMIT : %6.1lf < %6.1lf (%6.1lf - %6.1lf) Pos=%6.1lf(F:%6.1lf,R:%6.1lf,S:%6.1lf)"
            , dRealPositionOfNow, (dRealPositionOfMostPositive-MarkParam.Dist.dBackMoveDistLimit)
            , dRealPositionOfMostPositive, MarkParam.Dist.dBackMoveDistLimit
            , dRealPositionOfNow
            , dRealPositionOfFirstDetect
            , dRealPositionOfSecondDetect
			, dRealPositionOfSmallAddCheck
            );
        return nTmpError;
	}


    // --------------------------------------------------------------------------------------------------------------------------------------
    //1 1. Second 감지된 경우
    // --------------------------------------------------------------------------------------------------------------------------------------
    if( bDetectSecond==true )
	{
//		ADD_LOG("bDetectSecond Step 1");
        //2 1) 마크 루틴 완료 후 id를 확인하는 절차
        if( PreMarkState.IdCheck==true)
        {
			if(pnID==NULL)
            {
                *pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_NONE;
				pMarkState->Arrived = true;
            }
            else
            {
                if(bIdReaded==true)
                {
					*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_NONE;
					ADD_LOG("markOnTagStation Back: pMarkState->Arrived=true, Pos=%6.1lf(F:%6.1lf,R:%6.1lf,S:%6.1lf T:%6.1lf %d [%d %d])"
						, dRealPositionOfNow
                        , dRealPositionOfFirstDetect
                        , dRealPositionOfSecondDetect
						, dRealPositionOfSmallAddCheck
						, dRealDistSumToTarget
						, nReadedID
						,bDetectFirst
						,bDetectSecond
                        );
                    pMarkState->Arrived = true;
					*pnID = nReadedID;
				}
				else if(OHTUTILITY::PreventOverflowGetTimeMs(dwTriggerTime) > 200)
                {
					if(OHTUTILITY::PreventOverflowGetTimeMs(dwCheckTime) > 3500)// Time Over
                    {
                        *pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_NONE;
                        pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
                        pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
						nTmpError = ERR_BCR_BACK_READTIMEOUT;
						*pnID = nTmpTargetID;//ID_NONE;/ID_NONE;


                        ADD_LOG("markOnTagStation Back: ERR_BCR_READTIMEOUT, Pos=%6.1lf(F:%6.1lf,R:%6.1lf,S:%6.1lf)"
                            , dRealPositionOfNow
							, dRealPositionOfFirstDetect
							, dRealPositionOfSecondDetect
							, dRealPositionOfSmallAddCheck );
					}
					else
					{
						dwTriggerTime = timeGetTime();
                        *pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
                    }
                }
            }
		}
		//처음에 Rear센서 감지된경우, 일정거리 뒤로 후진 함.  puting
		else if( PreMarkState.OnRoutineIn == false )
		{
			pMarkState->OnRoutineIn = true;

           	pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfFirstMet;//Tag.AccelOfFirst;
			pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfFirstMet;//Tag.AccelOfFirst;
			pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfFirstMet);//Tag.SpeedOfFirst;
			pCtrlInfo->Dynamic.dDist    = dRealPositionOfNow -(MarkParam.Dist.dAddDistAfetrFirstMet/3);      // 현재 위치에서 Second 길이의 2배 위치까지

			memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));

			pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;//Event.Flag.MarkEvent_NextIsStop_and_SpeedDown   = true;

			ADD_LOG("Small Add Move 125mm 3-2-1, Pos=%6.1lf(F:%6.1lf,R:%6.1lf,S:%6.1lf)"
				, dRealPositionOfNow
				, dRealPositionOfFirstDetect
				, dRealPositionOfSecondDetect
				, dRealPositionOfSmallAddCheck
				);

		}
        //2 2)  마크 루틴 처음 들어왔을 때 Rear 감지된 경우: 뒤로 5mm 이동 후 2. Front 감지 처리로 처리
		else if( PreMarkState.FirstMet == false )
        {
			ADD_LOG("PreMarkState.FirstMet Step 1");
            // Second Met을 활성화 하지 않은 이유:  First 만나고 아래 정상 루틴으로 들어가게 하려함
            // First Met을 활성화 하지 않은 이유:       5mm 이동 완료 시 까지 이부분 계속 호출 시키려고
			pMarkState->OnRoutineIn = true;

            if( bStopWithoutFrontDetect==true && PreMarkState.OnMoveCmd==false) // 정지 시 뒤로 이동
			{

                pMarkState->OnMoveCmd=true;

                //1 >>>엔코더 값이 -10mm이하일 경우 에러 처리
                //1 >>>Small Add Move -2.5mm(Second 벗어날때까지)
                pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet; //Tag.AccelOfSecond;
                pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet; //Tag.AccelOfSecond;
                pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfSecondMet);   //Tag.SpeedOfSecond;
                pCtrlInfo->Dynamic.dDist    = dRealPositionOfNow - (2*MarkParam.Dist.dLengthOfSecond);//.LengthOfSecond);   // 현재 위치에서 Second 길이의 2배 위치까지

                memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
//              pCtrlInfo->Dynamic.AdditionalInfo.bStartOnSpeedDown     = true;
				pCtrlInfo->Dynamic.AdditionalInfo.bUseSmallAdd              = true;

#if((OHT_NAME == OHT_NAME_STD_V85) || (OHT_NAME == OHT_NAME_STD_V81S))
				pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 57;
#else
				pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 54;
#endif

                pCtrlInfo->Dynamic.AdditionalInfo.bIsTriggerOnRisingEdge    = true;
                pCtrlInfo->Dynamic.AdditionalInfo.dSmallDistance            = MarkParam.Dist.dAddDistAfterSecondMet;//Tag.AddLengthForSecond;

                pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;//Event.Flag.MarkEvent_SecondMet = true;
				ADD_LOG("Small Add Back: Abnormal SecondMet & Move Back 10, Pos=%6.1lf(F:%6.1lf,R:%6.1lf,S:%6.1lf[%d %d])"
					, dRealPositionOfNow
                    , dRealPositionOfFirstDetect
                    , dRealPositionOfSecondDetect
					, dRealPositionOfSmallAddCheck
					,bDetectFirst
					,bDetectSecond
                    );
            }
        }
        //2 3)  정상 Routine으로 Rear 센서가 처음 들어온 경우: 정지 대기
        else if( PreMarkState.SecondMet==false)//pMarkStatus->StateOnSecondMet == false)
        {
            pMarkState->SecondMet = true;   //pMarkStatus->StateOnSecondMet = true;
            dRealPositionOfSecondMet = dRealPositionOfNow;
            ADD_LOG("Small Add Back: SecondMet %7.1lf, Pos=%6.1lf(F:%6.1lf,R:%6.1lf,S:%6.1lf[%d %d])"
                , HwInfo.Axis1.dCurrPos
                , dRealPositionOfNow
                , dRealPositionOfFirstDetect
                , dRealPositionOfSecondDetect
				, dRealPositionOfSmallAddCheck
				,bDetectFirst
				,bDetectSecond
                );
        }
        //2 4)  정지 한 경우: 정위치 확인 및 완료 처리
        else if( bStopWithoutFrontDetect == true )
        {
            ADD_LOG("Small Add Back: Stop (%6.1lf - %6.1lf = %6.1lf, Pos=%6.1lf(F:%6.1lf,R:%6.1lf,S:%6.1lf)[%d %d])"
                , dRealPositionOfNow, dRealPositionOfSmallAddCheck
                , (dRealPositionOfNow-dRealPositionOfSmallAddCheck)
                , dRealPositionOfNow
                , dRealPositionOfFirstDetect
                , dRealPositionOfSecondDetect
				, dRealPositionOfSmallAddCheck
				,bDetectFirst
				,bDetectSecond
                );


            //1 >>>Arrived
            // 도착위치와 센서 감지 위치를 비교하여 차가 2.5mm ±0.5 이면 정상 처리함 (전진 후진에 대해 모두 처리)
			if( (fabs(dRealPositionOfNow-dRealPositionOfSmallAddCheck)<(MarkParam.Dist.dAddDistAfterSecondMet+MarkParam.Dist.dMarkInPosLimit)) &&
				(fabs(dRealPositionOfNow-dRealPositionOfSmallAddCheck)>(MarkParam.Dist.dAddDistAfterSecondMet-MarkParam.Dist.dMarkInPosLimit)) &&
				(dRealPositionOfSmallAddCheck!=0.0) && (bAxis1InPosition == true) )
			{

				ADD_LOG("bStopWithoutFrontDetect Step 1");
                if( bDetectFirst==true && bDetectSecond==true )//m_pTransStopTag->IsOnFrontSensor()==true )
				{
                    ADD_LOG("bStopWithoutFrontDetect Step 2");
                    pMarkState->IdCheck=true;
                    *pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
					dwCheckTime = dwCurrTime;   // ID 확인 되지 않을 때에 대한 TimeOut 처리 목적
					dwTriggerTime = dwCurrTime;
                }
			}
            else    // 멈췄으나 정위치 되지 않을 때에 대한 처리
			{

				if(nRecoveryLimitCount4TagStation < RecoveryLimitCountForMarkOnTagStation)
				{

					if(bStopWithoutFrontDetect==true)
					{

						nRecoveryLimitCount4TagStation++;

						pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet;
						pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;
						pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfSecondMet);
						pCtrlInfo->Dynamic.dDist	= dRealPositionOfNow - (2*MarkParam.Dist.dLengthOfSecond);

						memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));

						pCtrlInfo->Dynamic.AdditionalInfo.bUseSmallAdd              = true;

#if((OHT_NAME == OHT_NAME_STD_V85) || (OHT_NAME == OHT_NAME_STD_V81S))
						pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 57;
#else
						pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 54;
#endif

						pCtrlInfo->Dynamic.AdditionalInfo.bIsTriggerOnRisingEdge    = true;
						pCtrlInfo->Dynamic.AdditionalInfo.dSmallDistance            = MarkParam.Dist.dAddDistAfterSecondMet;

						pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;

						ADD_LOG("Small Add Back: SecondMet Not In Pos, bAxis1InPosition(%d), dRealPositionOfNow(%6.1lf), dRealPositionOfSmallAddCheck(%6.1lf), MarkParam.Dist.dAddDistAfterSecondMet(%6.1lf), MarkParam.Dist.dMarkInPosLimit(%6.1lf) [%d %d]"
							, bAxis1InPosition
							, dRealPositionOfNow
							, dRealPositionOfSmallAddCheck
							, MarkParam.Dist.dAddDistAfterSecondMet
							, MarkParam.Dist.dMarkInPosLimit
							,bDetectFirst
							,bDetectSecond);
					}
				}
				else
				{

					nRecoveryLimitCount4TagStation = 0;

					pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
					pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
					nTmpError = ERR_NOTMATCH_TAGLENGTH_FINALSTATION_IN_POSITION_ERROR;

					ADD_LOG("Back [Error][ERR_NOTMATCH_TAGLENGTH_FINALSTATION_IN_POSITION_ERROR] bAxis1InPosition(%d), dRealPositionOfNow(%6.1lf), dRealPositionOfSmallAddCheck(%6.1lf), MarkParam.Dist.dAddDistAfterSecondMet(%6.1lf), MarkParam.Dist.dMarkInPosLimit(%6.1lf)"
							, bAxis1InPosition
							, dRealPositionOfNow
							, dRealPositionOfSmallAddCheck
							, MarkParam.Dist.dAddDistAfterSecondMet
							, MarkParam.Dist.dMarkInPosLimit );

					return nTmpError;
                }
			}
		}

		return nTmpError;
	}

	// --------------------------------------------------------------------------------------------------------------------------------------
    //1 2. First 감지 된 경우
    // --------------------------------------------------------------------------------------------------------------------------------------
    else if( bDetectFirst==true )
	{
//		ADD_LOG("bDetectFirst Step 1");
        if(PreMarkState.Recovery==true) //pMarkStatus->StateOnOverRunBack==true)
		{
			ADD_LOG("bDetectFirst Step 2");
            if( bStopWithoutFrontDetect == true )
            {

                //1 >>>에러 처리
            }
        }
        //2 1)  마크 루틴 처음 들어왔을 때 Front 감지된 경우: small add move 시작(2.5mm : 0.05mm/msec : 0.0005 mm/msec2 )
        else if( PreMarkState.OnRoutineIn==false )//pMarkStatus->StateOnStopRoutineIn == false)
        {
			pMarkState->FirstMet = true;        //pMarkStatus->StateOnFirstMet = true;
            pMarkState->OnRoutineIn = true; //pMarkStatus->StateOnStopRoutineIn = true;
            ADD_LOG("bDetectFirst Step 3");
            //1 >>>Small Add Move 2.5mm
            pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet;//Tag.AccelOfSecond;
            pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;//Tag.AccelOfSecond;
            pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfSecondMet);//Tag.SpeedOfSecond;
            pCtrlInfo->Dynamic.dDist    = dRealPositionOfNow + MarkParam.Dist.dAddDistAfetrFirstMet;      // 현재 위치에서 Second 길이의 2배 위치까지

            memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
//          pCtrlInfo->Dynamic.AdditionalInfo.bStartOnSpeedDown     = true;
            pCtrlInfo->Dynamic.AdditionalInfo.bUseSmallAdd              = true;

#if((OHT_NAME == OHT_NAME_STD_V85) || (OHT_NAME == OHT_NAME_STD_V81S))
			pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 57;
#else
			pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 54;
#endif

            pCtrlInfo->Dynamic.AdditionalInfo.bIsTriggerOnRisingEdge    = false;
            pCtrlInfo->Dynamic.AdditionalInfo.dSmallDistance            = MarkParam.Dist.dAddDistAfterSecondMet;//Tag.AddLengthForSecond;

            pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;//Event.Flag.MarkEvent_FirstMet = true;

            ADD_LOG("Small Add Move Back 2.5mm 2-1, Pos=%6.1lf(F:%6.1lf,R:%6.1lf,S:%6.1lf [%d %d])"
                , dRealPositionOfNow
                , dRealPositionOfFirstDetect
                , dRealPositionOfSecondDetect
				, dRealPositionOfSmallAddCheck
				,bDetectFirst
				,bDetectSecond
                );


        }
        //2 2)  정상 Routine으로 Rear 센서가 처음 들어온 경우: small add move 시작(2.5mm : 0.05mm/msec : 0.0005 mm/msec2 )
        else if( PreMarkState.FirstMet == false )//pMarkStatus->StateOnFirstMet == false)
		{

            //1 정상 루틴으로 들어온 경우 지연 처리
            if(bPauseSecondSmallMove==false)
            {
                pMarkState->FirstMet = true;//pMarkStatus->StateOnFirstMet = true;

                //1 >>>Small Add Move 2.5mm
                pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet;//Tag.AccelOfSecond;
                pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;//Tag.AccelOfSecond;
                pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfSecondMet);//Tag.SpeedOfSecond;
				pCtrlInfo->Dynamic.dDist    = dRealPositionOfNow + MarkParam.Dist.dAddDistAfetrFirstMet;      // 현재 위치에서 Second 길이의 2배 위치까지

                memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
//              pCtrlInfo->Dynamic.AdditionalInfo.bStartOnSpeedDown     = true;
                pCtrlInfo->Dynamic.AdditionalInfo.bUseSmallAdd              = true;

#if((OHT_NAME == OHT_NAME_STD_V85) || (OHT_NAME == OHT_NAME_STD_V81S))
				pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 57;
#else
				pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 54;
#endif

                pCtrlInfo->Dynamic.AdditionalInfo.bIsTriggerOnRisingEdge    = false;
                pCtrlInfo->Dynamic.AdditionalInfo.dSmallDistance            = MarkParam.Dist.dAddDistAfterSecondMet;//Tag.AddLengthForSecond;

                pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;//Event.Flag.MarkEvent_FirstMet = true;

                ADD_LOG("Small Add back Move 2.5mm 2-2, Pos=%6.1lf(F:%6.1lf,R:%6.1lf,S:%6.1lf[%d %d])"
                    , dRealPositionOfNow
                    , dRealPositionOfFirstDetect
                    , dRealPositionOfSecondDetect
					, dRealPositionOfSmallAddCheck
					,bDetectFirst
					,bDetectSecond
                    );
            }

        }
        //2 3)  정지 한 경우: 현재 위치 확인 후 에러  혹은 small add move
        else if( bStopWithoutFrontDetect == true )
        {
            //1 >>>Small Add Move 2.5mm
            pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet;//Tag.AccelOfSecond;
            pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;//Tag.AccelOfSecond;
            pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfSecondMet);//Tag.SpeedOfSecond;
            pCtrlInfo->Dynamic.dDist    = dRealPositionOfNow + MarkParam.Dist.dAddDistAfetrFirstMet;      // 현재 위치에서 Second 길이의 2배 위치까지

            memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
//          pCtrlInfo->Dynamic.AdditionalInfo.bStartOnSpeedDown     = true;
            pCtrlInfo->Dynamic.AdditionalInfo.bUseSmallAdd              = true;

#if((OHT_NAME == OHT_NAME_STD_V85) || (OHT_NAME == OHT_NAME_STD_V81S))
			pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 57;
#else
			pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 54;
#endif

            pCtrlInfo->Dynamic.AdditionalInfo.bIsTriggerOnRisingEdge    = false;
            pCtrlInfo->Dynamic.AdditionalInfo.dSmallDistance            = MarkParam.Dist.dAddDistAfterSecondMet;//Tag.AddLengthForSecond;

            pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;//Event.Flag.MarkEvent_FirstMet = true;

            ADD_LOG("Small Add Back Move 2.5mm 2-3, Pos=%6.1lf(F:%6.1lf,R:%6.1lf,S:%6.1lf)[%d %d]"
                , dRealPositionOfNow
                , dRealPositionOfFirstDetect
                , dRealPositionOfSecondDetect
				, dRealPositionOfSmallAddCheck
				,bDetectFirst
				,bDetectSecond
                );

        }
        //2 4)  기타 이동 중 처리
        else
        {

        }
        return nTmpError;
    }
    // --------------------------------------------------------------------------------------------------------------------------------------
    //1 3. Rear/Front 미감지 된 경우
    // --------------------------------------------------------------------------------------------------------------------------------------
    else
    {
        //2 1)  Front 감지되었다가 넘어간 경우
        if( PreMarkState.FirstMet == true )//pMarkStatus->StateOnFirstMet == true )
        {

            if( PreMarkState.OverRun==false)//pMarkStatus->StateOnOverRunBack==false && CurrStatus->StopWithoutFrontDetect == false )
            {
                if( bStopWithoutFrontDetect == false )
                {
                    if( (bCheckTargetIsNearTargetDist==false)   // Manual 명령 처리
                    ||  (dRealPositionOfNow>dRealDistSumToTarget+20)    // 타겟 거리보다 20mm 더 먼 곳
                    ||  (   (dRealPositionOfFirstMetWithNoDetectStart!=0.0) // Front 시작 점 부터 거리
                        &&  (dRealPositionOfNow>dRealPositionOfFirstMetWithNoDetectStart
                                                +MarkParam.Dist.dDistFromFirstToSecond
                                                +MarkParam.Dist.dLengthOfSecond)
                        )
                    ||  (   (dRealPositionOfSecondMet!=0.0) // Rear 만난 경우 그 위치에서 Rear 감지거리 만큼 더
                        &&  (dRealPositionOfNow>dRealPositionOfSecondMet
                                                +MarkParam.Dist.dLengthOfSecond)
                        )

                    )
                    {
                        pMarkState->OverRun = true;
                        //1 >>>MoveStop
                        pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;//Tag.AccelOfSecond;
                        pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;

						ADD_LOG("MoveStop Back(OverRun) 3, Pos=%6.1lf(F:%6.1lf,R:%6.1lf,S:%6.1lf) (%6.1lf:%6.1lf:%6.1lf)[%d %d]"
							, dRealPositionOfNow
							, dRealPositionOfFirstDetect
							, dRealPositionOfSecondDetect
							, dRealPositionOfSmallAddCheck
							, dRealDistSumToTarget
							, dRealPositionOfFirstMetWithNoDetectStart
							, dRealPositionOfSecondMet
							,bDetectFirst
							,bDetectSecond
                            );
                    }
                }
            }
            else if(PreMarkState.OverRun==true)
            {
                if( bStopWithoutFrontDetect == true)
                {
                    pMarkState->Recovery=true;
                    // Second Met을 활성화 하는 이유:   Second 만나고 아래 완료 루틴으로 들어가게 하려함
//                  pMarkState->OverRun = true; //pMarkStatus->StateOnOverRunBack = true;
                    //1     >>>Second 넘어간 경우:  Small Add Move -2.5mm
                    pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet;//Tag.AccelOfSecond;
                    pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;//Tag.AccelOfSecond;
                    pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfSecondMet);//Tag.SpeedOfSecond;
                    pCtrlInfo->Dynamic.dDist    = dRealPositionOfNow-100.0;     // 현재 위치에서 Second 감지 거리의 2배 위치까지

                    memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
//                  pCtrlInfo->Dynamic.AdditionalInfo.bStartOnSpeedDown     = true;
                    pCtrlInfo->Dynamic.AdditionalInfo.bUseSmallAdd              = true;

#if((OHT_NAME == OHT_NAME_STD_V85) || (OHT_NAME == OHT_NAME_STD_V81S))
					pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 57;
#else
					pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 54;
#endif

                    pCtrlInfo->Dynamic.AdditionalInfo.bIsTriggerOnRisingEdge    = false;
                    pCtrlInfo->Dynamic.AdditionalInfo.dSmallDistance            = MarkParam.Dist.dAddDistAfterSecondMet;//Tag.AddLengthForSecond;

                    pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;//Event.Flag.MarkEvent_BackFromOverRun= true;

                    ADD_LOG("Small Add Back Move -2.5mm 3-1, Pos=%6.1lf(F:%6.1lf,R:%6.1lf,S:%6.1lf)[%d %d]"
                        , dRealPositionOfNow
                        , dRealPositionOfFirstDetect
                        , dRealPositionOfSecondDetect
						, dRealPositionOfSmallAddCheck
						,bDetectFirst
						,bDetectSecond
                        );
                }

            }
        }
        //2 2)  정상 Routine으로 센서가 아직 감지되지 않은 경우: small add move 시작(125mm : 0.50mm/msec : 0.0010 mm/msec2 )
        else if( PreMarkState.OnRoutineIn == false )//pMarkStatus->StateOnStopRoutineIn== false)
        {
            pMarkState->OnRoutineIn = true; //pMarkStatus->StateOnStopRoutineIn = true;

            //1 >>>Small Add Move 125mm
            pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfFirstMet;//Tag.AccelOfFirst;
            pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfFirstMet;//Tag.AccelOfFirst;
            pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfFirstMet);//Tag.SpeedOfFirst;
            pCtrlInfo->Dynamic.dDist    = dRealDistSumToLimit;      // 현재 위치에서 Second 길이의 2배 위치까지

            memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
//          pCtrlInfo->Dynamic.AdditionalInfo.bStartOnSpeedDown     = true;
            pCtrlInfo->Dynamic.AdditionalInfo.bUseSmallAdd              = true;

		   //	pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 53;
#if((OHT_NAME == OHT_NAME_STD_V85) || (OHT_NAME == OHT_NAME_STD_V81S))
			pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 57;
#else
			pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 54;
#endif

            pCtrlInfo->Dynamic.AdditionalInfo.bIsTriggerOnRisingEdge    = false;
			pCtrlInfo->Dynamic.AdditionalInfo.dSmallDistance            = (MarkParam.Dist.dAddDistAfetrFirstMet/3);//MarkParam.Dist.dAddDistAfterSecondMet;//MarkParam.Dist.dAddDistAfetrFirstMet;//125;//Tag.AddLengthForFirst;

            pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;//Event.Flag.MarkEvent_NextIsStop_and_SpeedDown   = true;

            ADD_LOG("Small Add Back Move 125mm 3-2, Pos=%6.1lf(F:%6.1lf,R:%6.1lf,S:%6.1lf)[%d %d]"
                , dRealPositionOfNow
                , dRealPositionOfFirstDetect
                , dRealPositionOfSecondDetect
				, dRealPositionOfSmallAddCheck
				,bDetectFirst
				,bDetectSecond
				);
        }
        //2 3)  정지 한 경우: 현재 위치 확인 후 에러  혹은 small add move
        else if( bStopWithoutFrontDetect == true )
        {
            //1 >>>Small Add Move 125mm
            pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfFirstMet;//Tag.AccelOfFirst;
            pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfFirstMet;//Tag.AccelOfFirst;
            pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfFirstMet);//Tag.SpeedOfFirst;
            pCtrlInfo->Dynamic.dDist    = dRealPositionOfNow + MarkParam.Dist.dAddDistAfetrFirstMet;      // 현재 위치에서 Second 길이의 2배 위치까지

            memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
//          pCtrlInfo->Dynamic.AdditionalInfo.bStartOnSpeedDown     = true;
            pCtrlInfo->Dynamic.AdditionalInfo.bUseSmallAdd              = true;

#if((OHT_NAME == OHT_NAME_STD_V85) || (OHT_NAME == OHT_NAME_STD_V81S))
			pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 57;
#else
			pCtrlInfo->Dynamic.AdditionalInfo.byTriggerIONumber         = 54;
#endif

            pCtrlInfo->Dynamic.AdditionalInfo.bIsTriggerOnRisingEdge    = false;
            pCtrlInfo->Dynamic.AdditionalInfo.dSmallDistance            = (MarkParam.Dist.dAddDistAfetrFirstMet/3);//125;//Tag.AddLengthForFirst;

            pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;//Event.Flag.MarkEvent_NextIsStop_and_SpeedDown   = true;

            ADD_LOG("Small Add Back Move 125mm 3-3, Pos=%6.1lf(F:%6.1lf,R:%6.1lf,S:%6.1lf)[%d %d]"
                , dRealPositionOfNow
                , dRealPositionOfFirstDetect
                , dRealPositionOfSecondDetect
				, dRealPositionOfSmallAddCheck
				,bDetectFirst
				,bDetectSecond
                );
        }
        //2 4)  기타 이동 중 처리
        else
        {

        }
        return nTmpError;
    }

    return nTmpError;

}
/**
@brief DrivingControl Mark 구동 정보 획득 함수(QRStation)
@author
@date    2013.07.01
*/
int DrivingControl::markOnQRStationDiffType(bool bIsLeft, DRIVING_HW_INFO_SET HwInfo, double dRealDistSumToTarget, double dSpeedLimit, int nTargetID, DRIVING_MARK_STATE* pMarkState, CTRL_INFO_OF_SYNC_AXIS_MOVE* pCtrlInfo, CTRL_INFO_OF_ID_READER_CMD_TYPE *pIdReaderCmdType, int* pnID)
{
	int     nTmpID = 0;
    static int nTmpTargetID =0;
    double  dOffset  = 0.0;
    static double dStaticQRCenterPosition = 0.0;
    static int nStaticQrReenableCount = 0;
    bool    bIdReaded = false;
	static DWORD dwStaticCheckTime = 0;
	static DWORD dwQRCheckTime = 0;
	static bool bQRRestart = false;
	static bool bQRRestartCompleted = false;
	static DWORD dwStaticQRRestartTime = 0;
	DWORD   dwCurrTime = timeGetTime();
	static int nCntMarkPos = 0;

	int     nTmpError = NO_ERR;

	// Omron QR Reader 용 16.02.03
	static CTRL_INFO_OF_ID_READER_CMD_TYPE	preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_NONE;

    memset(pCtrlInfo, 0x00, sizeof(CTRL_INFO_OF_SYNC_AXIS_MOVE));
	*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_NONE;

    DRIVING_MARK_STATE PreMarkState = *pMarkState;
    DRIVING_MARK_PARAM MarkParam;

    static CTRL_INFO_OF_SYNC_AXIS_MOVE NextCtrlInfo;
	static bool bNextCtrlInfoExist = false;
	static bool bFrontDetectOffAfterMoveS = false;
	static bool bNonSenseFlag = false;

	// --------------------------------------------------------------------------------------------------------------------------------------
    //1 0. 정보 획득
    // --------------------------------------------------------------------------------------------------------------------------------------
	if(bIsLeft==true)
	{
		MarkParam = m_pParamSet->Mark[2];
        nTmpID = HwInfo.QrStaionLeft.nQrId;
        dOffset = HwInfo.QrStaionLeft.dQrOffset;
    }
    else
    {
		MarkParam = m_pParamSet->Mark[3];
		nTmpID = HwInfo.QrStaionRight.nQrId;
        dOffset = HwInfo.QrStaionRight.dQrOffset;
    }

    bool    bAxis1InPosition            = HwInfo.IO.Axis1InPosition;
    static  TIME_CHECK  StopWithoutFrontDetect;
	bool    bStopWithoutFrontDetect = false;

//    if(HwInfo.IO.Axis1Running==false && HwInfo.IO.ObsStatus!=DETECT_AND_STOP && HwInfo.IO.DetectStatus!=DETECT_AND_STOP)
	if(HwInfo.IO.Axis1Running==false
	&& ((HwInfo.IO.DetectStatus!=DETECT_AND_STOP) || (pHWSet->GetAMCVHLDetectStatus() ==0)))
	{
		if(StopWithoutFrontDetect.bFlag==false)
        {
            StopWithoutFrontDetect.dwTime = dwCurrTime;
            StopWithoutFrontDetect.bFlag = true;
        }
		else if(OHTUTILITY::PreventOverflowGetTimeMs(StopWithoutFrontDetect.dwTime)>200)
        {
            bStopWithoutFrontDetect = true;
        }
    }
    else
    {
        StopWithoutFrontDetect.bFlag = false;
        bStopWithoutFrontDetect = false;
    }


	double  dSpeedOfNow          		       	= HwInfo.Axis1.dSpeed;      //m_pDrivingAxis->GetCurrentPosition(); //미보정 현재 위치
    double  dRealPositionOfNow                  = HwInfo.Axis1.dCurrPos;    //미보정 현재 위치
    static  double  dRealPositionOfMostPositive = 0.0;                      // 최대로 멀리갔을 때의 거리

	static 	double  dRealPositionOfFirstDetect = 0.0;
	static	double  dQROffset = 0.0;

	if(PreMarkState.OnRoutineIn==false)
    {
        StopWithoutFrontDetect.bFlag = false;
        StopWithoutFrontDetect.dwTime = dwCurrTime;
        dwStaticCheckTime = dwCurrTime;
        nTmpTargetID = nTargetID;
        dRealPositionOfMostPositive = dRealPositionOfNow;
        dStaticQRCenterPosition = 0.0;
        nStaticQrReenableCount = 0;
        memset(&NextCtrlInfo, 0x00, sizeof(CTRL_INFO_OF_SYNC_AXIS_MOVE));
		bNextCtrlInfoExist = false;
		bQRRestartCompleted = false;
		bQRRestart = false;
		dwStaticQRRestartTime = dwCurrTime;
		bFrontDetectOffAfterMoveS = false;
		bNonSenseFlag= false;

		ADD_MCC_LOG(",%s,DRV,QR MARK,Start,FOUP,%06d,%06d,%06d,%d,%6.1lf,Mark Type,%d",
					m_defualtparam->VHLName,
					m_mccparam.uSourceNode,
					m_mccparam.uTargetNode,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					dSpeedOfNow,
					m_InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType);
		m_mccparam.bMarkStartFlag = true;
		m_mccparam.dMarkStartSpeed = dSpeedOfNow;
		m_mccparam.dMarkStartDist = dRealPositionOfNow;
    }
    else
    {
        dRealPositionOfMostPositive = (dRealPositionOfNow>dRealPositionOfMostPositive)?dRealPositionOfNow:dRealPositionOfMostPositive;
    }

    if(nTmpTargetID==0 && nTmpID!=0)
    {
        nTmpTargetID = nTmpID;
    }
    bIdReaded = (nTmpID==nTmpTargetID&&nTmpTargetID!=0)?true:false;
    if(bIdReaded==true)
    {
        dStaticQRCenterPosition = dRealPositionOfNow + dOffset;
    }

	//2 근접 제어 센서를 Off 시키는 조건
//	if(pMarkState->FollowCtrlOffArea==false)
	if(pHWSet->GetAMCVHLDetectStatus() ==1)
	{

		if(PreMarkState.FirstMet==true)
//		if(PreMarkState.Arrived==true)
		{

			m_pDrivingAxis->SetVHLDetectIgnor();
			m_bIsAMCVHLDetectIgnore = true;
//			pMarkState->FollowCtrlOffArea=true;
			bFrontDetectOffAfterMoveS = false;
			bNonSenseFlag = true;
        }
    }
	if(pMarkState->FollowCtrlOffArea==false)
	{
		if(PreMarkState.Arrived==true)
		{
        	pMarkState->FollowCtrlOffArea=true;
		}
	}

	// 근접제어 센서 off이후 Move S 명령 추가
//	if(pMarkState->FollowCtrlOffArea==true && bFrontDetectOffAfterMoveS ==false)
	if(pHWSet->GetAMCVHLDetectStatus() ==0 && bFrontDetectOffAfterMoveS ==false && bNonSenseFlag ==true)
	{
       pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
	   pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
	   bFrontDetectOffAfterMoveS = true;
	   return nTmpError;
	}

    // --------------------------------------------------------------------------------------------------------------------------------------
    //1 0. 에러 처리
    // --------------------------------------------------------------------------------------------------------------------------------------
    if(dRealPositionOfNow>(dRealDistSumToTarget+MarkParam.Dist.dForwardMoveDistLimit))
    {
		pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
        pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
		nTmpError = (bIsLeft)?ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_LEFT_MET_LATE:ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_RIGHT_MET_LATE;
		ADD_FDC_LOG("ERR/%d/2/6/%06d/%06d/%d/%d/%06d/%6.1lf",
					nTmpError,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pExecuteInfo->ExecutePositionInfo.NextNode,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					m_pOHTMainStatus->StatusCommon.ExistFoup,
					m_pOHTMainStatus->StatusCommon.StopStationID,
					dRealPositionOfNow - (dRealDistSumToTarget+MarkParam.Dist.dForwardMoveDistLimit));
//		//오버런 처리
//		m_pExecuteInfo->FlagOverRunInfo.bCheck = true;
//		m_pExecuteInfo->FlagOverRunInfo.OverrunType = 0x02; //이적재
//		m_pExecuteInfo->FlagOverRunInfo.nFinalNode = nTmpTargetID;    //주행은 주행, 이적재는 이적재
//		m_pExecuteInfo->FlagOverRunInfo.dDrivingInitPosition = MarkParam.Dist.dForwardMoveDistLimit;

//		m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset =  MarkParam.Dist.dForwardMoveDistLimit;
		ERR_LOG("[QR Mark] ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_MET_LATE(Left%d): %6.1lf > %6.1lf (%6.1lf + %6.1lf)"
            , bIsLeft, dRealPositionOfNow, (dRealDistSumToTarget+MarkParam.Dist.dForwardMoveDistLimit)
            , dRealDistSumToTarget, MarkParam.Dist.dForwardMoveDistLimit);
        return nTmpError;
    }
    else if(dRealPositionOfNow<(dRealPositionOfMostPositive-MarkParam.Dist.dBackMoveDistLimit))
    {
        pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
        pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
        nTmpError = (bIsLeft)?ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_LEFT_MOVE_BACK_LIMIT:ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_RIGHT_MOVE_BACK_LIMIT;
        ERR_LOG("[QR] ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_MOVE_BACK_LIMIT(Left%d): %6.1lf < %6.1lf (%6.1lf - %6.1lf)"
            , bIsLeft
            , dRealPositionOfNow, (dRealPositionOfMostPositive-MarkParam.Dist.dBackMoveDistLimit)
            , dRealPositionOfMostPositive, MarkParam.Dist.dBackMoveDistLimit);
		ADD_FDC_LOG("ERR/%d/1/8/%06d/%06d/%d/%d/%06d/%f/%f/%f",
					nTmpError,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pExecuteInfo->ExecutePositionInfo.NextNode,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					m_pOHTMainStatus->StatusCommon.ExistFoup,
					m_pOHTMainStatus->StatusCommon.StopStationID,
					dRealPositionOfNow,
					dRealPositionOfMostPositive,
					MarkParam.Dist.dBackMoveDistLimit);
        return nTmpError;
    }

    // --------------------------------------------------------------------------------------------------------------------------------------
    //1 1. Target 위치로 정위치 이동 중
	// --------------------------------------------------------------------------------------------------------------------------------------
    if(PreMarkState.SecondMet==true)
    {
        // 정지 했을 때
		if(bStopWithoutFrontDetect==true)
        {
			if(PreMarkState.IdCheck==false)
			{
				*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;

				preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;

				pMarkState->IdCheck = true;
				dwStaticCheckTime = dwCurrTime;
				ADD_LOG("[QR Mark] 2nd Met: Stoped and check ID");
				nCntMarkPos++;
			}
			else
			{
//              *pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_OFF; //1 확인 필요: Trigger Off 시 읽은 이전 Trigger 정보 보내는 것도 취소 여부

				if(bIdReaded==true)
				{
					if(fabs(dOffset)<MarkParam.Dist.dMarkInPosLimit)
					{
						pMarkState->Arrived = true;
						if(pnID!=NULL)
						{
							*pnID = nTmpID;
							ADD_LOG("[QR Mark] 2nd Met: Arrived [Pos:%6.1lf ID:%6X, Offset:%6.1lf]"
								, dRealPositionOfNow, nTmpID, dOffset);
							ADD_LOG("Count ZigZag Position : %d", nCntMarkPos);
							nCntMarkPos = 0;
						}
					}
					else    // 오차 범위 가 아닐 경우 반복 보정
					{
						dwStaticCheckTime = dwCurrTime;

						//*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;

						//preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;

						pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet;
						pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;
						pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfSecondMet);
						pCtrlInfo->Dynamic.dDist    = dRealPositionOfNow+dOffset;
						memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
						pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;

						dStaticQRCenterPosition = dRealPositionOfNow+dOffset;
						nStaticQrReenableCount  = 0;

						ADD_LOG("[QR Mark] 2nd Met: ID Readed And move offset [Pos:%6.1lf ID:%6X, Offset:%6.1lf]"
							, dRealPositionOfNow, nTmpID, dOffset);
						nCntMarkPos++;
					}
				}
				else    // 일정 시간 읽히지 않을 경우 에러 처리
				{
					if(OHTUTILITY::PreventOverflowGetTimeMs(dwStaticCheckTime)>1100/*200*/)  //1100
					{
						if((nStaticQrReenableCount)>10)// Time Over
						{
							pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
							pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
							nTmpError = ERR_QRR_READTIMEOUT;
							*pnID = nTmpTargetID;
							//오버런 처리
							m_pExecuteInfo->FlagOverRunInfo.bCheck = true;
							m_pExecuteInfo->FlagOverRunInfo.OverrunType = 0x02; //이적재
							m_pExecuteInfo->FlagOverRunInfo.nFinalNode = nTmpTargetID;    //주행은 주행, 이적재는 이적재
							m_PositionInfo.CurrStation = nTmpTargetID;
							m_pExecuteInfo->FlagOverRunInfo.dDrivingInitPosition = 0.0;

							ERR_LOG("[QR Mark] 2nd Met: ERR_QRR_READTIMEOUT");

							ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d/%d",
										ERR_QRR_READTIMEOUT,
										m_pOHTMainStatus->StatusCommon.CurNodeID,
										m_pExecuteInfo->ExecutePositionInfo.NextNode,
										m_pOHTMainStatus->StatusCommon.CurNodeOffset,
										m_pOHTMainStatus->StatusCommon.ExistFoup,
										m_pOHTMainStatus->StatusCommon.StopStationID,
										bIsLeft);
						}
						*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;

						preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;

						nStaticQrReenableCount++;
						dwStaticCheckTime = dwCurrTime;
						ADD_LOG("[QR Mark] 2nd Met: ReEnable[%d]", nStaticQrReenableCount);
					}
					else
					{

						if(preQrCmdType != CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON)
						{
							preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
							*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
						}
					}
				}
			}
		}
		else    // 이동 중일 때
		{
			*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_OFF;

			if(preQrCmdType == CTRL_INFO_OF_ID_READER_CMD_TRIGGER_OFF)
			{
				*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_NONE;
			}
			preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_OFF;

			pMarkState->IdCheck = false;
			dwStaticCheckTime = dwCurrTime;
			dwQRCheckTime = dwCurrTime;
		}
	}
	// --------------------------------------------------------------------------------------------------------------------------------------
	//1 2. Target ID 를 처음으로 만난 경우
	// --------------------------------------------------------------------------------------------------------------------------------------
	else if(PreMarkState.FirstMet==true)
	{
		if(bStopWithoutFrontDetect==true)
		{
			if(PreMarkState.IdCheck==false)
			{
				*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;

				preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;

				pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
				pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
				memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));

				pMarkState->IdCheck = true;
				dwStaticCheckTime = dwCurrTime; // time check for moving back start
				ADD_LOG("[QR Mark] 1st Met: Stoped and check ID");
			}
			else
			{
				if(bIdReaded==true)
				{
					pMarkState->SecondMet=true;
					dwStaticCheckTime = dwCurrTime;

					//*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_RESTART;

					//preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_RESTART;

					pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet;
					pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;
					pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfSecondMet);
					pCtrlInfo->Dynamic.dDist    = dRealPositionOfNow+dOffset;
					memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
					pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;

					dStaticQRCenterPosition = dRealPositionOfNow+dOffset;
					nStaticQrReenableCount  = 0;

					ADD_LOG("[QR Mark] 1st Met: ID readed and move offset [Pos:%6.1lf ID:%6d, Offset:%6.1lf]"
						, dRealPositionOfNow, nTmpID, dOffset);
				}
				else    // 읽히지 않을 경우 뒤로 이동하며 확인
				{
					if(OHTUTILITY::PreventOverflowGetTimeMs(dwStaticCheckTime)>1100)// Time Interval Control  1100
					{
						pMarkState->OverRun=true;
						pMarkState->Recovery=true;
						dwStaticCheckTime = dwCurrTime;

						//*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_RESTART;

						//preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_RESTART;

						pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfFirstMet;
						pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfFirstMet;
						pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfFirstMet);
						pCtrlInfo->Dynamic.dDist    = dStaticQRCenterPosition
													- ((MarkParam.Dist.dAddDistAfetrFirstMet)*nStaticQrReenableCount);

						ERR_LOG("[QR Mark] 1st Met: Stoped and move back [Pos:%6.1lf BackDist:%6.1lf-%6.1lf] ReEnable[%d]"
							, dRealPositionOfNow
							, dStaticQRCenterPosition
							, ((MarkParam.Dist.dAddDistAfetrFirstMet)*nStaticQrReenableCount)
							, nStaticQrReenableCount
							);

						memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
						pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;
						nStaticQrReenableCount++;
					}
					else
					{
						if(preQrCmdType != CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON)
						{
							preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
							*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
						}
					}
				}
			}

		}
		else
		{
		/*
			if(bNextCtrlInfoExist==true)    // ID 읽혀 감속 정지 중일 경우 ID 위치로 다시 명령을 주는 Routine
			{
				*pCtrlInfo = NextCtrlInfo;
				bNextCtrlInfoExist = false;
			}
		*/
			pMarkState->IdCheck = false;
			dwStaticCheckTime = dwCurrTime;
		}
	}
	// --------------------------------------------------------------------------------------------------------------------------------------
	//1 3. Target ID 를 만나기 전 찾고 있는 경우
	// --------------------------------------------------------------------------------------------------------------------------------------
	else if(PreMarkState.OnRoutineIn==true)
	{
		if(bIdReaded==true)
		{
			pMarkState->FirstMet=true;

//			*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_RESTART;
//
//			preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_RESTART;
//
//			pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
//			pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
//			dwStaticCheckTime = dwCurrTime; // time check for moving back start
//			pMarkState->IdCheck = false;
//
//			NextCtrlInfo.Dynamic.dAccel = MarkParam.Accel.dOfFirstMet;
//			NextCtrlInfo.Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;;//MarkParam.Accel.dOfFirstMet;
//			NextCtrlInfo.Dynamic.dSpeed = MIN(dSpeedLimit, MarkParam.Speed.dOfFirstMet);
//			NextCtrlInfo.Dynamic.dDist  = dRealPositionOfNow+dOffset;
//			memset(&NextCtrlInfo.Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
//			NextCtrlInfo.byType = AXIS_CTRL_CMD_MOVE_DS;
//			bNextCtrlInfoExist = true;

//			if(m_pExecuteInfo->ExecuteMode == EXECUTE_MODE_MANUAL)
//			{
				pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
				pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;

				dwStaticCheckTime = dwCurrTime;
				pMarkState->IdCheck = false;
//			}
//			else
//			{
//				pCtrlInfo->Dynamic.dAccel = MarkParam.Accel.dOfFirstMet;
//				pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
//				pCtrlInfo->Dynamic.dSpeed = MIN(dSpeedLimit, MarkParam.Speed.dOfFirstMet);
//				pCtrlInfo->Dynamic.dDist  = dRealPositionOfNow+dOffset;
//				memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
//				pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;
//
//				dwStaticCheckTime = dwCurrTime;
//				pMarkState->IdCheck = false;
//			}

			ADD_LOG("[QR Mark] On Routine: ID Readed And MoveStop [Pos:%6.1lf ID:%6d, Offset:%6.1lf]"
				, dRealPositionOfNow, nTmpID, dOffset);
			dRealPositionOfFirstDetect = dRealPositionOfNow;
			dQROffset = dOffset;
		}
		else
		{
			if(preQrCmdType != CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON)
			{
				preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
				*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
			}

			if(OHTUTILITY::PreventOverflowGetTimeMs(dwStaticCheckTime)>1100)   // 50ms: QR 센서의 프로세싱 타임 20여ms 이므로 2배수 산정     1100
			{
				//preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_RESTART;
				//*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_RESTART;

				preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
				*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;

				dwStaticCheckTime = dwCurrTime; // time check for moving back start
			}

			if(bStopWithoutFrontDetect==true)
			{
				if(fabs(dRealPositionOfNow-(dRealDistSumToTarget+MarkParam.Dist.dForwardMoveDistLimit))<10) //+100 삭제
				{
					// 이곳에 들어오기 전에 거리 초과로 에러 발생, 만일 들어올 경우 에러 처리
					pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
					pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
					nTmpError = (bIsLeft)?ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_LEFT_MET_LATE:ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_RIGHT_MET_LATE;
//					//오버런 처리
//					m_pExecuteInfo->FlagOverRunInfo.bCheck = true;
//					m_pExecuteInfo->FlagOverRunInfo.OverrunType = 0x02; //이적재
//					m_pExecuteInfo->FlagOverRunInfo.nFinalNode = nTmpTargetID;    //주행은 주행, 이적재는 이적재
//					m_pExecuteInfo->FlagOverRunInfo.dDrivingInitPosition = MarkParam.Dist.dForwardMoveDistLimit;

					ERR_LOG("[QR Mark] On Routine: ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_MET_LATE(Left:%d) [Pos:%6.1lf ≒ %6.1lf (%6.1lf + %6.1lf + 100)]"
						, bIsLeft, dRealPositionOfNow, (dRealDistSumToTarget+MarkParam.Dist.dForwardMoveDistLimit)
						, dRealDistSumToTarget, MarkParam.Dist.dForwardMoveDistLimit);
					ADD_FDC_LOG("ERR/%d/3/6/%06d/%06d/%d/%d/%06d/%6.1lf",
								nTmpError,
								m_pOHTMainStatus->StatusCommon.CurNodeID,
								m_pExecuteInfo->ExecutePositionInfo.NextNode,
								m_pOHTMainStatus->StatusCommon.CurNodeOffset,
								m_pOHTMainStatus->StatusCommon.ExistFoup,
								m_pOHTMainStatus->StatusCommon.StopStationID,
								dRealPositionOfNow - (dRealDistSumToTarget+MarkParam.Dist.dForwardMoveDistLimit));
					return nTmpError;
				}
				else
				{
					if(bQRRestartCompleted == false)
					{
						if(bQRRestart == false)
						{
							*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;

							preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;

							bQRRestart = true;
							dwStaticQRRestartTime = dwCurrTime;
							ADD_LOG("[QR Mark] On Routine: Stoped and Renable [Pos:%6.1lf]", dRealPositionOfNow);
						}
						if((bQRRestart == true) && (OHTUTILITY::PreventOverflowGetTimeMs(dwStaticQRRestartTime)>200))
						{
							pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfFirstMet;
							pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfFirstMet;
							pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfFirstMet);
							pCtrlInfo->Dynamic.dDist    = dRealDistSumToTarget+MarkParam.Dist.dForwardMoveDistLimit+50;    // 50 : Dist margin to go over forward limit for checking overrun error
							memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
							pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;
							ADD_LOG("[QR Mark] On Routine: Stoped and go more(moveDS) to meet QR(%6.1lf) [Pos:%6.1lf]"
								, dRealDistSumToTarget+MarkParam.Dist.dForwardMoveDistLimit+50
								, dRealPositionOfNow);
							bQRRestartCompleted = true;
							bQRRestart = false;
						}
					}
				}
            }
            else
            {
//              ADD_LOG("[QR Mark]On Routine: On Stopping without ID Readed");
                // None
            }
        }
    }
	else if(PreMarkState.OnRoutineIn==false)
    {
        if((fabs(m_InfoSet.HwInfo.Axis1.dFinalPos - dRealDistSumToTarget) < ACCEPTABLE_DRIVING_POSITION_ERROR)
        || (m_InfoSet.HwInfo.Axis1.dFinalPos == 0))
        {
            pMarkState->OnRoutineIn=true;
        }

		*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;

		preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;

		pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfFirstMet;
		pCtrlInfo->Dynamic.dDecel   = QRR_MARK_FIRST_DECEL;//MarkParam.Accel.dOfFirstMet;
		pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfFirstMet);
		pCtrlInfo->Dynamic.dDist    = dRealDistSumToTarget;
        memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
		pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;
		ADD_LOG("[QR Mark] Routine In: Move To Target Dist(%6.1lf) [Pos:%6.1lf]"
            , dRealDistSumToTarget, dRealPositionOfNow);
    }

	if((pMarkState->Arrived == true) && (m_mccparam.bMarkStartFlag == true))
	{
		ADD_MCC_LOG(",%s,DRV,QR MARK,End,FOUP,%06d,%06d,%06d,%d,%6.1lf,Mark Type,%d,QR Mark Dist,%6.1lf,QR Offset,%6.1lf,QR Mark Start Speed,%6.1lf,ParentNode Offset Difference,%6.1lf",
					m_defualtparam->VHLName,
					m_mccparam.uSourceNode,
					m_mccparam.uTargetNode,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					dSpeedOfNow,
					m_InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType,
					dRealPositionOfFirstDetect - m_mccparam.dMarkStartDist,
					dQROffset,
					m_mccparam.dMarkStartSpeed,
					m_ClassifiedCmd.TargetInfo.dOffset - m_pOHTMainStatus->StatusCommon.CurNodeOffset);
		m_mccparam.bMarkStartFlag = false;
		m_mccparam.dMarkStartSpeed = 0.0;
		m_mccparam.dMarkStartDist = 0.0;
		dRealPositionOfFirstDetect = 0.0;
		dQROffset = 0.0;
	}

    return nTmpError;

}

/**
@brief DrivingControl Mark 구동 정보 획득 함수(QRStation)
@author
@date    2013.07.01
*/
int DrivingControl::markOnQRStationDiffType2(bool bIsLeft, DRIVING_HW_INFO_SET HwInfo, double dRealDistSumToTarget, double dSpeedLimit, int nTargetID, DRIVING_MARK_STATE* pMarkState, CTRL_INFO_OF_SYNC_AXIS_MOVE* pCtrlInfo, CTRL_INFO_OF_ID_READER_CMD_TYPE *pIdReaderCmdType, int* pnID,bool bOverrunIngn,double dSTBOffset)
{
	int     nTmpID = 0;
    static int nTmpTargetID =0;
	double  dOffset  = 0.0;
	double  dSTBGap  = 0.0;
    static double dStaticQRCenterPosition = 0.0;
    static int nStaticQrReenableCount = 0;
    bool    bIdReaded = false;
	static DWORD dwStaticCheckTime = 0;
	static DWORD dwQRCheckTime = 0;
	static bool bQRRestart = false;
	static bool bQRRestartCompleted = false;
	static DWORD dwStaticQRRestartTime = 0;
	DWORD   dwCurrTime = timeGetTime();
	static int nCntMarkPos = 0;
	static bool IsManual = false;
	double dForwardLimit = 0.0;

	int     nTmpError = NO_ERR;

	// Omron QR Reader 용 16.02.03
	static CTRL_INFO_OF_ID_READER_CMD_TYPE	preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_NONE;

    memset(pCtrlInfo, 0x00, sizeof(CTRL_INFO_OF_SYNC_AXIS_MOVE));
	*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_NONE;

    DRIVING_MARK_STATE PreMarkState = *pMarkState;
    DRIVING_MARK_PARAM MarkParam;

    static CTRL_INFO_OF_SYNC_AXIS_MOVE NextCtrlInfo;
	static bool bNextCtrlInfoExist = false;
	static bool bFrontDetectOffAfterMoveS = false;
	static bool bNonSenseFlag = false;

	// --------------------------------------------------------------------------------------------------------------------------------------
    //1 0. 정보 획득
    // --------------------------------------------------------------------------------------------------------------------------------------
	if(bIsLeft==true)
	{
		MarkParam = m_pParamSet->Mark[2];
        nTmpID = HwInfo.QrStaionLeft.nQrId;
		dOffset = HwInfo.QrStaionLeft.dQrOffset;
        dSTBGap = dSTBOffset;
    }
    else
    {
		MarkParam = m_pParamSet->Mark[3];
		nTmpID = HwInfo.QrStaionRight.nQrId;
		dOffset = HwInfo.QrStaionRight.dQrOffset;
		dSTBGap = dSTBOffset;
    }

    bool    bAxis1InPosition            = HwInfo.IO.Axis1InPosition;
    static  TIME_CHECK  StopWithoutFrontDetect;
	bool    bStopWithoutFrontDetect = false;

//    if(HwInfo.IO.Axis1Running==false && HwInfo.IO.ObsStatus!=DETECT_AND_STOP && HwInfo.IO.DetectStatus!=DETECT_AND_STOP)
	if(HwInfo.IO.Axis1Running==false
	&& ((HwInfo.IO.DetectStatus!=DETECT_AND_STOP) || (pHWSet->GetAMCVHLDetectStatus() ==0)))
    {
        if(StopWithoutFrontDetect.bFlag==false)
        {
            StopWithoutFrontDetect.dwTime = dwCurrTime;
            StopWithoutFrontDetect.bFlag = true;
        }
		else if(OHTUTILITY::PreventOverflowGetTimeMs(StopWithoutFrontDetect.dwTime)>200)
        {
            bStopWithoutFrontDetect = true;
        }
    }
    else
    {
        StopWithoutFrontDetect.bFlag = false;
        bStopWithoutFrontDetect = false;
    }

    double  dSpeedOfNow          		       	= HwInfo.Axis1.dSpeed;      //m_pDrivingAxis->GetCurrentPosition(); //미보정 현재 위치
    double  dRealPositionOfNow                  = HwInfo.Axis1.dCurrPos;    //미보정 현재 위치
    static  double  dRealPositionOfMostPositive = 0.0;                      // 최대로 멀리갔을 때의 거리
	static 	double  dRealPositionOfFirstDetect = 0.0;
	static	double  dQROffset = 0.0;

	if(PreMarkState.OnRoutineIn==false)
    {
        StopWithoutFrontDetect.bFlag = false;
        StopWithoutFrontDetect.dwTime = dwCurrTime;
        dwStaticCheckTime = dwCurrTime;
		nTmpTargetID = nTargetID;
		if(nTmpTargetID==0)	IsManual =true;
		else  IsManual =false;

        dRealPositionOfMostPositive = dRealPositionOfNow;
        dStaticQRCenterPosition = 0.0;
        nStaticQrReenableCount = 0;
        memset(&NextCtrlInfo, 0x00, sizeof(CTRL_INFO_OF_SYNC_AXIS_MOVE));
		bNextCtrlInfoExist = false;
		bQRRestartCompleted = false;
		bQRRestart = false;
		dwStaticQRRestartTime = dwCurrTime;
		bFrontDetectOffAfterMoveS = false;
		bNonSenseFlag = false;

		ADD_MCC_LOG(",%s,DRV,QR MARK,Start,FOUP,%06d,%06d,%06d,%d,%6.1lf,Mark Type,%d",
					m_defualtparam->VHLName,
					m_mccparam.uSourceNode,
					m_mccparam.uTargetNode,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					dSpeedOfNow,
					m_InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType);
		m_mccparam.bMarkStartFlag = true;
		m_mccparam.dMarkStartSpeed = dSpeedOfNow;
		m_mccparam.dMarkStartDist = dRealPositionOfNow;
    }
    else
    {
        dRealPositionOfMostPositive = (dRealPositionOfNow>dRealPositionOfMostPositive)?dRealPositionOfNow:dRealPositionOfMostPositive;
    }

	if(IsManual==true && nTmpID!=0)
    {
        nTmpTargetID = nTmpID;
    }
    bIdReaded = (nTmpID==nTmpTargetID&&nTmpTargetID!=0)?true:false;
    if(bIdReaded==true)
    {
        dStaticQRCenterPosition = dRealPositionOfNow + dOffset + dSTBGap;
    }

	//2 근접 제어 센서를 Off 시키는 조건
//	if(pMarkState->FollowCtrlOffArea==false)
	if(pHWSet->GetAMCVHLDetectStatus() ==1)
	{

		if(PreMarkState.FirstMet==true)
//		if(PreMarkState.Arrived==true)
		{

			m_pDrivingAxis->SetVHLDetectIgnor();
			m_bIsAMCVHLDetectIgnore = true;
//			pMarkState->FollowCtrlOffArea=true;
			bFrontDetectOffAfterMoveS = false;
			bNonSenseFlag = true;
        }
	}
	if(pMarkState->FollowCtrlOffArea==false)
	{
		if(PreMarkState.Arrived==true)
			pMarkState->FollowCtrlOffArea=true;
	}

	// 근접제어 센서 off이후 Move S 명령 추가
//	if(pMarkState->FollowCtrlOffArea==true && bFrontDetectOffAfterMoveS ==false)
	if(pHWSet->GetAMCVHLDetectStatus() == 0 && bFrontDetectOffAfterMoveS ==false && bNonSenseFlag ==true)
	{
       pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
	   pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
	   bFrontDetectOffAfterMoveS = true;
	   return nTmpError;
	}

    // --------------------------------------------------------------------------------------------------------------------------------------
    //1 0. 에러 처리
	// --------------------------------------------------------------------------------------------------------------------------------------

	if(bOverrunIngn ==false)
		dForwardLimit = MarkParam.Dist.dForwardMoveDistLimit;
	else
		dForwardLimit = 100.0;

	if(dRealPositionOfNow>(dRealDistSumToTarget+dForwardLimit))
	{
		pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
		pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
		nTmpError = (bIsLeft)?ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_LEFT_MET_LATE:ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_RIGHT_MET_LATE;

//		//오버런 처리
//		m_pExecuteInfo->FlagOverRunInfo.bCheck = true;
//		m_pExecuteInfo->FlagOverRunInfo.OverrunType = 0x02; //이적재
//		m_pExecuteInfo->FlagOverRunInfo.nFinalNode = nTmpTargetID;    //주행은 주행, 이적재는 이적재
//		m_pExecuteInfo->FlagOverRunInfo.dDrivingInitPosition = MarkParam.Dist.dForwardMoveDistLimit;

//		m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset =  MarkParam.Dist.dForwardMoveDistLimit;
		ERR_LOG("[QR Mark] ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_MET_LATE(Left%d): %6.1lf > %6.1lf (%6.1lf + %6.1lf)"
			, bIsLeft, dRealPositionOfNow, (dRealDistSumToTarget+dForwardLimit)
			, dRealDistSumToTarget, dForwardLimit);
		ADD_FDC_LOG("ERR/%d/2/6/%06d/%06d/%d/%d/%06d/%6.1lf",
					nTmpError,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pExecuteInfo->ExecutePositionInfo.NextNode,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					m_pOHTMainStatus->StatusCommon.ExistFoup,
					m_pOHTMainStatus->StatusCommon.StopStationID,
					dRealPositionOfNow - (dRealDistSumToTarget+dForwardLimit));
        return nTmpError;
    }
    else if(dRealPositionOfNow<(dRealPositionOfMostPositive-MarkParam.Dist.dBackMoveDistLimit))
    {
        pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
        pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
        nTmpError = (bIsLeft)?ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_LEFT_MOVE_BACK_LIMIT:ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_RIGHT_MOVE_BACK_LIMIT;
        ERR_LOG("[QR] ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_MOVE_BACK_LIMIT(Left%d): %6.1lf < %6.1lf (%6.1lf - %6.1lf)"
            , bIsLeft
            , dRealPositionOfNow, (dRealPositionOfMostPositive-MarkParam.Dist.dBackMoveDistLimit)
            , dRealPositionOfMostPositive, MarkParam.Dist.dBackMoveDistLimit);
		ADD_FDC_LOG("ERR/%d/1/8/%06d/%06d/%d/%d/%06d/%f/%f/%f",
					nTmpError,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pExecuteInfo->ExecutePositionInfo.NextNode,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					m_pOHTMainStatus->StatusCommon.ExistFoup,
					m_pOHTMainStatus->StatusCommon.StopStationID,
					dRealPositionOfNow,
					dRealPositionOfMostPositive,
					MarkParam.Dist.dBackMoveDistLimit);
        return nTmpError;
    }

    // --------------------------------------------------------------------------------------------------------------------------------------
    //1 1. Target 위치로 정위치 이동 중
	// --------------------------------------------------------------------------------------------------------------------------------------
    if(PreMarkState.SecondMet==true)
    {
        // 정지 했을 때
		if(bStopWithoutFrontDetect==true)
        {
			if(PreMarkState.IdCheck==false)
			{
				*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;

				preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;

				pMarkState->IdCheck = true;
				dwStaticCheckTime = dwCurrTime;
				ADD_LOG("[QR Mark] 2nd Met: Stoped and check ID");
				nCntMarkPos++;
			}
			else
			{
//              *pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_OFF; //1 확인 필요: Trigger Off 시 읽은 이전 Trigger 정보 보내는 것도 취소 여부

				if(bIdReaded==true)
				{
                    if(fabs(dOffset+dSTBGap)<MarkParam.Dist.dMarkInPosLimit)
//					if(fabs(dOffset)<MarkParam.Dist.dMarkInPosLimit)
					{
						pMarkState->Arrived = true;
						if(pnID!=NULL)
						{
							*pnID = nTmpID;
							ADD_LOG("[QR Mark] 2nd Met: Arrived [Pos:%6.1lf ID:%6X, Offset:%6.1lf, STBG:%6.11f]"
								, dRealPositionOfNow, nTmpID, dOffset,dSTBGap);
							ADD_LOG("Count ZigZag Position : %d", nCntMarkPos);
							nCntMarkPos = 0;
						}
					}
					else    // 오차 범위 가 아닐 경우 반복 보정
					{
						dwStaticCheckTime = dwCurrTime;

						//*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;

						//preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;

						pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet;
						pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;
						pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfSecondMet);
						pCtrlInfo->Dynamic.dDist    = dRealPositionOfNow+dOffset+dSTBGap;
						memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
						pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;

						dStaticQRCenterPosition = dRealPositionOfNow+dOffset+dSTBGap;
						nStaticQrReenableCount  = 0;

						ADD_LOG("[QR Mark] 2nd Met: ID Readed And move offset [Pos:%6.1lf ID:%6X, Offset:%6.1lf, STBG:%6.11f]"
							, dRealPositionOfNow, nTmpID, dOffset, dSTBGap);
						nCntMarkPos++;
					}
				}
				else    // 일정 시간 읽히지 않을 경우 에러 처리
				{
					if(OHTUTILITY::PreventOverflowGetTimeMs(dwStaticCheckTime)>500/*200*/)  //1100
					{
						if((nStaticQrReenableCount)>10)// Time Over
						{
							pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
							pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
							nTmpError = ERR_QRR_READTIMEOUT;
							*pnID = nTmpTargetID;
							//오버런 처리
							m_pExecuteInfo->FlagOverRunInfo.bCheck = true;
							m_pExecuteInfo->FlagOverRunInfo.OverrunType = 0x02; //이적재
							m_pExecuteInfo->FlagOverRunInfo.nFinalNode = nTmpTargetID;    //주행은 주행, 이적재는 이적재
							m_PositionInfo.CurrStation = nTmpTargetID;
							m_pExecuteInfo->FlagOverRunInfo.dDrivingInitPosition = dRealPositionOfNow - dStaticQRCenterPosition;

							ERR_LOG("[QR Mark] 2nd Met: ERR_QRR_READTIMEOUT");
							ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d/%d",
										ERR_QRR_READTIMEOUT,
										m_pOHTMainStatus->StatusCommon.CurNodeID,
										m_pExecuteInfo->ExecutePositionInfo.NextNode,
										m_pOHTMainStatus->StatusCommon.CurNodeOffset,
										m_pOHTMainStatus->StatusCommon.ExistFoup,
										m_pOHTMainStatus->StatusCommon.StopStationID,
										bIsLeft);
						}

						if(fabs(dRealPositionOfNow - dStaticQRCenterPosition) > 35.0)
						{
							if(fabs(dRealPositionOfNow - dStaticQRCenterPosition) < 69.0)
							{
								pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet;
								pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;
								pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfSecondMet);
								pCtrlInfo->Dynamic.dDist    = dStaticQRCenterPosition;
								memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
								pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;
							}
							else
                               nStaticQrReenableCount = 10;

							ERR_LOG("[QR Mark] 2nd Met: OverRun CurrPos:%f QRCenterPos:%f", dRealPositionOfNow,dStaticQRCenterPosition);
						}

						*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;

						preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;

						nStaticQrReenableCount++;
						dwStaticCheckTime = dwCurrTime;
						ADD_LOG("[QR Mark] 2nd Met: ReEnable[%d]", nStaticQrReenableCount);
					}
					else
					{

						if(preQrCmdType != CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON)
						{
							preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
							*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
						}
					}
				}
			}
		}
		else    // 이동 중일 때
		{
			*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_OFF;

			if(preQrCmdType == CTRL_INFO_OF_ID_READER_CMD_TRIGGER_OFF)
			{
				*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_NONE;
			}
			preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_OFF;

			pMarkState->IdCheck = false;
			dwStaticCheckTime = dwCurrTime;
			dwQRCheckTime = dwCurrTime;
		}
	}
	// --------------------------------------------------------------------------------------------------------------------------------------
	//1 2. Target ID 를 처음으로 만난 경우
	// --------------------------------------------------------------------------------------------------------------------------------------
	else if(PreMarkState.FirstMet==true)
	{
		if(bStopWithoutFrontDetect==true)
		{
			if(PreMarkState.IdCheck==false)
			{
				*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;

				preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;

				pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
				pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
				memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));

				pMarkState->IdCheck = true;
				dwStaticCheckTime = dwCurrTime; // time check for moving back start
				ADD_LOG("[QR Mark] 1st Met: Stoped and check ID");
			}
			else
			{
				if(bIdReaded==true)
				{
					pMarkState->SecondMet=true;
					dwStaticCheckTime = dwCurrTime;

					//*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_RESTART;

					//preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_RESTART;

					pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet;
					pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;
					pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfSecondMet);
					pCtrlInfo->Dynamic.dDist    = dRealPositionOfNow+dOffset +dSTBGap;
					memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
					pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;

					dStaticQRCenterPosition = dRealPositionOfNow+dOffset+dSTBGap;
					nStaticQrReenableCount  = 0;

					ADD_LOG("[QR Mark] 1st Met: ID readed and move offset [Pos:%6.1lf ID:%6d, Offset:%6.1lf, STBG:%6.11f]"
						, dRealPositionOfNow, nTmpID, dOffset, dSTBGap);
				}
				else    // 읽히지 않을 경우 뒤로 이동하며 확인
				{
					if(OHTUTILITY::PreventOverflowGetTimeMs(dwStaticCheckTime)>500)// Time Interval Control  1100
					{
						pMarkState->OverRun=true;
						pMarkState->Recovery=true;
						dwStaticCheckTime = dwCurrTime;

						//*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_RESTART;

						//preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_RESTART;

						pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfFirstMet;
						pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfFirstMet;
						pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfFirstMet);
						pCtrlInfo->Dynamic.dDist    = dStaticQRCenterPosition
													- ((MarkParam.Dist.dAddDistAfetrFirstMet)*nStaticQrReenableCount);

						ERR_LOG("[QR Mark] 1st Met: Stoped and move back [Pos:%6.1lf BackDist:%6.1lf-%6.1lf] ReEnable[%d]"
							, dRealPositionOfNow
							, dStaticQRCenterPosition
							, ((MarkParam.Dist.dAddDistAfetrFirstMet)*nStaticQrReenableCount)
							, nStaticQrReenableCount
							);

						memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
						pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;
						nStaticQrReenableCount++;
					}
					else
					{
						if(preQrCmdType != CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON)
						{
							preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
							*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
						}
					}
				}
			}

		}
		else
		{
		/*
			if(bNextCtrlInfoExist==true)    // ID 읽혀 감속 정지 중일 경우 ID 위치로 다시 명령을 주는 Routine
			{
				*pCtrlInfo = NextCtrlInfo;
				bNextCtrlInfoExist = false;
			}
		*/
			pMarkState->IdCheck = false;
			dwStaticCheckTime = dwCurrTime;
		}
	}
	// --------------------------------------------------------------------------------------------------------------------------------------
	//1 3. Target ID 를 만나기 전 찾고 있는 경우
	// --------------------------------------------------------------------------------------------------------------------------------------
	else if(PreMarkState.OnRoutineIn==true)
	{
		if(bIdReaded==true)
		{
			pMarkState->FirstMet=true;

//			*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_RESTART;
//
//			preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_RESTART;
//
//			pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
//			pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
//			dwStaticCheckTime = dwCurrTime; // time check for moving back start
//			pMarkState->IdCheck = false;
//
//			NextCtrlInfo.Dynamic.dAccel = MarkParam.Accel.dOfFirstMet;
//			NextCtrlInfo.Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;;//MarkParam.Accel.dOfFirstMet;
//			NextCtrlInfo.Dynamic.dSpeed = MIN(dSpeedLimit, MarkParam.Speed.dOfFirstMet);
//			NextCtrlInfo.Dynamic.dDist  = dRealPositionOfNow+dOffset;
//			memset(&NextCtrlInfo.Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
//			NextCtrlInfo.byType = AXIS_CTRL_CMD_MOVE_DS;
//			bNextCtrlInfoExist = true;

//			if(m_pExecuteInfo->ExecuteMode == EXECUTE_MODE_MANUAL)
//			{
				pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
				pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;

				dwStaticCheckTime = dwCurrTime;
				pMarkState->IdCheck = false;
//			}
//			else
//			{
//				pCtrlInfo->Dynamic.dAccel = MarkParam.Accel.dOfFirstMet;
//				pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
//				pCtrlInfo->Dynamic.dSpeed = MIN(dSpeedLimit, MarkParam.Speed.dOfFirstMet);
//				pCtrlInfo->Dynamic.dDist  = dRealPositionOfNow+dOffset;
//				memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
//				pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;
//
//				dwStaticCheckTime = dwCurrTime;
//				pMarkState->IdCheck = false;
//			}

			ADD_LOG("[QR Mark] On Routine: ID Readed And MoveStop [Pos:%6.1lf ID:%6d, Offset:%6.1lf, STB:%6.11f]"
				, dRealPositionOfNow, nTmpID, dOffset, dSTBGap);
			dRealPositionOfFirstDetect = dRealPositionOfNow;
			dQROffset = dOffset;

		}
		else
		{
			if(preQrCmdType != CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON)
			{
				preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
				*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
			}

			if(OHTUTILITY::PreventOverflowGetTimeMs(dwStaticCheckTime)>100)   // 50ms: QR 센서의 프로세싱 타임 20여ms 이므로 2배수 산정     1100
			{
				//preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_RESTART;
				//*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_RESTART;

				preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
				*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;

				dwStaticCheckTime = dwCurrTime; // time check for moving back start
			}

			if(bStopWithoutFrontDetect==true)
			{
				if(fabs(dRealPositionOfNow-(dRealDistSumToTarget+dForwardLimit))<10) //+100 삭제
				{
					// 이곳에 들어오기 전에 거리 초과로 에러 발생, 만일 들어올 경우 에러 처리
					pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
					pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
					nTmpError = (bIsLeft)?ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_LEFT_MET_LATE:ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_RIGHT_MET_LATE;
//					//오버런 처리
//					m_pExecuteInfo->FlagOverRunInfo.bCheck = true;
//					m_pExecuteInfo->FlagOverRunInfo.OverrunType = 0x02; //이적재
//					m_pExecuteInfo->FlagOverRunInfo.nFinalNode = nTmpTargetID;    //주행은 주행, 이적재는 이적재
//					m_pExecuteInfo->FlagOverRunInfo.dDrivingInitPosition = MarkParam.Dist.dForwardMoveDistLimit;

					ERR_LOG("[QR Mark] On Routine: ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_MET_LATE(Left:%d) [Pos:%6.1lf ≒ %6.1lf (%6.1lf + %6.1lf + 100)]"
						, bIsLeft, dRealPositionOfNow, (dRealDistSumToTarget+dForwardLimit)
						, dRealDistSumToTarget, dForwardLimit);
					ADD_FDC_LOG("ERR/%d/3/6/%06d/%06d/%d/%d/%06d/%6.1lf",
								nTmpError,
								m_pOHTMainStatus->StatusCommon.CurNodeID,
								m_pExecuteInfo->ExecutePositionInfo.NextNode,
								m_pOHTMainStatus->StatusCommon.CurNodeOffset,
								m_pOHTMainStatus->StatusCommon.ExistFoup,
								m_pOHTMainStatus->StatusCommon.StopStationID,
								dRealPositionOfNow - (dRealDistSumToTarget+dForwardLimit));
					return nTmpError;
				}
				else
				{
					if(bQRRestartCompleted == false)
					{
						if(bQRRestart == false)
						{
							*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;

							preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;

							bQRRestart = true;
							dwStaticQRRestartTime = dwCurrTime;
							ADD_LOG("[QR Mark] On Routine: Stoped and Renable [Pos:%6.1lf]", dRealPositionOfNow);
						}
						if((bQRRestart == true) && (OHTUTILITY::PreventOverflowGetTimeMs(dwStaticQRRestartTime)>200))
						{
							pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfFirstMet;
							pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfFirstMet;
							pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfFirstMet);
							pCtrlInfo->Dynamic.dDist    = dRealDistSumToTarget+MarkParam.Dist.dForwardMoveDistLimit+50;    // 50 : Dist margin to go over forward limit for checking overrun error
							memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
							pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;
							ADD_LOG("[QR Mark] On Routine: Stoped and go more(moveDS) to meet QR(%6.1lf) [Pos:%6.1lf]"
								, dRealDistSumToTarget+MarkParam.Dist.dForwardMoveDistLimit+50
								, dRealPositionOfNow);
							bQRRestartCompleted = true;
							bQRRestart = false;
						}
					}
				}
            }
            else
            {
//              ADD_LOG("[QR Mark]On Routine: On Stopping without ID Readed");
                // None
            }
        }
    }
	else if(PreMarkState.OnRoutineIn==false)
    {
        if((fabs(m_InfoSet.HwInfo.Axis1.dFinalPos - dRealDistSumToTarget) < ACCEPTABLE_DRIVING_POSITION_ERROR)
        || (m_InfoSet.HwInfo.Axis1.dFinalPos == 0))
        {
            pMarkState->OnRoutineIn=true;
        }


		*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;

		preQrCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;

		pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfFirstMet;
		pCtrlInfo->Dynamic.dDecel   = QRR_MARK_FIRST_DECEL;//MarkParam.Accel.dOfFirstMet;
		pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfFirstMet);
		pCtrlInfo->Dynamic.dDist    = dRealDistSumToTarget;
        memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
		pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;
		ADD_LOG("[QR Mark] Routine In: Move To Target Dist(%6.1lf) [Pos:%6.1lf]"
            , dRealDistSumToTarget, dRealPositionOfNow);
    }

	if((pMarkState->Arrived == true) && (m_mccparam.bMarkStartFlag == true))
	{
		ADD_MCC_LOG(",%s,DRV,QR MARK,End,FOUP,%06d,%06d,%06d,%d,%6.1lf,Mark Type,%d,QR Mark Dist,%6.1lf,QR Offset,%6.1lf,QR Mark Start Speed,%6.1lf,ParentNode Offset Difference,%6.1lf",
					m_defualtparam->VHLName,
					m_mccparam.uSourceNode,
					m_mccparam.uTargetNode,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					dSpeedOfNow,
					m_InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType,
					dRealPositionOfFirstDetect - m_mccparam.dMarkStartDist,
					dQROffset,
					m_mccparam.dMarkStartSpeed,
					m_ClassifiedCmd.TargetInfo.dOffset - m_pOHTMainStatus->StatusCommon.CurNodeOffset);
		m_mccparam.bMarkStartFlag = false;
		m_mccparam.dMarkStartSpeed = 0.0;
		m_mccparam.dMarkStartDist = 0.0;
		dRealPositionOfFirstDetect = 0.0;
		dQROffset = 0.0;
	}
    return nTmpError;

}

/**
@brief DrivingControl Mark 구동 정보 획득 함수(QRStation)
@author  임태웅
@date    2013.07.01
*/
int DrivingControl::markOnQRStation(bool bIsLeft, DRIVING_HW_INFO_SET HwInfo, double dRealDistSumToTarget, double dSpeedLimit, int nTargetID, DRIVING_MARK_STATE* pMarkState, CTRL_INFO_OF_SYNC_AXIS_MOVE* pCtrlInfo, CTRL_INFO_OF_ID_READER_CMD_TYPE *pIdReaderCmdType, int* pnID)
{
	int     nTmpID = 0;
	static int nTmpTargetID =0;
	double  dOffset  = 0.0;
	static double dStaticQRCenterPosition = 0.0;
	static int nStaticQrReTriggerCount = 0;
	static int nStaticQrRetryCount = 0;
	bool    bIdReaded = false;
	static DWORD dwStaticCheckTime = 0;
	static bool bQRMoveTargetPosition = false;
	static DWORD dwStaticQRRestartTime = 0;
	DWORD   dwCurrTime = timeGetTime();

	int     nTmpError = NO_ERR;

	memset(pCtrlInfo, 0x00, sizeof(CTRL_INFO_OF_SYNC_AXIS_MOVE));
	*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_NONE;

	DRIVING_MARK_STATE PreMarkState = *pMarkState;
	DRIVING_MARK_PARAM MarkParam;

	static CTRL_INFO_OF_SYNC_AXIS_MOVE NextCtrlInfo;
	static bool bNextCtrlInfoExist = false;

	// --------------------------------------------------------------------------------------------------------------------------------------
    //1 0. 정보 획득
    // --------------------------------------------------------------------------------------------------------------------------------------
	if(bIsLeft==true)
    {
        MarkParam = m_pParamSet->Mark[2];
        nTmpID = HwInfo.QrStaionLeft.nQrId;
        dOffset = HwInfo.QrStaionLeft.dQrOffset;
    }
    else
	{
        MarkParam = m_pParamSet->Mark[3];
		nTmpID = HwInfo.QrStaionRight.nQrId;
        dOffset = HwInfo.QrStaionRight.dQrOffset;
    }

    bool    bAxis1InPosition            = HwInfo.IO.Axis1InPosition;
    static  TIME_CHECK  StopWithoutFrontDetect;
	bool    bStopWithoutFrontDetect = false;

#if(UBG_SENSOR_ENABLE == ON)
//	if(HwInfo.IO.Axis1Running==false && HwInfo.IO.ObsStatus!=DETECT_AND_STOP && HwInfo.IO.DetectStatus!=DETECT_AND_STOP)
	if(HwInfo.IO.Axis1Running==false
	&& ((HwInfo.IO.DetectStatus!=DETECT_AND_STOP) || (pHWSet->GetAMCVHLDetectStatus() ==0)))
#else
	if(HwInfo.IO.Axis1Running==false && HwInfo.IO.ObsStatus!=DETECT_AND_STOP)
#endif
	{
        if(StopWithoutFrontDetect.bFlag==false)
        {
            StopWithoutFrontDetect.dwTime = dwCurrTime;
            StopWithoutFrontDetect.bFlag = true;
        }
		else if(OHTUTILITY::PreventOverflowGetTimeMs(StopWithoutFrontDetect.dwTime)>200)
        {
            bStopWithoutFrontDetect = true;
        }
    }
    else
    {
        StopWithoutFrontDetect.bFlag = false;
		bStopWithoutFrontDetect = false;
	}

    double  dSpeedOfNow          		       	= HwInfo.Axis1.dSpeed;      //m_pDrivingAxis->GetCurrentPosition(); //미보정 현재 위치
    double  dRealPositionOfNow                  = HwInfo.Axis1.dCurrPos;    //미보정 현재 위치
	static  double  dRealPositionOfMostPositive = 0.0;                      // 최대로 멀리갔을 때의 거리
	static 	double  dRealPositionOfFirstDetect = 0.0;
	static	double  dQROffset = 0.0;

	if(PreMarkState.OnRoutineIn==false)
    {
        StopWithoutFrontDetect.bFlag = false;
        StopWithoutFrontDetect.dwTime = dwCurrTime;
        dwStaticCheckTime = dwCurrTime;
		nTmpTargetID = nTargetID;
        dRealPositionOfMostPositive = dRealPositionOfNow;
		dStaticQRCenterPosition = 0.0;
		nStaticQrRetryCount = 0;
		nStaticQrReTriggerCount = 0;
        memset(&NextCtrlInfo, 0x00, sizeof(CTRL_INFO_OF_SYNC_AXIS_MOVE));
		bNextCtrlInfoExist = false;
		bQRMoveTargetPosition = false;
		dwStaticQRRestartTime = dwCurrTime;

		ADD_MCC_LOG(",%s,DRV,QR MARK,Start,FOUP,%06d,%06d,%06d,%d,%6.1lf,Mark Type,%d",
					m_defualtparam->VHLName,
					m_mccparam.uSourceNode,
					m_mccparam.uTargetNode,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					dSpeedOfNow,
					m_InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType);
		m_mccparam.bMarkStartFlag = true;
		m_mccparam.dMarkStartSpeed = dSpeedOfNow;
		m_mccparam.dMarkStartDist = dRealPositionOfNow;
	}
    else
    {
		dRealPositionOfMostPositive = (dRealPositionOfNow>dRealPositionOfMostPositive)?dRealPositionOfNow:dRealPositionOfMostPositive;
    }

    if(nTmpTargetID==0 && nTmpID!=0)
    {
        nTmpTargetID = nTmpID;
	}

	bIdReaded = (nTmpID==nTmpTargetID&&nTmpTargetID!=0)?true:false;

    if(bIdReaded==true)
    {
        dStaticQRCenterPosition = dRealPositionOfNow + dOffset;
    }

    //2 근접 제어 센서를 Off 시키는 조건
//	if(pMarkState->FollowCtrlOffArea==false)
	if(pHWSet->GetAMCVHLDetectStatus() ==1)
	{

		if(PreMarkState.FirstMet==true)
//		if(PreMarkState.Arrived==true)
		{

			m_pDrivingAxis->SetVHLDetectIgnor();
			m_bIsAMCVHLDetectIgnore = true;
//			pMarkState->FollowCtrlOffArea=true;
		}
	}
	if(pMarkState->FollowCtrlOffArea==false)
	{
		if(PreMarkState.FirstMet==true)
			pMarkState->FollowCtrlOffArea=true;
	}

    // --------------------------------------------------------------------------------------------------------------------------------------
    //1 0. 에러 처리
    // --------------------------------------------------------------------------------------------------------------------------------------
	if(dRealPositionOfNow>(dRealDistSumToTarget+MarkParam.Dist.dForwardMoveDistLimit))
    {
        pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
        pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
		nTmpError = (bIsLeft)?ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_LEFT_MET_LATE:ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_RIGHT_MET_LATE;

		//오버런 처리
//		m_pExecuteInfo->FlagOverRunInfo.bCheck = true;
//		m_pExecuteInfo->FlagOverRunInfo.OverrunType = 0x02; //이적재
//		m_pExecuteInfo->FlagOverRunInfo.nFinalNode = nTmpTargetID;    //주행은 주행, 이적재는 이적재
//		m_pExecuteInfo->FlagOverRunInfo.dDrivingInitPosition = MarkParam.Dist.dForwardMoveDistLimit;

		ERR_LOG("[QR Mark] ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_MET_LATE(Left%d): %6.1lf > %6.1lf (%6.1lf + %6.1lf)"
            , bIsLeft, dRealPositionOfNow, (dRealDistSumToTarget+MarkParam.Dist.dForwardMoveDistLimit)
            , dRealDistSumToTarget, MarkParam.Dist.dForwardMoveDistLimit);
		ADD_FDC_LOG("ERR/%d/2/6/%06d/%06d/%d/%d/%06d/%6.1lf",
					nTmpError,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pExecuteInfo->ExecutePositionInfo.NextNode,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					m_pOHTMainStatus->StatusCommon.ExistFoup,
					m_pOHTMainStatus->StatusCommon.StopStationID,
					dRealPositionOfNow - (dRealDistSumToTarget+MarkParam.Dist.dForwardMoveDistLimit));
        return nTmpError;
    }
    else if(dRealPositionOfNow<(dRealPositionOfMostPositive-MarkParam.Dist.dBackMoveDistLimit))
    {
        pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
		pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
        nTmpError = (bIsLeft)?ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_LEFT_MOVE_BACK_LIMIT:ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_RIGHT_MOVE_BACK_LIMIT;
        ERR_LOG("[QR] ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_MOVE_BACK_LIMIT(Left%d): %6.1lf < %6.1lf (%6.1lf - %6.1lf)"
            , bIsLeft
            , dRealPositionOfNow, (dRealPositionOfMostPositive-MarkParam.Dist.dBackMoveDistLimit)
			, dRealPositionOfMostPositive, MarkParam.Dist.dBackMoveDistLimit);
		ADD_FDC_LOG("ERR/%d/1/8/%06d/%06d/%d/%d/%06d/%f/%f/%f",
					nTmpError,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pExecuteInfo->ExecutePositionInfo.NextNode,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					m_pOHTMainStatus->StatusCommon.ExistFoup,
					m_pOHTMainStatus->StatusCommon.StopStationID,
					dRealPositionOfNow,
					dRealPositionOfMostPositive,
					MarkParam.Dist.dBackMoveDistLimit);
        return nTmpError;
    }

    // --------------------------------------------------------------------------------------------------------------------------------------
    //1 1. Target 위치로 정위치 이동 중
    // --------------------------------------------------------------------------------------------------------------------------------------
    if(PreMarkState.SecondMet==true)
    {
		// 정지 했을 때
        if(bStopWithoutFrontDetect==true)
		{
			if(PreMarkState.IdCheck==false)
            {
				*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
				pMarkState->IdCheck = true;
				dwStaticCheckTime = dwCurrTime;
				ADD_LOG("[QR Mark] 2nd Met: Stoped and check ID");
            }
            else
			{
				if(bIdReaded==true)
                {
                    if(fabs(dOffset)<MarkParam.Dist.dMarkInPosLimit)
                    {
                        pMarkState->Arrived = true;
                        if(pnID!=NULL)
                        {
                            *pnID = nTmpID;
							ADD_LOG("[QR Mark] 2nd Met: Arrived [Pos:%6.1lf ID:%6X, Offset:%6.1lf]", dRealPositionOfNow, nTmpID, dOffset);
						}
					}
					else if(nStaticQrRetryCount > 20 )
					{
						pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
						pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
						nTmpError = ERR_QRR_READTIMEOUT;
                        *pnID = nTmpTargetID;
					   	//오버런 처리
						m_pExecuteInfo->FlagOverRunInfo.bCheck = true;
						m_pExecuteInfo->FlagOverRunInfo.OverrunType = 0x02; //이적재
						m_pExecuteInfo->FlagOverRunInfo.nFinalNode = nTmpTargetID;    //주행은 주행, 이적재는 이적재
						m_PositionInfo.CurrStation = nTmpTargetID;
						m_pExecuteInfo->FlagOverRunInfo.dDrivingInitPosition = 0.0;

						ADD_LOG("[QR Mark] 2nd Met: No MarkInPosLimit  [Pos:%6.1lf ID:%6X, Offset:%6.1lf]", dRealPositionOfNow, nTmpID, dOffset);
						ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d/%d",
										ERR_QRR_READTIMEOUT,
										m_pOHTMainStatus->StatusCommon.CurNodeID,
										m_pExecuteInfo->ExecutePositionInfo.NextNode,
										m_pOHTMainStatus->StatusCommon.CurNodeOffset,
										m_pOHTMainStatus->StatusCommon.ExistFoup,
										m_pOHTMainStatus->StatusCommon.StopStationID,
										bIsLeft);
					}
					else    // 오차 범위 가 아닐 경우 반복 보정
					{
						dwStaticCheckTime = dwCurrTime;

						pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet;
						pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;
						pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfSecondMet);
						pCtrlInfo->Dynamic.dDist    = dRealPositionOfNow+dOffset;
						memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
						pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;

						dStaticQRCenterPosition = dRealPositionOfNow+dOffset;
						nStaticQrRetryCount++;
						nStaticQrReTriggerCount  = 0;

						ADD_LOG("[QR Mark] 2nd Met: ID Readed And move offset [Pos:%6.1lf ID:%6X, Offset:%6.1lf]", dRealPositionOfNow, nTmpID, dOffset);
					}
				}
				else    // 일정 시간 읽히지 않을 경우 에러 처리
				{
					if(OHTUTILITY::PreventOverflowGetTimeMs(dwStaticCheckTime)>200)
					{
						if((nStaticQrReTriggerCount)>10)	// Time Over
						{
							pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
							pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
							nTmpError = ERR_QRR_READTIMEOUT;
							*pnID = nTmpTargetID;

							//오버런 처리
							m_pExecuteInfo->FlagOverRunInfo.bCheck = true;
							m_pExecuteInfo->FlagOverRunInfo.OverrunType = 0x02; //이적재
							m_pExecuteInfo->FlagOverRunInfo.nFinalNode = nTmpTargetID;    //주행은 주행, 이적재는 이적재
							m_PositionInfo.CurrStation = nTmpTargetID;
							m_pExecuteInfo->FlagOverRunInfo.dDrivingInitPosition = 0.0;

							ERR_LOG("[QR Mark] 2nd Met: ERR_QRR_READTIMEOUT");
							ADD_FDC_LOG("ERR/%d/1/6/%06d/%06d/%d/%d/%06d/%d",
										ERR_QRR_READTIMEOUT,
										m_pOHTMainStatus->StatusCommon.CurNodeID,
										m_pExecuteInfo->ExecutePositionInfo.NextNode,
										m_pOHTMainStatus->StatusCommon.CurNodeOffset,
										m_pOHTMainStatus->StatusCommon.ExistFoup,
										m_pOHTMainStatus->StatusCommon.StopStationID,
										bIsLeft);
						}

						*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;   //Trigger on
						nStaticQrReTriggerCount++;
						dwStaticCheckTime = dwCurrTime;
						ADD_LOG("[QR Mark] 2nd Met: ReEnable[%d]", nStaticQrReTriggerCount);
					}
				}
			}
		}
		else    // 이동 중일 때
		{
			pMarkState->IdCheck = false;
            dwStaticCheckTime = dwCurrTime;
		}
	}
    // --------------------------------------------------------------------------------------------------------------------------------------
    //1 2. Target ID 를 처음으로 만난 경우
    // --------------------------------------------------------------------------------------------------------------------------------------
	else if(PreMarkState.FirstMet==true)
    {
        if(bStopWithoutFrontDetect==true)
		{
			if(PreMarkState.IdCheck==false)
			{
				*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
				pMarkState->IdCheck = true;

				pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
				pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
				memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));

				dwStaticCheckTime = dwCurrTime; // time check for moving back start
				ADD_LOG("[QR Mark] 1st Met: Stoped and check ID");
			}
			else
			{
				if(bIdReaded==true)
				{
					pMarkState->SecondMet=true;
					dwStaticCheckTime = dwCurrTime;

					pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfSecondMet;
					pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfSecondMet;
					pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfSecondMet);
					pCtrlInfo->Dynamic.dDist    = dRealPositionOfNow+dOffset;
					memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
					pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;

					dStaticQRCenterPosition = dRealPositionOfNow+dOffset;
					nStaticQrReTriggerCount  = 0;

					ADD_LOG("[QR Mark] 1st Met: ID readed and move offset [Pos:%6.1lf ID:%6d, Offset:%6.1lf]", dRealPositionOfNow, nTmpID, dOffset);
				}
				else    // 읽히지 않을 경우 뒤로 이동하며 확인
				{
					if(OHTUTILITY::PreventOverflowGetTimeMs(dwStaticCheckTime)>200)								// Time Interval Control
					{
						pMarkState->OverRun=true;
						pMarkState->Recovery=true;
						dwStaticCheckTime = dwCurrTime;

						*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;      // Trigger on

						pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfFirstMet;
						pCtrlInfo->Dynamic.dDecel   = MarkParam.Accel.dOfFirstMet;
						pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, MarkParam.Speed.dOfFirstMet);
						pCtrlInfo->Dynamic.dDist    = dStaticQRCenterPosition - (10.0*nStaticQrReTriggerCount);

						ERR_LOG("[QR Mark] 1st Met: Stoped and move back [Pos:%6.1lf BackDist:%6.1lf-%6.1lf] ReEnable[%d]"
							, dRealPositionOfNow
							, dStaticQRCenterPosition
							, ((MarkParam.Dist.dAddDistAfetrFirstMet)*nStaticQrReTriggerCount)
							, nStaticQrReTriggerCount
							);

						memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
						pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;
						nStaticQrReTriggerCount++;
					}
				}
			}
		}
		else
		{
			pMarkState->IdCheck = false;
			dwStaticCheckTime = dwCurrTime;
		}
	}
	// --------------------------------------------------------------------------------------------------------------------------------------
	//1 3. Target ID 를 만나기 전 찾고 있는 경우
	// --------------------------------------------------------------------------------------------------------------------------------------
	else if(PreMarkState.OnRoutineIn==true)
	{
		if(bIdReaded==true)
		{
			pMarkState->FirstMet = true;

			if(m_pExecuteInfo->ExecuteMode == EXECUTE_MODE_MANUAL)
			{
				pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
				pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;

				dwStaticCheckTime = dwCurrTime;
				pMarkState->IdCheck = false;
			}
			else
			{
				pCtrlInfo->Dynamic.dAccel = MarkParam.Accel.dOfFirstMet;
				pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
				pCtrlInfo->Dynamic.dSpeed = MIN(dSpeedLimit, MarkParam.Speed.dOfFirstMet);
				pCtrlInfo->Dynamic.dDist  = dRealPositionOfNow+dOffset;
				memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
				pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;

				dwStaticCheckTime = dwCurrTime;
				pMarkState->IdCheck = false;
			}

			ADD_LOG("[QR Mark] On Routine: ID Readed And MoveStop [Pos:%6.1lf ID:%6d, Offset:%6.1lf]", dRealPositionOfNow, nTmpID, dOffset);
			dRealPositionOfFirstDetect = dRealPositionOfNow;
			dQROffset = dOffset;
		}
		else
		{
			if(OHTUTILITY::PreventOverflowGetTimeMs(dwStaticCheckTime)>200)	// 50ms: QR 센서의 프로세싱 타임 20여ms 이므로 2배수 산정
			{
				*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
				dwStaticCheckTime = dwCurrTime;		// time check for moving back start
			}

			if(bStopWithoutFrontDetect==true)
			{
				if(fabs(dRealPositionOfNow-(dRealDistSumToTarget+MarkParam.Dist.dForwardMoveDistLimit))<10) //+100 삭제
				{
					// 이곳에 들어오기 전에 거리 초과로 에러 발생, 만일 들어올 경우 에러 처리
					pCtrlInfo->Dynamic.dDecel = m_pParamSet->Axis.Default.dDefaultDecel;
					pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_S;
					nTmpError = (bIsLeft)?ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_LEFT_MET_LATE:ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_RIGHT_MET_LATE;

//					//오버런 처리
//					m_pExecuteInfo->FlagOverRunInfo.bCheck = true;
//					m_pExecuteInfo->FlagOverRunInfo.OverrunType = 0x02; //이적재
//					m_pExecuteInfo->FlagOverRunInfo.nFinalNode = nTmpTargetID;    //주행은 주행, 이적재는 이적재
//					m_pExecuteInfo->FlagOverRunInfo.dDrivingInitPosition = MarkParam.Dist.dForwardMoveDistLimit;

					ERR_LOG("[QR Mark] On Routine: ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_MET_LATE(Left:%d) [Pos:%6.1lf ≒ %6.1lf (%6.1lf + %6.1lf + 100)]", bIsLeft, dRealPositionOfNow, (dRealDistSumToTarget+MarkParam.Dist.dForwardMoveDistLimit+100)
						, dRealDistSumToTarget, MarkParam.Dist.dForwardMoveDistLimit);
					ADD_FDC_LOG("ERR/%d/3/6/%06d/%06d/%d/%d/%06d/%6.1lf",
								nTmpError,
								m_pOHTMainStatus->StatusCommon.CurNodeID,
								m_pExecuteInfo->ExecutePositionInfo.NextNode,
								m_pOHTMainStatus->StatusCommon.CurNodeOffset,
								m_pOHTMainStatus->StatusCommon.ExistFoup,
								m_pOHTMainStatus->StatusCommon.StopStationID,
								dRealPositionOfNow - (dRealDistSumToTarget+MarkParam.Dist.dForwardMoveDistLimit));

					return nTmpError;
				}
				else
				{
					if(bQRMoveTargetPosition == false)
					{
						pCtrlInfo->Dynamic.dAccel = MarkParam.Accel.dOfFirstMet;
						pCtrlInfo->Dynamic.dDecel = MarkParam.Accel.dOfFirstMet;
						pCtrlInfo->Dynamic.dSpeed = MIN(dSpeedLimit, MarkParam.Speed.dOfFirstMet);
						pCtrlInfo->Dynamic.dDist  = dRealDistSumToTarget+MarkParam.Dist.dForwardMoveDistLimit+50;    // 50 : Dist margin to go over forward limit for checking overrun error
						memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
						pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;
						bQRMoveTargetPosition = true;

						ADD_LOG("[QR Mark] On Routine: Stoped and go more(moveDS) to meet QR(%6.1lf) [Pos:%6.1lf]", dRealDistSumToTarget+MarkParam.Dist.dForwardMoveDistLimit+100, dRealPositionOfNow);
					}
				}
			}
		}
	}
	else if(PreMarkState.OnRoutineIn==false)
	{
		if((fabs(m_InfoSet.HwInfo.Axis1.dFinalPos - dRealDistSumToTarget) < ACCEPTABLE_DRIVING_POSITION_ERROR)
        || (m_InfoSet.HwInfo.Axis1.dFinalPos == 0))
        {
            pMarkState->OnRoutineIn=true;
        }


		*pIdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_TRIGGER_ON;
		dwStaticCheckTime = dwCurrTime;

		pCtrlInfo->Dynamic.dAccel   = MarkParam.Accel.dOfFirstMet;
		pCtrlInfo->Dynamic.dDecel   = QRR_MARK_FIRST_DECEL;
		pCtrlInfo->Dynamic.dSpeed   = MIN(dSpeedLimit, QRR_MARK_FIRST_SPEED);
		pCtrlInfo->Dynamic.dDist    = dRealDistSumToTarget;
		memset(&pCtrlInfo->Dynamic.AdditionalInfo, 0x00, sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
		pCtrlInfo->byType = AXIS_CTRL_CMD_MOVE_DS;

		ADD_LOG("[QR Mark] Routine In: Move To Target Dist(%6.1lf) [Pos:%6.1lf]", dRealDistSumToTarget, dRealPositionOfNow);
	}

	if((pMarkState->Arrived == true) && (m_mccparam.bMarkStartFlag == true))
	{
		ADD_MCC_LOG(",%s,DRV,QR MARK,End,FOUP,%06d,%06d,%06d,%d,%6.1lf,Mark Type,%d,QR Mark Dist,%6.1lf,QR Offset,%6.1lf,QR Mark Start Speed,%6.1lf,ParentNode Offset Difference,%6.1lf",
					m_defualtparam->VHLName,
					m_mccparam.uSourceNode,
					m_mccparam.uTargetNode,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					dSpeedOfNow,
					m_InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType,
					dRealPositionOfFirstDetect - m_mccparam.dMarkStartDist,
					dQROffset,
					m_mccparam.dMarkStartSpeed,
					m_ClassifiedCmd.TargetInfo.dOffset - m_pOHTMainStatus->StatusCommon.CurNodeOffset);
		m_mccparam.bMarkStartFlag = false;
		m_mccparam.dMarkStartSpeed = 0.0;
		m_mccparam.dMarkStartDist = 0.0;
		dRealPositionOfFirstDetect = 0.0;
		dQROffset = 0.0;
	}

	return nTmpError;
}

/**
@brief   DrivingControl Axis 동작 가능 여부 확인 및 가능 상태로 가기 위해 필요한 Command 작성
@author  임태웅
@date    2013.07.01
*/
bool DrivingControl::checkReadyToRun(DRIVING_HW_INFO_SET HwInfo, USER_DETECT_INFO DetectCtrl, CTRL_INFO_OF_SYNC_AXIS_MOVE* pAxisCmd, CTRL_INFO_OF_STEER* pSteerCmd, CTRL_INFO_OF_FRONT_DETECT* pDetectCtrl, bool bIsManual)
{
    bool bAllReady = false;
    bool bAxisHome = false;
    bool bAxisAmpOn = false;
    bool bNodeCountReset = false;
    bool bSteerFrontReady = false;
	bool bSteerRearReady = false;

	bool bDrivingBreakRelease = m_pDrivingAxis->IsBrakeReleased();
	bool TempbAllReady = false;

	bool bAxisReady = false;
	bool bSteerReady = false;
	bool bFrontDetectReady = false;
	bool bInnerLimitTorque = false;

	static bool bIsLastNodeCountReset = false;

//	DRIVING_CMD_INFO_OF_NODE* pNodeInfo = getNodeInfo(0);
    //2 기본 플래그 획득
	if((fabs(HwInfo.Axis1.dCurrPos)<5.0) && (fabs(HwInfo.Axis2.dCurrPos)<5.0))
	{
        m_RunOffsetDistance =  m_InfoSet.Position.Compensation.dPreArriveOffset;
		bAxisHome = true;
	}
	else
		bIsLastNodeCountReset =false;

    if(HwInfo.IO.Axis1AmpOn==true && HwInfo.IO.Axis2AmpOn==true)
    {
		bAxisAmpOn = true;
	}

	if((bAxisHome==true) &&     		//엔코더가 Hmone이 아니고,
	  (bIsLastNodeCountReset ==true) && //마지막 한번더 처리
	  ((HwInfo.Node.nNodeCount==0) && ((HwInfo.Node.nPreCheckCount==0) || (HwInfo.IO.NodePreCheckOn ==true))))
	{
		m_RunOffsetDistance =  m_InfoSet.Position.Compensation.dPreArriveOffset;
		bNodeCountReset = true;
	}

	//2 Pass : 구동중, 근접제어 정지
	if(HwInfo.IO.Axis1AmpOn==true)
	{
	/*
		if( (HwInfo.IO.Axis1Running==true) && (HwInfo.IO.Axis2Running==true))
		{
			bAllReady=true;
			return bAllReady;
		}
	*/
#if(OHT_NAME != OHT_NAME_STD_V81S)
#if(UBG_SENSOR_ENABLE == ON)
		if((HwInfo.IO.ObsStatus==DETECT_AND_STOP) || (HwInfo.IO.DetectStatus==DETECT_AND_STOP) )
#else
		if(HwInfo.IO.ObsStatus==DETECT_AND_STOP)
#endif
		{
            bAllReady=false;
            return bAllReady;
		}
#endif


    }

   //1 Axis: Home 상태 + Amp Enable + NodeCount Reset
    if(bAxisHome==true && bAxisAmpOn==true && bNodeCountReset==true)
    {
        bAxisReady = true;
	}

    else if(bAxisHome==false && bAxisAmpOn==true)
	{
//		if(pNodeInfo->SlopeInfo ==NODE_SLOPE)
//		{

			//경사로로 인해서 브레이크 유무 확인 후 서버 Off처리
			if(bDrivingBreakRelease ==false)
			{
				pAxisCmd->byType = AXIS_CTRL_CMD_STATIC;
				pAxisCmd->Static.Axis1AmpCmdOn = true;
				pAxisCmd->Static.Axis1AmpOn = false;
				pAxisCmd->Static.Axis2AmpCmdOn = true;
				pAxisCmd->Static.Axis2AmpOn = false;
			}
			else
			{
				m_pDrivingAxis->SetBrakeRelease(false);
			}

//			ADD_LOG("checkReadyToRun Slope");
//		}else
////		{
//				pAxisCmd->byType = AXIS_CTRL_CMD_STATIC;
//				pAxisCmd->Static.Axis1AmpCmdOn = true;
//				pAxisCmd->Static.Axis1AmpOn = false;
//				pAxisCmd->Static.Axis2AmpCmdOn = true;
//				pAxisCmd->Static.Axis2AmpOn = false;
//
//				ADD_LOG("checkReadyToRun No_Slope");
////		}

//		m_pDrivingAxis->SetBrakeRelease(false);
	}
	else if(bAxisHome==true && bAxisAmpOn==false)
	{
		pAxisCmd->byType = AXIS_CTRL_CMD_STATIC;
		pAxisCmd->Static.Axis1AmpCmdOn = true;
		pAxisCmd->Static.Axis1AmpOn = true;
		pAxisCmd->Static.Axis2AmpCmdOn = true;
		pAxisCmd->Static.Axis2AmpOn = true;

//		m_pDrivingAxis->SetBrakeRelease(true);
	}
    else if(bAxisHome==false && bAxisAmpOn==false)
	{
		pAxisCmd->byType = AXIS_CTRL_CMD_STATIC;
        pAxisCmd->Static.Axis1SetHomeCmdOn = true;
        pAxisCmd->Static.Axis2SetHomeCmdOn = true;
	}

    //1 NodeCount Reset
	if((bNodeCountReset==false) && (bAxisHome==true)) // Node Count Reset 지속 실행 -> 엔코더가 클리어되고나서 노드카운트 클리어실시
    {
		pAxisCmd->byType = AXIS_CTRL_CMD_STATIC;
		pAxisCmd->Static.NodeCountReset = true;
		bIsLastNodeCountReset= true; //엔코더가 클리어 되고나서 최초 회는 실행하기 위해

	}


    //1 Steer 현재 방향에 맞추는 명령
    if( ((HwInfo.IO.SteerFrontLeftInOn==true) && (HwInfo.IO.SteerFrontDirCmd==DRIVING_IO_STEER_DIRECTION_CMD_LEFT))     ||
        ((HwInfo.IO.SteerFrontRightInOn==true) && (HwInfo.IO.SteerFrontDirCmd==DRIVING_IO_STEER_DIRECTION_CMD_RIGHT))   ||
        ((HwInfo.IO.SteerFrontLeftInOn==false) && (HwInfo.IO.SteerFrontRightInOn==false))   )
    {
        bSteerFrontReady = true;
    }
    if( ((HwInfo.IO.SteerRearLeftInOn==true) && (HwInfo.IO.SteerRearDirCmd==DRIVING_IO_STEER_DIRECTION_CMD_LEFT))   ||
        ((HwInfo.IO.SteerRearRightInOn==true) && (HwInfo.IO.SteerRearDirCmd==DRIVING_IO_STEER_DIRECTION_CMD_RIGHT)) ||
        ((HwInfo.IO.SteerRearLeftInOn==false) && (HwInfo.IO.SteerRearRightInOn==false))     )
    {
        bSteerRearReady = true;
    }

    if(bSteerFrontReady==true &&  bSteerRearReady==true)
    {
        bSteerReady = true;
    }
    else
    {
        *pSteerCmd = setSteerCmdToCurrPosition(HwInfo);
    }

    //1 전방 감시 상태 확인
	//todo: 변경 확인 기능 추가
		if(m_bOnBackMove == true)
		{
			ADD_LOG("Detect Init(back)");
			memset(&DetectCtrl,0,sizeof(USER_DETECT_INFO));

			if((DetectCtrl.UseFollowControlFlag != pDetectCtrl->Info.UseFollowControlFlag)
#if(USE_CHANGENODE == 1)
			|| (DetectCtrl.OHTDetectType != pDetectCtrl->Info.OHTDetectType)
			|| (DetectCtrl.OBSDetectType != pDetectCtrl->Info.OBSDetectType)
#else
			|| (DetectCtrl.Type != pDetectCtrl->Info.Type)
#endif
			|| (DetectCtrl.NodeCount != pDetectCtrl->Info.NodeCount)
			|| (DetectCtrl.DistSumOfStraightPath != pDetectCtrl->Info.DistSumOfStraightPath)
			|| (DetectCtrl.FollowCommandType != pDetectCtrl->Info.FollowCommandType)
			|| (DetectCtrl.PBSIgnoreFlag != pDetectCtrl->Info.PBSIgnoreFlag)
			)
			{
				if(bAxisReady == true)
				{
					pDetectCtrl->bCmdOn = true;
					pDetectCtrl->Info = DetectCtrl;
				}
	//			bFrontDetectReady=false;
			}
			else
			  bFrontDetectReady=true;
		}
		else
		{
			if((DetectCtrl.UseFollowControlFlag != pDetectCtrl->Info.UseFollowControlFlag)
#if(USE_CHANGENODE == 1)
			|| (DetectCtrl.OHTDetectType != pDetectCtrl->Info.OHTDetectType)
			|| (DetectCtrl.OBSDetectType != pDetectCtrl->Info.OBSDetectType)
#else
			|| (DetectCtrl.Type != pDetectCtrl->Info.Type)
#endif
			|| (DetectCtrl.NodeCount != pDetectCtrl->Info.NodeCount)
			|| (DetectCtrl.DistSumOfStraightPath != pDetectCtrl->Info.DistSumOfStraightPath)
			|| (DetectCtrl.FollowCommandType != pDetectCtrl->Info.FollowCommandType)
			|| (DetectCtrl.PBSIgnoreFlag != pDetectCtrl->Info.PBSIgnoreFlag)
			|| ((pHWSet->GetAMCVHLDetectStatus() ==0) && (bIsManual ==false)))
			{
				if(bAxisReady == true)
				{
					pDetectCtrl->bCmdOn = true;
					pDetectCtrl->Info = DetectCtrl;
				}
	//			bFrontDetectReady=false;
			}
			else
			  bFrontDetectReady=true;
		}




	if(m_pServoControl->IsSetInnerLimitTorque_800() ==false)
	{
		m_pServoControl->SetInnerLimitTorque_800();
		ADD_LOG("SetInnerLimitTorque_800");
	}

	if((m_pDrivingAxis->IsBrakeReleased()==false) && (bAxisReady == true))
	{
		m_pDrivingAxis->SetBrakeRelease(true);
		ADD_LOG("SetBrakeRelease");
	}

	if((m_pDrivingAxis->IsBrakeReleased()==true) &&  (m_pServoControl->IsSetInnerLimitTorque_800() ==true))
		bInnerLimitTorque = true;


	//1 Ready 정보 확인 및 return
	bAllReady = bAxisReady & bSteerReady & bFrontDetectReady & bInnerLimitTorque;



	ADD_LOG("checkReadyToRun: %d=Ax%d \& Sr%d \& FD%d VDS %d LiTor %d// %d %d %d//[F:%6.1lf(%d),R:%6.1lf(%d)] NC:%d %d %d"
		, bAllReady, bAxisReady, bSteerReady, bFrontDetectReady, pHWSet->GetAMCVHLDetectStatus(),bInnerLimitTorque
		, bAxisHome, bAxisAmpOn, bNodeCountReset
        , HwInfo.Axis1.dCurrPos, HwInfo.IO.Axis1AmpOn
        , HwInfo.Axis2.dCurrPos, HwInfo.IO.Axis2AmpOn
        , HwInfo.Node.nNodeCount,HwInfo.Node.nPreCheckCount,HwInfo.IO.NodePreCheckOn);

    return bAllReady;
}
/**
@brief   DrivingControl Axis 동작 완료 여부 확인 및 완료 상태로 가기 위해 필요한 Command 작성
@author  임태웅
@date    2013.07.01
*/
bool DrivingControl::checkCompletion    (DRIVING_HW_INFO_SET HwInfo, CTRL_INFO_OF_SYNC_AXIS_MOVE* pAxisCmd, CTRL_INFO_OF_STEER* pSteerCmd, CTRL_INFO_OF_FRONT_DETECT* pDetectCtrl)
{
    bool bAllCompleted = false;

    bool bSteerFrontCompleted = false;
    bool bSteerRearCompleted = false;

    bool bAxisAmpOn = true;

    bool bAxisCompleted = false;
    bool bSteerCompleted = false;
    bool bFrontDetectCompleted = false;
	bool bNodeCountCleared = true;
	bool bInnerLimitTorque = false;

	static DWORD dwRearSensorChatteringStart = timeGetTime();
	static DWORD dwRearSensorChattering = timeGetTime();
    static int nRearSensorCheckcnt = 0;



    //2 기본 플래그 획득
    memset(pAxisCmd, 0x00, sizeof(CTRL_INFO_OF_SYNC_AXIS_MOVE));

    if(HwInfo.IO.Axis1AmpOn==true && HwInfo.IO.Axis2AmpOn==false)
    {
        bAxisAmpOn = false;
    }

    //1 Axis: Home 상태 + Amp Enable
	if(m_cSlopeNodeInfo ==SLOPE_NTYPE)
	{
         if(HwInfo.IO.Axis1AmpOn==true && HwInfo.IO.Axis2AmpOn==true)
		{
			bAxisAmpOn = false;
		}

		//1 Axis: Home 상태 + Amp Enable
		if( bAxisAmpOn==false)
		{
			bAxisCompleted = true;
		}
		else
		{
			pAxisCmd->byType = AXIS_CTRL_CMD_STATIC;
			pAxisCmd->Static.Axis2AmpCmdOn = true;
			pAxisCmd->Static.Axis2AmpOn = true;
		}
	}else
	{
		if(HwInfo.IO.Axis1AmpOn==true && HwInfo.IO.Axis2AmpOn==false)
		{
			bAxisAmpOn = false;
		}

	   //1 Axis: Home 상태 + Amp Enable
        // Rearm Motor Off된 상태
        if( bAxisAmpOn==false)
        {
            // Mark 수행한 Tag가 Station의 경우 Rear Stop 센서 채터링 기능 추가
            if(m_ClassifiedCmd.TargetInfo.Type == MARK_TYPE_TAG_STATION)
			{
                if(HwInfo.IO.TagStationRearOn == true)
				{
					 if(OHTUTILITY::PreventOverflowGetTimeMs(dwRearSensorChatteringStart) > 500)
					{
						bAxisCompleted = true;
						ADD_LOG("[Station Mark] Rear Sensor Check OK(%d)", nRearSensorCheckcnt);
					}


				}
				else
				{
					 // Rear Servo OFF 상태에서 Rear가 OFF되어 있는 경우
					// 최대 1500msec 대기하면서 Rear Stop 센서 Check 수행
					if(OHTUTILITY::PreventOverflowGetTimeMs(dwRearSensorChattering) > 2000)
					{
                        bAxisCompleted = true;
						ADD_LOG("[Station Mark] Rear Sensor Check NG(%d)", nRearSensorCheckcnt);

                    }
                    else
                    {
						nRearSensorCheckcnt++;
					}
                }
            }
            else
            {
                bAxisCompleted = true;
            }
            /*
            bAxisCompleted = true;
            */
        }
        else
		{
			dwRearSensorChatteringStart = timeGetTime();
			dwRearSensorChattering = timeGetTime();

			nRearSensorCheckcnt = 0;

            pAxisCmd->byType = AXIS_CTRL_CMD_STATIC;
            pAxisCmd->Static.Axis2AmpCmdOn = true;
            pAxisCmd->Static.Axis2AmpOn = false;
        }
    }



    //1 Steer 현재 방향에 맞추는 명령
    if( ((HwInfo.IO.SteerFrontLeftInOn==true) && (HwInfo.IO.SteerFrontDirCmd==DRIVING_IO_STEER_DIRECTION_CMD_LEFT))     ||
        ((HwInfo.IO.SteerFrontRightInOn==true) && (HwInfo.IO.SteerFrontDirCmd==DRIVING_IO_STEER_DIRECTION_CMD_RIGHT))   ||
        ((HwInfo.IO.SteerFrontLeftInOn==false) && (HwInfo.IO.SteerFrontRightInOn==false))   )
    {
        bSteerFrontCompleted = true;
    }
    if( ((HwInfo.IO.SteerRearLeftInOn==true) && (HwInfo.IO.SteerRearDirCmd==DRIVING_IO_STEER_DIRECTION_CMD_LEFT))   ||
        ((HwInfo.IO.SteerRearRightInOn==true) && (HwInfo.IO.SteerRearDirCmd==DRIVING_IO_STEER_DIRECTION_CMD_RIGHT)) ||
        ((HwInfo.IO.SteerRearLeftInOn==false) && (HwInfo.IO.SteerRearRightInOn==false))     )
    {
        bSteerRearCompleted = true;
    }

    if(bSteerFrontCompleted==true &&  bSteerRearCompleted==true)
    {
        bSteerCompleted = true;
    }
    else
    {
        *pSteerCmd = setSteerCmdToCurrPosition(HwInfo);
    }

    //1 전방 감시 상태 확인
    //todo: 변경 확인 기능 추가
    if(pDetectCtrl!=NULL)
	{
		if(bAxisCompleted && bNodeCountCleared)
		{
			pDetectCtrl->bCmdOn = true;
			pDetectCtrl->Info.UseFollowControlFlag = false;
#if(USE_CHANGENODE == 1)
			pDetectCtrl->Info.OHTDetectType = PATH_DIRECTION_NO_USE;
			pDetectCtrl->Info.OBSDetectType = PATH_OBS_DIRECTION_NO_USE;
#else
			pDetectCtrl->Info.Type = PATH_DIRECTION_NO_USE;
#endif
			pDetectCtrl->Info.NodeCount = 0;
			pDetectCtrl->Info.DistSumOfStraightPath = 0;

			bFrontDetectCompleted=true;
        }
    }


    //1 Node Count Clear 확인
//#if 0
//  if(HwInfo.Node.nNodeCount==0 && HwInfo.Node.nPreCheckCount==0)//Node Count가 0이면
//  {
//      bNodeCountCleared = true;
//  }
//  else
//  {
//      m_pDrivingAxis->ClearNodeCountInfo();
//  }
//#else
//    bNodeCountCleared = true;
//#endif


	if(m_cSlopeNodeInfo ==SLOPE_NTYPE)
	{
		if(m_pServoControl->IsSetInnerLimitTorque_90() == true)
        {
			m_cSlopeNodeInfo = INIT_NTYPE;
			bInnerLimitTorque = true;
			ADD_LOG("Complete:SetInnerLimitTorque_90");
		}else
		{
         	m_pServoControl->SetInnerLimitTorque_90();
        }

	}
	else
		bInnerLimitTorque = true;

    //1 Ready 정보 확인 및 return
	bAllCompleted = bAxisCompleted & bSteerCompleted & bFrontDetectCompleted & bNodeCountCleared & bInnerLimitTorque;


//    ADD_LOG("Tag Station Mark Test: %d=%d \& %d \& %d \& %d", bAllCompleted, bAxisCompleted, bSteerCompleted, bFrontDetectCompleted, bNodeCountCleared);
    return bAllCompleted;

}

/**
@brief   DrivingControl Steering을 HW 방향에 맞춰 명령을 변경
@author  임태웅
@date    2013.07.10
*/
CTRL_INFO_OF_STEER DrivingControl::setSteerCmdToCurrPosition(DRIVING_HW_INFO_SET    HwInfo)
{
    CTRL_INFO_OF_STEER SteerCmd;

    if(HwInfo.IO.SteerFrontLeftInOn==true)
    {
        SteerCmd.FrontDirection = DRIVING_IO_STEER_DIRECTION_CMD_LEFT;
    }
    else if(HwInfo.IO.SteerFrontRightInOn==true)
	{
		SteerCmd.FrontDirection = DRIVING_IO_STEER_DIRECTION_CMD_RIGHT;
    }
    else
    {
        SteerCmd.FrontDirection = HwInfo.IO.SteerFrontDirCmd;
    }

    if(HwInfo.IO.SteerRearLeftInOn==true)
    {
        SteerCmd.RearDirection = DRIVING_IO_STEER_DIRECTION_CMD_LEFT;
    }
    else if(HwInfo.IO.SteerRearRightInOn==true)
    {
        SteerCmd.RearDirection = DRIVING_IO_STEER_DIRECTION_CMD_RIGHT;
    }
    else
    {
        SteerCmd.RearDirection = HwInfo.IO.SteerFrontDirCmd;
    }

    SteerCmd.FrontCmdOn = true;
    SteerCmd.FrontTorque = DRIVING_IO_STEER_TORQUE_CMD_STOP;

    SteerCmd.RearCmdOn= true;
    SteerCmd.RearTorque= DRIVING_IO_STEER_TORQUE_CMD_STOP;

    return SteerCmd;
}


int DrivingControl::manual_Mark(MARK_TYPE MarkType)
{
    static DRIVING_MARK_STATE MarkState;
    static int nIdResult = 0;
    int nTmpError = NO_ERR;
    DRIVING_HW_INFO_SET HwInfo = getHWInfo();

    DRIVING_CTRL_INFO_SET CtrlInfo;
    memset(&CtrlInfo, 0, sizeof(CtrlInfo));

    CTRL_INFO_OF_ID_READER_CMD_TYPE IdReaderCmdType = CTRL_INFO_OF_ID_READER_CMD_NONE;

    USER_DETECT_INFO DetectCtrl;
    memset(&DetectCtrl, 0, sizeof(DetectCtrl));
	DetectCtrl.UseFollowControlFlag = false;


	double dRealDistSumToTarget = 50;
    double dSpeedLimit = 0.2;   //1 임시 0.2m/s
    int nID = 0;
	int nTargetID = 0;

	int nTempNodeID = 0;
	int nNodeIndex = 0;
	NODE_INFO	*pNODE_INFO		= NULL;	// Node 정보
	STATION_DATA *pSData  =NULL; //Station 정보

    static int nNodeCount = 1; // for MARK_TYPE_NODE

	double dNodeDistOffset = 0.0;
	int nSTBQROffset = 0;

	static manual_Mark_cnt = 0;
	int SteerFront=0;
	int CIDResetNode_arr = INDEX_NONE;
	int CIDResetNode = 0;
	int CIDResetNodeType = 0;
//     ADD_LOG("Mark Test1:%d",  m_StatusSet.uStep);
	//1 처음 시작이면 위치 정보 초기화: 추후 변경 필요

    if(m_StatusSet.uStep==DRIVING_CTRL_STEP_NONE)
    {
        //1 NEW
        initCommandSet();
        initInfoSet();
        initPreviousArrivalInfo();

		m_PositionInfo.Marked = false;
		m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uStation = 0x00;
        m_PositionInfo.CurrStation=0x00;

        m_pDrivingBCR->ReStart();
        m_pTransBCR->ReStart();
        m_pLeftQRR->ReStart();
        m_pRightQRR->ReStart();

        if(m_pSteer->IsLeftPos(BOTH)==false && m_pSteer->IsRightPos(BOTH)==false)
        {
            nTmpError   = ERR_STEER_NOTSAMESTATUS;
            m_StatusSet.byStatus    = STS_ERROR;
            m_StatusSet.uError      = nTmpError;
            return nTmpError;
        }

        m_StatusSet.uStep = DRIVING_CTRL_STEP_MANUAL_MARK_INIT;
    }
//    ADD_LOG("Mark Test2:%d",  m_StatusSet.uStep);
	//1 명령 생성
    switch(m_StatusSet.uStep)
    {
    case DRIVING_CTRL_STEP_MANUAL_MARK_INIT:
        //2 정보 초기화
        m_StatusSet.bIsOnProcess    = true;
        m_StatusSet.byStatus        = STS_RUNNING;

        memset(&MarkState, 0, sizeof(MarkState));
        nIdResult = 0;
		manual_Mark_cnt = 0;

        setMarkStatusFalse();

        //2 Node Count Reset
        m_pDrivingAxis->ClearNodeCountInfo();

        //2 근젭제어 Off
        m_Detect.UseFollowControlFlag = false;
        m_Detect.NodeCount = 0;
		CtrlInfo.FrontObservation.Info = m_Detect;

		CheckReadyToRunTime_ManualMark = timeGetTime();
        m_StatusSet.uStep = DRIVING_CTRL_STEP_MANUAL_MARK_PREPARE;
		break;
    case DRIVING_CTRL_STEP_MANUAL_MARK_PREPARE:
		if(checkReadyToRun(HwInfo, DetectCtrl, &(CtrlInfo.Axis), &(CtrlInfo.Steer), &(CtrlInfo.FrontObservation),true)==true)
		{
			m_StatusSet.uStep = DRIVING_CTRL_STEP_MANUAL_MARK_RUN;
			ADD_LOG("Mark Test: m_StatusSet.uStep = %d", m_StatusSet.uStep);
			nNodeCount = (HwInfo.IO.NodeOn==true)?0:1;   // for MARK_TYPE_NODE
		}
		else
		{
			if(OHTUTILITY::PreventOverflowGetTimeMs(CheckReadyToRunTime_ManualMark) > 5000)
			{
				if(m_pServoControl->IsSetInnerLimitTorque_800() ==false)
				{
					nTmpError=ERR_SERVO_DRIVING_ALARM;
					CheckReadyToRunTime_ManualMark = timeGetTime();
					ADD_LOG("checkReadyToRun[executeGoPrepare] Fail");
				}
			}
		}
        break;

    case DRIVING_CTRL_STEP_MANUAL_MARK_RUN:
        switch(MarkType)
        {
			case MARK_TYPE_NODE:
	//          dRealDistSumToTarget = m_pParamSet->Mark[0].Dist.dDistFromFirstToSecond-40;
				nTmpError = markOnNode(HwInfo, dRealDistSumToTarget, dSpeedLimit, nTargetID, nNodeCount, &MarkState, &(CtrlInfo.Axis), &IdReaderCmdType, &nID);
			break;
			case MARK_TYPE_TAG_STATION:
				nTmpError = markOnTagStation(HwInfo, dRealDistSumToTarget, dSpeedLimit, nTargetID, &MarkState, &(CtrlInfo.Axis), &IdReaderCmdType, &nID,false);
			break;
			case MARK_TYPE_QR_STATION_LEFT:
				if(HwInfo.QrStaionLeft.nQrId !=0)
				{
					TEACHING_DATA *teachingData = OHTMainForm->GetTeachingDataManager()->Find(HwInfo.QrStaionLeft.nQrId, PORT_TYPE_STB_L);
					if (teachingData != NULL)
					{
                     	nSTBQROffset = teachingData->STBOffSet;
					}

                	ADD_LOG("QR Left Mark Test: = %d ID %d",nSTBQROffset,HwInfo.QrStaionLeft.nQrId);
                }
				if(m_pParamSet->Mark[2].MakerType ==MAKER_TYPE_KEYENCE)
					nTmpError = markOnQRStation(true, HwInfo, dRealDistSumToTarget, dSpeedLimit, nTargetID, &MarkState, &(CtrlInfo.Axis), &IdReaderCmdType, &nID);
				else if(m_pParamSet->Mark[2].MakerType ==MAKER_TYPE_OMRON)
					nTmpError = markOnQRStationDiffType(true, HwInfo, dRealDistSumToTarget, dSpeedLimit, nTargetID, &MarkState, &(CtrlInfo.Axis), &IdReaderCmdType, &nID);
				else
					nTmpError = markOnQRStationDiffType2(true, HwInfo, dRealDistSumToTarget, dSpeedLimit, nTargetID, &MarkState, &(CtrlInfo.Axis), &IdReaderCmdType, &nID, false,nSTBQROffset);
			break;
			case MARK_TYPE_QR_STATION_RIGHT:
				if(HwInfo.QrStaionRight.nQrId !=0)
				{
					TEACHING_DATA *teachingData = OHTMainForm->GetTeachingDataManager()->Find(HwInfo.QrStaionRight.nQrId, PORT_TYPE_STB_R);
					if (teachingData != NULL)
					{
						nSTBQROffset = teachingData->STBOffSet;

						ADD_LOG("QR Right Mark Test: = %d %d %d",teachingData->Shift, teachingData->Hoist,teachingData->STBOffSet);
					}

					ADD_LOG("QR Right Mark Test: = %d ID:%d",nSTBQROffset, HwInfo.QrStaionRight.nQrId);
                }
				if(m_pParamSet->Mark[3].MakerType ==MAKER_TYPE_KEYENCE)
					nTmpError = markOnQRStation(false, HwInfo, dRealDistSumToTarget, dSpeedLimit, nTargetID, &MarkState, &(CtrlInfo.Axis), &IdReaderCmdType, &nID);
				else if(m_pParamSet->Mark[3].MakerType ==MAKER_TYPE_OMRON)
					nTmpError = markOnQRStationDiffType(false, HwInfo, dRealDistSumToTarget, dSpeedLimit, nTargetID, &MarkState, &(CtrlInfo.Axis), &IdReaderCmdType, &nID);
				else
					nTmpError = markOnQRStationDiffType2(false, HwInfo, dRealDistSumToTarget, dSpeedLimit, nTargetID, &MarkState, &(CtrlInfo.Axis), &IdReaderCmdType, &nID, false,nSTBQROffset);
			break;
	//추가
		   case MARK_TYPE_TAG_STATION_BACK:
				dRealDistSumToTarget = -dRealDistSumToTarget;
				nTmpError = markOnTagStationBack(HwInfo, dRealDistSumToTarget, dSpeedLimit, nTargetID, &MarkState, &(CtrlInfo.Axis), &IdReaderCmdType, &nID);
			break;
		}
		
		//1 조향 방향 찾기
		SteerFront = pHWSet->m_pSteer->GetFrontPos();
		
		manual_Mark_cnt++;
		//2 CID 모드 선택(CID모드 및 매뉴얼 설정)
		pHWSet->m_pCID->ElevetorOperatingModeSet(ON);//CID Mode
		//ADD_LOG_TASKCONTROL("[CID] CID_Mode_ON");

		//3 Select ON
		if(SteerFront == HW_STEER_DIRECTION_RIGHT)
		{	
			pHWSet->m_pCID->CID_Out_Manual(ON);
			pHWSet->m_pCID->CID_Out_Left_Select(OFF);
			Sleep(20);
			pHWSet->m_pCID->CID_Out_Right_Select(ON);
			
			//ADD_LOG("[CID] ManualMark OUT_CID_Right_Select_ON");
		}
		else if(SteerFront == HW_STEER_DIRECTION_LEFT)
		{
			pHWSet->m_pCID->CID_Out_Manual(ON);
			pHWSet->m_pCID->CID_Out_Right_Select(OFF);
			Sleep(20);
			pHWSet->m_pCID->CID_Out_Left_Select(ON);
			//ADD_LOG("[CID] ManualMark OUT_CID_Left_Select_ON");
		}
		else
		{}
		
		//4 Link 확인 후 점유
		if(pHWSet->m_pCID->IsLinkOK() == ON)
		{
			CIDResetNode_arr = INDEX_NONE;
			CIDResetNode = 0;
			CIDResetNodeType = 0;
			if(m_pExecuteInfo->ExecutePositionInfo.CurrNode != 0) // Node 정보를 아는 경우 
			{
				CIDResetNode_arr = OHTMainForm->GetMap()->FindNodeIndexFromCIDStop_1(m_pExecuteInfo->ExecutePositionInfo.CurrNode);
				if (CIDResetNode_arr != INDEX_NONE)
				{
					if(pHWSet->m_pCID->IsInterlock_ON() == false)
					{
						pHWSet->m_pCID->CID_Occup_OK();
						ADD_LOG("[CID] ManualMark CIDStop_1");
					}
				}
				else
				{
					CIDResetNode_arr = OHTMainForm->GetMap()->FindNodeIndexFromCIDStop_2(m_pExecuteInfo->ExecutePositionInfo.CurrNode);
					if (CIDResetNode_arr != INDEX_NONE)
					{
						if(pHWSet->m_pCID->IsInterlock_ON() == false)
						{
							pHWSet->m_pCID->CID_Occup_OK();
							ADD_LOG("[CID] ManualMark CIDStop_2");
						}
					}
					else
					{
						ADD_LOG("[CID] ManualMark No Occupancy");
					}
				}
			}
			else // Node 정보를 모르는 경우
			{
				if(pHWSet->m_pCID->IsInterlock_ON() == false)
				{
					pHWSet->m_pCID->CID_Occup_OK();
					ADD_LOG("[CID] ManualMark Unknown Node");
				}
			}
		}
		
        if(MarkState.Arrived==true)
        {
            nIdResult = nID;
			m_StatusSet.uStep = DRIVING_CTRL_STEP_MANUAL_MARK_COMPLETE;
			CheckComplete_ManualMark = timeGetTime();
            ADD_LOG("Mark Test: m_StatusSet.uStep = %d", m_StatusSet.uStep);
        }
        break;
    case DRIVING_CTRL_STEP_MANUAL_MARK_COMPLETE: //2  완료
		if( checkCompletion(HwInfo, &(CtrlInfo.Axis), &(CtrlInfo.Steer) , &(CtrlInfo.FrontObservation))==true )
		{
			//경사로 유무 확인 ---정위치 일 경우.
			if(MarkType == MARK_TYPE_NODE)
			{
				nNodeIndex =	OHTMainForm->GetMap()->FindNodeIndex(nIdResult);
				if(nNodeIndex!=INDEX_NONE) pNODE_INFO = &(OHTMainForm->GetMap()->m_NodeArray[nNodeIndex]);		// Node 정보

				m_nCidControlStep = CID_STEP_CONNECTING;
				//3 마크 동작 후 CID 점유 해제
				pHWSet->m_pCID->CID_Occup_return(6);
			}
			else
			{
				pSData = OHTMainForm->GetStationDataManager()->Find(nIdResult);
				if (pSData != NULL)
				{
					nNodeIndex =	OHTMainForm->GetMap()->FindNodeIndex(pSData->ParentNodeID);
					if(nNodeIndex!=INDEX_NONE) pNODE_INFO = &(OHTMainForm->GetMap()->m_NodeArray[nNodeIndex]);		// Node 정보

				//3 마크 동작 후 CID 점유 해제
				CIDResetNode_arr = INDEX_NONE;
				CIDResetNode = 0;
				CIDResetNodeType = 0;

				CIDResetNode_arr = OHTMainForm->GetMap()->FindNodeIndexFromCIDReset(pSData->NextNodeID);
				if (CIDResetNode_arr != INDEX_NONE)
				{
				  CIDResetNode = OHTMainForm->GetCID_STD()->m_NodeArray[CIDResetNode_arr].ResetNode;
				  CIDResetNodeType = OHTMainForm->GetCID_STD()->m_NodeArray[CIDResetNode_arr].ResetNodeType;
				}
				
				ADD_LOG("[CID] StationData.NextNodeID : %d, CIDResetNode : %d", pSData->NextNodeID, CIDResetNode);

				if(CIDResetNode == pSData->NextNodeID)//StationData.NextNodeID 가 Resetnode 이면, 점유 유지
				{
					//nop
				}
				else
				{
					pHWSet->m_pCID->CID_Occup_return(7);
					}
				}
            }

             if(pNODE_INFO !=NULL)
			 {
				m_cSlopeNodeInfo = pNODE_INFO->InOutInfo ;

				if(pNODE_INFO->InOutInfo ==SLOPE_NTYPE)
				{
					if(m_pDrivingAxis->IsSlaveAMPEnable() ==false)
                        m_pDrivingAxis->SetSlaveAMPEnable(true);

					DWORD dwCurrTime  = timeGetTime();

					while(OHTUTILITY::PreventOverflowGetTimeMs(dwCurrTime)<1000)
					{
						if(m_pServoControl->IsSetInnerLimitTorque_90() ==true)
							break;

						m_pServoControl->SetInnerLimitTorque_90();  //DrivingControl::manual_Mark Retry 존재 Error 처리 0
						ADD_LOG("[manual_Mark1] SetInnerLimitTorque_90");
						Sleep(5);
					}

					if(m_pServoControl->IsSetInnerLimitTorque_90() == false)
					{
					   nTmpError = ERR_SERVO_DRIVING_ALARM;
					   ERR_LOG("[manual_Mark] Fail SetInnerLimitTorque_90");
					}
					else
					{
						//ERR_LOG("[manual_Mark1] Success SetInnerLimitTorque_90");
					}

				}
				else
                {
                    m_pDrivingAxis->SetSlaveAMPEnable(false);
                }
			}
			else
                {
                    m_pDrivingAxis->SetSlaveAMPEnable(false);
                }


			if(m_pExecuteInfo->bJogInterlockIgnore == true)
			{
				EnterCriticalSection(&OHTMainForm->m_CS);
				m_pExecuteInfo->bJogInterlockIgnore = false;
				LeaveCriticalSection(&OHTMainForm->m_CS);
			}

//          m_nCMDType = 0;
            m_StatusSet.byStatus    = STS_COMPLETE;
            m_StatusSet.uError      = NO_ERR;
            m_StatusSet.uStep       = 0;


            //1 NEW
            //------------------------------------------------------------------------------------------------------------------------
//          m_PreviousArrivalInfo.bMarked = true;
//          m_PreviousArrivalInfo.uRealArrivedNode = (MarkType==MARK_TYPE_NODE)?nIdResult:0;
//          m_PreviousArrivalInfo.Info.MarkType = MarkType;
//          m_PreviousArrivalInfo.Info.uNode = (MarkType==MARK_TYPE_NODE)?nIdResult:0;
//          m_PreviousArrivalInfo.Info.uNextNode = 0;
//          m_PreviousArrivalInfo.Info.uStation = (MarkType!=MARK_TYPE_NODE)?nIdResult:0;
//          m_PreviousArrivalInfo.Info.dOffset = 0;
//          m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus = m_PreviousArrivalInfo;

            //1 결과 정리

            dNodeDistOffset = (MarkType==MARK_TYPE_NODE)?m_pParamSet->Mark[0].Dist.dAddDistAfterSecondMet:0.0;

            //2  현재 위치 정리
            m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.bMarked = true;
			if(pSData==NULL)
            {
	            m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.uRealArrivedNode = (MarkType==MARK_TYPE_NODE)?nIdResult:0;
                m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode = (MarkType==MARK_TYPE_NODE)?nIdResult:0;
			}else
			{
				m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.uRealArrivedNode = (MarkType==MARK_TYPE_NODE)?nIdResult:pSData->ParentNodeID;
				m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode = (MarkType==MARK_TYPE_NODE)?nIdResult:pSData->ParentNodeID;
            }
            m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.MarkType =  MarkType;
			m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNextNode = 0;
            m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uStation = (MarkType!=MARK_TYPE_NODE)?nIdResult:0;
            m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset = dNodeDistOffset;


            //2 마크 정보로 정리
            m_InfoSet.Position.Mark.dFrontPosition  = HwInfo.Axis1.dCurrPos;
            m_InfoSet.Position.Mark.dRearPosition   = HwInfo.Axis2.dCurrPos;
            m_InfoSet.Position.Mark.PositionStatus  = m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus;

            //2 마크 정보를 멤버변수로 저장
            setPreviousArrivalInfo(m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus);

            getPostionInfoOnMarked(m_InfoSet, &m_PositionInfo);

            //------------------------------------------------------------------------------------------------------------------------
            ADD_LOG("Mark Test: m_StatusSet.uStep = %d", m_StatusSet.uStep);

            m_StatusSet.bIsOnProcess    = false;
		}
		else
		{

			if(OHTUTILITY::PreventOverflowGetTimeMs(CheckComplete_ManualMark) > 5000)
			{
					nTmpError=ERR_SERVO_DRIVING_ALARM;
					CheckComplete_ManualMark = timeGetTime();
					ADD_LOG("[checkCompletion_Manual Mark] Fail SetInnerLimitTorque_90");
			}
		}
        break;
    }
//	ADD_LOG("Mark Test3:%d",  m_StatusSet.uStep);
    //1 동작
    if(nTmpError==NO_ERR)   nTmpError = controlAxis(CtrlInfo.Axis);
    if(nTmpError==NO_ERR)   nTmpError = controlSteer(CtrlInfo.Steer);
    if(nTmpError==NO_ERR)   nTmpError = controlFrontObservation(CtrlInfo.FrontObservation);
//    if(IdReaderCmdType!=CTRL_INFO_OF_ID_READER_CMD_NONE)
//	{
////        ADD_LOG("Mark Test: %d : %d",MarkType, IdReaderCmdType);
//	}
	if(nTmpError==NO_ERR)   nTmpError = controlIdReader(MarkType, IdReaderCmdType);
//	if(IdReaderCmdType!=CTRL_INFO_OF_ID_READER_CMD_NONE)
//	{
////        ADD_LOG("Mark Test:  Error: %d, %d : %d",nTmpError, MarkType, IdReaderCmdType);
//	}

    //1 에러 확인
    if(nTmpError!=NO_ERR)
    {
		m_pDrivingAxis->MoveStop(0.001);
//        m_pDrivingAxis->SetSlaveAMPEnable(false);

//      m_nCMDType = 0;
        m_StatusSet.byStatus        = STS_ERROR;
        m_StatusSet.uError          = nTmpError;
        m_StatusSet.uStep           = 0;

        m_StatusSet.bIsOnProcess    = false;
    }
    return nTmpError;
}



STEER_HW_INFO_POSITION DrivingControl::getSteerPosition(bool bLeftOn, bool bRightOn)
{
    STEER_HW_INFO_POSITION Result;
    if(bLeftOn==false && bRightOn==false) Result = STEER_HW_INFO_POSITION_NONE;
    else if(bLeftOn==true && bRightOn==false) Result = STEER_HW_INFO_POSITION_LEFT;
    else if(bLeftOn==false && bRightOn==true) Result = STEER_HW_INFO_POSITION_RIGHT;
    else  Result = STEER_HW_INFO_POSITION_BOTH;
    return Result;
}

STEER_HW_INFO_POSITION DrivingControl::getSteerTotalPosition(bool bFrontLeftOn, bool bFrontRightOn, bool bRearLeftOn, bool bRearRightOn)
{
    STEER_HW_INFO_POSITION Result;
    STEER_HW_INFO_POSITION TmpValue[2];

    TmpValue[0] = getSteerPosition(bFrontLeftOn, bFrontRightOn);
    TmpValue[1] = getSteerPosition(bRearLeftOn, bRearRightOn);

    if(TmpValue[0]==STEER_HW_INFO_POSITION_NONE || TmpValue[1]==STEER_HW_INFO_POSITION_NONE) Result=STEER_HW_INFO_POSITION_NONE;
    else if(TmpValue[0]==STEER_HW_INFO_POSITION_LEFT && TmpValue[1]==STEER_HW_INFO_POSITION_LEFT) Result=STEER_HW_INFO_POSITION_LEFT;
    else if(TmpValue[0]==STEER_HW_INFO_POSITION_RIGHT && TmpValue[1]==STEER_HW_INFO_POSITION_RIGHT) Result=STEER_HW_INFO_POSITION_RIGHT;
    else if(TmpValue[0]==STEER_HW_INFO_POSITION_BOTH || TmpValue[1]==STEER_HW_INFO_POSITION_BOTH) Result=STEER_HW_INFO_POSITION_BOTH;
    else Result=STEER_HW_INFO_POSITION_NONE;

    return Result;
}


DRIVING_CMD_INFO_OF_NODE* DrivingControl::getNodeInfo(int nNodeCount)
{
    DRIVING_CMD_INFO_OF_NODE* pNodeInfo = NULL;

    int nCount = m_ClassifiedCmd.NodeList.getCount();
    for(int nIndex = 0; nIndex<nCount; nIndex++)
    {
        pNodeInfo = m_ClassifiedCmd.NodeList.refer(nIndex);
        if(pNodeInfo->nCount==nNodeCount)
        {
            return pNodeInfo;
        }
    }
    return NULL;    //없음
}

DRIVING_CMD_INFO_OF_PATH* DrivingControl::getPathInfo(int nStartNodeCount)
{
    DRIVING_CMD_INFO_OF_PATH* pPathInfo = NULL;

    int nCount = m_ClassifiedCmd.PathList.getCount();
    for(int nIndex = 0; nIndex<nCount; nIndex++)
	{
        pPathInfo = m_ClassifiedCmd.PathList.refer(nIndex);
        if(pPathInfo->nCount==(nStartNodeCount+1))
		{
            return pPathInfo;
        }
    }
    return NULL;    //없음

}

double DrivingControl::compensate(double dRealPos)
{
    double dCompensatedPos  = dRealPos
                                - m_InfoSet.Position.Compensation.dDistErrorSum
                                + m_InfoSet.Position.Compensation.dPreArriveOffset;
    return dCompensatedPos;
}
double DrivingControl::getRealPos(double dCompensatedPos)
{
    double dRealPos = dCompensatedPos
                        + m_InfoSet.Position.Compensation.dDistErrorSum
                        - m_InfoSet.Position.Compensation.dPreArriveOffset;
    return dRealPos;
}

double DrivingControl::getSpeedDownPos(double dAccel, double dSpeed, double dDist)
{
	double dSpeedDownPos = 0.0;
    dSpeedDownPos   = dDist-fabs((dSpeed*dSpeed)/(2*dAccel));   // S=(V^2)/(2*a)
    return dSpeedDownPos;
}

bool DrivingControl::isMarkArea()
{
    bool bOnMarkArea = false;

    double dOffset = 0.0;
    double dMarkStartPos = m_ClassifiedCmd.TargetInfo.dDistSumToNode;

    switch(m_ClassifiedCmd.TargetInfo.Type)
    {
		case MARK_TYPE_NODE:
            dOffset = m_pParamSet->Mark[0].Dist.dMinLengthToNext;
        break;
		case MARK_TYPE_TAG_STATION:
			dOffset = m_pParamSet->Mark[1].Dist.dMinLengthToNext;
		break;
		case MARK_TYPE_TAG_STATION_BACK:
            dOffset = -(m_pParamSet->Mark[1].Dist.dMinLengthToNext*1.5);
		break;
        case MARK_TYPE_QR_STATION_LEFT:
            dOffset = m_pParamSet->Mark[2].Dist.dMinLengthToNext;
        break;
        case MARK_TYPE_QR_STATION_RIGHT:
            dOffset = m_pParamSet->Mark[3].Dist.dMinLengthToNext;
        break;
    }
    if(m_ClassifiedCmd.TargetInfo.Type==MARK_TYPE_NODE)
    {
        dMarkStartPos   = m_ClassifiedCmd.TargetInfo.dDistSumToNode
						- dOffset -50;
	}
	else
	{
		dMarkStartPos   = m_ClassifiedCmd.TargetInfo.dDistSumToNode
                        + m_ClassifiedCmd.TargetInfo.dOffset
						- dOffset -50;

//		ADD_LOG("<<IsMark : %f>>",dMarkStartPos);
    }

   if(m_ClassifiedCmd.TargetInfo.Type != MARK_TYPE_TAG_STATION_BACK)
   {
		if( m_InfoSet.HwInfo.Axis1.dCurrPos >=getRealPos(dMarkStartPos) )
		{
			if(     (m_ClassifiedCmd.TargetInfo.dOffset>=dOffset)
				||  (m_ClassifiedCmd.TargetInfo.Type==MARK_TYPE_NODE)   )
			{
				bOnMarkArea = true;
			}
			else
			{
				switch(m_ClassifiedCmd.TargetInfo.Steering)
				{
				case PATH_STEERING_NONE:
					bOnMarkArea = true;
					break;

				case PATH_STEERING_LEFT:
				case PATH_STEERING_N_BRANCH_L2R:
					if(     (m_InfoSet.Steer.FrontPosition==STEER_HW_INFO_POSITION_LEFT)
						&&  (m_InfoSet.Steer.RearPosition==STEER_HW_INFO_POSITION_LEFT))
					{
						bOnMarkArea = true;
					}
					break;

				case PATH_STEERING_RIGHT:
				case PATH_STEERING_N_BRANCH_R2L:
					if(     (m_InfoSet.Steer.FrontPosition==STEER_HW_INFO_POSITION_RIGHT)
						&&  (m_InfoSet.Steer.RearPosition==STEER_HW_INFO_POSITION_RIGHT))
					{
						bOnMarkArea = true;
					}
					break;
				}
			}
		}
	 }else
	 {

		if( (double)m_InfoSet.HwInfo.Axis1.dCurrPos <=(double)getRealPos(dMarkStartPos))
		{
		   ADD_LOG("<<IsMark2 : %06f, %06f, %06f, %06f>>",m_InfoSet.HwInfo.Axis1.dCurrPos,getRealPos(dMarkStartPos),m_ClassifiedCmd.TargetInfo.dOffset, dOffset);
//		   if((double)m_ClassifiedCmd.TargetInfo.dOffset>=(double)dOffset)
           bOnMarkArea = true;
//		   else
//		   {
//		   		switch(m_ClassifiedCmd.TargetInfo.Steering)
//				{
//				case PATH_STEERING_NONE:
//					bOnMarkArea = true;
//					break;
//
//				case PATH_STEERING_LEFT:
//				case PATH_STEERING_N_BRANCH_L2R:
//					if(     (m_InfoSet.Steer.FrontPosition==STEER_HW_INFO_POSITION_LEFT)
//						&&  (m_InfoSet.Steer.RearPosition==STEER_HW_INFO_POSITION_LEFT))
//					{
//						bOnMarkArea = true;
//					}
//					break;
//
//				case PATH_STEERING_RIGHT:
//				case PATH_STEERING_N_BRANCH_R2L:
//					if(     (m_InfoSet.Steer.FrontPosition==STEER_HW_INFO_POSITION_RIGHT)
//						&&  (m_InfoSet.Steer.RearPosition==STEER_HW_INFO_POSITION_RIGHT))
//					{
//						bOnMarkArea = true;
//					}
//					break;
//				}
//			}
        }
	 }

#if 0   // Log Test 완료 후 주석 처리
    if(bOnMarkArea==true)// && m_InfoSet.EventAndState.State.MarkArea==false)
    {
        ADD_LOG("MarkAreaIn[%06d(%7.1lf) %d:%06d(%7.1lf) %06d(%7.1lf)] Curr:%06d(%7.1lf)"
            , m_ClassifiedCmd.TargetInfo.Node
            , m_ClassifiedCmd.TargetInfo.dDistSumToNode
            , m_ClassifiedCmd.TargetInfo.Type
            , m_ClassifiedCmd.TargetInfo.Station
            , m_ClassifiedCmd.TargetInfo.dOffset
            , m_ClassifiedCmd.TargetInfo.NextNode
            , m_ClassifiedCmd.TargetInfo.dLength
            , m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode
			, m_InfoSet.Position.Compensation.dCompensatedPosition
            )
        ADD_LOG("%7.1lf=%7.1lf+%7.1lf-%7.1lf : %7.1lf>%7.1lf(%7.1lf+%7.1lf-%7.1lf)"
            , dMarkStartPos
            , m_ClassifiedCmd.TargetInfo.dDistSumToNode
            , m_ClassifiedCmd.TargetInfo.dOffset
            , dOffset
            , m_InfoSet.HwInfo.Axis1.dCurrPos
            , getRealPos(dMarkStartPos)
            , dMarkStartPos
			, m_InfoSet.Position.Compensation.dDistErrorSum
            , m_InfoSet.Position.Compensation.dPreArriveOffset
            );
    }
#endif


    return bOnMarkArea;
}



/**
@brief   입력하는 Node Count 다음의 Path들에서 추후 조향 방향 구하는 함수: 특별히 없으면 false Return
@author  임태웅
@date    2013.08.06
@param nNodeCount: Node Count
@param SteerCmd: 조향 명령(0: Left / 1: Right)
@return 명령이 있으면 true 반환, 없으면 false 반환
*/
bool DrivingControl::getSteerCmd(int nNodeCount, STEER_HW_INFO_CMD *pSteerCmd)
{
    int nListCount = m_ClassifiedCmd.SteerList.getCount();
    int nTmpIndex   = 0;
    DRIVING_CMD_INFO_OF_STEER* pItem = NULL;
    STEER_HW_INFO_CMD TmpSteerCmd;
    bool bCmdExist = false;

    //1 명령이 없을 경우
    if(nListCount==0) //명령이 없음
    {
        return false;
	}

    //1 명령이 있을 경우
    for(nTmpIndex; nTmpIndex<nListCount; nTmpIndex++)
    {
        pItem = m_ClassifiedCmd.SteerList.refer(nTmpIndex);
        if(pItem!=NULL)
        {

//          ADD_LOG("getSteerCmd[%d] %d(%d), (%d:%d), %6.1lf"
//              , nTmpIndex
//              , pItem->nCount, nNodeCount, pItem->Type, pItem->NextType, pItem->dDistSumToEndNode);

            if(pItem->nCount<=nNodeCount)
            {
				continue;
            }
			else
            {
//              ADD_LOG("pItem->Type = %d",pItem->Type);
				if(getSteerCmdTypeFrom(pItem->Type, &TmpSteerCmd)==true)
                {
                    *pSteerCmd = TmpSteerCmd;
//					ADD_LOG("[getSteerCmdTypeFrom] %d %d",pItem->Type,TmpSteerCmd);
//                  ADD_LOG("pItem->Type=%d / TmpSteerCmd=%d / *pSteerCmd=%d"
//                      ,pItem->Type, TmpSteerCmd, *pSteerCmd);
                    return true;
                }
            }
        }
    }

    //1 명령에 조향 명령이 없고 마지막에 선조향 명령이 있을 경우
    if(pItem!=NULL)
    {
		if(getSteerCmdTypeFrom(pItem->NextType, &TmpSteerCmd)==true)
		{
//			ADD_LOG("[getSteerCmdTypeFromNext] %d %d",pItem->NextType,TmpSteerCmd);
	        *pSteerCmd = TmpSteerCmd;
			return true;
	    }
    }

    //1 명령에 조향 명령이 없고 선조향 명령도 없을 경우
    return  false;

}


bool DrivingControl::getSteerCmdOnNBranch(STEER_HW_INFO_CMD *pSteerCmd)
{
//  ADD_LOG("getSteerCmdOnNBranch FP:%d, Path:%d"
//      , m_InfoSet.Steer.FrontPosition
//      , m_InfoSet.Steer.PathSteer);
    if(m_InfoSet.Steer.FrontPosition==STEER_HW_INFO_POSITION_NONE)
    {

        switch(m_InfoSet.Steer.PathSteer)
        {
        case PATH_STEERING_N_BRANCH_L2R:
            *pSteerCmd = STEER_HW_INFO_CMD_RIGHT;
            break;
        case PATH_STEERING_N_BRANCH_R2L:
			*pSteerCmd = STEER_HW_INFO_CMD_LEFT;
            break;
        default:
            return false;
        }
        return true;
    }
    return false;
}


bool DrivingControl::getSteerCmdTypeFrom(PATH_STEERING_INFO PathSteerInfo, STEER_HW_INFO_CMD *pSteerCmd, STEER_HW_INFO_CMD *pSteerKey)
{
    STEER_HW_INFO_CMD SteerCmd;
    STEER_HW_INFO_CMD SteerKey;

    switch(PathSteerInfo)
    {
	case PATH_STEERING_NONE:
        return false;
        break;
    case PATH_STEERING_LEFT:
		SteerCmd = STEER_HW_INFO_CMD_LEFT;
		SteerKey = STEER_HW_INFO_CMD_LEFT;
		break;
    case PATH_STEERING_RIGHT:
        SteerCmd = STEER_HW_INFO_CMD_RIGHT;
        SteerKey = STEER_HW_INFO_CMD_RIGHT;
        break;
    case PATH_STEERING_N_BRANCH_L2R:
		SteerCmd = STEER_HW_INFO_CMD_LEFT;
        SteerKey = STEER_HW_INFO_CMD_RIGHT;
        break;
    case PATH_STEERING_N_BRANCH_R2L:
        SteerCmd = STEER_HW_INFO_CMD_RIGHT;
        SteerKey = STEER_HW_INFO_CMD_LEFT;
        break;
    }
    if(pSteerCmd!=NULL)*pSteerCmd = SteerCmd;
    if(pSteerKey!=NULL)*pSteerKey = SteerKey;
    return true;
}


bool DrivingControl::getSteerCmdTypeFrom(PATH_STEERING_INFO PathSteerInfo, STEER_HW_INFO_CMD *pSteerCmd)
{
    return getSteerCmdTypeFrom(PathSteerInfo, pSteerCmd, NULL);
}


bool DrivingControl::isSteerChangeAreaByGuide()
{
	DRIVING_CMD_INFO_OF_PATH* pPathInfo = getPathInfo(m_InfoSet.HwInfo.Node.nNodeCount);

	bool bSteerChangeAreaByGuide = false;   // N분기 가이드 레일에 의해 조향이 변경되는 구간

    // N분기 영역 확인
	if(pPathInfo!=NULL)
    {
//      ADD_LOG("[isSteerChangeAreaByGuide] Type:%d", pPathInfo->Steering);
		if(pPathInfo->Steering==STEERING_N_BRANCH_L2R||pPathInfo->Steering==STEERING_N_BRANCH_R2L)
        {
//          ADD_LOG("[isSteerChangeAreaByGuide] Offset:%6.1lf, Margin:%6.1lf, NC[%d:%d]"
//              , m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset
//              , m_pParamSet->Link.dNBranchMiddleAreaInMargin
//              , m_InfoSet.HwInfo.Node.nNodeCount
//              , m_InfoSet.HwInfo.Node.nPreCheckCount);
//
            if(     (m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset
                    >m_pParamSet->Link.dNBranchMiddleAreaInMargin )
                &&  (m_InfoSet.HwInfo.Node.nNodeCount==m_InfoSet.HwInfo.Node.nPreCheckCount)
                )
            {
				bSteerChangeAreaByGuide = true;
			}
		}
    }

	return bSteerChangeAreaByGuide;

}


bool DrivingControl::isSteerChangeAreaByGuideNodeCountAdd()
{
	DRIVING_CMD_INFO_OF_PATH* pPathInfo = getPathInfo(m_InfoSet.HwInfo.Node.nNodeCount);

	bool bSteerChangeAreaByGuide = false;   // N분기 가이드 레일에 의해 조향이 변경되는 구간

    // N분기 영역 확인
	if(pPathInfo!=NULL)
    {
//      ADD_LOG("[isSteerChangeAreaByGuide] Type:%d", pPathInfo->Steering);
		if(pPathInfo->Steering==STEERING_N_BRANCH_L2R||pPathInfo->Steering==STEERING_N_BRANCH_R2L)
        {
//          ADD_LOG("[isSteerChangeAreaByGuide] Offset:%6.1lf, Margin:%6.1lf, NC[%d:%d]"
//              , m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset
//              , m_pParamSet->Link.dNBranchMiddleAreaInMargin
//              , m_InfoSet.HwInfo.Node.nNodeCount
//              , m_InfoSet.HwInfo.Node.nPreCheckCount);
//
            if(     (m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset
                    >m_pParamSet->Link.dNBranchMiddleAreaInMargin )
                )
            {
				bSteerChangeAreaByGuide = true;
			}
		}
    }

	return bSteerChangeAreaByGuide;

}

/**
@brief   분기 정보
@author  puting
@date    2016.11.06
*/
bool DrivingControl::getDivergenceInfo(int nNodeCount, PATH_DIVERGENCE_INFO* pDivInfo,PATH_DIVERGENCE_INFO* pPreDivInfo, int *NodeCount)
{
	int nListCount = m_ClassifiedCmd.DivList.getCount();
    int nTmpIndex   = 0;
    DRIVING_CMD_INFO_OF_DIV* pItem = NULL;
//	PATH_DIVERGENCE_INFO DetectInfo;
    bool bCmdExist = false;

    //1 명령이 없을 경우
    if(nListCount==0) //명령이 없음
    {
        return false;
    }

    //1 명령이 있을 경우
	for(nTmpIndex; nTmpIndex<nListCount; nTmpIndex++)
	{
		pItem = m_ClassifiedCmd.DivList.refer(nTmpIndex);

		if(pItem!=NULL)
		{

			if(pItem->nCount<=nNodeCount)
            {
                continue;
            }
            else
			{
				 // ADD_LOG("nNodeCount:%d/%d (%d,%d)", nNodeCount,pItem->nCount,pItem->Type, pItem->NextType);
				*pDivInfo = pItem->Type;
				*pPreDivInfo =  pItem->NextType;
				*NodeCount =  pItem->nCount;
				return true;
			}
		}
	}

	//1 명령이 없을 경우
	return  false;

}


bool DrivingControl::getFrontObservation(int nPreCheckCount, USER_DETECT_INFO* pDetectInfo)
{
    int nListCount = m_ClassifiedCmd.DirectionList.getCount();
    int nTmpIndex   = 0;
    DRIVING_CMD_INFO_OF_DIRECTION* pItem = NULL;
//	USER_DETECT_INFO DetectInfo;
    bool bCmdExist = false;

    //1 명령이 없을 경우
    if(nListCount==0) //명령이 없음
    {
        return false;
	}

    //1 명령이 있을 경우
    for(nTmpIndex; nTmpIndex<nListCount; nTmpIndex++)
    {
        pItem = m_ClassifiedCmd.DirectionList.refer(nTmpIndex);
        if(pItem!=NULL)
        {
            if(pItem->nCount<=nPreCheckCount)
            {
                continue;
            }
            else
			{
				pDetectInfo->UseFollowControlFlag = true;

#if(USE_CHANGENODE == 1)
				//인터락 보완 패턴이 없을 경우 디폴트로 직선패턴(20170219)
				if(pItem->UBGRegion == PATH_DIRECTION_NO_USE) pItem->UBGRegion = PATH_DIRECTION_NORMAL;
				if(pItem->OptUBGRegion == PATH_DIRECTION_NO_USE) pItem->OptUBGRegion = PATH_DIRECTION_NORMAL;
				if(pItem->ObstacleRegion == PATH_OBS_DIRECTION_NO_USE) pItem->ObstacleRegion = PATH_OBS_DIRECTION_NORMAL;
				if(pItem->OptObstacleRegion == PATH_OBS_DIRECTION_NO_USE) pItem->OptObstacleRegion = PATH_OBS_DIRECTION_NORMAL;

				pDetectInfo->OHTDetectType = pItem->UBGRegion;
				pDetectInfo->OBSDetectType = pItem->ObstacleRegion;
				pDetectInfo->NodeCount = nPreCheckCount;//pItem->nCount;
				pDetectInfo->DistSumOfStraightPath    = getRealPos(pItem->dDistSumToEndNode)
                                                    + m_pParamSet->FrontDetect.dObsStraightDetectMargin;
				pDetectInfo->FollowCommandType = pItem->nFollowsCommandType;
				pDetectInfo->PBSIgnoreFlag = pItem->nPBSIgnoreFlag;

				// for change node (jhoun.lim)
				pDetectInfo->NodeType = pItem->NodeType;
				pDetectInfo->DistON = pItem->OptDistance;
				pDetectInfo->DistAfterON = pItem->OptDistanceAfter;
				pDetectInfo->OHTDetectTypeOpt = pItem->OptUBGRegion;
				pDetectInfo->OBSDetectTypeOpt = pItem->OptObstacleRegion;
#else
				//인터락 보완 패턴이 없을 경우 디폴트로 직선패턴(20170219)
				if(pItem->Type == PATH_DIRECTION_NO_USE)
				{
                   pItem->Type = PATH_DIRECTION_NORMAL;
				   pItem->Type = pItem->Type | (PATH_DIRECTION_NORMAL<<4);
				}

				pDetectInfo->Type = pItem->Type;
				pDetectInfo->NodeCount = nPreCheckCount;//pItem->nCount;
				pDetectInfo->DistSumOfStraightPath    = getRealPos(pItem->dDistSumToEndNode)
                                                    + m_pParamSet->FrontDetect.dObsStraightDetectMargin;
				pDetectInfo->FollowCommandType = pItem->nFollowsCommandType;
				pDetectInfo->PBSIgnoreFlag = pItem->nPBSIgnoreFlag;
#endif
//				*pDetectInfo = DetectInfo;
				return true;
			}
        }
    }

    //1 명령이 없을 경우
    return  false;

}

bool DrivingControl::getFrontObservationNodeCount(int nPreCheckCount)
{
    int nListCount = m_ClassifiedCmd.DirectionList.getCount();
    int nTmpIndex   = 0;
    DRIVING_CMD_INFO_OF_DIRECTION* pItem = NULL;
	USER_DETECT_INFO DetectInfo;
    bool bCmdExist = false;

    //1 명령이 없을 경우
    if(nListCount==0) //명령이 없음
    {
        return false;
	}

    //1 명령이 있을 경우
    for(nTmpIndex; nTmpIndex<nListCount; nTmpIndex++)
    {
        pItem = m_ClassifiedCmd.DirectionList.refer(nTmpIndex);
        if(pItem!=NULL)
        {
            if(pItem->nCount<=nPreCheckCount)
            {
                continue;
            }
            else
			{

#if(USE_CHANGENODE == 1)
				//인터락 보완 패턴이 없을 경우 디폴트로 직선패턴(20170219)
				if(pItem->UBGRegion == PATH_DIRECTION_NO_USE) pItem->UBGRegion = PATH_DIRECTION_NORMAL;
				if(pItem->OptUBGRegion == PATH_DIRECTION_NO_USE) pItem->OptUBGRegion = PATH_DIRECTION_NORMAL;
				if(pItem->ObstacleRegion == PATH_OBS_DIRECTION_NO_USE) pItem->ObstacleRegion = PATH_OBS_DIRECTION_NORMAL;
				if(pItem->OptObstacleRegion == PATH_OBS_DIRECTION_NO_USE) pItem->OptObstacleRegion = PATH_OBS_DIRECTION_NORMAL;

				m_Dectect_Dir = pItem->UBGRegion;
				m_Dectect_OBS_Dir = pItem->ObstacleRegion;
#else
				//인터락 보완 패턴이 없을 경우 디폴트로 직선패턴(20170219)
				if(pItem->Type == PATH_DIRECTION_NO_USE)
				{
                   pItem->Type = PATH_DIRECTION_NORMAL;
				   pItem->Type = pItem->Type | (PATH_DIRECTION_NORMAL<<4);
				}

				m_Dectect_Dir = pItem->Type & 0x0F;
				m_Dectect_OBS_Dir = (pItem->Type & 0xF0) >> 4;
#endif


				return true;
			}
        }
    }

    //1 명령이 없을 경우
    return  false;

}
/**
@brief   후진 명령 생성
@author  puting
@date    2016.11.06
*/
bool DrivingControl::getAxisCmdInfoBack(DRIVING_INFO_SET *pInfoSet, CTRL_INFO_OF_SYNC_AXIS_MOVE* pCtrlInfo)

{

	bool    bCmdExist = false;          // 명령이 있다
	bool    bLowSpeed = false;          // 직진부 전후로 조향이 다른 경우
	bool    bOutInNode = false;     // Node 전후로 조향이 다른 경우
	bool    bIsToTarget = false;
	bool    bNextPathExist = false; // 명령 나간 Node 이후 Path 존재 여부 확인, 마지막 Node까지 명령이 나갔다
	int     nKeyNodeCount = 0;
	int     nResultNodeCount = 0;
	int     nCheckPointOfPosition = 0;  // 이동 거리가 산출된 곳을 확인하기 위한 변수, 실제로 사용되는 곳 없음

	int     nCurrNodeCount = pInfoSet->HwInfo.Node.nNodeCount;
	int     nCurrPreNodeCount = pInfoSet->HwInfo.Node.nPreCheckCount;




	int nPreCheckCount = pInfoSet->HwInfo.Node.nNodeCount;

	//  DRIVING_CMD_INFO_OF_PATH* pPathInfo = getPathInfo(pInfoSet->HwInfo.Node.nNodeCount);
    DRIVING_CMD_INFO_OF_PATH* pPathInfo = getPathInfo(pInfoSet->Position.CmdRefInfo.nCount);

	if(pPathInfo!=NULL)bNextPathExist=true;

	if( (nPreCheckCount==0)
	&&  (pInfoSet->Position.bPreCheckIsOverFirstNode==true)
	)
	{
		nPreCheckCount=1;
    }


	int     nCmdTargetNodeCount = pInfoSet->Position.CmdRefInfo.nCount;
	double dCurrPos = pInfoSet->HwInfo.Axis1.dCurrPos;


	double  dSafetySpeedLimit = m_pParamSet->Axis.Limit.Speed.MaxValue; // 초기화(최대값)
	double  dSpeedLimit= 0.0;
	double  dSpeedResult= 0.0;
	int     nNodeCountBySpeed = 0;
    double  dTmpSpeedLimit = 0.0;



	STEER_HW_INFO_POSITION  CurrTotalSteerPos;
    int     anNodeCountBySteer[2] = {0,};



	bool bSpeedDownPassed   = pInfoSet->EventAndState.State.SpeedDownPassed;
	double dCurrSpeed       = pInfoSet->HwInfo.Axis1.dSpeed;
	double dCurrCmdSpeed    = pInfoSet->Position.CmdRefInfo.dCmdSpeed;
	double dNextPathSpeed;

	if(pPathInfo!=NULL)
	{
		dNextPathSpeed   = (bNextPathExist==true)?pPathInfo->dSpeed:0.0; // 명령 받은 Node 다음 Path의 속도
	}

	double dTmpdist = 0.0;
	double dTmpPosition = 0.0;
	double dPreCmdPosition = pInfoSet->Position.CmdRefInfo.dDist;
	double dSmoothSpeed = 0.0;
	DRIVING_CMD_INFO_OF_NODE* pNodeInfo = NULL;

	STEER_HW_INFO_CMD TmpSteerCmdForNext;   // Front 조향 변경 시 300mm 더가는 것 학인 목적
	bool bNeedNextSteer;            // Front 조향 변경 시 300mm 더가는 것 학인 목적
	double dMarginBeforeFinalNode = 0.0;


#if(UBG_SENSOR_ENABLE == ON)
	bool sStopWithNoReason  =   (   pInfoSet->HwInfo.IO.Axis1Running==false
									&&  pInfoSet->HwInfo.IO.DetectStatus==0
									&&  pInfoSet->HwInfo.IO.ObsStatus==0)
									?true:false;
#else
	bool sStopWithNoReason  =   (   pInfoSet->HwInfo.IO.Axis1Running==false
									&& pInfoSet->HwInfo.IO.ObsStatus==0)
									?true:false;
#endif



	double  dTmpAccel = m_pParamSet->Axis.Default.dDefaultAccel;

    double  dTmpDecel = m_pParamSet->Axis.Default.dDefaultDecel;



	//1 Node Count 시작 위치 설정
	// SpeedDown 통과 시
	if(bSpeedDownPassed==true)
	{
		// 다음 속도가 적을 경우: 다음 명령 수행
		if(dNextPathSpeed<dCurrCmdSpeed)
		{
			nKeyNodeCount = nCmdTargetNodeCount;
			pInfoSet->Position.CmdRefInfo.nKeyCount = nCmdTargetNodeCount;
   		}
		// 다음 속도가 크거나 같은 경우: 일반 처리
		else
		{
			nKeyNodeCount = nPreCheckCount;
        }
	}
	// SpeedDown 미통과 시: 일반 처리
	else
	{
        nKeyNodeCount = nPreCheckCount;
	}





	// 감속 중일 때, 적정 속도 확보
	if(nKeyNodeCount < pInfoSet->Position.CmdRefInfo.nKeyCount) // 감속 위치를 한번이라도 지나면 나타나는 현상
	{
		nKeyNodeCount = pInfoSet->Position.CmdRefInfo.nKeyCount;
		// 안전 속도 확보
		if(bNextPathExist==true)// 명령 준 Node 넘어로 Path 가 더 남아 있는 경우
		{
			dSafetySpeedLimit = MIN(dCurrCmdSpeed, dNextPathSpeed);
		}
		else    // 명령 준 Node 넘어로 남아있는 Path 가 없는 경우 , 명령 준 Node 가 마지막인 경우 마지막 명령 준 속도를 리밋으로 한다.
		 {
			 dSafetySpeedLimit = dCurrCmdSpeed;
		}

    }



	//1  명령 기준 정보 획득
    //2 속도 변화에 따른 정보 획득(Node Count, 속도, 거리) : OutLine
	bCmdExist = getAxisCmdInfoBySpeed(nKeyNodeCount, &dSpeedLimit, &nNodeCountBySpeed);
	dSpeedLimit = MIN(dSafetySpeedLimit, dSpeedLimit);// 저속 중 Node 만나서 가속 경우 : 노드 만나기 전까지  빠른 가속 방지

//	ADD_LOG("getAxisCmdInfo Step3 %d %d %d",nKeyNodeCount, bCmdExist, nNodeCountBySpeed);
	//2 Steer에 따른 정보 획득(Node Count, 속도, 거리) : --> 감속 거리
	if(bCmdExist==true)
	{
		CurrTotalSteerPos = getSteerTotalPosition(    pInfoSet->HwInfo.IO.SteerFrontLeftInOn
													, pInfoSet->HwInfo.IO.SteerFrontRightInOn
													, pInfoSet->HwInfo.IO.SteerRearLeftInOn
                                                    , pInfoSet->HwInfo.IO.SteerRearRightInOn);

		switch(CurrTotalSteerPos)
		{
		case STEER_HW_INFO_POSITION_NONE:
            break;

		case STEER_HW_INFO_POSITION_LEFT:
			if( (pInfoSet->Steer.FrontCmdDirection!=DRIVING_IO_STEER_DIRECTION_CMD_LEFT)
			||  (pInfoSet->Time.Steer.FrontSteeringArrived.bFlag==false)
			||  (pInfoSet->Time.Steer.RearSteeringArrived.bFlag==false)
			)
			{
				bCmdExist = false;
			}

            break;

		case STEER_HW_INFO_POSITION_RIGHT:
			if( (pInfoSet->Steer.FrontCmdDirection!=DRIVING_IO_STEER_DIRECTION_CMD_RIGHT)
			||  (pInfoSet->Time.Steer.FrontSteeringArrived.bFlag==false)
			||  (pInfoSet->Time.Steer.RearSteeringArrived.bFlag==false)
			)
			{
				bCmdExist = false;
			}
            break;

        case STEER_HW_INFO_POSITION_BOTH:

            break;

		}

	}



//	ADD_LOG("getAxisCmdInfo Step4 %d %f",bCmdExist, CurrTotalSteerPos);



    //2 Node Count 결과 확인

	if(bCmdExist==true)
	{
		nResultNodeCount = nNodeCountBySpeed;
		bOutInNode = false;

        // Node Count 가 명령 나간 지점 보다 적어지면 명령 나간 곳으로 명령(PreCheck 지점 에서 조향 변경 중)

		if(nResultNodeCount<nCmdTargetNodeCount)
		{
			//bCmdExist=false;
            nResultNodeCount=nCmdTargetNodeCount;
        }

	}



//	ADD_LOG("getAxisCmdInfo Step5 %d %f",nResultNodeCount, nCmdTargetNodeCount);



    //2 Data 결과 처리

	if(bCmdExist==true)
	{

		pNodeInfo = getNodeInfo(nResultNodeCount);
		if(pNodeInfo!=NULL)
		{

			dTmpPosition = getRealPos(pNodeInfo->dDistSum);
			nCheckPointOfPosition = 0;

			//1 속도 사다리꼴화
			dSpeedResult = dSpeedLimit;

			ADD_LOG("getMaxSpeed[%f][%f][%f] %d",dTmpPosition,pNodeInfo->dDistSum,pInfoSet->HwInfo.Axis1.dCurrPos,nResultNodeCount);

			//1 거리 구하기

			if(pNodeInfo->nCount==m_ClassifiedCmd.TargetInfo.nCount)
			{

				bIsToTarget = true;

				 dMarginBeforeFinalNode = (nResultNodeCount==nCurrNodeCount)?-150:-DIST_MARGIN_TO_NODE_TO_CONPENSATE_SLIP; // 타겟 도착하기 전이면 이 값을 빼서 이동, 최종 Node 지나서 정확한 위치로 보냄
				 dTmpPosition    =(dTmpPosition+dMarginBeforeFinalNode);
				 nCheckPointOfPosition = 2;

			}
			else
			{
				dTmpPosition    =   (bSpeedDownPassed==true)
								?   MIN(dPreCmdPosition,(dTmpPosition-DIST_MARGIN_TO_NODE_TO_CONPENSATE_SLIP))
								:   (dTmpPosition-DIST_MARGIN_TO_NODE_TO_CONPENSATE_SLIP);

				nCheckPointOfPosition = 14;
			}
			ADD_LOG("nCheckPointOfPosition[%d] %f",nCheckPointOfPosition, dTmpPosition);


            //1 조향 사이 Normal Path 이동 부드럽게

			dTmpAccel   = (m_pParamSet->Axis.Default.dDefaultAccel)
						/ (getAccelDivisor(nCurrPreNodeCount));
			dTmpDecel   = (bIsToTarget)?(m_pParamSet->Axis.Default.dDefaultDecel*2/3)
						:(m_pParamSet->Axis.Default.dDefaultDecel
						/getDecelDivisor(MAX(nCurrNodeCount,(nResultNodeCount-1))));

            // 가속도 변경에 의한 고속 커브 진입 방지
			if( (pInfoSet->Position.CmdRefInfo.dRefSpeed>=dSpeedLimit)// 이전 속도가 빠르고
			&&  (pInfoSet->Position.CmdRefInfo.dCmdDecel>dTmpDecel)// 이전 감속도가 크고
			&&  (dCurrSpeed>(dSpeedLimit+m_pParamSet->Axis.Default.dDefaultDecel*16))// 현재 속도가 다음 속도보다 빠르고: 16ms(Thread 1주기)
			&&  (nCurrNodeCount<nKeyNodeCount)// 노드 카운트가 키 노드 카운트를 지나지 않았을 경우
			 )
			{
				dTmpDecel = pInfoSet->Position.CmdRefInfo.dCmdDecel;
			}


			dSpeedResult = dSpeedLimit;
			if(bLowSpeed)                  			{

				// 마지막이 아니거나, 마지막인데 Path 중간의 Node 인 경우
				if(     (m_ClassifiedCmd.TargetInfo.nCount!=pNodeInfo->nCount)
					&&  ((m_ClassifiedCmd.TargetInfo.nCount==pNodeInfo->nCount)
							&&(m_ClassifiedCmd.TargetInfo.Type==MARK_TYPE_NODE)
							&&(pNodeInfo->Type!=NORMAL_POINT))
				)
				{

					dTmpdist = getDist(anNodeCountBySteer[0], nResultNodeCount);
					dSmoothSpeed = getSmoothSpeed(dTmpDecel, dTmpdist, m_pParamSet->Steer.dwChangeTime);
					dSpeedResult = MIN(dSmoothSpeed, dSpeedResult);
					dSpeedResult = MIN(dSmoothSpeed, dSpeedLimit);

                }

			}

//          else

//          {

//              dSpeedResult = MIN(dSpeedLimit,(DRIVING_SPEED_SMOOTHING_FACTOR

//                                                  *getMaxSpeed(   dTmpAccel ,dTmpDecel ,(dTmpPosition-pInfoSet->HwInfo.Axis1.dCurrPos))));

//          }





			//2 속도 이전과 비교 처리: 사다리꼴 모양 만들기 --> 후반부 감속 처리 제거 및 초기 튐 제거
            if( (pInfoSet->Position.CmdRefInfo.nCount!=0)
			   &&  (pInfoSet->Position.CmdRefInfo.nCount==nResultNodeCount)
			&&  (pInfoSet->Position.CmdRefInfo.dCmdSpeed>dSpeedResult)
			   &&  (bSpeedDownPassed==false)
			)
            {

                if( (bNextPathExist==true)              // 다음 경로가 있고
				&&  (dNextPathSpeed<dSpeedLimit)        // 다음 경로 기준 속도가 현재 경로 기준 속도보다 느리고
				&&  (dNextPathSpeed>dSpeedResult)   // 다음 경로 속도가 현재 결과 속도보다 큰 경우
				)
				{
					dSpeedResult = dNextPathSpeed;
				}
				else
				{
					if(nCurrPreNodeCount<nResultNodeCount)
					{
						dSpeedResult = pInfoSet->Position.CmdRefInfo.dCmdSpeed;
					}
				}
            }

            //2 속도 Min Max 처리

			dSpeedResult = MAX(dSpeedResult, (m_pParamSet->Axis.Limit.Speed.MinValue));
			dSpeedResult = MIN(dSpeedResult, (m_pParamSet->Axis.Limit.Speed.MaxValue));

            //2 시작 시 뒤로 이동 방지 처리

			dTmpPosition = MIN(dCurrPos, dTmpPosition); // 뒤로 이동 방지

			//ADD_LOG("AxisRun[%f][%f][%f][%f][%f]",dTmpPosition,dCurrPos,dTmpAccel,dTmpDecel,dSpeedResult);
			memset(pCtrlInfo, 0x00, sizeof(CTRL_INFO_OF_SYNC_AXIS_MOVE));

            pCtrlInfo->byType=AXIS_CTRL_CMD_MOVE_DS;

//          memset(&(pCtrlInfo->Dynamic.AdditionalInfo),0,sizeof(USER_MOVE_DS_ADDITIONAL_INFO));

			pCtrlInfo->Dynamic.dAccel       = dTmpAccel;
			pCtrlInfo->Dynamic.dDecel       = dTmpDecel;
			pCtrlInfo->Dynamic.dSpeed       = dSpeedResult;
			pCtrlInfo->Dynamic.dDist        = dTmpPosition;


			pInfoSet->Position.CmdRefInfo.dCmdSpeed     = dSpeedResult;
			pInfoSet->Position.CmdRefInfo.dRefSpeed     = dSpeedLimit;
			pInfoSet->Position.CmdRefInfo.dCmdDecel     = dTmpDecel;
			pInfoSet->Position.CmdRefInfo.nCount        = nResultNodeCount;
			pInfoSet->Position.CmdRefInfo.dDist         = dTmpPosition;
            pInfoSet->Position.CmdRefInfo.dSpeedDownPos = getSpeedDownPos(dTmpDecel, dSpeedResult ,dTmpPosition);

		}
    }



	if(bCmdExist==true)
    {

		ADD_LOG("AxisRunBack[%06d(%3d:%3d(%3d),%6.1lf/%8.1lf:E%6.1lf)]:%6.4lf,%6.4lf, %3.1lf(←%3.1lf,Ref%3.1lf), %6.1lf(←%6.1lf:E%6.1lf[%2d])Event[%4X]SPDN[%d(%6.1lf)] NC[%d]->[%d,(%d:%d)] Steer[%d]"
			, pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.uNode
			, pInfoSet->HwInfo.Node.nNodeCount
			, pInfoSet->HwInfo.Node.nPreCheckCount
			, nPreCheckCount
			, pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset
			, pInfoSet->Position.Compensation.dCompensatedPosition
			, pInfoSet->Position.Compensation.dDistErrorSum
			, pCtrlInfo->Dynamic.dAccel, pCtrlInfo->Dynamic.dDecel
			, pCtrlInfo->Dynamic.dSpeed, pInfoSet->HwInfo.Axis1.dSpeed, dSpeedLimit
			, pCtrlInfo->Dynamic.dDist
			, pInfoSet->HwInfo.Axis1.dCurrPos
			, pInfoSet->Position.Compensation.dLinkDistError
			, nCheckPointOfPosition
			, pInfoSet->EventAndState.Event
			, bSpeedDownPassed
			, pInfoSet->Position.CmdRefInfo.dSpeedDownPos
			, nKeyNodeCount
			, nResultNodeCount
			, anNodeCountBySteer[0]
			, anNodeCountBySteer[1]
			, CurrTotalSteerPos
            );

    }



    return bCmdExist;

}

// Path 속도에 의한 주행 정보 획득: 감속하는 지점까지의 정보 획득
bool DrivingControl::getAxisCmdInfoBySpeed(int nNodeCount, double *pdSpeed, int *pnStopNodeCount)
{
    int nListCount = m_ClassifiedCmd.SpeedlList.getCount();
    int nTmpIndex   = 0;
    DRIVING_CMD_INFO_OF_SPEED* pItem = NULL;

    bool bCmdExist = false;
    double dKeySpeed = 0.0;
    double dSpeed = 0.0;
    int nTmpNodeCount = 0;

    //1 명령이 없을 경우
    if(nListCount==0) //명령이 없음
    {
        return false;
    }

    //1 명령이 있을 경우
    for(nTmpIndex; nTmpIndex<nListCount; nTmpIndex++)
    {
        pItem = m_ClassifiedCmd.SpeedlList.refer(nTmpIndex);
        if(pItem!=NULL)
		{

            if(pItem->nCount<=nNodeCount)
            {
                continue;
            }
            else
            {
                if(pItem->dSpeed>=dKeySpeed)
                {
                    if(dKeySpeed==0.0)
                    {
                        dSpeed = pItem->dSpeed;
                    }
                    nTmpNodeCount = pItem->nCount;
                    dKeySpeed = pItem->dSpeed;
                }
                else
                {
                    break;
                }
            }
        }
    }

    //1 감속 없이 끝까지 온 경우
    if(dKeySpeed!=0.0)
    {
        *pdSpeed = dSpeed;
        *pnStopNodeCount = nTmpNodeCount;
        return true;    // 마지막까지 온 경우
    }
    else
    {
        return  false;
    }

}

// Path 조향에 의한 주행 정보 획득
bool DrivingControl::getAxisCmdInfoBySteer(int nNodeCount, STEER_HW_INFO_POSITION CurTotalSteerPos, int *pnStopNodeCount1, int *pnStopNodeCount2,STEER_HW_INFO_POSITION RealCurTotalSteerPos)
{
    int nListCount = m_ClassifiedCmd.SteerList.getCount();
    int nTmpIndex   = 0;
    DRIVING_CMD_INFO_OF_STEER* pItem = NULL;
    DRIVING_CMD_INFO_OF_STEER* pTmpItem = NULL;
    DRIVING_CMD_INFO_OF_STEER* pPreItem = NULL;
    STEER_HW_INFO_CMD SteerKey;
    STEER_HW_INFO_CMD TmpSteerCmd;
    STEER_HW_INFO_CMD TmpSteerKey;

    bool bOnlyNormal = false;
    bool bCmdExist = false;
    bool bBreaked = false;
    int nTmpNodeCount[2] = {0,};


    //1 시작 Key를 만듬
    switch(CurTotalSteerPos)
    {
    case STEER_HW_INFO_POSITION_NONE:
		bOnlyNormal = true;
        break;

    case STEER_HW_INFO_POSITION_LEFT:
		SteerKey = STEER_HW_INFO_CMD_LEFT;
        break;

	case STEER_HW_INFO_POSITION_RIGHT:
		SteerKey = STEER_HW_INFO_CMD_RIGHT;
        break;

    case STEER_HW_INFO_POSITION_BOTH:
        return false;
        break;
    }

    //1 추가 명령이 없을 경우
    if(nListCount==0) //그 이상의 명령이 없음
    {
        return false;
    }

    //1 추가 명령이 있을 경우
    for(nTmpIndex; nTmpIndex<nListCount; nTmpIndex++)
    {
        pPreItem = pItem;
        pItem = m_ClassifiedCmd.SteerList.refer(nTmpIndex);
        if(pItem!=NULL)
        {
            if(pItem->nCount<=nNodeCount)
            {
                continue;
            }
            else
            {
                bCmdExist = true;
                if(getSteerCmdTypeFrom(pItem->Type, &TmpSteerCmd, &TmpSteerKey)==true)
                {

//                  ADD_LOG("nTmpIndex=%d/%d (%d,%5lf,%d,%d) (%d:%d→%d)"
//                      , nTmpIndex, nListCount
//					  , pItem->nCount, pItem->dDistSumToEndNode, pItem->Type, pItem->NextType
//					  , SteerKey, TmpSteerCmd, TmpSteerKey);

					//2 Normal 확인
                    if(bOnlyNormal==true)
					{
						if(nTmpIndex==0)// __L/R__ⓞ
						{
							nTmpNodeCount[0] = nNodeCount;
							nTmpNodeCount[1] = nNodeCount;
						}
						else if(nTmpIndex>=1)// ____N___ⓞ__L/R__①
						{
							nTmpNodeCount[0] = nNodeCount;
							nTmpNodeCount[1] = pPreItem->nCount;

						}
						bBreaked = true;
						break;

					}

					//2     같은 조향을 만나면
					if(SteerKey==TmpSteerCmd)
					{
						SteerKey = TmpSteerKey;
					}
					//2     다른 조향을 만나면
					else
					{
						if(nTmpIndex==0)// __L/R__ⓞ // 시작 부터 다른 방향
						{
							nTmpNodeCount[0] = nNodeCount;
							nTmpNodeCount[1] = nNodeCount;
						}
						else if(nTmpIndex==1)
						{
							if(pPreItem->Type!=STEERING_NONE)// ____R___ⓞ___L___①
							{
								nTmpNodeCount[0] = pPreItem->nCount;
								nTmpNodeCount[1] = pPreItem->nCount;
                            }
                            else // ____N___ⓞ__L/R__①
                            {
                                nTmpNodeCount[0] = nNodeCount;
                                nTmpNodeCount[1] = pPreItem->nCount;
                            }
                        }
                        else if(nTmpIndex>1)
                        {
                            if(pPreItem->Type!=STEERING_NONE)// ___X___ⓞ___R___①___L___②
                            {
                                nTmpNodeCount[0] = pPreItem->nCount;
                                nTmpNodeCount[1] = pPreItem->nCount;

                            }
                            else // ___R___ⓞ___N___①___L___②
                            {
                                pTmpItem = m_ClassifiedCmd.SteerList.refer(nTmpIndex-2);
                                nTmpNodeCount[0] = pTmpItem->nCount;
                                nTmpNodeCount[1] = pPreItem->nCount;
                            }
                        }
                        bBreaked = true;
                        break;
                    }
                }
            }
        }
    }

    if(bCmdExist==true)
    {
        if(bBreaked == true)
        {
            *pnStopNodeCount1 = nTmpNodeCount[0];
            *pnStopNodeCount2 = nTmpNodeCount[1];
//          ADD_LOG("bBreaked = true");
        }
        else
		{
			/*
			if(pItem->Type==STEERING_NONE)// ____N___①
			{
				*pnStopNodeCount1 = (pPreItem!=NULL)?pPreItem->nCount:0;
				ADD_LOG("Case9 %d, %d",*pnStopNodeCount1,pItem->nCount);
			}
			else// ____X___ⓞ__L/R__①
			{
				*pnStopNodeCount1 = pItem->nCount;
				ADD_LOG("Case10 %d, %d",*pnStopNodeCount1,pItem->nCount);
			}
			*/
			*pnStopNodeCount1 = pItem->nCount;
			*pnStopNodeCount2 = pItem->nCount;
			//ADD_LOG("Case11 %d, %d",*pnStopNodeCount1,pItem->nCount);
		}
    }

//  ADD_LOG("%d,%d", *pnStopNodeCount1, *pnStopNodeCount2);

    return  bCmdExist;

}





// 속도 프로파일 생성 함수
bool DrivingControl::getAxisCmdInfo(DRIVING_INFO_SET *pInfoSet, CTRL_INFO_OF_SYNC_AXIS_MOVE* pCtrlInfo)
{

	bool    bCmdExist = false;          // 명령이 있다
    bool    bLowSpeed = false;          // 직진부 전후로 조향이 다른 경우
    bool    bOutInNode = false;     // Node 전후로 조향이 다른 경우
    bool    bIsToTarget = false;
    bool    bNextPathExist = false; // 명령 나간 Node 이후 Path 존재 여부 확인, 마지막 Node까지 명령이 나갔다
    int     nKeyNodeCount = 0;
    int     nResultNodeCount = 0;
    int     nCheckPointOfPosition = 0;  // 이동 거리가 산출된 곳을 확인하기 위한 변수, 실제로 사용되는 곳 없음

	int     nCurrNodeCount = pInfoSet->HwInfo.Node.nNodeCount;
	int     nCurrPreNodeCount = pInfoSet->HwInfo.Node.nPreCheckCount;

	//대차센서가 Off이므로 주행 명령 안줌.
	if(m_pOHTDetect->CheckSensorOff() == true)
	{
		return bCmdExist;
	}

	if(pInfoSet->EventAndState.Event.TargetChanged == true)
	{
//		memset(&pInfoSet->Position.CmdRefInfo, 0x00, sizeof(DRIVING_CTRL_REFERENCE));
//		pInfoSet->Position.CmdRefInfo.nCount =nCurrNodeCount;
//		pInfoSet->Position.CmdRefInfo.nKeyCount =nCurrNodeCount;


//		pInfoSet->EventAndState.Event.TargetChanged  = false;

//		ADD_LOG("Run-TargetChanged %d", nCurrNodeCount);

	}


    int nPreCheckCount = ((pInfoSet->HwInfo.Node.nPreCheckCount-pInfoSet->HwInfo.Node.nNodeCount)>1)
                            ?(pInfoSet->HwInfo.Node.nNodeCount+1)
							:(pInfoSet->HwInfo.Node.nPreCheckCount);

    //  DRIVING_CMD_INFO_OF_PATH* pPathInfo = getPathInfo(pInfoSet->HwInfo.Node.nNodeCount);
    DRIVING_CMD_INFO_OF_PATH* pPathInfo = getPathInfo(pInfoSet->Position.CmdRefInfo.nCount);
    if(pPathInfo!=NULL)bNextPathExist=true;

    if( (nPreCheckCount==0)
    &&  (pInfoSet->Position.bPreCheckIsOverFirstNode==true)
    )
    {
		nPreCheckCount=1;
    }


    int     nCmdTargetNodeCount = pInfoSet->Position.CmdRefInfo.nCount;

    double dCurrPos = pInfoSet->HwInfo.Axis1.dCurrPos;

    double  dSafetySpeedLimit = m_pParamSet->Axis.Limit.Speed.MaxValue; // 초기화(최대값)
    double  dSpeedLimit= 0.0;
	double  dSpeedResult= 0.0;
    int     nNodeCountBySpeed = 0;
    double  dTmpSpeedLimit = 0.0;

	STEER_HW_INFO_POSITION  CurrTotalSteerPos;
	STEER_HW_INFO_POSITION  TmepCurrTotalSteerPos;
    int     anNodeCountBySteer[2] = {0,};

    bool bSpeedDownPassed   = pInfoSet->EventAndState.State.SpeedDownPassed;
    double dCurrSpeed       = pInfoSet->HwInfo.Axis1.dSpeed;
    double dCurrCmdSpeed    = pInfoSet->Position.CmdRefInfo.dCmdSpeed;
	double dNextPathSpeed;
	if(pPathInfo!=NULL)
	{
		dNextPathSpeed   = (bNextPathExist==true)?pPathInfo->dSpeed:0.0; // 명령 받은 Node 다음 Path의 속도
	}
    double dTmpdist = 0.0;
    double dTmpPosition = 0.0;
    double dPreCmdPosition = pInfoSet->Position.CmdRefInfo.dDist;
	double dSmoothSpeed = 0.0;
    DRIVING_CMD_INFO_OF_NODE* pNodeInfo = NULL;

    STEER_HW_INFO_CMD TmpSteerCmdForNext;   // Front 조향 변경 시 300mm 더가는 것 학인 목적
    bool bNeedNextSteer;            // Front 조향 변경 시 300mm 더가는 것 학인 목적

	double dMarginBeforeFinalNode = 0.0;


#if(UBG_SENSOR_ENABLE == ON)
	bool sStopWithNoReason  =   (   pInfoSet->HwInfo.IO.Axis1Running==false
                                    &&  pInfoSet->HwInfo.IO.DetectStatus==0
                                    &&  pInfoSet->HwInfo.IO.ObsStatus==0)
                                    ?true:false;
#else
	bool sStopWithNoReason  =   (   pInfoSet->HwInfo.IO.Axis1Running==false
									&& pInfoSet->HwInfo.IO.ObsStatus==0)
									?true:false;
#endif

	double  dTmpAccel = m_pParamSet->Axis.Default.dDefaultAccel;
    double  dTmpDecel = m_pParamSet->Axis.Default.dDefaultDecel;

    //1 Node Count 시작 위치 설정
    // SpeedDown 통과 시
    if(bSpeedDownPassed==true)
	{

		// 다음 속도가 적을 경우: 다음 명령 수행
		if(dNextPathSpeed<getPathInfo(pInfoSet->HwInfo.Node.nNodeCount)->dSpeed) // -> 현재 map speed와 비교
		{
			nKeyNodeCount = nCmdTargetNodeCount;
			pInfoSet->Position.CmdRefInfo.nKeyCount = nCmdTargetNodeCount;
		}
		// 다음 속도가 크거나 같은 경우: 일반 처리
		else
		{
			nKeyNodeCount = nPreCheckCount;
		}

		/*
		// 다음 속도가 적을 경우: 다음 명령 수행
		if(dNextPathSpeed<dCurrCmdSpeed)
		{
			nKeyNodeCount = nCmdTargetNodeCount;
			pInfoSet->Position.CmdRefInfo.nKeyCount = nCmdTargetNodeCount;
		}
		// 다음 속도가 크거나 같은 경우: 일반 처리
		else
		{
			nKeyNodeCount = nPreCheckCount;
		}

		*/
    }
    // SpeedDown 미통과 시: 일반 처리
    else
    {
        nKeyNodeCount = nPreCheckCount;
	}


    // 감속 중일 때, 적정 속도 확보
    if(nKeyNodeCount < pInfoSet->Position.CmdRefInfo.nKeyCount) // 감속 위치를 한번이라도 지나면 나타나는 현상
    {
        nKeyNodeCount = pInfoSet->Position.CmdRefInfo.nKeyCount;
        // 안전 속도 확보
        if(bNextPathExist==true)// 명령 준 Node 넘어로 Path 가 더 남아 있는 경우
        {
            dSafetySpeedLimit = MIN(dCurrCmdSpeed, dNextPathSpeed);
        }
        else    // 명령 준 Node 넘어로 남아있는 Path 가 없는 경우 , 명령 준 Node 가 마지막인 경우 마지막 명령 준 속도를 리밋으로 한다.
        {
            dSafetySpeedLimit = dCurrCmdSpeed;
        }
    }



    //1  명령 기준 정보 획득
    //2 속도 변화에 따른 정보 획득(Node Count, 속도, 거리) : OutLine
    bCmdExist = getAxisCmdInfoBySpeed(nKeyNodeCount, &dSpeedLimit, &nNodeCountBySpeed);

    dSpeedLimit = MIN(dSafetySpeedLimit, dSpeedLimit);// 저속 중 Node 만나서 가속 경우 : 노드 만나기 전까지  빠른 가속 방지

//	ADD_LOG("getAxisCmdInfo Step3 %d %d %d",nKeyNodeCount, bCmdExist, nNodeCountBySpeed);

    //2 Steer에 따른 정보 획득(Node Count, 속도, 거리) : --> 감속 거리
    if(bCmdExist==true)
    {
        CurrTotalSteerPos = getSteerTotalPosition(    pInfoSet->HwInfo.IO.SteerFrontLeftInOn
                                                    , pInfoSet->HwInfo.IO.SteerFrontRightInOn
                                                    , pInfoSet->HwInfo.IO.SteerRearLeftInOn
													, pInfoSet->HwInfo.IO.SteerRearRightInOn);

		TmepCurrTotalSteerPos = CurrTotalSteerPos; //puting 20170220

        switch(CurrTotalSteerPos)
        {
        case STEER_HW_INFO_POSITION_NONE:
            break;
        case STEER_HW_INFO_POSITION_LEFT:
            if( (pInfoSet->Steer.FrontCmdDirection!=DRIVING_IO_STEER_DIRECTION_CMD_LEFT)
            ||  (pInfoSet->Time.Steer.FrontSteeringArrived.bFlag==false)
            ||  (pInfoSet->Time.Steer.RearSteeringArrived.bFlag==false)
            )
			{
//				ADD_LOG("STEER_HW_INFO_POSITION_LEFT %d %d %d",pInfoSet->Steer.FrontCmdDirection,pInfoSet->Time.Steer.FrontSteeringArrived.bFlag,pInfoSet->Time.Steer.RearSteeringArrived.bFlag);
                CurrTotalSteerPos = STEER_HW_INFO_POSITION_NONE;
            }
            break;
		case STEER_HW_INFO_POSITION_RIGHT:
            if( (pInfoSet->Steer.FrontCmdDirection!=DRIVING_IO_STEER_DIRECTION_CMD_RIGHT)
            ||  (pInfoSet->Time.Steer.FrontSteeringArrived.bFlag==false)
			||  (pInfoSet->Time.Steer.RearSteeringArrived.bFlag==false)
            )
			{
//				ADD_LOG("STEER_HW_INFO_POSITION_RIGHT %d %d %d",pInfoSet->Steer.FrontCmdDirection,pInfoSet->Time.Steer.FrontSteeringArrived.bFlag,pInfoSet->Time.Steer.RearSteeringArrived.bFlag);
                CurrTotalSteerPos = STEER_HW_INFO_POSITION_NONE;
            }
            break;
        case STEER_HW_INFO_POSITION_BOTH:
            break;
		}
		bCmdExist = getAxisCmdInfoBySteer(nKeyNodeCount, CurrTotalSteerPos, anNodeCountBySteer, (anNodeCountBySteer+1),TmepCurrTotalSteerPos);
        if(bCmdExist==true && anNodeCountBySteer[0]==anNodeCountBySteer[1])
        {
            bOutInNode = true;
        }

	}



    //2 Node Count 결과 확인
    if(bCmdExist==true)
    {
		// Node Count 획득


		if(anNodeCountBySteer[0]<=nKeyNodeCount)
		{
            nResultNodeCount = MIN(anNodeCountBySteer[1],nNodeCountBySpeed);
            bLowSpeed = ((bOutInNode!=false)&&(anNodeCountBySteer[1]<=nNodeCountBySpeed))?true:false;
//          bLowSpeed = false;
        }
        else if(anNodeCountBySteer[0]<=nNodeCountBySpeed)
        {
            dTmpSpeedLimit = MAX(dSpeedLimit, (m_pParamSet->Axis.Limit.Speed.MinValue));
            if( (anNodeCountBySteer[1]<=nNodeCountBySpeed)
            &&  ((getDist(anNodeCountBySteer[0], anNodeCountBySteer[1])/dTmpSpeedLimit)
                >(m_pParamSet->Steer.dwChangeTime+m_pParamSet->Steer.dwCompleteCheckTime))
            )
            {
                nResultNodeCount = anNodeCountBySteer[1];
            }
            else if(    (anNodeCountBySteer[1]>nNodeCountBySpeed)
            &&  ((getDist(anNodeCountBySteer[0], nNodeCountBySpeed)/dTmpSpeedLimit)
                >(m_pParamSet->Steer.dwChangeTime+m_pParamSet->Steer.dwCompleteCheckTime))
            )
            {
                nResultNodeCount = nNodeCountBySpeed;
            }
            else
            {
                nResultNodeCount = anNodeCountBySteer[0];
            }
        }
        else
        {
            nResultNodeCount = nNodeCountBySpeed;
            bOutInNode = false;
        }

        // Node Count 가 명령 나간 지점 보다 적어지면 명령 나간 곳으로 명령(PreCheck 지점 에서 조향 변경 중)
		if(nResultNodeCount<nCmdTargetNodeCount)
        {
            //bCmdExist=false;
            nResultNodeCount=nCmdTargetNodeCount;
        }
    }

//	ADD_LOG("getAxisCmdInfo Step5 %d %f",nResultNodeCount, nCmdTargetNodeCount);

    //2 Data 결과 처리
    if(bCmdExist==true)
	{
		if((nResultNodeCount == nCurrNodeCount) && (isSteerChangeAreaByGuideNodeCountAdd()==true))
		{
			nResultNodeCount++;
			ADD_LOG("[Run]ArearByGuide");
		}

		pNodeInfo = getNodeInfo(nResultNodeCount);
        if(pNodeInfo!=NULL)
		{
			dTmpPosition = getRealPos(pNodeInfo->dDistSum);
            nCheckPointOfPosition = 0;

			//1 속도 사다리꼴화
			if(pInfoSet->EventAndState.Event.TargetChanged == true)
			{
				dSpeedResult = MIN(dSpeedLimit,
									getMaxSpeed(   m_pParamSet->Axis.Default.dDefaultAccel
														,m_pParamSet->Axis.Default.dDefaultDecel
														,(dTmpPosition-pInfoSet->HwInfo.Axis1.dCurrPos))
									);

				ADD_LOG("[Run]Speed Data: dSpeedResult %f, dSpeedLimit :%f, Count:%d",dSpeedResult,dSpeedLimit,nResultNodeCount);
			}else
			{
				dSpeedResult = MIN(dSpeedLimit,
                                 	getMaxSpeed(   m_pParamSet->Axis.Default.dDefaultAccel
										,m_pParamSet->Axis.Default.dDefaultDecel
										,(dTmpPosition-pInfoSet->HwInfo.Axis1.dCurrPos),pInfoSet->HwInfo.Axis1.dSpeed ,dSpeedLimit)
					);
            }

			ADD_LOG("getAxisCmdInfo Step4 CuurnSteer %d, key%d Zero:%d One:%d Speed %d getMaxSpeed[%f][%f][%f] %d"
			,CurrTotalSteerPos, nKeyNodeCount, anNodeCountBySteer[0],anNodeCountBySteer[1],nNodeCountBySpeed,
			dTmpPosition,pNodeInfo->dDistSum,pInfoSet->HwInfo.Axis1.dCurrPos,nResultNodeCount);

			//1 거리 구하기
            if(pNodeInfo->nCount==m_ClassifiedCmd.TargetInfo.nCount)
            {
                bIsToTarget = true;
				switch(m_ClassifiedCmd.TargetInfo.Type)
                {
                case MARK_TYPE_NODE:
					dMarginBeforeFinalNode = (nResultNodeCount==nCurrNodeCount)?DIST_MARGIN_TO_NODE_TO_CONPENSATE_SLIP_200:DIST_MARGIN_TO_NODE_TO_CONPENSATE_SLIP_200;  // 타겟 도착하기 전이면 이 값을 빼서 이동, 최종 Node 지나서 정확한 위치로 보냄
					dTmpPosition    =(dTmpPosition-dMarginBeforeFinalNode);
                    nCheckPointOfPosition = 1;
                    break;

				case MARK_TYPE_TAG_STATION:
					dMarginBeforeFinalNode = (nResultNodeCount==nCurrNodeCount)?DIST_MARGIN_TO_NODE_TO_CONPENSATE_SLIP_200:DIST_MARGIN_TO_NODE_TO_CONPENSATE_SLIP_200; // 타겟 도착하기 전이면 이 값을 빼서 이동, 최종 Node 지나서 정확한 위치로 보냄
                    dTmpPosition    =(dTmpPosition-dMarginBeforeFinalNode-m_ClassifiedCmd.TargetInfo.dLength+m_ClassifiedCmd.TargetInfo.dOffset);
                    nCheckPointOfPosition = 2;
					break;

                case MARK_TYPE_QR_STATION_LEFT:
                case MARK_TYPE_QR_STATION_RIGHT:
					dMarginBeforeFinalNode = (nResultNodeCount==nCurrNodeCount)?DIST_MARGIN_TO_NODE_TO_CONPENSATE_SLIP_200:DIST_MARGIN_TO_NODE_TO_CONPENSATE_SLIP_200;  // 타겟 도착하기 전이면 이 값을 빼서 이동, 최종 Node 지나서 정확한 위치로 보냄
                    dTmpPosition    =(dTmpPosition-dMarginBeforeFinalNode-m_ClassifiedCmd.TargetInfo.dLength+m_ClassifiedCmd.TargetInfo.dOffset);
                    nCheckPointOfPosition = 3;
                    break;

                }
            }
			else
			{

                if(pInfoSet->EventAndState.State.SteerFrontCompleted==true)
                {
                    pPathInfo = getPathInfo(nResultNodeCount);
                    if(pPathInfo!=NULL)
                    {

                        bNeedNextSteer = getSteerCmdTypeFrom(pPathInfo->Steering, &TmpSteerCmdForNext);

                        if( (m_ClassifiedCmd.TargetInfo.Type!=MARK_TYPE_NODE)
                        &&  (pNodeInfo->nCount==m_ClassifiedCmd.TargetInfo.nCount-1))
                        {
							if(pInfoSet->HwInfo.IO.SteerFrontDirCmd==TmpSteerCmdForNext)
                            {
								if((pNodeInfo->nCount>0)
                                && (nCurrPreNodeCount==pNodeInfo->nCount)
								&& (pInfoSet->HwInfo.Node.dPreCheckPosition>0.0)
                                )
                                {
                                    if(m_ClassifiedCmd.TargetInfo.dOffset<m_pParamSet->Mark[0].Dist.dLengthOfSecond)
                                    {
                                        dTmpPosition=pInfoSet->HwInfo.Node.dPreCheckPosition+m_pParamSet->Mark[0].Dist.dAddDistAfetrFirstMet;
                                        nCheckPointOfPosition = 4;
                                        if(sStopWithNoReason==true)
                                        {
                                            dTmpPosition = MAX(dCurrPos+1.0, dTmpPosition);
											nCheckPointOfPosition = 5;
                                        }
									}
                                    else
                                    {
                                        dTmpPosition=pInfoSet->HwInfo.Node.dPreCheckPosition+m_pParamSet->Mark[0].Dist.dDistFromFirstToSecond;
                                        nCheckPointOfPosition = 6;
                                    }

                                }
                                else
                                {
                                    if(pNodeInfo->nCount>0)
									{
										if(pInfoSet->HwInfo.Node.nNodeCount==0)
											dTmpPosition=dTmpPosition+30;
										else
											dTmpPosition=dTmpPosition-DIST_MARGIN_TO_NODE_TO_CONPENSATE_SLIP;//1    문제 발생 가능성 있음 //+40;

										nCheckPointOfPosition = 7;
									}
								}
							}
							else
							{
								if(pInfoSet->HwInfo.Node.nNodeCount==0)
									dTmpPosition = dTmpPosition+30;//-DIST_MARGIN_TO_NODE_TO_CONPENSATE_SLIP;
								else
									dTmpPosition=dTmpPosition - DIST_MARGIN_TO_NODE_TO_CONPENSATE_SLIP;
								nCheckPointOfPosition = 8;
							}
						}
						else if(    (bNeedNextSteer==false)
						||          (pInfoSet->HwInfo.IO.SteerFrontDirCmd==TmpSteerCmdForNext))
                        {
                            if( (nPreCheckCount!=nKeyNodeCount) // SpeedDown지났거나
                            ||  (bOutInNode==true)
//                          ||  (   (nCurrNodeCount<nKeyNodeCount)
//                              &&  (pInfoSet->Position.CmdRefInfo.dRefSpeed<=dSpeedLimit)// 이전 속도가 빠르고
//                              &&  (dCurrSpeed<(dSpeedLimit+m_pParamSet->Axis.Default.dDefaultDecel*16)))// 현재 속도가 다음 속도보다 빠르고: 16ms(Thread 1주기)
                            )
                            {
                                dTmpPosition=dTmpPosition+50;//300;
                                nCheckPointOfPosition = 9;
                            }
                            else
                            {
                                dTmpPosition=dTmpPosition + 50;//+300-DIST_MARGIN_TO_NODE_TO_CONPENSATE_SLIP;
                                nCheckPointOfPosition = 10;
                            }
                        }
                        else
                        {
                            // 여기로 들어오는 케이스 없음
                            dTmpPosition    =dTmpPosition + 50;//-DIST_MARGIN_TO_NODE_TO_CONPENSATE_SLIP;
                            nCheckPointOfPosition = 11;
                        }
                    }

//					ADD_LOG("AxisRun[%f][%f][%f]22",dSpeedLimit,dSpeedResult,pPathInfo->dSpeed);
					pPathInfo = getPathInfo(nPreCheckCount);
					if(pPathInfo!=NULL)
					{
						dSpeedLimit = MIN(dSpeedLimit, dSpeedResult);
						dSpeedLimit = MIN(dSpeedResult, pPathInfo->dSpeed);
                        if(bOutInNode==true)
                        {
                            if(nCurrPreNodeCount==pNodeInfo->nCount)
                            {
                                dSpeedLimit = MIN(dSpeedResult, SPEED_OF_OUT_IN_NODE);
                            }
                        }
                    }
                }
                else
                {
                    if(bOutInNode==true)
                    {
                        if(nCurrPreNodeCount<pNodeInfo->nCount)
                        {
							dTmpPosition=(bSpeedDownPassed==true)?MAX(dPreCmdPosition,(dTmpPosition-100)):(dTmpPosition-100);
							nCheckPointOfPosition =12;
                        }
                        else if(nCurrPreNodeCount==pNodeInfo->nCount)
						{
//							dTmpPosition= (bSpeedDownPassed==true)?MAX(dPreCmdPosition,(dTmpPosition-50)):(dTmpPosition-50);
							dTmpPosition= (bSpeedDownPassed==true)?MAX(dPreCmdPosition,(dTmpPosition+50)):(dTmpPosition+50);
							nCheckPointOfPosition = 13;
							dSpeedLimit = MIN(SPEED_OF_OUT_IN_NODE,dSpeedResult);
                        }
                    }
                    else
                    {
						if( (m_ClassifiedCmd.TargetInfo.Type!=MARK_TYPE_NODE)
						&&  (pNodeInfo->nCount >=m_ClassifiedCmd.TargetInfo.nCount-1))
						{
							 dTmpPosition    =   (bSpeedDownPassed==true)
											?   MAX(dPreCmdPosition,(dTmpPosition-DIST_MARGIN_TO_NODE_TO_CONPENSATE_SLIP))
											:   (dTmpPosition-DIST_MARGIN_TO_NODE_TO_CONPENSATE_SLIP);
						}else
						{
							 dTmpPosition    =   (bSpeedDownPassed==true)
											?   MAX(dPreCmdPosition,(dTmpPosition+50))//-DIST_MARGIN_TO_NODE_TO_CONPENSATE_SLIP))
											:   (dTmpPosition+50);//-DIST_MARGIN_TO_NODE_TO_CONPENSATE_SLIP);
                        }
						nCheckPointOfPosition = 14;
					}
				}
			}

//			ADD_LOG("nCheckPointOfPosition[%d]",nCheckPointOfPosition);

            //1 조향 사이 Normal Path 이동 부드럽게
			dTmpAccel   = (m_pParamSet->Axis.Default.dDefaultAccel)
						/ (getAccelDivisor(nCurrPreNodeCount));
			dTmpDecel   = (bIsToTarget)?(m_pParamSet->Axis.Default.dDefaultDecel*2/3)
						:(m_pParamSet->Axis.Default.dDefaultDecel
						/getDecelDivisor(MAX(nCurrNodeCount,(nResultNodeCount-1))));
		   /*
			// Lifter 구간에서 가속도 수정 하드코딩 by jhoun.lim (18.03.15)
			   DRIVING_CMD_INFO_OF_NODE* pNodeInfo = getNodeInfo(pInfoSet->HwInfo.Node.nNodeCount); // 현재 부모 node
			   if(((pNodeInfo->NodeType >= LIFTIN_NTYPE_LEFT) && (pNodeInfo->NodeType <= LIFTOUT_NTYPE)))
			   {
			   dTmpAccel = 0.0027;

			   ADD_LOG("Lifter Region :%6.4lf,%6.4lf", dTmpAccel, dTmpDecel);
			   }
           */


			// 가속도 변경에 의한 고속 커브 진입 방지
            if( (pInfoSet->Position.CmdRefInfo.dRefSpeed>=dSpeedLimit)// 이전 속도가 빠르고
            &&  (pInfoSet->Position.CmdRefInfo.dCmdDecel>dTmpDecel)// 이전 감속도가 크고
			&&  (dCurrSpeed>(dSpeedLimit+m_pParamSet->Axis.Default.dDefaultDecel*16))// 현재 속도가 다음 속도보다 빠르고: 16ms(Thread 1주기)
			&&  (nCurrNodeCount<nKeyNodeCount)// 노드 카운트가 키 노드 카운트를 지나지 않았을 경우
            )
            {
				dTmpDecel = pInfoSet->Position.CmdRefInfo.dCmdDecel;
            }


//			dSpeedResult = MIN(dSpeedLimit,(DRIVING_SPEED_SMOOTHING_FACTOR
//												*getMaxSpeed(dTmpAccel ,dTmpDecel ,(dTmpPosition - pInfoSet->HwInfo.Axis1.dCurrPos))));
//

			if(pInfoSet->EventAndState.Event.TargetChanged == true)
			{
				dSpeedResult = MIN(dSpeedLimit, getMaxSpeed(dTmpAccel ,dTmpDecel ,(dTmpPosition - pInfoSet->HwInfo.Axis1.dCurrPos)));


			}else
			{
				dSpeedResult = MIN(dSpeedLimit,getMaxSpeed(dTmpAccel ,dTmpDecel ,(dTmpPosition - pInfoSet->HwInfo.Axis1.dCurrPos),pInfoSet->HwInfo.Axis1.dSpeed ,dSpeedLimit));


			}

			if(bLowSpeed)
            {
				// 마지막이 아니거나, 마지막인데 Path 중간의 Node 인 경우
				if(     (m_ClassifiedCmd.TargetInfo.nCount!=pNodeInfo->nCount)
					&&  ((m_ClassifiedCmd.TargetInfo.nCount==pNodeInfo->nCount)
                            &&(m_ClassifiedCmd.TargetInfo.Type==MARK_TYPE_NODE)
							&&(pNodeInfo->Type!=NORMAL_POINT))
                )
                {
                    dTmpdist = getDist(anNodeCountBySteer[0], nResultNodeCount);
                    dSmoothSpeed = getSmoothSpeed(dTmpDecel, dTmpdist, m_pParamSet->Steer.dwChangeTime);
					dSpeedResult = MIN(dSmoothSpeed, dSpeedResult);
                    dSpeedResult = MIN(dSmoothSpeed, dSpeedLimit);
                }
			}
//          else
//          {
//              dSpeedResult = MIN(dSpeedLimit,(DRIVING_SPEED_SMOOTHING_FACTOR
//                                                  *getMaxSpeed(   dTmpAccel ,dTmpDecel ,(dTmpPosition-pInfoSet->HwInfo.Axis1.dCurrPos))));
//          }


            //2 속도 이전과 비교 처리: 사다리꼴 모양 만들기 --> 후반부 감속 처리 제거 및 초기 튐 제거
            if( (pInfoSet->Position.CmdRefInfo.nCount!=0)
            &&  (pInfoSet->Position.CmdRefInfo.nCount==nResultNodeCount)
            &&  (pInfoSet->Position.CmdRefInfo.dCmdSpeed>dSpeedResult)
            &&  (bSpeedDownPassed==false)
//          &&  (dSpeedResult>1.0)
//          &&  (nCurrPreNodeCount<nResultNodeCount)
            )
            {
                if( (bNextPathExist==true)              // 다음 경로가 있고
                &&  (dNextPathSpeed<dSpeedLimit)        // 다음 경로 기준 속도가 현재 경로 기준 속도보다 느리고
                &&  (dNextPathSpeed>dSpeedResult)   // 다음 경로 속도가 현재 결과 속도보다 큰 경우
                )
                {
                    dSpeedResult = dNextPathSpeed;
                }
                else
                {
                    if(nCurrPreNodeCount<nResultNodeCount)
                    {
                        dSpeedResult = pInfoSet->Position.CmdRefInfo.dCmdSpeed;
                    }
                }
			}

            //2 속도 Min Max 처리
            dSpeedResult = MAX(dSpeedResult, (m_pParamSet->Axis.Limit.Speed.MinValue));
            dSpeedResult = MIN(dSpeedResult, (m_pParamSet->Axis.Limit.Speed.MaxValue));

            //2 시작 시 뒤로 이동 방지 처리
//          dTmpPosition = MAX(dCurrPos+1.0, dTmpPosition); // 뒤로 이동 방지
			dTmpPosition = MAX(dCurrPos, dTmpPosition); // 뒤로 이동 방지
            dTmpPosition = MAX(0.0, dTmpPosition);
		   //	ADD_LOG("AxisRun[%f][%f][%f][%f][%f]Smooth[%f]",dTmpPosition,dCurrPos,dTmpAccel,dTmpDecel,dSpeedResult,dSmoothSpeed);
            memset(pCtrlInfo, 0x00, sizeof(CTRL_INFO_OF_SYNC_AXIS_MOVE));

			if(dTmpPosition < RUN_TO_MARK_MINDIST)
				dSpeedResult = MIN(dSpeedResult,RUN_TO_MARK_MINSPEED);

			//AMC<->Main 감속도 동기화(1 기준값 확인)
			if(pHWSet->GetAMCDecelStatus() >= AMCDECEL_VHLDETECT)
			  //(pInfoSet->EventAndState.State.MarkArea ==false))//3.5m/s 감속도 일 경우
			{
			     //1) 최초 AMC 근접제어 감속도가 온 경우,
				if(m_dCheckAMCDecelPosition == 0.0)
				{
					m_dCheckAMCDecelPosition = m_dPreTargetPosition;    	//m_pDrivingAxis->GetFinalPosition()  //출발시 이슈가 있으므로 VHL Main이 저장함.
                	ADD_LOG("AMCDecelStatus1:%d(TargetPos:%f)",pHWSet->GetAMCDecelStatus(),m_dPreTargetPosition);
				}

                //2) 작업변경에 의해 타겟이 기존보다 짧아진 경우
				if((pInfoSet->EventAndState.Event.TargetChanged ==true) && (dTmpPosition < m_dCheckAMCDecelPosition))
				{
					m_dCheckAMCDecelPosition =  dTmpPosition;
					ADD_LOG("AMCDecelStatus2:%d(TargetPos:%f)",pHWSet->GetAMCDecelStatus(),m_dPreTargetPosition);
				}

				//3) AMC 근접제어에 의해 감속호고 있는 기존구간을 넘어간 경우
				if(pInfoSet->HwInfo.Axis1.dCurrPos > m_dCheckAMCDecelPosition)
				{
					m_dCheckAMCDecelPosition = m_dPreTargetPosition;
					ADD_LOG("AMCDecelStatus3:%d(TargetPos:%f)",pHWSet->GetAMCDecelStatus(),m_dPreTargetPosition);
				}

			}
			else
				m_dCheckAMCDecelPosition = 0.0;

			//AMC<->Main 감속도 동기화(2 거리 비교 및 적용 유무 판단)
			if(m_dCheckAMCDecelPosition !=0.0)
			{
			  //pInfoSet->HwInfo.Axis1.dSpeed    현재 속도
			  //pInfoSet->HwInfo.Axis1.dCurrPos  현재 위치

				double dTempDis = m_dCheckAMCDecelPosition - pInfoSet->HwInfo.Axis1.dCurrPos; //남은 거리
			   	double dCurrentDecelDis = (pInfoSet->HwInfo.Axis1.dSpeed * pInfoSet->HwInfo.Axis1.dSpeed)/(2*dTmpDecel);

				if(m_dCheckAMCDecelPosition - pInfoSet->HwInfo.Axis1.dCurrPos > 0.0)
				{

					ADD_LOG("AMCDecelCommit_1:%f,%f,%f) CurPos:%f,SP:%f",dTempDis,dCurrentDecelDis,m_dCheckAMCDecelPosition,pInfoSet->HwInfo.Axis1.dCurrPos,pInfoSet->HwInfo.Axis1.dSpeed);
					if(dTempDis - dCurrentDecelDis < 0.0)
					{
						dTmpDecel = DEFAULT_EMERGENCY_DECEL;  // 최영재 프로 확인 필요.
					}
					else
						m_dCheckAMCDecelPosition = 0.0;
				}
				else
				{
					ADD_LOG("AMCDecelCommit_2_NoCase:%f,%f,%f) CurPos:%f,SP:%f",dTempDis,dCurrentDecelDis,m_dCheckAMCDecelPosition,pInfoSet->HwInfo.Axis1.dCurrPos,pInfoSet->HwInfo.Axis1.dSpeed);
					//하기 조건은 만족할수 없음.
					/*
					double dTempDis = dTmpPosition - pInfoSet->HwInfo.Axis1.dCurrPos; //남은 거리
					double dCurrentDecelDis = (pInfoSet->HwInfo.Axis1.dSpeed * pInfoSet->HwInfo.Axis1.dSpeed)/(2*dTmpDecel);

					if(dTempDis - dCurrentDecelDis < 0.0)
					{
						dTmpDecel = DEFAULT_EMERGENCY_DECEL;
					}
					else
						m_dCheckAMCDecelPosition = 0.0;
					*/

					m_dCheckAMCDecelPosition = 0.0;
			   	}
			 //
			}

			pCtrlInfo->byType=AXIS_CTRL_CMD_MOVE_DS;
//          memset(&(pCtrlInfo->Dynamic.AdditionalInfo),0,sizeof(USER_MOVE_DS_ADDITIONAL_INFO));
            pCtrlInfo->Dynamic.dAccel       = dTmpAccel;
			pCtrlInfo->Dynamic.dDecel       = dTmpDecel;
            pCtrlInfo->Dynamic.dSpeed       = dSpeedResult;
			pCtrlInfo->Dynamic.dDist        = dTmpPosition;


            pInfoSet->Position.CmdRefInfo.dCmdSpeed     = dSpeedResult;
            pInfoSet->Position.CmdRefInfo.dRefSpeed     = dSpeedLimit;
            pInfoSet->Position.CmdRefInfo.dCmdDecel     = dTmpDecel;
            pInfoSet->Position.CmdRefInfo.nCount        = nResultNodeCount;
            pInfoSet->Position.CmdRefInfo.dDist         = dTmpPosition;
			pInfoSet->Position.CmdRefInfo.dSpeedDownPos = getSpeedDownPos(dTmpDecel, dSpeedResult ,dTmpPosition);

			m_dPreTargetPosition = dTmpPosition;

        }


	}

	//작업변경 플래그 초기화
	pInfoSet->EventAndState.Event.TargetChanged  = false;

    if(bCmdExist==true)
    {
        ADD_LOG("AxisRun[%06d(%3d:%3d(%3d),%6.1lf/%8.1lf:E%6.1lf)]:%6.4lf,%6.4lf, %3.1lf(←%3.1lf,Ref%3.1lf), %6.1lf(←%6.1lf:E%6.1lf[%2d])Event[%4X]SPDN[%d(%6.1lf)] NC[%d]->[%d,(%d:%d)] Steer[%d] %d"
            , pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.uNode
            , pInfoSet->HwInfo.Node.nNodeCount
            , pInfoSet->HwInfo.Node.nPreCheckCount
            , nPreCheckCount
            , pInfoSet->Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset
			, pInfoSet->Position.Compensation.dCompensatedPosition
			, pInfoSet->Position.Compensation.dDistErrorSum
            , pCtrlInfo->Dynamic.dAccel, pCtrlInfo->Dynamic.dDecel
            , pCtrlInfo->Dynamic.dSpeed, pInfoSet->HwInfo.Axis1.dSpeed, dSpeedLimit
			, pCtrlInfo->Dynamic.dDist
            , pInfoSet->HwInfo.Axis1.dCurrPos
            , pInfoSet->Position.Compensation.dLinkDistError
            , nCheckPointOfPosition
            , pInfoSet->EventAndState.Event
            , bSpeedDownPassed
            , pInfoSet->Position.CmdRefInfo.dSpeedDownPos
            , nKeyNodeCount
            , nResultNodeCount
            , anNodeCountBySteer[0]
            , anNodeCountBySteer[1]
			, CurrTotalSteerPos
			, nCheckPointOfPosition
            );
    }

    return bCmdExist;
}

// nFromNodeCount ~ nToNodeCount 의 거리를 구한다.
double DrivingControl::getDist(int nFromNodeCount, int nToNodeCount)
{
    double dDist = 0.0;
    DRIVING_CMD_INFO_OF_NODE *pNode[2];

    pNode[0] = getNodeInfo(MIN(nFromNodeCount,nToNodeCount));
    pNode[1] = getNodeInfo(MAX(nFromNodeCount,nToNodeCount));

    if(pNode[0]!=NULL && pNode[1]!=NULL)
    {
        dDist = pNode[1]->dDistSum-pNode[0]->dDistSum;
    }

    return dDist;
}

double DrivingControl::getSmoothSpeed(double dDecel, double dDist, DWORD dwTime)
{
    double  dTmpDecel = fabs(dDecel);
    double  dTmpDist = fabs(dDist);
    DWORD   dwTmpTime = fabs(dwTime);
    double dResult = 0.0;

    dResult = ((-1)*dTmpDecel*dwTmpTime)+sqrt((dTmpDecel*dTmpDecel*dwTmpTime*dwTmpTime)+(2*dTmpDecel*dTmpDist));
	return dResult;
}

double DrivingControl::getMaxSpeed(double dAccel, double dDecel, double dDist, double dCurSpeed, double dTargetSpeed)
{
     double dTmpAccel = fabs(dAccel);
    double dTmpDecel = fabs(dDecel);
    double dTmpDist = fabs(dDist);
    double dResult = 0.0;

    double dynamicVel[3]; // border of accel regions (m/sec)
    dynamicVel[0] = 1.2;
    dynamicVel[1] = 3.3;
    dynamicVel[2] = 5.0;

    double dynamicAcc[3]; // (m/sec^2)
    dynamicAcc[0] = dTmpAccel*1000;
    dynamicAcc[1] = 2;
    dynamicAcc[2] = 1;

    int numArea = 3;

    if((dCurSpeed ==0.0) && (dTargetSpeed == 0.0))
    {
        //dResult = sqrt(2*dTmpDist*((dTmpAccel*dTmpDecel)/(dTmpAccel+dTmpDecel)));
        //dResult = DRIVING_SPEED_SMOOTHING_FACTOR *dResult;
        dResult = calcMaxSpeedDynamic(dCurSpeed, dynamicVel, dynamicAcc, numArea, dTmpDecel*1000, TIME_OF_CONST_VEL, dTmpDist*0.001);
    }
    else
    {
        if(dCurSpeed > (dTargetSpeed*0.95))
        {
            //타겟 속도 적용.
            dResult = dTargetSpeed;
        }
        else
        {
            //상황에 따라 현재속도 대비
            //double dSpeedDownPos = fabs((dCurSpeed*dCurSpeed)/(2*dAccel));   // S=(V^2)/(2*a)
            //dResult = sqrt(2*(dTmpDist+dSpeedDownPos)*((dTmpAccel*dTmpDecel)/(dTmpAccel+dTmpDecel)));
            //dResult = DRIVING_SPEED_SMOOTHING_FACTOR *dResult;
            dResult = calcMaxSpeedDynamic(dCurSpeed, dynamicVel, dynamicAcc, numArea, dTmpDecel*1000, TIME_OF_CONST_VEL, dTmpDist*0.001);
        }
    }

    return dResult;
}

double DrivingControl::getAccelDivisor(int nStartNodeCount)
{
    double dDivisor[2] = {1.0,};
	DRIVING_CMD_INFO_OF_PATH* pPathInfo = getPathInfo(nStartNodeCount);
	DRIVING_CMD_INFO_OF_NODE* pNodeInfo = getNodeInfo(nStartNodeCount);

//	m_Dectect_Dir = pItem->Type & 0x0F;

	if(pPathInfo != NULL)
	{
#if(USE_CHANGENODE == 1)
		if((pPathInfo->UBGRegion == PATH_DIRECTION_NORMAL)
#else
		if(((pPathInfo->Direction & 0x0F) == PATH_DIRECTION_NORMAL)
#endif
		 &&(pPathInfo->Steering == PATH_STEERING_NONE))
		{
			dDivisor[0] = 1.0;
		}
		else
		{
			dDivisor[0] = 1.3;
		}
	}

//	if(pPathInfo!=NULL)
//	{
//		switch(pPathInfo->Direction)
//		{
//		case PATH_DIRECTION_NO_USE:// 미사용: 예전 없음
//			dDivisor[0] = 1.0;
//			break;
//		case PATH_DIRECTION_NORMAL:// 직진 구간: 예전 N
//			if(pPathInfo->dSpeed < 1.3)
//				dDivisor[0] = 1.0;  //0.6
//			else if((pPathInfo->dSpeed >= 1.3) &&(pPathInfo->dSpeed <= 3.3))
//				dDivisor[0] = 1.3;  //1.0
//			else if(pPathInfo->dSpeed > 3.3)
//				dDivisor[0] = 1.6;
//			break;
//		case PATH_DIRECTION_LEFT:// 왼쪽: 예전 L
//		case PATH_DIRECTION_SPECIAL_C_L:
//			dDivisor[0] = 1.0;  //2.0 (D사 기준으로 변경)
//			break;
//		case PATH_DIRECTION_RIGHT:// 오른쪽: 예전 R
//		case PATH_DIRECTION_SPECIAL_C_R:
//			dDivisor[0] = 1.0; //2.0 (D사 기준으로 변경)
//			break;
//		case PATH_DIRECTION_SHORT:// N분기 사용: 예전 S
//		case PATH_DIRECTION_SPECIAL_L:// N분기 사용: 예전 S
//		case PATH_DIRECTION_SPECIAL_R:// N분기 사용: 예전 S
//			dDivisor[0] = 1.0; //2.0 (D사 기준으로 변경)
//			break;
//		case PATH_DIRECTION_BOTH:// 짧은 S자형 곡선: 예전 B
//			dDivisor[0] = 2.0;
//			break;
//		case PATH_DIRECTION_NARROW:// 레일 간격이 900mm 이하일때의 짧은 S자형 곡선: 예전 V
//			dDivisor[0] = 1.0;
//			break;
//		default:
//			dDivisor[0] = 1.0;
//			break;
//		}
//
//		switch(pPathInfo->Steering)
//		{
//		case PATH_STEERING_NONE:// 없음
//			dDivisor[1] = 1.0;
//			break;
//		case PATH_STEERING_LEFT:// 왼쪽
//			dDivisor[1] = 1.0; //2.0 (D사 기준으로 변경)
//			break;
//		case PATH_STEERING_RIGHT:// 오른쪽
//			dDivisor[1] = 1.0;  //2.0 (D사 기준으로 변경)
//			break;
//		case PATH_STEERING_N_BRANCH_L2R:// N분기
//			dDivisor[1] = 1.0;  //2.0 (D사 기준으로 변경)
//			break;
//		case PATH_STEERING_N_BRANCH_R2L:// N분기
//			dDivisor[1] = 1.0;  //2.0 (D사 기준으로 변경)
//            break;
//        default:
//            dDivisor[1] = 1.0;
//            break;
//        }
//
//
//	}

		//경사로 유무 판단하는 부분
	if(pNodeInfo!=NULL)
	{
		if(pNodeInfo->NodeType ==SLOPE_NTYPE)
			dDivisor[1] = 1.4;
	}

    return MAX(dDivisor[0], dDivisor[1]);

}



double DrivingControl::getDecelDivisor(int nStartNodeCount)
{
	double dDivisor[2] = {1.0,};
    DRIVING_CMD_INFO_OF_PATH* pPathInfo = getPathInfo(nStartNodeCount);

    if(pPathInfo!=NULL)
	{
#if(USE_CHANGENODE == 1)
        switch(pPathInfo->UBGRegion)
#else
        switch(pPathInfo->Direction)
#endif
        {
        case PATH_DIRECTION_NO_USE:// 미사용: 예전 없음
            dDivisor[0] = 1.0;
			break;
		case PATH_DIRECTION_NORMAL:// 직진 구간: 예전 N
			if(pPathInfo->dSpeed < 3.0)
				dDivisor[0] = 1.0;  //0.6
			else if(pPathInfo->dSpeed < 4.0)
				dDivisor[0] = 1.3;  //1.0
			else
				dDivisor[0] = 1.6;  //1.0
			break;
		case PATH_DIRECTION_LEFT:// 왼쪽: 예전 L
		case PATH_DIRECTION_SPECIAL_C_L:
            dDivisor[0] = 1.5;
            break;
		case PATH_DIRECTION_RIGHT:// 오른쪽: 예전 R
		case PATH_DIRECTION_SPECIAL_C_R:
            dDivisor[0] = 1.5;
            break;
		case PATH_DIRECTION_SHORT:// N분기 사용: 예전 S
		case PATH_DIRECTION_SPECIAL_L:// N분기 사용: 예전 S
		case PATH_DIRECTION_SPECIAL_R:// N분기 사용: 예전 S
			dDivisor[0] = 1.5;
            break;
		case PATH_DIRECTION_BOTH:// 짧은 S자형 곡선: 예전 B
            dDivisor[0] = 1.5;
            break;
		case PATH_DIRECTION_NARROW: // 레일 간격이 900mm 이하일때의 짧은 S자형 곡선: 예전 V
            dDivisor[0] = 1.0;
            break;
        default:
			dDivisor[0] = 1.0;
            break;
        }

        switch(pPathInfo->Steering)
		{
        case PATH_STEERING_NONE:// 없음
            dDivisor[1] = 1.0;
            break;
        case PATH_STEERING_LEFT:// 왼쪽
            dDivisor[1] = 1.5;
            break;
        case PATH_STEERING_RIGHT:// 오른쪽
            dDivisor[1] = 1.5;
            break;
        case PATH_STEERING_N_BRANCH_L2R:// N분기
            dDivisor[1] = 1.5;
            break;
        case PATH_STEERING_N_BRANCH_R2L:// N분기
            dDivisor[1] = 1.5;
            break;
        default:
            dDivisor[1] = 1.0;
            break;
        }


    }

    return MAX(dDivisor[0], dDivisor[1]);

}

bool DrivingControl::getMarkStatus()
{
    return m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.bMarked;
}


void DrivingControl::setMarkStatusFalse_AutoTeahcing()
{
	m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.bMarked = false;
	m_InfoSet.Position.Mark.PositionStatus.bMarked = false;
}

void DrivingControl::setMarkStatusFalse()
{
	m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uStation = 0;
	m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.bMarked = false;
	m_InfoSet.Position.Mark.PositionStatus.Info.uStation = 0;
	m_InfoSet.Position.Mark.PositionStatus.bMarked = false;
}

/**
@brief   저장된 구조체의 정보를 이용하여 현재 위치 정보를 획득
@author  임태웅
@date    2013.8.29.
@param InfoSet: 구조체 정보
@param pCurrPositionInfo: 위치 정보
@return 현재 위치 정보를 반환
*/
void DrivingControl::getPostionInfoOnRunning(DRIVING_INFO_SET InfoSet, EXECUTE_POSITION_INFO *pCurrPositionInfo)
{
    bool bUpdate = true;
    double dOffset = 0.0;

    EXECUTE_POSITION_INFO PrePositionInfo;
	EXECUTE_POSITION_INFO TempPositionInfo;
    memset(&TempPositionInfo, 0, sizeof(EXECUTE_POSITION_INFO));

	DRIVING_CMD_INFO_OF_NODE* pNodeInfo = getNodeInfo(InfoSet.HwInfo.Node.nNodeCount);
	DRIVING_CMD_INFO_OF_PATH* pPathInfo = getPathInfo(InfoSet.HwInfo.Node.nNodeCount);

	DRIVING_CMD_INFO_OF_NODE* pPreNodeInfo = getNodeInfo(InfoSet.HwInfo.Node.nPreCheckCount);

//  int nNodeDistOffset = (InfoSet.HwInfo.Node.nNodeCount==0)?0:(int)m_pParamSet->Mark[0].Dist.dAddDistAfterSecondMet;

	if(pNodeInfo==NULL)
	{
		ADD_LOG("[getPostionInfoOnRunning] %d %d retrun",InfoSet.HwInfo.Node.nNodeCount, InfoSet.HwInfo.Node.nPreCheckCount);
        return;// bUpdate = false;
    }

    if( (   (InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType==MARK_TYPE_NODE)
        &&  (pNodeInfo->ID==InfoSet.Position.CurrentAndTarget.TargetPosition.uNode))
    ||  (   (InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType!=MARK_TYPE_NODE)
        &&  (pNodeInfo->ID==InfoSet.Position.CurrentAndTarget.TargetPosition.uNextNode))
    )
    {
        bUpdate = false;
	   //	ADD_LOG("[getPostionInfoOnRunning]false(%d) PreCount:%d", bUpdate, InfoSet.HwInfo.Node.nNodeCount);

		if((InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType==MARK_TYPE_NODE)
		&&  (pNodeInfo->ID==InfoSet.Position.CurrentAndTarget.TargetPosition.uNode))
		{
			if(m_bOnBackMove == false)
			{
				pCurrPositionInfo->CurrNode = pNodeInfo->ID;
				m_pExecuteInfo->ExecutePositionInfo.CurrNode =pNodeInfo->ID;

				pCurrPositionInfo->CurrNodeOffset  = MAX(((int)InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset),0);
			}
		}
	}

    //2 CurrPositionStatus
    if(bUpdate==true)
	{
			//20160520

		if(m_bOnBackMove == false)
		{
			dOffset = MAX(((int)InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset),0);
			pCurrPositionInfo->CurrNode         = pNodeInfo->ID;
			if(pPreNodeInfo==NULL)
				pCurrPositionInfo->CurrPreCheckNode	= pNodeInfo->ID;
			else
				pCurrPositionInfo->CurrPreCheckNode	= pPreNodeInfo->ID;

		}
		else
        {
		   dOffset = InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset;
		   pCurrPositionInfo->CurrNode         = InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode;
        }

        if(InfoSet.EventAndState.State.MarkArea==true)
			pCurrPositionInfo->CurrStation      = InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uStation;
		else
		{
			if(m_pExecuteInfo->FlagOverRunInfo.bCheck ==false)
				pCurrPositionInfo->CurrStation      = 0;
		}

		pCurrPositionInfo->CurrNodeOffset   = (int)dOffset;
//      pCurrPositionInfo->CurrNodeOffset   = (InfoSet.HwInfo.Node.nPreCheckCount!=InfoSet.HwInfo.Node.nNodeCount)
//                                          ? 0:(MAX(((int)InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset-nNodeDistOffset),0));
        pCurrPositionInfo->NextNode         = (pPathInfo!=NULL)?pPathInfo->EndNID:0;
        pCurrPositionInfo->Marked           = InfoSet.Position.CurrentAndTarget.CurrPositionStatus.bMarked;
		pCurrPositionInfo->StationType      = InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.MarkType;

	   //	ADD_LOG("[getPostionInfoOnRunning]true PreCount:%d", InfoSet.HwInfo.Node.nPreCheckCount);
	}

    //2 TargetPosition
	pCurrPositionInfo->CurrCommandedNode    = InfoSet.Position.CurrentAndTarget.TargetPosition.uNode;
	pCurrPositionInfo->CurrCommandedStation = InfoSet.Position.CurrentAndTarget.TargetPosition.uStation;

	//3 puting
//	pCurrPositionInfo->dCompensatedPosition = InfoSet.Position.Compensation.dCompensatedPosition;
}

/**
@brief   저장된 구조체의 정보를 이용하여 현재 위치 정보를 획득
@author  임태웅
@date    2013.8.29.
@param InfoSet: 구조체 정보
@param pCurrPositionInfo: 위치 정보
@return 현재 위치 정보를 반환
*/
void DrivingControl::getPostionInfoOnMarked(DRIVING_INFO_SET InfoSet, EXECUTE_POSITION_INFO *pCurrPositionInfo)
{
    bool bOverRun = false;

    if( (   (m_InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType!=MARK_TYPE_NODE)
        &&  (m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode
            ==m_InfoSet.Position.CurrentAndTarget.TargetPosition.uNextNode))
    )
    {
        bOverRun = true;
    }

//  double dNodeDistOffset  = (m_InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType!=MARK_TYPE_NODE)
//                              ? 0:(int)m_pParamSet->Mark[0].Dist.dAddDistAfterSecondMet;

    //2 CurrPositionStatus
    if(bOverRun==false)
    {
//      pCurrPositionInfo->CurrNode         = InfoSet.Position.CurrentAndTarget.TargetPosition.uNode;
//      pCurrPositionInfo->CurrNodeOffset   = InfoSet.Position.CurrentAndTarget.TargetPosition.dOffset;
//      pCurrPositionInfo->NextNode         = InfoSet.Position.CurrentAndTarget.TargetPosition.uNextNode;

        pCurrPositionInfo->CurrNode         =   (InfoSet.Position.CurrentAndTarget.TargetPosition.uNode!=0)
                                            ?   InfoSet.Position.CurrentAndTarget.TargetPosition.uNode
											:   InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode;

	  	pCurrPositionInfo->CurrPreCheckNode =   (InfoSet.Position.CurrentAndTarget.TargetPosition.uNode!=0)
											?   InfoSet.Position.CurrentAndTarget.TargetPosition.uNode
											:   InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode;

        pCurrPositionInfo->CurrNodeOffset   = (m_InfoSet.Position.CurrentAndTarget.TargetPosition.MarkType==MARK_TYPE_NODE)
                                            ?   MAX(((int)(InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset)),0)
                                            :   InfoSet.Position.CurrentAndTarget.TargetPosition.dOffset;
        pCurrPositionInfo->NextNode         =   ( InfoSet.Position.CurrentAndTarget.TargetPosition.uNextNode!=0)
                                            ?    InfoSet.Position.CurrentAndTarget.TargetPosition.uNextNode
                                            :   InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNextNode;

//      pCurrPositionInfo->CurrNode         = InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode;
//      pCurrPositionInfo->CurrNodeOffset   = MAX(((int)(InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset)),0);
//      pCurrPositionInfo->NextNode         = InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNextNode;
//		ADD_LOG("[getPostionInfoOnMarked] %f ",pCurrPositionInfo->CurrNodeOffset);
    }

    pCurrPositionInfo->CurrStation          = InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uStation;
    pCurrPositionInfo->Marked               = InfoSet.Position.CurrentAndTarget.CurrPositionStatus.bMarked;
    pCurrPositionInfo->StationType          = InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.MarkType;

    //2 TargetPosition
	pCurrPositionInfo->CurrCommandedNode    = InfoSet.Position.CurrentAndTarget.TargetPosition.uNode;
    pCurrPositionInfo->CurrCommandedStation = InfoSet.Position.CurrentAndTarget.TargetPosition.uStation;

}

/**
@brief   저장된 구조체의 정보를 이용하여 현재 위치 정보를 획득
@author  임태웅
@date    2013.8.29.
@param InfoSet: 구조체 정보
@param pCurrPositionInfo: 위치 정보
@return 현재 위치 정보를 반환
*/
void DrivingControl::getPostionInfoOnManual(DRIVING_HW_INFO_SET HwInfo, EXECUTE_POSITION_INFO *pCurrPositionInfo)
{
    int nNodeDistOffset = (int)m_pParamSet->Mark[0].Dist.dAddDistAfterSecondMet;
	static int nCount = 0;
	static int strPreBCRLog = 0;
	nCount++;
	if(nCount > 10) nCount =0;


    if(m_StatusSet.byStatus  == STS_TURN_OFF) //기동 Off일때
	{

	   DRIVING_CMD_INFO_OF_NODE* pNodeInfo = getNodeInfo(HwInfo.Node.nNodeCount);


	   if(pNodeInfo != NULL)
	   {
			if(m_pExecuteInfo->ExecutePositionInfo.CurrNode  != pNodeInfo->ID)
			{
				ADD_LOG("[getPostionInfoOnManual]TurnOff[%d %d]",m_pExecuteInfo->ExecutePositionInfo.CurrNode,pNodeInfo->ID);
				m_RunOffsetDistance =0.0;
				pCurrPositionInfo->CurrNode = pNodeInfo->ID;
				m_pExecuteInfo->ExecutePositionInfo.CurrNode =pNodeInfo->ID;
				if(pCurrPositionInfo->CurrNode == nRunNextNodeID)
				{
					if(cRunNextDivInfo != PATH_DIVERGENCE_NONE)
						m_pExecuteInfo->nCheckDivInfo = cRunNextDivInfo;
				}
			}
	   }
	}
	else if(HwInfo.Node.nBcrId!=0)
	{

		if(strPreBCRLog != HwInfo.Node.nBcrId)
		{
			BCR_LOG("/%6d/%d/", HwInfo.Node.nBcrId, m_InfoSet.HwInfo.Node.nNodeCount);
			strPreBCRLog = HwInfo.Node.nBcrId;
		}

		m_RunOffsetDistance =0.0;
		pCurrPositionInfo->CurrNode = HwInfo.Node.nBcrId;
	    m_pExecuteInfo->ExecutePositionInfo.CurrNode =HwInfo.Node.nBcrId;
		if(pCurrPositionInfo->CurrNode == nRunNextNodeID)
		{
			if(m_StatusSet.byStatus != STS_AUTORECOVERY_OVERRUN)
			{
				ADD_LOG("[getPostionInfoOnManual]NodeID%d %d",pCurrPositionInfo->CurrNode, cRunNextDivInfo);

				if(cRunNextDivInfo != PATH_DIVERGENCE_NONE)
					m_pExecuteInfo->nCheckDivInfo = cRunNextDivInfo;
			}
		}

	}


	if(pCurrPositionInfo->CurrNode!=0)
	{

		pCurrPositionInfo->CurrNodeOffset = ((int)(HwInfo.Axis1.dCurrPos-HwInfo.Node.dNodePosition)-10 + m_RunOffsetDistance);

		if(m_pExecuteInfo->ExecuteMode == EXECUTE_MODE_AUTO)
		{
			pCurrPositionInfo->CurrNodeOffset = MAX(((int)(pCurrPositionInfo->CurrNodeOffset)),0);
		}

		m_pExecuteInfo->dCompensatedPosition   = HwInfo.Axis1.dCurrPos - m_InfoSet.Position.Compensation.dDistErrorSum;
//		if((nCount%3) ==0)
//			ADD_LOG("[getPostionInfoOnManual] Offset %d : %f", pCurrPositionInfo->CurrNodeOffset, m_pExecuteInfo->dCompensatedPosition);

	}
    else
	{
		cRunNextDivInfo = PATH_DIVERGENCE_NONE;
		m_RunOffsetDistance =0.0;
        pCurrPositionInfo->CurrNodeOffset = 0.0;
	}

}



void DrivingControl::checkStartCmd(EXECUTE_DRIVING_INFO *pTmpDrivingInfo)
{
    EXECUTE_DRIVING_INFO TmpDrivingInfo;
    memset(&TmpDrivingInfo, 0x00, sizeof(EXECUTE_DRIVING_INFO));

    if(m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.MarkType==MARK_TYPE_NODE)
    {
        return;  // 추후 에러 추가
    }
    else    // Station Marked
    {
        if(pTmpDrivingInfo->BasicInfo.EndNID==m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNextNode)
        {
            return;
        }
        else if(pTmpDrivingInfo->BasicInfo.StartNID==m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNextNode)
        {
            TmpDrivingInfo = m_LastDrivingCmdInfo;
			memset(&(TmpDrivingInfo.AddInfo), 0x00, sizeof(EXECUTE_DRIVING_ADD_INFO));
            makeCmdInfoLists(&TmpDrivingInfo);
            ADD_LOG("[checkStartCmd] StartCmd Added");
        }
        else
        {
            // 추후 에러 처리

        }
    }
}

EXECUTE_ACK DrivingControl::checkStartCmdStandard(EXECUTE_DRIVING_INFO *pTmpDrivingInfo)
{
	EXECUTE_ACK TmpExecuteAck = EXECUTE_ACK_ON_ERR;
    EXECUTE_DRIVING_INFO TmpDrivingInfo;
    memset(&TmpDrivingInfo, 0x00, sizeof(EXECUTE_DRIVING_INFO));

	if(m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.MarkType==MARK_TYPE_NODE)
	{
		return EXECUTE_ACK_NOT_AVAILABLE_CMD;  // 추후 에러 추가
	}
	else    // Station Marked
	{
		if(pTmpDrivingInfo->BasicInfo.EndNID==m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNextNode)
		{
			return EXECUTE_ACK_NOT_AVAILABLE_CMD;
		}
		else if(pTmpDrivingInfo->BasicInfo.StartNID==m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNextNode)
		{
		   // TmpDrivingInfo = m_LastDrivingCmdInfo;
		   //	memset(&(TmpDrivingInfo.AddInfo), 0x00, sizeof(EXECUTE_DRIVING_ADD_INFO));
			TmpExecuteAck=  makeCmdInfoLists(&TmpDrivingInfo);
			ADD_LOG("[checkStartCmd] StartCmd Added");
		}
		else
		{
			// 추후 에러 처리

		}
	}
}

double  DrivingControl::getMarkSpeedLimitOnGoing(int nCurrNodeCount)
{
    double  dSpeedLimit = m_pParamSet->Axis.Limit.Speed.MaxValue;
    DRIVING_CMD_INFO_OF_PATH* pPathInfo = NULL;

    //2 현재 Path의 최대 속도가 작을 경우 Limit Speed로 설정
    pPathInfo = getPathInfo(nCurrNodeCount);
    if(pPathInfo!=NULL)
    {
        dSpeedLimit = MIN(dSpeedLimit, pPathInfo->dSpeed);
    }

    //2 다음 Path의 최대 속도가 더 작을 경우 Limit Speed로 설정
    pPathInfo = getPathInfo(nCurrNodeCount+1);
    if(pPathInfo!=NULL)
    {
        dSpeedLimit = MIN(dSpeedLimit, pPathInfo->dSpeed);
    }

    return dSpeedLimit;

}


/**
 @brief   오버런 에러 관련 Auto Recovery 실행 함수
 @author  puting
 @date    2016.05.23
 @param   Error_AV : AutoRecovery를 하게 되는 Error Code
 @return  함수 실행 시 문제 없으면 0, 문제가 발생되면 해당 에러 코드 리턴
 */
int DrivingControl::AutoRecovery_Driving(int Error_AV)
{
	int nError = NO_ERR;
    double dVel_mmpermsec = 0.0;
	double dAccel_mmpermsec2 = 0.0;
	DWORD dwStartTime = 0;

	if((Error_AV == ERR_BCR_READTIMEOUT) ||
	   (Error_AV == ERR_QRR_READTIMEOUT))
//	   (Error_AV == ERR_MARK_FAIL))
//	   (Error_AV == ERR_NOTMATCH_TAGLENGTH_FINALSTATION_TAG_MET_LATE) ||
//	   (Error_AV == ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_LEFT_MET_LATE) ||
//	   (Error_AV == ERR_NOTMATCH_TAGLENGTH_FINALSTATION_QR_RIGHT_MET_LATE))
	{

            ERR_LOG("Overrun Driving");
			m_StatusSet.byStatus = STS_AUTORECOVERY_OVERRUN;
			m_StatusSet.uError = Error_AV;
			m_StatusSet.bIsOnProcess = false;
			DrivingCMDExuteFunc(false);
			m_StatusSet.uStep = DRIVING_CTRL_STEP_NONE;

	}
	else
	{
     	nError = Error_AV;
	}
	return nError;
}

/**
@brief   pList 의 상태를 확인하고 nNodeCount 값 이전 정보를 삭제
@author  ehoto
@date    2013.7.19
@param pList: Command 리스트
@param Index: 찾기 시작하는 위치
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
template <typename T>
bool    clearListLessThan(List<T*> *pList, int nNodeCount)
{
    int nListCount      = pList->getCount();
    int nTmpIndex   = 0;
    T *pItem = NULL;

    if(nListCount==0) return true;
    for(nTmpIndex; nTmpIndex<nListCount; nTmpIndex++)
    {
        pItem   = pList->referFront();
        if(pItem!=NULL)
        {
            if(pItem->nCount>=nNodeCount)
            {
                break;
            }
            else
            {
                pItem   = pList->popFront();
                delete pItem;
                pItem   = NULL;
            }
        }
    }
    return true;
}



/**
@brief   pList 의 상태를 확인하고 nNodeID값 이후 정보를 삭제
@author  ehoto
@date    2013.7.19
@param pList: Command 리스트
@param Index: 찾기 시작하는 위치
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
template <typename T>
bool    clearListLessAfter(List<T*> *pList, int nNodeCount)
{
    int nListCount      = pList->getCount();
    int nTmpIndex   = 0;
    T *pItem = NULL;

	if(nListCount==0) return false;

	for(nTmpIndex; nTmpIndex<nListCount; nTmpIndex++)
	{
        pItem   = pList->referBack();
        if(pItem!=NULL)
        {
            if(pItem->nCount>=nNodeCount)
            {
                break;
            }
            else
            {
                pItem   = pList->popBack();
                delete pItem;
                pItem   = NULL;
            }
        }
	}

    return true;
}



/**
@brief   pList 의 상태를 확인하고 Index의 값 이후 의 정보를 삭제
@author  ehoto
@date    2013.7.19
@param pList: Command 리스트
@param Index: 찾기 시작하는 위치
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
template <typename T>
bool    clearListFrom(List<T*> *pList, int nIndex)
{
    int nListCount      = pList->getCount();
    int nTmpIndex   = nIndex;
    T *pItem = NULL;

    if(nListCount==0) return true;
    for(nTmpIndex; nTmpIndex<nListCount; nTmpIndex++)
    {
        pItem   = pList->popFront();
        if(pItem!=NULL)
        {
            delete pItem;
            pItem   = NULL;
        }
    }
    return true;
}

/**
@brief   pList 의 상태를 확인하고 모든 정보를 삭제
@author  ehoto
@date    2013.7.19
@param pList: Command 리스트
@return 성공하면 true 반환, List에 명령이 없어 추가 못하면 false 반환
*/
template <typename T>
bool    clearList(List<T*> *pList)
{
    clearListFrom(pList, 0);
}



// ===============  VHL 엘리베이터 구현 관련 추가 함수 정의 ===============

// 통과허가를 요청한다
/*
	OHT_NAME 6Byte.  Priority 2Byte. 그외 1Byte
*/
int DrivingControl::VHL_OPC_PASS_REQUEST (char* OHTNAME, unsigned char Priority,
										  unsigned char Turn, unsigned char LightGuideID)
{
	OPC_TO_TRANSPER_PKT PASS_REQ_PKT;

	PASS_REQ_PKT.STX = OPC_SERIAL_INIT_STX;
	PASS_REQ_PKT.CMD = OPC_TO_TRANSPER_CMD;

	memcpy(&PASS_REQ_PKT.OHTNAME, 		OHTNAME, 	sizeof(PASS_REQ_PKT.OHTNAME));
	PASS_REQ_PKT.Priority[ELEVETOR_HIGH_BYTE] = Priority;
	PASS_REQ_PKT.Priority[ELEVETOR_LOW_BYTE]  = Priority;
	PASS_REQ_PKT.Turn = Turn;
	PASS_REQ_PKT.LightGuideID = LightGuideID;

	CheckSum((char*)& PASS_REQ_PKT, OPC_TO_TRANSPER_PKT_CHECKSUM_LENGTH, (char*)&PASS_REQ_PKT.SUM);
	PASS_REQ_PKT.ETX = OPC_SERIAL_INIT_ETX;

	return SEND_SERIAL((char*)&PASS_REQ_PKT, sizeof(OPC_TO_TRANSPER_PKT));
	// return OPC_SERIAL_SEND_OK;
}


int DrivingControl::VHL_OPC_PASS_RESPONSE(unsigned char LightGuideID)
{
	int iReceivedByte = 0;
	AnsiString strTmp, strLog;

	char Tempbuff[255] ={0,};

	TRANSPER_TO_OPC_PKT RECV_PKT;

   	iReceivedByte = pHWSet->m_pCID->ReadData((char*)&Tempbuff, (char)OPC_SERIAL_INIT_ETX);

	strLog.sprintf("[LIFTER] VHL_OPC_PASS_RESPONSE () Byte : %d", iReceivedByte);
	ADD_CID_LOG(strLog);

	if(iReceivedByte == 0)
		return TRANSPER_STATUS_DATA_NOT_RECEIVED;

	if(iReceivedByte == sizeof(TRANSPER_TO_OPC_PKT))
	   memmove(&RECV_PKT,&Tempbuff,sizeof(TRANSPER_TO_OPC_PKT));
	else
	   return TRANSPER_STATUS_DATA_NOT_RECEIVED;

	if(RECV_PKT.STX != OPC_SERIAL_INIT_STX)
		return TRANSPER_STATUS_OTHER_ERR;

	if(RECV_PKT.CMD != TRANSPER_TO_OPC_CMD)
		return TRANSPER_STATUS_OTHER_ERR;

	 if(m_defualtparam->VHLLifterPassEnable == 0)
	 {

		if(RECV_PKT.LightGuideID != LightGuideID)
		return TRANSPER_STATUS_OTHER_ERR;

		if(memcmp(&m_defualtparam->VHLName, &RECV_PKT.OHTNAME, sizeof(RECV_PKT.OHTNAME)) != 0)
		{
			ADD_LOG("OHTID Miss %s",RECV_PKT.OHTNAME);
			return TRANSPER_STATUS_OTHER_ERR;
		}
	 }
	 else
	 {
       	//AOHC-217 VHLLifter 속도 개선
		// Lightguide ID 정합성 체크 제거. 181107 jhoun.lim
		//	if(RECV_PKT.LightGuideID != LightGuideID)
		//		return TRANSPER_STATUS_OTHER_ERR;

		if(memcmp(&m_defualtparam->VHLName, &RECV_PKT.OHTNAME, sizeof(RECV_PKT.OHTNAME)) != 0)
		{
			//ADD_LOG("OHTID Miss %s",RECV_PKT.OHTNAME);
			return TRANSPER_STATUS_OTHER_ERR;
		}

		// LightGuideID 를 비교한다. (상부진입 or 하부진입 판단) 2018.06.04 by jhoun.lim
		// Lifter 진입시에 최초 1번만 실행된다.
		if(m_nElevetorDirection == PASS_DIRECTION_REQUEST_BEFORECHECK)
		{
			ADD_CID_LOG("[NEW Function] start finding lifter out node");
			m_nElevetorDirection = PASS_DIRECTION_REQUEST_ALL;
			bool isFindOutNode = false;
			for(int pathIndex = 0; pathIndex < m_pExecuteInfo->ListOfCmd.getCount(); pathIndex++)
			{
				EXECUTE_DRIVING_INFO* tmpDrvInfo = (EXECUTE_DRIVING_INFO*)m_pExecuteInfo->ListOfCmd.refer(pathIndex);

				int nid = tmpDrvInfo->BasicInfo.StartNID;
				int ntype = tmpDrvInfo->BasicInfo.NodeType;
				strLog.sprintf("[NEW Function] %d : nid : %d, ntype : %d", pathIndex, nid, ntype);
				ADD_CID_LOG(strLog);

				if(tmpDrvInfo->BasicInfo.NodeType == LIFTOUT_NTYPE)
				{
					isFindOutNode = true;
					if((RECV_PKT.LightGuideID == LIGHT_GUIDE_ID_INPUT_DOWN && tmpDrvInfo->BasicInfo.DivInfo == PATH_DIVERGENCE_LEFT) ||
						(RECV_PKT.LightGuideID == LIGHT_GUIDE_ID_INPUT_UP && tmpDrvInfo->BasicInfo.DivInfo == PATH_DIVERGENCE_RIGHT) ||
						(RECV_PKT.LightGuideID == LIGHT_GUIDE_ID_INPUT_DOWN_PRE && tmpDrvInfo->BasicInfo.DivInfo == PATH_DIVERGENCE_LEFT) ||
						(RECV_PKT.LightGuideID == LIGHT_GUIDE_ID_INPUT_UP_PRE && tmpDrvInfo->BasicInfo.DivInfo == PATH_DIVERGENCE_RIGHT))
					{
						ADD_CID_LOG("[NEW Function] PASS_DIRECTION_REQUEST_PASS");
						m_nElevetorDirection = PASS_DIRECTION_REQUEST_PASS;
					}
					else
					{
						ADD_CID_LOG("[NEW Function] PASS_DIRECTION_REQUEST_ALL");
					}
					break;
				}
			}
			if(!isFindOutNode)
			{
				ADD_CID_LOG("[NEW Function] can not find lifter out node!!");
			}
			return TRANSPER_STATUS_OTHER_ERR;
		}
		// for safety jhoun.lim 18.11.20
		if(m_nElevetorDirection == PASS_DIRECTION_REQUEST_PASS && RECV_PKT.PassInfo == VHL_LIFTER_TO_CID_R_ALL_PASS_OK)
		{
			m_nElevetorDirection = PASS_DIRECTION_REQUEST_ALL;
		}
	 }

	if(RECV_PKT.PassInfo == VHL_LIFTER_TO_CID_R_RIGHT_PASS_OK)
		strTmp.sprintf("우방향 통과 OK");
	else if(RECV_PKT.PassInfo == VHL_LIFTER_TO_CID_R_LEFT_PASS_OK)
		strTmp.sprintf("좌방향 통과 OK");
	else if(RECV_PKT.PassInfo == VHL_LIFTER_TO_CID_R_RIGHT_LOWSPEED_OK)
		strTmp.sprintf("우방향 저속 통과 OK");
	else if(RECV_PKT.PassInfo == VHL_LIFTER_TO_CID_R_LEFT_LOWSPEED_OK)
		strTmp.sprintf("좌방향 저속 통과 OK");

	else if(RECV_PKT.PassInfo == VHL_LIFTER_TO_CID_R_RIGHT_ONLY_OK)
		strTmp.sprintf("우방향 통과 가능");
	else if(RECV_PKT.PassInfo == VHL_LIFTER_TO_CID_R_LEFT_ONLY_OK)
		strTmp.sprintf("좌방향 통과 가능");
	else if(RECV_PKT.PassInfo == VHL_LIFTER_TO_CID_R_ALL_PASS_OK)
		strTmp.sprintf("방향지정 없이 가능");	
	else if(RECV_PKT.PassInfo == VHL_LIFTER_TO_CID_R_ALL_PASS_OK_P) // jhoun.lim
		strTmp.sprintf("내부 정지 없이 통과 가능");
	else if(RECV_PKT.PassInfo == VHL_LIFTER_TO_CID_R_ALL_LOWSPEED_OK)
		strTmp.sprintf("방향없이 저속통과 가능");

	else if(RECV_PKT.PassInfo == VHL_LIFTER_TO_CID_R_PASS_NG)
		strTmp.sprintf("통과불가능");
	else if(RECV_PKT.PassInfo == VHL_LIFTER_TO_CID_R_PASS_OK)
		strTmp.sprintf("리프터 호출후 응답은 있으나 무효한 응답임");
	else if(RECV_PKT.PassInfo == VHL_LIFTER_TO_CID_R_LIFTER_OFF_STATE)
		strTmp.sprintf("리프트 기동 Off상태 (자동운전 아님)");
	else strTmp.sprintf("알수 없음");

	strLog.sprintf("[LIFTER] Pass Result : %s", strTmp);
	ADD_CID_LOG(strLog);

	if(iReceivedByte == sizeof(TRANSPER_TO_OPC_PKT))
	{
		strLog.sprintf("[LIFTER] VHL_OPC_PASS_RESPONSE () PassInfo : %c", RECV_PKT.PassInfo);
		ADD_CID_LOG(strLog);

		return RECV_PKT.PassInfo;		// TRANSPER_STATUS_DATA_RECEIVED_OK;
	}
	else
		return TRANSPER_STATUS_DATA_LENGTH_ERR;
}



// 시리얼로 1바이트를 전송한다 (항상 성공)
int DrivingControl::SendLowSerial(char* cTemp)
{
	return OPC_SERIAL_SEND_OK;
	// 실패시 OPC_SERIAL_SEND_ERR를 리턴한다
}


// 시리얼로 문자열을 보낸다 (시뮬레이션이며, 화면에 표시해보자)
int DrivingControl::SEND_SERIAL(char* cProtocol, int iSize)
{
	return pHWSet->m_pCID->SendLGCmd(cProtocol,iSize);

}

int DrivingControl::SEND_SERIAL_NOT_CLEAR(char* cProtocol, int iSize)
{
	return pHWSet->m_pCID->SendLGCmd_NotClear(cProtocol,iSize);

}


void DrivingControl::VHL_OPC_RESET_RESPONSE_SIMUL(OPC_INIT_PKT RECV_PKT)
{
	//int button = MessageBox(Handle,"VHL_OPC_RESET_RESPONSE_SIMUL. Are you sure?",
	//		"Confirmation", MB_ICONQUESTION|MB_OKCANCEL|MB_APPLMODAL);

	RECV_PKT.STX = OPC_SERIAL_INIT_STX;

	//if (button == IDOK)
		RECV_PKT.CMD = OPC_SERIAL_INIT_CMD;
	//else
	//	RECV_PKT.CMD = OPC_SERIAL_INIT_TEST;

	RECV_PKT.Reserve[ELEVETOR_HIGH_BYTE] = OPC_SERIAL_INIT_RESERVE;
	RECV_PKT.Reserve[ELEVETOR_LOW_BYTE]  = OPC_SERIAL_INIT_RESERVE;
	RECV_PKT.ETX = OPC_SERIAL_INIT_ETX;

	CheckSum((char*)& RECV_PKT, OPC_INIT_PKT_CHECKSUM_LENGTH, (char*)&RECV_PKT.SUM);
}


int DrivingControl::VHL_OPC_RESET_RESPONSE()
{
	int iReceivedByte = 0;
	OPC_INIT_PKT RECV_PKT;
	AnsiString strLogTmp;

	char Tempbuff[255] ={0,};
	ADD_CID_LOG("[Elevetor] VHL_OPC_RESET_RESPONSE() - START POS");
	try{
		iReceivedByte = pHWSet->m_pCID->ReadData((char*)& Tempbuff, (char)OPC_SERIAL_INIT_ETX);
	}
	catch(...)
	{
		iReceivedByte =0;
		ADD_CID_LOG("[Elevetor] Exception Error");
	}
	strLogTmp.sprintf("[Elevetor] VHL_OPC_RESET_RESPONSE () Byte : %d", iReceivedByte);
	ADD_CID_LOG(strLogTmp);

	if(iReceivedByte == 0)
		return TRANSPER_STATUS_DATA_NOT_RECEIVED;

	if(iReceivedByte == sizeof(OPC_INIT_PKT))
	   memmove(&RECV_PKT,&Tempbuff,sizeof(OPC_INIT_PKT));
	else
	   return TRANSPER_STATUS_DATA_NOT_RECEIVED;

	if(RECV_PKT.STX != OPC_SERIAL_INIT_STX)
		return TRANSPER_STATUS_OTHER_ERR;

	if(RECV_PKT.CMD != OPC_SERIAL_INIT_CMD)
		return TRANSPER_STATUS_OTHER_ERR;

	if(iReceivedByte == sizeof(OPC_INIT_PKT))
		return TRANSPER_STATUS_DATA_RECEIVED_OK;
	else
		return TRANSPER_STATUS_DATA_LENGTH_ERR;
}

// OPC보드로 시리얼 리셋 명령을 보낸다
int DrivingControl::VHL_OPC_RESET()
{
	OPC_INIT_PKT SEND_PKT;

	SEND_PKT.STX = OPC_SERIAL_INIT_STX;
	SEND_PKT.CMD = OPC_SERIAL_INIT_CMD;
	SEND_PKT.Reserve[ELEVETOR_HIGH_BYTE] = OPC_SERIAL_INIT_RESERVE;
	SEND_PKT.Reserve[ELEVETOR_LOW_BYTE]  = OPC_SERIAL_INIT_RESERVE;
	SEND_PKT.ETX = OPC_SERIAL_INIT_ETX;

	CheckSum((char*)& SEND_PKT, OPC_INIT_PKT_CHECKSUM_LENGTH, (char*)&SEND_PKT.SUM);

	return SEND_SERIAL((char*)&SEND_PKT, sizeof(OPC_INIT_PKT));
}

// CheckSum3 - 내가 만들어본 것
// 위 함수에서 조금 고쳐서, Sum을 바로 담아준다 (호출측 코드 간략화)
AnsiString DrivingControl::CheckSum(char* buf, int len, char* check)
{
	unsigned int iCheckSum = 0;
	unsigned char cTmp = 0;


	for(int i = 1; i < len; i++)
	{
		cTmp = buf[i];
		iCheckSum = iCheckSum + cTmp;	// buf[i];
	}

	AnsiString sRv = "";   //iCheckSum = 0x0a;
	sRv.sprintf("%04X", iCheckSum);
	// sRv.sprintf("%04x", iCheckSum);

	AnsiString Tmp1, Tmp2;

	Tmp1 = sRv.SubString(3,1);
	Tmp2 = sRv.SubString(4,1);

	// 주의 : 덧셈의 결과가 나오면, 최하위 1바이트만 가지고, 체크썸에 태워야 한다
	memcpy((check + ELEVETOR_HIGH_BYTE), Tmp1.c_str(), 1);
	memcpy((check + ELEVETOR_LOW_BYTE) , Tmp2.c_str(), 1);

	return sRv; // 이전 전체 분석된 바이트 수
}


/*
	CID-O는 I5(Reserved)를 ‘1’로 설정함에 의해, MTL/Lifter 영역임을 VHL에 알릴 수 있습니다
	VHL은 I5(Reserved) 에서 ‘1’로 입력됨을 확인하고, Select Off한 후
	Operating Mode (O6)를 “0(MTL/Lifter)” 설정 후 Select On하시면 됩니다
*/
int DrivingControl::GetCID_ELEVETORMODE_VALUE()
{
	return pHWSet->m_pCID->IsElevetorArea();
}

// 엘리베이터 바깥의, LG1링크를 켜야하는 첫 포지션을 감지
// 도달했으면 true, 아니면 false반환
bool DrivingControl::Check_Elevetor_LG1_START_AREA_Tag()
{
	return false;
}

// 엘리베이터 바깥의, LG1링크의 중앙 (엘리베이터 타기전, 허가를 기다리는 곳)
// 도달했으면 true, 아니면 false반환
bool DrivingControl::Check_Elevetor_LG1_WAIT_AREA_Tag()
{
	return false;
}

// 엘리베이터 안쪽의, LG2링크의 중앙 (엘리베이터 안에서, 출발 허가를 기다리는 곳)
// 도달했으면 true, 아니면 false반환
bool DrivingControl::Check_Elevetor_LG2_INSIDE_WAIT_AREA_Tag()
{
	return false;
}


// VHL동작을 제어한다 (true : 동작, false : 정지). 리턴값 : true - 성공, false - 실패
bool DrivingControl::MotionOnOff(bool bOnOff)
{
	return true;
}
// bOnceRunReset 인수는 스테이트 머신에서 실행하면서, 불필요하게 여러번 리셋하는 것을
// 막기위한 것이다.
// true로 하면, 해당 함수 내부의 static 변수가 리셋 후, 빠져나가며 (다른 동작은 안함)
// 다음번에 실제 기능을 동작시키기 위해 호출하면 (이때 이 인수는 반드시 false) 실행후 flag가 set 된다
//
// 인수내용 (bOnceRunReset)
//   true -> 다음번에는 리셋명령을 보내야 한다 (예약만 해두고 return. I/O 명령은 보내지 않는다)
//   false -> 현재 상태를 보고, 리셋명령을 보내야 하는 경우에만 I/O 명령을 보내라
//
// 변수내용 (bOnceRun)
//	 true : 리셋명령을 실제 보내야 하는 상태 (초기상태)
//   false : 리셋명령을 이미 보낸 상태 (더이상 중복해서 보낼 필요없음)

void DrivingControl::CID_IO_SETTING_LIFTER(bool LightGuideDirectionIsLeft)
{
	int nError;
	AnsiString strLogTmp;
	static bool bOnceRun = true;

	strLogTmp.sprintf("[LIFTER] CID_IO_SETTING_LIFTER() LightGuideDirectionIsLeft : %d  ",
							LightGuideDirectionIsLeft);
	ADD_CID_LOG(strLogTmp);

	/*
	if (bOnceRunReset == true)
	{
		bOnceRun = true;
		return;
	}
	*/
	//if (bOnceRun == true)
	{
		nError = CID_SELECT_ALL_OFF();		// CID의 Select를 모두 Off한다
		strLogTmp.sprintf("[LIFTER] SELECT all off return : %d", nError);
		ADD_CID_LOG(strLogTmp);
		Sleep(DELAY_CID_COMMAND);	// 장비사양상 최소 10ms딜레이 줘야 함

		nError = CID_OPERATION_MODE_LIFTER();	// CID장치를 리프터 모드로 전환한다
		strLogTmp.sprintf("[LIFTER] OP MODE LIFTER : %d", nError);
		ADD_CID_LOG(strLogTmp);
		Sleep(DELAY_CID_COMMAND);

		// 좌,우 방향을 선택한다
		if(LightGuideDirectionIsLeft == true)
		{
			nError = CID_SELECT_DIRECTION_LEFT();
			strLogTmp.sprintf("[LIFTER] LEFT 선택 : %d", nError);
			ADD_CID_LOG(strLogTmp);
			Sleep(DELAY_CID_COMMAND);
		}
		else
		{
			nError = CID_SELECT_DIRECTION_RIGHT();
			strLogTmp.sprintf("[LIFTER] RIGHT 선택 : %d", nError);
			ADD_CID_LOG(strLogTmp);
			Sleep(DELAY_CID_COMMAND);
		}

		bOnceRun = false;
	}
}

int DrivingControl::CID_SELECT_ALL_OFF()
{
	return pHWSet->m_pCID->ElevetorSelectOff();
}

int DrivingControl::CID_OPERATION_MODE_LIFTER()
{
	return pHWSet->m_pCID->ElevetorOperatingModeSet(OFF);
}

int DrivingControl::CID_SELECT_DIRECTION_LEFT()
{
	return pHWSet->m_pCID->Left_Link_Lifter();
}

int DrivingControl::CID_OPERATION_MODE_CID()
{
	return pHWSet->m_pCID->ElevetorOperatingModeSet(ON);
}

int DrivingControl::CID_SELECT_DIRECTION_RIGHT()
{
	return pHWSet->m_pCID->Right_Link_Lifter();
}

bool DrivingControl::CID_Check_Mode_Lifter(bool LightGuideDirectionIsLeft)
{
	return  pHWSet->m_pCID->Check_Mode_Lifter(LightGuideDirectionIsLeft);
}


int DrivingControl::ModeChg_CALL()
{
	// 임시 - 디버그용
	AnsiString OHTNAME = "OHT001";
	int Priority;
	int Turn;
	int LightGuideID;
	// bool LightGuideDirectionIsLeft;

	Priority = '9';
	Turn = PASS_DIRECTION_REQUEST_ALL;
	LightGuideID = 'A';
	// LightGuideDirectionIsLeft = true;
	// -----------------------------


	int iReturn = VHL_OPC_PASS_REQUEST(m_defualtparam->VHLName, Priority, Turn, LightGuideID);

	return iReturn;

}


int DrivingControl::ModeChg_UP()
{

	// 임시 - 디버그용
	AnsiString OHTNAME = "OHT001";
	int Priority;
	int Turn;
	int LightGuideID;

	Priority = '9';
	Turn = PASS_DIRECTION_REQUEST_RIGHT;

	LightGuideID = 'A';

	// LightGuideID = StrToInt(OHTMainForm->Edit1->Text);


	// -----------------------------
	// ascii test

//#ifdef LIFTER_SCR_DEBUG
//	AnsiString strT;
//	strT.sprintf("지금보낸값 : %c", iTemp);
//	OHTMainForm->Memo1->Lines->Add(strT);
//#endif

	int iReturn = VHL_OPC_PASS_REQUEST(m_defualtparam->VHLName, Priority, Turn, LightGuideID);

	return iReturn;
}


int DrivingControl::ModeChg_DOWN()
{
	// 임시 - 디버그용
	AnsiString OHTNAME = "OHT001";
	int Priority;
	int Turn;
	int LightGuideID;


	Priority = '9';
	Turn = PASS_DIRECTION_REQUEST_LEFT;
	LightGuideID = 'A';

	// -----------------------------


	int iReturn = VHL_OPC_PASS_REQUEST(m_defualtparam->VHLName, Priority, Turn, LightGuideID);

	return iReturn;
}

void DrivingControl::ADD_CID_LOG(AnsiString strLog)
{
	pHWSet->m_pCID->LOG_WRITE_2_CID_LOG(strLog);
}

void DrivingControl::SetOhtName(AnsiString strName)
{
	m_strOhtName = strName;
}


// 이 부분은 MAP에 리프터의 PreNode를 정의하기 전이므로, 임시로 하드코딩하여 만든 함수임
bool DrivingControl::Lifter_Prenode_Check(UINT iNodeNum)
{
	AnsiString strLogTmp;


	if ((iNodeNum == 126) || (iNodeNum == 210))
	{
		//strLogTmp.sprintf("[LIFTER PRE] Lifter_Prenode_Check()-true node no : %d", iNodeNum);
		//ADD_CID_LOG(strLogTmp);

		return true;
	}
	else
	{
		// strLogTmp.sprintf("[LIFTER PRE] Lifter_Prenode_Check()- FALSE!! node no : %d", iNodeNum);
		// ADD_CID_LOG(strLogTmp);

		return false;
	}
}
/////////////////////////////////////////
////사전동작 관련 함수 모음 -- puting////
////////////////////////////////////////
#define  EQPIO_BASE_CHANNEL         178     //LimJY_20160119 : For IR+RF PIO 시작 채널 178 (178 ~ 217 사용가능)

int DrivingControl::ExeCmdEQPIOOpen(int nPIOType, int nPIOID, int nPIOChannel,int nPIOCS)
{
	int nError = NO_ERR;

	int nTempPIOChannel = 0;

	if(nPIOChannel ==0)
	{
		nTempPIOChannel = nPIOID % 100;
		nTempPIOChannel = nTempPIOChannel % 40;
		nTempPIOChannel = EQPIO_BASE_CHANNEL + nTempPIOChannel;
	}
	else if(nPIOChannel >= EQPIO_BASE_CHANNEL && nPIOChannel < (EQPIO_BASE_CHANNEL+40) )
	{
		nTempPIOChannel = nPIOChannel;
	}
	else  //사용하지 않는 채널 번호가 적힌 경우
	{
		nTempPIOChannel = nPIOID % 100;
		nTempPIOChannel = nTempPIOChannel % 40;
		nTempPIOChannel = EQPIO_BASE_CHANNEL + nTempPIOChannel;
	}

	if(pHWSet->m_pLeftEQPIO->GetRFPIOConnectStep()!=8)
	{
		 if(nPIOType != TYPE_PIO_IR)
		 {
			nError = pHWSet->m_pLeftEQPIO->Set_RFPIO_Data_RS232_Hybrid(nPIOType, nPIOID, nTempPIOChannel, nPIOCS, m_defualtparam->VHLName, true);
		 }

         {
         // 로그 중복 방지 코드 3000ms
             static DWORD dwPrevTick = 0;
             DWORD curTick = timeGetTime();
			 if(OHTUTILITY::PreventOverflowGetTimeMs( dwPrevTick) > 3000)   //20191104 KDS
             {
                    ADD_LOG("[PreTrans] PIO Open");
                    dwPrevTick = curTick;
             }

         }


	}

	return nError;

}

int DrivingControl::ExeCmdEQPIOClose()
{
	int nError = NO_ERR;

	nError = pHWSet->m_pLeftEQPIO->PIODisable(true);
//nError = m_pHWSet->m_pRightEQPIO->PIODisable(true);

	ADD_LOG("[PreTrans] PIO Close");

	return nError;

}

int DrivingControl::ExeCmdShutterClose(double dSpeedOfNow)
{
	int nError = NO_ERR;

	if(IsInnerFoup() == true)
	{
		if(pHWSet->m_pShutter->IsOpen(BOTH) && pHWSet->m_pShutter->IsInposition(BOTH))
		{
			nError = pHWSet->m_pShutter->IO_Init();
			Sleep(200);
		}

		if(!pHWSet->m_pShutter->IsClose(BOTH))
		{
			if(pHWSet->m_pShutter->IsInposition(BOTH))
			{
				pHWSet->m_pShutter->SendCloseCmd();
				ADD_LOG("[PreTrans] Shutter Close");

				ADD_MCC_LOG(",%s,DRV,SHUTTER FRONT CLOSE,Start,FOUP,%06d,%06d,%06d,%d,%6.1lf,Close Start Station Dist,%6.1lf",
							m_defualtparam->VHLName,
							m_mccparam.uSourceNode,
							m_mccparam.uTargetNode,
							m_pOHTMainStatus->StatusCommon.CurNodeID,
							m_pOHTMainStatus->StatusCommon.CurNodeOffset,
							dSpeedOfNow,
							m_InfoSet.HwInfo.Axis1.dCurrPos);
				ADD_MCC_LOG(",%s,DRV,SHUTTER REAR CLOSE,Start,FOUP,%06d,%06d,%06d,%d,%6.1lf,Close Start Station Dist,%6.1lf",
							m_defualtparam->VHLName,
							m_mccparam.uSourceNode,
							m_mccparam.uTargetNode,
							m_pOHTMainStatus->StatusCommon.CurNodeID,
							m_pOHTMainStatus->StatusCommon.CurNodeOffset,
							dSpeedOfNow,
							m_InfoSet.HwInfo.Axis1.dCurrPos);
				if(m_mccparam.dwShutterFrontTime == 0)
				{
					m_mccparam.dwShutterFrontTime = timeGetTime();
					m_mccparam.dwShutterRearTime = timeGetTime();
				}
			}
			else
			{
				 m_bShutterCloseMovingFlag = true;
			}
		}
		else
		{
		  nError = pHWSet->m_pShutter->IO_Init();
		  ADD_LOG("[PreTrans] Shutter Close Init");
//		  m_bShutterCloseMovingFlag = true;

		}

		m_bShutterCloseFlag = true;  //사전동작 flags
		m_bShutterOpenFlag = false;

	}



	return nError;
}

int DrivingControl::ExeCmdShutterOpen(double dSpeedOfNow)
{
	int nError = NO_ERR;
	static bCheckOpenCmd = false;

	bool bShutterFrontClose = pHWSet->m_pShutter->IsClose(FRONT) & pHWSet->m_pShutter->IsInposition(FRONT);
	bool bShutterRearClose = pHWSet->m_pShutter->IsClose(REAR) & pHWSet->m_pShutter->IsInposition(REAR);
	bool bShutterBothClose = bShutterFrontClose & bShutterRearClose;

//	bool bShutterFrontOpen = pHWSet->m_pShutter->IsOpen(FRONT);
//	bool bShutterRearOpen = pHWSet->m_pShutter->IsOpen(REAR);
//	bool bShutterBothOpen = bShutterFrontOpen & bShutterRearOpen;

	if((IsInnerFoup() == true) && (bShutterBothClose == true) && (m_bShutterOpenFlag ==false) &&(m_bShutterCloseFlag ==false))
	{
		pHWSet->m_pShutter->SendOpenCmd();
		m_bShutterOpenFlag = true;
		bCheckOpenCmd = false;

		ADD_LOG("[PreTrans] Shutter Open");

		ADD_MCC_LOG(",%s,DRV,SHUTTER FRONT OPEN,Start,FOUP,%06d,%06d,%06d,%d,%6.1lf,Open Start Station Dist,%6.1lf",
					m_defualtparam->VHLName,
					m_mccparam.uSourceNode,
					m_mccparam.uTargetNode,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					dSpeedOfNow,
					m_ClassifiedCmd.TargetInfo.dDistSumToNode - m_InfoSet.HwInfo.Axis1.dCurrPos);
		ADD_MCC_LOG(",%s,DRV,SHUTTER REAR OPEN,Start,FOUP,%06d,%06d,%06d,%d,%6.1lf,Open Start Station Dist,%6.1lf",
					m_defualtparam->VHLName,
					m_mccparam.uSourceNode,
					m_mccparam.uTargetNode,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					dSpeedOfNow,
					m_ClassifiedCmd.TargetInfo.dDistSumToNode - m_InfoSet.HwInfo.Axis1.dCurrPos);
		m_mccparam.bFrontShutterFlag = true;
		m_mccparam.bRearShutterFlag = true;
		if(m_mccparam.dwShutterFrontTime == 0)
		{
			m_mccparam.dwShutterFrontTime = timeGetTime();
			m_mccparam.dwShutterRearTime = timeGetTime();
		}
	}
	else if(m_bShutterOpenFlag == true)
	{
		if(bCheckOpenCmd == false)
		{
			if(pHWSet->m_pShutter->IsInposition(FRONT) && pHWSet->m_pShutter->IsOpen(FRONT) && m_mccparam.bFrontShutterFlag)
			{
				ADD_MCC_LOG(",%s,DRV,SHUTTER FRONT OPEN,End,FOUP,%06d,%06d,%06d,%d,%6.1lf,Open End Station Dist,%6.1lf,Shutter Front Open Time,%d",
					m_defualtparam->VHLName,
					m_mccparam.uSourceNode,
					m_mccparam.uTargetNode,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					dSpeedOfNow,
					m_ClassifiedCmd.TargetInfo.dDistSumToNode - m_InfoSet.HwInfo.Axis1.dCurrPos,
					OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwShutterFrontTime));
				m_mccparam.dwShutterFrontTime = 0;
				m_mccparam.bFrontShutterFlag = false;
			}
			if(pHWSet->m_pShutter->IsInposition(REAR) && pHWSet->m_pShutter->IsOpen(REAR) && m_mccparam.bRearShutterFlag)
			{
				ADD_MCC_LOG(",%s,DRV,SHUTTER REAR OPEN,End,FOUP,%06d,%06d,%06d,%d,%6.1lf,Open End Station Dist,%6.1lf,Shutter Rear Open Time,%d",
					m_defualtparam->VHLName,
					m_mccparam.uSourceNode,
					m_mccparam.uTargetNode,
					m_pOHTMainStatus->StatusCommon.CurNodeID,
					m_pOHTMainStatus->StatusCommon.CurNodeOffset,
					dSpeedOfNow,
					m_ClassifiedCmd.TargetInfo.dDistSumToNode - m_InfoSet.HwInfo.Axis1.dCurrPos,
					OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwShutterRearTime));
				m_mccparam.dwShutterRearTime = 0;
				m_mccparam.bRearShutterFlag = false;
			}
			if(pHWSet->m_pShutter->CheckComplete() ==NO_ERR)
			{
				bCheckOpenCmd = true;
				ADD_LOG("[PreTrans] Shutter Open Finish");
			}
		}
    }

	return nError;

}
int DrivingControl::CheckShutterClose(double dSpeedOfNow)
{
	int nError = NO_ERR;
	static DWORD dwTimeOfShutterClose = timeGetTime();
	// [ SHUTTER ] //

	bool bShutterFrontClose = pHWSet->m_pShutter->IsClose(FRONT) & pHWSet->m_pShutter->IsInposition(FRONT);
	bool bShutterRearClose = pHWSet->m_pShutter->IsClose(REAR) & pHWSet->m_pShutter->IsInposition(REAR);
	bool bShutterBothClose = bShutterFrontClose & bShutterRearClose;

//	bool bShutterFrontOpen = pHWSet->m_pShutter->IsOpen(FRONT);
//	bool bShutterRearOpen = pHWSet->m_pShutter->IsOpen(REAR);
//	bool bShutterBothOpen = bShutterFrontOpen & bShutterRearOpen;



//	ADD_LOG("[PreTrans] Shutter Check");

	/*
	if(bShutterBothClose == true)
	{

		if((timeGetTime() - dwTimeOfShutterClose) > 300)
		{
			nError = pHWSet->m_pShutter->CheckComplete();
			m_bShutterCloseFlag = false;  //Check 완료시 클리어.
		}
	}
	else
	{
		dwTimeOfShutterClose = timeGetTime();
	}
	*/

	if(pHWSet->m_pShutter->IsInposition(FRONT) && pHWSet->m_pShutter->IsOpen(FRONT) && m_mccparam.bFrontShutterFlag)
	{
		ADD_MCC_LOG(",%s,DRV,SHUTTER FRONT CLOSE,End,FOUP,%06d,%06d,%06d,%d,%6.1lf,Close End Station Dist,%6.1lf,Shutter Front Close Time,%d",
			m_defualtparam->VHLName,
			m_mccparam.uSourceNode,
			m_mccparam.uTargetNode,
			m_pOHTMainStatus->StatusCommon.CurNodeID,
			m_pOHTMainStatus->StatusCommon.CurNodeOffset,
			dSpeedOfNow,
			m_InfoSet.HwInfo.Axis1.dCurrPos,
			OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwShutterFrontTime));
		m_mccparam.dwShutterFrontTime = 0;
		m_mccparam.bFrontShutterFlag = false;
	}
	if(pHWSet->m_pShutter->IsInposition(REAR) && pHWSet->m_pShutter->IsOpen(REAR) && m_mccparam.bRearShutterFlag)
	{
		ADD_MCC_LOG(",%s,DRV,SHUTTER REAR CLOSE,End,FOUP,%06d,%06d,%06d,%d,%6.1lf,Close End Station Dist,%6.1lf,Shutter Rear Close Time,%d",
			m_defualtparam->VHLName,
			m_mccparam.uSourceNode,
			m_mccparam.uTargetNode,
			m_pOHTMainStatus->StatusCommon.CurNodeID,
			m_pOHTMainStatus->StatusCommon.CurNodeOffset,
			dSpeedOfNow,
			m_InfoSet.HwInfo.Axis1.dCurrPos,
			OHTUTILITY::PreventOverflowGetTimeMs(m_mccparam.dwShutterRearTime));
		m_mccparam.dwShutterRearTime = 0;
		m_mccparam.bRearShutterFlag = false;
	}

	if(pHWSet->m_pShutter->CheckComplete() ==NO_ERR)
	{
        Sleep(200);
		m_bShutterCloseFlag = false;  //Check 완료시 클리어.

		m_mccparam.bFrontShutterFlag = true;
		m_mccparam.bRearShutterFlag = true;
	}

	return nError;
}

bool DrivingControl::IsInnerFoup()   //재하 유무 확인 플래그
{
	bool breturn = false;

	if((pHWSet->m_pHand->IsClose(BOTH) == true) &&
	   (pHWSet->m_pInnerFoup->IsFoupDetect() == true))
		breturn = true;

	return breturn;
}

int DrivingControl::CheckShutterAlarm()   //셔터 알람
{
	int nReturn = NO_ERR;

	bool bShutterFrontAlarm = pHWSet->m_pShutter->IsAlarm(FRONT);
	bool bShutterRealAlarm = pHWSet->m_pShutter->IsAlarm(REAR);
	int  nCurrNodeID  	= m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.uNode;
	double dCurrOffset = m_InfoSet.Position.CurrentAndTarget.CurrPositionStatus.Info.dOffset;

	static int nCehck =0;

	if((bShutterFrontAlarm == true) || (bShutterRealAlarm == true))
	{
		nCehck++;

		if(nCehck ==10)
		{
			nReturn = pHWSet->m_pShutter->IO_Init();
			Sleep(10);

			nReturn = pHWSet->m_pShutter->AlarmReset();
			ADD_MD_LOG("SHU_ALARM Cur N 1:%d, Offset:%7.1lf", nCurrNodeID, dCurrOffset);
			if(nReturn != NO_ERR)
			{
				nReturn = pHWSet->m_pShutter->AlarmReset();
				ADD_MD_LOG("SHU_ALARM Cur N 2:%d, Offset:%7.1lf ",nCurrNodeID, dCurrOffset);
			}

		}
	}else
		nCehck =0;
	return nReturn;

}

void DrivingControl::Reload_QR_Data()
{
	m_pLeftQRR->SetQRMaker(m_pParamSet->Mark[2].MakerType);
	m_pRightQRR->SetQRMaker(m_pParamSet->Mark[3].MakerType);
}


void DrivingControl::Reset_DrivingControl()
{

		m_pDrivingAxis->SetGearRatio(m_defualtparam->DrivingDefault);

		m_pDrivingAxis->SetNegativeSWLimit(-1*MAX_DRIVING_DISTANCE);
		m_pDrivingAxis->SetPositiveSWLimit(MAX_DRIVING_DISTANCE);

	//	m_pDrivingAxis->SetBrakeRelease(ON);
		m_pDrivingAxis->SetBrakeRelease(false);    //브레이 잡는거

		m_pDrivingAxis->SetAMPEnable(true); 		 //서버 On
		m_pDrivingAxis->SetSlaveAMPEnable(true);	 //서버 On

		m_cSlopeNodeInfo = INIT_NTYPE;
		m_pServoControl->SetInnerLimitTorque_90();

		Reload_QR_Data();

		m_bOnMapMake = false;
		m_bOnBackMove = false;
	//	m_bJobChange = false;
		memset(&m_bMapMakeType, 0x00, sizeof(MAP_MAKER_TYPE));

		/*
		m_DiagManager = DiagManager::getInstance();
		*/

		//1 NEW
		initCommandSet();
		initInfoSet();
		initPreviousArrivalInfo();
		memset(&m_PositionInfo, 0, sizeof(EXECUTE_POSITION_INFO));

		init();
}

double DrivingControl::GetDefaultAccel(void)
{
	return m_pParamSet->Axis.Default.dDefaultAccel;
}

double DrivingControl::GetDefaultDecel(void)
{
	return m_pParamSet->Axis.Default.dDefaultDecel;
}

double DrivingControl::calcMaxSpeedDynamic(double velIn, const double* dynamicVel, const double* dynamicAcc, const int numDynamicArea, const double decel, const double constTime, double dist)
{
	// 감속거리 보장 안되면 v_max = in
	double decelDist = (velIn*velIn) / (2.0*decel);
	if(dist < decelDist)
	{
		return velIn;
	}

	// constTime을 보장할 수 없으면 v_max = in
	double constDist = velIn * constTime;
	if (dist < decelDist + constDist)
	{
		return velIn;
	}

	int areaIn = 0;
	for (int i = 0; i < 3; ++i)
	{
		areaIn = i;
		if (velIn < dynamicVel[i]) break;
	}

	double velMax = 0.0;
	while (1)
	{
		double acc = dynamicAcc[areaIn];
		double _acc = 1.0 / acc;

		double A = 1.0 * _acc + 1.0 / decel;
		double B = constTime;
		double C = -2.0*dist - velIn * velIn * _acc;

		// Av^2 + 2Bv + C = 0
		velMax = (-1.0*B + sqrt(B*B - A * C)) / A;

		int areaMax;
		for (int i = 0; i < numDynamicArea; ++i)
		{
			areaMax = i;
			if (velMax <= dynamicVel[i]) break;
		}

		if (areaMax <= areaIn) break;

		dist -= (dynamicVel[areaIn] * dynamicVel[areaIn] - velIn * velIn) / (2.0*acc);
		velIn = dynamicVel[areaIn++];
	}
	return velMax;
}

